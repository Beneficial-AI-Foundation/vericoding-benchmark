// <vc-preamble>
// Helper function to evaluate a Hermite polynomial at a point
// This is a mathematical specification of Hermite polynomial evaluation
ghost function HermitePolynomial(k: nat, x: real): real
  decreases k
{
  if k == 0 then 1.0
  else if k == 1 then 2.0 * x
  else 2.0 * x * HermitePolynomial(k-1, x) - 2.0 * (k-1) as real * HermitePolynomial(k-2, x)
}

// Evaluate a Hermite series with given coefficients at a point
ghost function EvaluateHermiteSeries(coeffs: seq<real>, x: real): real
  requires |coeffs| > 0
{
  EvaluateHermiteSeriesHelper(coeffs, x, 0)
}

ghost function EvaluateHermiteSeriesHelper(coeffs: seq<real>, x: real, i: nat): real
  requires |coeffs| > 0
  requires i <= |coeffs|
  decreases |coeffs| - i
{
  if i == |coeffs| then 0.0
  else coeffs[i] * HermitePolynomial(i, x) + EvaluateHermiteSeriesHelper(coeffs, x, i+1)
}

// Calculate sum of squared errors for given coefficients
ghost function SumSquaredError(x_vals: seq<real>, y_vals: seq<real>, coeffs: seq<real>): real
  requires |x_vals| == |y_vals|
  requires |x_vals| > 0
  requires |coeffs| > 0
{
  SumSquaredErrorHelper(x_vals, y_vals, coeffs, 0)
}

ghost function SumSquaredErrorHelper(x_vals: seq<real>, y_vals: seq<real>, coeffs: seq<real>, i: nat): real
  requires |x_vals| == |y_vals|
  requires |coeffs| > 0
  requires i <= |x_vals|
  decreases |x_vals| - i
{
  if i == |x_vals| then 0.0
  else
    var predicted := EvaluateHermiteSeries(coeffs, x_vals[i]);
    var error := y_vals[i] - predicted;
    error * error + SumSquaredErrorHelper(x_vals, y_vals, coeffs, i+1)
}
// </vc-preamble>

// <vc-helpers>
// </vc-helpers>

// <vc-spec>
method hermfit(x: seq<real>, y: seq<real>, deg: nat) returns (coeff: seq<real>)
  requires |x| == |y|
  requires |x| > 0
  requires deg >= 0
  
  ensures |coeff| == deg + 1
  ensures deg + 1 > 0
  
  // Least squares optimality property: the returned coefficients minimize
  // the sum of squared errors compared to any other coefficient vector
  ensures forall other_coeffs: seq<real> :: 
    |other_coeffs| == deg + 1 ==>
    SumSquaredError(x, y, coeff) <= SumSquaredError(x, y, other_coeffs)
  
  // For interpolation case: when number of points equals degree + 1,
  // and points are distinct, the polynomial passes through all points exactly
  ensures |x| == deg + 1 && (forall i, j :: 0 <= i < j < |x| ==> x[i] != x[j]) ==>
    forall i :: 0 <= i < |x| ==> EvaluateHermiteSeries(coeff, x[i]) == y[i]
// </vc-spec>
// <vc-code>
{
  assume {:axiom} false;
}
// </vc-code>
