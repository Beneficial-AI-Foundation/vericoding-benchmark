{"id": "LA0240", "language": "lean", "source": "apps", "source-id": "apps_test_1116", "source-notes": "", "vc-description": "", "vc-preamble": "def gcd (a b : Nat) : Nat :=\n  if b = 0 then a else gcd b (a % b)\ntermination_by gcd a b => b\n\ndef ValidInput (r b k : Int) : Prop :=\n  r > 0 ∧ b > 0 ∧ k > 0\n\ndef MaxConsecutiveSameColor (r b : Int) : Int :=\n  let a := Int.min r b\n  let b_val := Int.max r b\n  let n := Int.ofNat (gcd a.natAbs b_val.natAbs)\n  -((n - b_val) / a)\n\ndef CanAvoidConsecutive (r b k : Int) : Bool :=\n  if r > 0 ∧ b > 0 ∧ k > 0 then MaxConsecutiveSameColor r b < k else false\n\n@[reducible, simp]\ndef solve_precond (r b k : Int) : Prop :=\n  ValidInput r b k", "vc-helpers": "", "vc-definitions": "def solve (r b k : Int) (_ : solve_precond r b k) : String :=\n  if CanAvoidConsecutive r b k then \"OBEY\" else \"REBEL\"", "vc-theorems": "@[reducible, simp]\ndef solve_postcond (r b k : Int) (result : String) (_ : solve_precond r b k) : Prop :=\n  result = (if CanAvoidConsecutive r b k then \"OBEY\" else \"REBEL\")\n\ntheorem solve_spec_satisfied (r b k : Int) (h_precond : solve_precond r b k) :\n    solve_postcond r b k (solve r b k h_precond) h_precond := by\n  simp [solve, solve_postcond]", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0016", "language": "lean", "source": "fvapps", "source-id": "fvapps_000016", "source-notes": "", "vc-description": "/-\nPolycarp, Arkady's friend, prepares to the programming competition and decides to write a contest. The contest consists of $n$ problems and lasts for $T$ minutes. Each of the problems is defined by two positive integers $a_i$ and $p_i$ — its difficulty and the score awarded by its solution.\n\nPolycarp's experience suggests that his skill level is defined with positive real value $s$, and initially $s=1.0$. To solve the $i$-th problem Polycarp needs $a_i/s$ minutes.\n\nPolycarp loves to watch series, and before solving each of the problems he will definitely watch one episode. After Polycarp watches an episode, his skill decreases by $10\\%$, that is skill level $s$ decreases to $0.9s$. Each episode takes exactly $10$ minutes to watch. When Polycarp decides to solve some problem, he firstly has to watch one episode, and only then he starts solving the problem without breaks for $a_i/s$ minutes, where $s$ is his current skill level. In calculation of $a_i/s$ no rounding is performed, only division of integer value $a_i$ by real value $s$ happens.\n\nAlso, Polycarp can train for some time. If he trains for $t$ minutes, he increases his skill by $C \\cdot t$, where $C$ is some given positive real constant. Polycarp can train only before solving any problem (and before watching series). Duration of the training can be arbitrary real value.\n\nPolycarp is interested: what is the largest score he can get in the contest? It is allowed to solve problems in any order, while training is only allowed before solving the first problem.\n\n-----Input-----\n\nThe first line contains one integer $tc$ ($1 \\le tc \\le 20$) — the number of test cases. Then $tc$ test cases follow.\n\nThe first line of each test contains one integer $n$ ($1 \\le n \\le 100$) — the number of problems in the contest.\n\nThe second line of the test contains two real values $C, T$ ($0 < C < 10$, $0 \\le T \\le 2 \\cdot 10^5$), where $C$ defines the efficiency of the training and $T$ is the duration of the contest in minutes. Value $C, T$ are given exactly with three digits after the decimal point.\n\nEach of the next $n$ lines of the test contain characteristics of the corresponding problem: two integers $a_i, p_i$ ($1 \\le a_i \\le 10^4$, $1 \\le p_i \\le 10$) — the difficulty and the score of the problem.\n\nIt is guaranteed that the value of $T$ is such that changing it by the $0.001$ in any direction will not change the test answer.\n\nPlease note that in hacks you can only use $tc = 1$.\n\n-----Output-----\n\nPrint $tc$ integers — the maximum possible score in each test case.\n\n-----Examples-----\nInput\n2\n4\n1.000 31.000\n12 3\n20 6\n30 1\n5 1\n3\n1.000 30.000\n1 10\n10 10\n20 8\n\nOutput\n7\n20\n\n-----Note-----\n\nIn the first example, Polycarp can get score of $7$ as follows:  Firstly he trains for $4$ minutes, increasing $s$ to the value of $5$;  Then he decides to solve $4$-th problem: he watches one episode in $10$ minutes, his skill level decreases to $s=5*0.9=4.5$ and then he solves the problem in $5/s=5/4.5$, which is roughly $1.111$ minutes;  Finally, he decides to solve $2$-nd problem: he watches one episode in $10$ minutes, his skill level decreases to $s=4.5*0.9=4.05$ and then he solves the problem in $20/s=20/4.05$, which is roughly $4.938$ minutes. \n\nThis way, Polycarp uses roughly $4+10+1.111+10+4.938=30.049$ minutes, to get score of $7$ points. It is not possible to achieve larger score in $31$ minutes.\n\nIn the second example, Polycarp can get $20$ points as follows:  Firstly he trains for $4$ minutes, increasing $s$ to the value of $5$;  Then he decides to solve $1$-st problem: he watches one episode in $10$ minutes, his skill decreases to $s=5*0.9=4.5$ and then he solves problem in $1/s=1/4.5$, which is roughly $0.222$ minutes.  Finally, he decides to solve $2$-nd problem: he watches one episode in $10$ minutes, his skill decreases to $s=4.5*0.9=4.05$ and then he solves the problem in $10/s=10/4.05$, which is roughly $2.469$ minutes. \n\nThis way, Polycarp gets score of $20$ in $4+10+0.222+10+2.469=26.691$ minutes. It is not possible to achieve larger score in $30$ minutes.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x :: xs => x + xs.sum\n\ninstance : LE Problem where\n  le a b := a.difficulty ≤ b.difficulty\n\ndef List.sorted [Ord α] (l : List α) : List α :=\n  l.toArray.qsort (fun x y => compare x y == .lt) |>.toList", "vc-helpers": "", "vc-definitions": "def solve_contest (n : Nat) (train_efficiency : Float) (time_limit : Float) (problems : List Problem) : Float :=\n  sorry", "vc-theorems": "theorem solve_contest_non_negative \n  {n : Nat} {train_efficiency : Float} {time_limit : Float} {problems : List Problem}\n  (h1 : train_efficiency ≥ 0.1) (h2 : train_efficiency ≤ 10) \n  (h3 : time_limit ≥ 1) (h4 : time_limit ≤ 100)\n  (h5 : problems.length = n) (h6 : n ≥ 1) (h7 : n ≤ 10) :\n  solve_contest n train_efficiency time_limit problems ≥ 0 := \nsorry\n\ntheorem solve_contest_upper_bound\n  {n : Nat} {train_efficiency : Float} {time_limit : Float} {problems : List Problem}\n  (h1 : train_efficiency ≥ 0.1) (h2 : train_efficiency ≤ 10)\n  (h3 : time_limit ≥ 1) (h4 : time_limit ≤ 100)\n  (h5 : problems.length = n) (h6 : n ≥ 1) (h7 : n ≤ 10) :\n  solve_contest n train_efficiency time_limit problems ≤ Float.ofNat ((problems.map Problem.score).sum) := \nsorry\n\ntheorem solve_contest_time_monotonic\n  {n : Nat} {train_efficiency : Float} {time_limit high_time : Float} {problems : List Problem}\n  (h1 : train_efficiency ≥ 0.1) (h2 : train_efficiency ≤ 10)\n  (h3 : high_time > 1000) (h4 : time_limit = high_time / 10)\n  (h5 : problems.length = n) (h6 : n ≥ 1) (h7 : n ≤ 10) :\n  solve_contest n train_efficiency high_time problems ≥ solve_contest n train_efficiency time_limit problems :=\nsorry\n\ntheorem problem_sorting_property\n  {problems : List Problem} (h1 : problems.length ≥ 1) (h2 : problems.length ≤ 10) :\n  let sorted := problems.sorted\n  ∀ i, i + 1 < sorted.length → \n    (sorted.get! i).difficulty ≥ (sorted.get! (i + 1)).difficulty := \nsorry\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval solve_contest 4 1.0 31.0 #[Problem(12, 3), Problem(20, 6), Problem(30, 1), Problem(5, 1)]\n\n/-\ninfo: 20\n-/\n-- #guard_msgs in\n-- #eval solve_contest 3 1.0 30.0 #[Problem(1, 10), Problem(10, 10), Problem(20, 8)]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0036", "language": "lean", "source": "fvapps", "source-id": "fvapps_000036", "source-notes": "", "vc-description": "/-\nIt is lunch time for Mole. His friend, Marmot, prepared him a nice game for lunch.\n\nMarmot brought Mole n ordered piles of worms such that i-th pile contains a_{i} worms. He labeled all these worms with consecutive integers: worms in first pile are labeled with numbers 1 to a_1, worms in second pile are labeled with numbers a_1 + 1 to a_1 + a_2 and so on. See the example for a better understanding.\n\nMole can't eat all the worms (Marmot brought a lot) and, as we all know, Mole is blind, so Marmot tells him the labels of the best juicy worms. Marmot will only give Mole a worm if Mole says correctly in which pile this worm is contained.\n\nPoor Mole asks for your help. For all juicy worms said by Marmot, tell Mole the correct answers.\n\n-----Input-----\n\nThe first line contains a single integer n (1 ≤ n ≤ 10^5), the number of piles.\n\nThe second line contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^3, a_1 + a_2 + ... + a_{n} ≤ 10^6), where a_{i} is the number of worms in the i-th pile.\n\nThe third line contains single integer m (1 ≤ m ≤ 10^5), the number of juicy worms said by Marmot.\n\nThe fourth line contains m integers q_1, q_2, ..., q_{m} (1 ≤ q_{i} ≤ a_1 + a_2 + ... + a_{n}), the labels of the juicy worms.\n\n-----Output-----\n\nPrint m lines to the standard output. The i-th line should contain an integer, representing the number of the pile where the worm labeled with the number q_{i} is.\n\n-----Examples-----\nInput\n5\n2 7 3 4 9\n3\n1 25 11\n\nOutput\n1\n5\n3\n\n-----Note-----\n\nFor the sample input:\n\n  The worms with labels from [1, 2] are in the first pile.  The worms with labels from [3, 9] are in the second pile.  The worms with labels from [10, 12] are in the third pile.  The worms with labels from [13, 16] are in the fourth pile.  The worms with labels from [17, 25] are in the fifth pile.\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | x :: xs => x + List.sum xs", "vc-helpers": "", "vc-definitions": "def find_pile_numbers (n : Nat) (pile_sizes : List Nat) (m : Nat) (labels : List Nat) : List Nat :=\n  sorry\n\n-- Properties about length and valid pile numbers", "vc-theorems": "theorem find_pile_nums_length (n : Nat) (pile_sizes : List Nat) (m : Nat) (labels : List Nat)\n    (h1 : pile_sizes.length = n)\n    (h2 : labels.length = m)\n    (h3 : n > 0)\n    (h4 : m > 0)\n    (h5 : ∀ x ∈ pile_sizes, x > 0)\n    (h6 : ∀ x ∈ labels, x > 0) :\n    (find_pile_numbers n pile_sizes m labels).length = labels.length :=\n  sorry\n\ntheorem find_pile_nums_valid_output (n : Nat) (pile_sizes : List Nat) (m : Nat) (labels : List Nat)\n    (h1 : pile_sizes.length = n)\n    (h2 : labels.length = m)\n    (h3 : n > 0)\n    (h4 : m > 0)\n    (h5 : ∀ x ∈ pile_sizes, x > 0)\n    (h6 : ∀ x ∈ labels, x > 0) :\n    ∀ x ∈ find_pile_numbers n pile_sizes m labels, 1 ≤ x ∧ x ≤ n :=\n  sorry\n\n-- Property about correct pile indices based on prefix sums\n\ntheorem find_pile_nums_correct_indices (n : Nat) (pile_sizes : List Nat) (m : Nat) (labels : List Nat)\n    (h1 : pile_sizes.length = n)\n    (h2 : labels.length = m)\n    (h3 : n > 0)\n    (h4 : m > 0)\n    (h5 : ∀ x ∈ pile_sizes, x > 0)\n    (h6 : ∀ x ∈ labels, x > 0) :\n    ∀ (i : Nat) (label : Nat) (pile_num : Nat),\n      (label ∈ labels) →\n      (pile_num ∈ find_pile_numbers n pile_sizes m labels) →\n      label ≤ (List.take i pile_sizes).sum →\n      pile_num ≤ i :=\n  sorry\n\n-- Property about identical labels mapping to same pile\n\ntheorem find_pile_nums_identical_labels (n : Nat) (pile_sizes : List Nat) (label : Nat)\n    (h1 : pile_sizes.length = n)\n    (h2 : n > 0)\n    (h3 : ∀ x ∈ pile_sizes, x > 0)\n    (h4 : label > 0) :\n    let labels := List.replicate 3 label\n    let result := find_pile_numbers n pile_sizes 3 labels\n    ∀ (x y : Nat), x ∈ result → y ∈ result → x = y :=\n  sorry\n\n-- Property about single pile case\n\ntheorem find_pile_nums_single_pile (pile_size : Nat)\n    (h : pile_size > 0) :\n    find_pile_numbers 1 [pile_size] 1 [1] = [1] :=\n  sorry\n\n/-\ninfo: [1, 5, 3]\n-/\n-- #guard_msgs in\n-- #eval find_pile_numbers 5 [2, 7, 3, 4, 9] 3 [1, 25, 11]\n\n/-\ninfo: [2, 3]\n-/\n-- #guard_msgs in\n-- #eval find_pile_numbers 3 [1, 2, 3] 2 [2, 6]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0054", "language": "lean", "source": "fvapps", "source-id": "fvapps_000054", "source-notes": "", "vc-description": "/-\nYou are playing a variation of game 2048. Initially you have a multiset $s$ of $n$ integers. Every integer in this multiset is a power of two. \n\nYou may perform any number (possibly, zero) operations with this multiset.\n\nDuring each operation you choose two equal integers from $s$, remove them from $s$ and insert the number equal to their sum into $s$.\n\nFor example, if $s = \\{1, 2, 1, 1, 4, 2, 2\\}$ and you choose integers $2$ and $2$, then the multiset becomes $\\{1, 1, 1, 4, 4, 2\\}$.\n\nYou win if the number $2048$ belongs to your multiset. For example, if $s = \\{1024, 512, 512, 4\\}$ you can win as follows: choose $512$ and $512$, your multiset turns into $\\{1024, 1024, 4\\}$. Then choose $1024$ and $1024$, your multiset turns into $\\{2048, 4\\}$ and you win.\n\nYou have to determine if you can win this game.\n\nYou have to answer $q$ independent queries.\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 100$) – the number of queries.\n\nThe first line of each query contains one integer $n$ ($1 \\le n \\le 100$) — the number of elements in multiset.\n\nThe second line of each query contains $n$ integers $s_1, s_2, \\dots, s_n$ ($1 \\le s_i \\le 2^{29}$) — the description of the multiset. It is guaranteed that all elements of the multiset are powers of two. \n\n-----Output-----\n\nFor each query print YES if it is possible to obtain the number $2048$ in your multiset, and NO otherwise.\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\n\n-----Example-----\nInput\n6\n4\n1024 512 64 512\n1\n2048\n3\n64 512 2\n2\n4096 4\n7\n2048 2 2048 2048 2048 2048 2048\n2\n2048 4096\n\nOutput\nYES\nYES\nNO\nNO\nYES\nYES\n\n-----Note-----\n\nIn the first query you can win as follows: choose $512$ and $512$, and $s$ turns into $\\{1024, 64, 1024\\}$. Then choose $1024$ and $1024$, and $s$ turns into $\\{2048, 64\\}$ and you win.\n\nIn the second query $s$ contains $2048$ initially.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_win (nums : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem can_win_large_numbers_filtered {nums : List Nat} :\n  can_win nums = can_win (nums.filter (· < 2049)) :=\n  sorry\n\ntheorem can_win_sum_condition {nums : List Nat} :\n  can_win nums = ((nums.filter (· < 2049)).foldl (· + ·) 0 ≥ 2048) :=\n  sorry\n\ntheorem can_win_large_number_ignored {n : Nat} (h : n ≥ 2049) : \n  can_win [n] = false :=\n  sorry\n\ntheorem can_win_large_with_2048 {n : Nat} (h : n ≥ 2049) :\n  can_win [n, 2048] = true :=\n  sorry\n\ntheorem can_win_small_numbers_sum {nums : List Nat}\n  (h : ∀ n ∈ nums, n ≤ 2047) :\n  can_win nums = (nums.foldl (· + ·) 0 ≥ 2048) :=\n  sorry\n\nend GameTheory\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval can_win [1024, 512, 64, 512]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval can_win [64, 512, 2]\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval can_win [2048, 4096]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0056", "language": "lean", "source": "fvapps", "source-id": "fvapps_000056", "source-notes": "", "vc-description": "/-\nA mad scientist Dr.Jubal has made a competitive programming task. Try to solve it!\n\nYou are given integers $n,k$. Construct a grid $A$ with size $n \\times n$ consisting of integers $0$ and $1$. The very important condition should be satisfied: the sum of all elements in the grid is exactly $k$. In other words, the number of $1$ in the grid is equal to $k$.\n\nLet's define:  $A_{i,j}$ as the integer in the $i$-th row and the $j$-th column.  $R_i = A_{i,1}+A_{i,2}+...+A_{i,n}$ (for all $1 \\le i \\le n$).  $C_j = A_{1,j}+A_{2,j}+...+A_{n,j}$ (for all $1 \\le j \\le n$).  In other words, $R_i$ are row sums and $C_j$ are column sums of the grid $A$.  For the grid $A$ let's define the value $f(A) = (\\max(R)-\\min(R))^2 + (\\max(C)-\\min(C))^2$ (here for an integer sequence $X$ we define $\\max(X)$ as the maximum value in $X$ and $\\min(X)$ as the minimum value in $X$). \n\nFind any grid $A$, which satisfies the following condition. Among such grids find any, for which the value $f(A)$ is the minimum possible. Among such tables, you can find any.\n\n-----Input-----\n\nThe input consists of multiple test cases. The first line contains a single integer $t$ ($1 \\le t \\le 100$) — the number of test cases. Next $t$ lines contain descriptions of test cases.\n\nFor each test case the only line contains two integers $n$, $k$ $(1 \\le n \\le 300, 0 \\le k \\le n^2)$.\n\nIt is guaranteed that the sum of $n^2$ for all test cases does not exceed $10^5$.\n\n-----Output-----\n\nFor each test case, firstly print the minimum possible value of $f(A)$ among all tables, for which the condition is satisfied.\n\nAfter that, print $n$ lines contain $n$ characters each. The $j$-th character in the $i$-th line should be equal to $A_{i,j}$.\n\nIf there are multiple answers you can print any.\n\n-----Example-----\nInput\n4\n2 2\n3 8\n1 0\n4 16\n\nOutput\n0\n10\n01\n2\n111\n111\n101\n0\n0\n0\n1111\n1111\n1111\n1111\n\n-----Note-----\n\nIn the first test case, the sum of all elements in the grid is equal to $2$, so the condition is satisfied. $R_1 = 1, R_2 = 1$ and $C_1 = 1, C_2 = 1$. Then, $f(A) = (1-1)^2 + (1-1)^2 = 0$, which is the minimum possible value of $f(A)$.\n\nIn the second test case, the sum of all elements in the grid is equal to $8$, so the condition is satisfied. $R_1 = 3, R_2 = 3, R_3 = 2$ and $C_1 = 3, C_2 = 2, C_3 = 3$. Then, $f(A) = (3-2)^2 + (3-2)^2 = 2$. It can be proven, that it is the minimum possible value of $f(A)$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_grid (n k : Nat) : Nat × Grid := sorry\n\ntheorem solve_grid_divisible {n k : Nat} (h : k % n = 0) :\n  (solve_grid n k).1 = 0\n  := sorry", "vc-theorems": "", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0061", "language": "lean", "source": "fvapps", "source-id": "fvapps_000061", "source-notes": "", "vc-description": "/-\nYou are given a permutation $p_1, p_2, \\dots, p_n$. Recall that sequence of $n$ integers is called a permutation if it contains all integers from $1$ to $n$ exactly once.\n\nFind three indices $i$, $j$ and $k$ such that:   $1 \\le i < j < k \\le n$;  $p_i < p_j$ and $p_j > p_k$.  Or say that there are no such indices.\n\n-----Input-----\n\nThe first line contains a single integer $T$ ($1 \\le T \\le 200$) — the number of test cases.\n\nNext $2T$ lines contain test cases — two lines per test case. The first line of each test case contains the single integer $n$ ($3 \\le n \\le 1000$) — the length of the permutation $p$.\n\nThe second line contains $n$ integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$; $p_i \\neq p_j$ if $i \\neq j$) — the permutation $p$.\n\n-----Output-----\n\nFor each test case:   if there are such indices $i$, $j$ and $k$, print YES (case insensitive) and the indices themselves;  if there are no such indices, print NO (case insensitive). \n\nIf there are multiple valid triples of indices, print any of them.\n\n-----Example-----\nInput\n3\n4\n2 1 4 3\n6\n4 6 1 2 5 3\n5\n5 3 1 2 4\n\nOutput\nYES\n2 3 4\nYES\n3 5 6\nNO\n-/", "vc-preamble": "def find_mountain_indices (n : Nat) (perm : List Int) : Answer :=\n  sorry", "vc-helpers": "", "vc-definitions": "def is_mountain (perm : List Int) (start_idx : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem find_mountain_indices_valid_format {n : Nat} {perm : List Int} :\n  match find_mountain_indices n perm with\n  | Answer.YES indices => indices.length = 3\n  | Answer.NO => True := sorry\n\ntheorem mountain_indices_are_valid {n : Nat} {perm : List Int} :\n  match find_mountain_indices n perm with\n  | Answer.YES indices => \n    indices.length = 3 →\n    ∀ i j k, indices = [i, j, k] →\n    1 ≤ i ∧ i < j ∧ j < k ∧ k ≤ n\n  | Answer.NO => True := sorry\n\ntheorem mountain_indices_form_mountain {n : Nat} {perm : List Int} :\n  match find_mountain_indices n perm with\n  | Answer.YES indices =>\n    indices.length = 3 →\n    ∀ i, indices.head? = some i →\n    is_mountain perm (i-1)\n  | Answer.NO => True := sorry\n\ntheorem no_result_means_no_mountain {n : Nat} {perm : List Int} :\n  find_mountain_indices n perm = Answer.NO →\n  ∀ i, i < n - 2 →\n  ¬is_mountain perm i := sorry\n\ntheorem increasing_has_no_mountain {n : Nat} {perm : List Int} (h : n ≥ 3) : \n  perm = List.map Int.ofNat (List.range n) →\n  find_mountain_indices n perm = Answer.NO := sorry\n\ntheorem decreasing_has_no_mountain {n : Nat} {perm : List Int} (h : n ≥ 3) :\n  perm = List.map Int.ofNat (List.range n).reverse →\n  find_mountain_indices n perm = Answer.NO := sorry\n\ntheorem mountain_indices_are_consecutive {n : Nat} {perm : List Int} :\n  match find_mountain_indices n perm with\n  | Answer.YES indices =>\n    indices.length = 3 →\n    ∀ i j k, indices = [i, j, k] →\n    j = i + 1 ∧ k = j + 1\n  | Answer.NO => True := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0083", "language": "lean", "source": "fvapps", "source-id": "fvapps_000083", "source-notes": "", "vc-description": "/-\nLet's look at the following process: initially you have an empty stack and an array $s$ of the length $l$. You are trying to push array elements to the stack in the order $s_1, s_2, s_3, \\dots s_{l}$. Moreover, if the stack is empty or the element at the top of this stack is not equal to the current element, then you just push the current element to the top of the stack. Otherwise, you don't push the current element to the stack and, moreover, pop the top element of the stack. \n\nIf after this process the stack remains empty, the array $s$ is considered stack exterminable.\n\nThere are samples of stack exterminable arrays:   $[1, 1]$;  $[2, 1, 1, 2]$;  $[1, 1, 2, 2]$;  $[1, 3, 3, 1, 2, 2]$;  $[3, 1, 3, 3, 1, 3]$;  $[3, 3, 3, 3, 3, 3]$;  $[5, 1, 2, 2, 1, 4, 4, 5]$; \n\nLet's consider the changing of stack more details if $s = [5, 1, 2, 2, 1, 4, 4, 5]$ (the top of stack is highlighted).   after pushing $s_1 = 5$ the stack turn into $[\\textbf{5}]$;  after pushing $s_2 = 1$ the stack turn into $[5, \\textbf{1}]$;  after pushing $s_3 = 2$ the stack turn into $[5, 1, \\textbf{2}]$;  after pushing $s_4 = 2$ the stack turn into $[5, \\textbf{1}]$;  after pushing $s_5 = 1$ the stack turn into $[\\textbf{5}]$;  after pushing $s_6 = 4$ the stack turn into $[5, \\textbf{4}]$;  after pushing $s_7 = 4$ the stack turn into $[\\textbf{5}]$;  after pushing $s_8 = 5$ the stack is empty. \n\nYou are given an array $a_1, a_2, \\ldots, a_n$. You have to calculate the number of its subarrays which are stack exterminable.\n\nNote, that you have to answer $q$ independent queries.\n\n-----Input-----\n\nThe first line contains one integer $q$ ($1 \\le q \\le 3 \\cdot 10^5$) — the number of queries.\n\nThe first line of each query contains one integer $n$ ($1 \\le n \\le 3 \\cdot 10^5$) — the length of array $a$.\n\nThe second line of each query contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\le a_i \\le n$) — the elements.\n\nIt is guaranteed that the sum of all $n$ over all queries does not exceed $3 \\cdot 10^5$.\n\n-----Output-----\n\nFor each test case print one integer in single line — the number of stack exterminable subarrays of the array $a$.\n\n-----Example-----\nInput\n3\n5\n2 1 1 2 2\n6\n1 2 1 1 3 2\n9\n3 1 2 2 1 6 6 3 3\n\nOutput\n4\n1\n8\n\n-----Note-----\n\nIn the first query there are four stack exterminable subarrays: $a_{1 \\ldots 4} = [2, 1, 1, 2], a_{2 \\ldots 3} = [1, 1], a_{2 \\ldots 5} = [1, 1, 2, 2], a_{4 \\ldots 5} = [2, 2]$.\n\nIn the second query, only one subarray is exterminable subarray — $a_{3 \\ldots 4}$.\n\nIn the third query, there are eight stack exterminable subarrays: $a_{1 \\ldots 8}, a_{2 \\ldots 5}, a_{2 \\ldots 7}, a_{2 \\ldots 9}, a_{3 \\ldots 4}, a_{6 \\ldots 7}, a_{6 \\ldots 9}, a_{8 \\ldots 9}$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_stack_exterminable (arr : List Int) : Nat :=\n  sorry", "vc-theorems": "theorem solve_stack_exterminable_nonnegative \n  (arr : List Int) \n  (h : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 100) \n  (h2 : arr ≠ []) : \n  0 ≤ solve_stack_exterminable arr :=\n  sorry\n\ntheorem solve_stack_exterminable_reverse_equals_forward\n  (arr : List Int)\n  (h : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 100)\n  (h2 : arr ≠ []) :\n  solve_stack_exterminable arr = solve_stack_exterminable arr.reverse :=\n  sorry\n\ntheorem solve_stack_exterminable_pair_elements\n  (arr : List Int)\n  (h : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 100) \n  (h2 : arr.length ≥ 2) :\n  let doubled := arr.bind (fun x => [x, x])\n  solve_stack_exterminable doubled ≥ arr.length :=\n  sorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval solve_stack_exterminable [2, 1, 1, 2, 2]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval solve_stack_exterminable [1, 2, 1, 1, 3, 2]\n\n/-\ninfo: 8\n-/\n-- #guard_msgs in\n-- #eval solve_stack_exterminable [3, 1, 2, 2, 1, 6, 6, 3, 3]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0084", "language": "lean", "source": "fvapps", "source-id": "fvapps_000084", "source-notes": "", "vc-description": "/-\nConsider the following process. You have a binary string (a string where each character is either 0 or 1) $w$ of length $n$ and an integer $x$. You build a new binary string $s$ consisting of $n$ characters. The $i$-th character of $s$ is chosen as follows:\n\n  if the character $w_{i-x}$ exists and is equal to 1, then $s_i$ is 1 (formally, if $i > x$ and $w_{i-x} = $ 1, then $s_i = $ 1);  if the character $w_{i+x}$ exists and is equal to 1, then $s_i$ is 1 (formally, if $i + x \\le n$ and $w_{i+x} = $ 1, then $s_i = $ 1);  if both of the aforementioned conditions are false, then $s_i$ is 0. \n\nYou are given the integer $x$ and the resulting string $s$. Reconstruct the original string $w$.\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 1000$) — the number of test cases.\n\nEach test case consists of two lines. The first line contains the resulting string $s$ ($2 \\le |s| \\le 10^5$, each character of $s$ is either 0 or 1). The second line contains one integer $x$ ($1 \\le x \\le |s| - 1$).\n\nThe total length of all strings $s$ in the input does not exceed $10^5$.\n\n-----Output-----\n\nFor each test case, print the answer on a separate line as follows:\n\n  if no string $w$ can produce the string $s$ at the end of the process, print $-1$;  otherwise, print the binary string $w$ consisting of $|s|$ characters. If there are multiple answers, print any of them. \n\n-----Example-----\nInput\n3\n101110\n2\n01\n1\n110\n1\n\nOutput\n111011\n10\n-1\n-/", "vc-preamble": "def length_eq (s₁ s₂ : BinaryString) : Prop := sorry\ndef is_binary (s : BinaryString) : Prop := sorry", "vc-helpers": "", "vc-definitions": "def matches_at_index (s₁ s₂ : BinaryString) (x i : Nat) : Prop := sorry\n\ndef solve_binary_string (s : BinaryString) (x : Nat) : Option BinaryString :=\nsorry\n\n/- Result is either None or has same structure/length as input -/", "vc-theorems": "theorem length_preservation (s : BinaryString) (x : Nat) : \n  match solve_binary_string s x with\n  | none => True \n  | some result => length_eq s result\n:= sorry\n\n/- Result only contains valid binary digits -/\n\ntheorem output_chars_valid (s : BinaryString) (x : Nat) :\n  match solve_binary_string s x with\n  | none => True\n  | some result => is_binary result\n:= sorry\n\n/- Main correctness theorem capturing all validity conditions -/\n\ntheorem valid_solution (s : BinaryString) (x : Nat) :\n  match solve_binary_string s x with\n  | none => True\n  | some result => \n      length_eq s result ∧ \n      is_binary result ∧ \n      (∀ i, matches_at_index s result x i)\n:= sorry\n\n/-\ninfo: '111011'\n-/\n-- #guard_msgs in\n-- #eval solve_binary_string \"101110\" 2\n\n/-\ninfo: '10'\n-/\n-- #guard_msgs in\n-- #eval solve_binary_string \"01\" 1\n\n/-\ninfo: '-1'\n-/\n-- #guard_msgs in\n-- #eval solve_binary_string \"110\" 1", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0085", "language": "lean", "source": "fvapps", "source-id": "fvapps_000085", "source-notes": "", "vc-description": "/-\nAlexandra has an even-length array $a$, consisting of $0$s and $1$s. The elements of the array are enumerated from $1$ to $n$. She wants to remove at most $\\frac{n}{2}$ elements (where $n$ — length of array) in the way that alternating sum of the array will be equal $0$ (i.e. $a_1 - a_2 + a_3 - a_4 + \\dotsc = 0$). In other words, Alexandra wants sum of all elements at the odd positions and sum of all elements at the even positions to become equal. The elements that you remove don't have to be consecutive.\n\nFor example, if she has $a = [1, 0, 1, 0, 0, 0]$ and she removes $2$nd and $4$th elements, $a$ will become equal $[1, 1, 0, 0]$ and its alternating sum is $1 - 1 + 0 - 0 = 0$.\n\nHelp her!\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^3$). Description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ ($2 \\le n \\le 10^3$, $n$ is even)  — length of the array.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 1$)  — elements of the array.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^3$.\n\n-----Output-----\n\nFor each test case, firstly, print $k$ ($\\frac{n}{2} \\leq k \\leq n$) — number of elements that will remain after removing in the order they appear in $a$. Then, print this $k$ numbers. Note that you should print the numbers themselves, not their indices.\n\nWe can show that an answer always exists. If there are several answers, you can output any of them. \n\n-----Example-----\nInput\n4\n2\n1 0\n2\n0 0\n4\n0 1 1 1\n4\n1 1 0 0\n\nOutput\n1\n0\n1\n0\n2\n1 1\n4\n1 1 0 0\n\n-----Note-----\n\nIn the first and second cases, alternating sum of the array, obviously, equals $0$.\n\nIn the third case, alternating sum of the array equals $1 - 1 = 0$.\n\nIn the fourth case, alternating sum already equals $1 - 1 + 0 - 0 = 0$, so we don't have to remove anything.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n| [] => 0\n| x::xs => x + (sum xs)", "vc-helpers": "", "vc-definitions": "def solve_alternating_array (n: Nat) (arr: List Nat) : Nat × List Nat := sorry\n\ntheorem solve_alternating_array_size_constraints {n: Nat} {arr: List Nat} \n  (h1: n > 0) (h2: ∀ x ∈ arr, x ≤ 1) :\n  let (size, result) := solve_alternating_array n arr\n  (size = result.length ∧ size ≤ n ∧ size ≥ n/2) := sorry", "vc-theorems": "theorem solve_alternating_array_result_constraints {n: Nat} {arr: List Nat}\n  (h1: n > 0) (h2: ∀ x ∈ arr, x ≤ 1) :\n  let (_, result) := solve_alternating_array n arr\n  (∀ x ∈ result, x ≤ 1) := sorry\n\ntheorem solve_alternating_array_all_zeros {n: Nat} {arr: List Nat}\n  (h1: n > 0) (h2: ∀ x ∈ arr, x ≤ 1) \n  (h3: List.sum arr ≤ n/2) :\n  let (_, result) := solve_alternating_array n arr\n  (∀ x ∈ result, x = 0) := sorry\n\ntheorem solve_alternating_array_all_ones {n: Nat} {arr: List Nat}\n  (h1: n > 0) (h2: ∀ x ∈ arr, x ≤ 1)\n  (h3: List.sum arr > n/2) :\n  let (_, result) := solve_alternating_array n arr\n  (∀ x ∈ result, x = 1) := sorry\n\ntheorem solve_alternating_array_extreme_cases {n: Nat} \n  (h1: n > 0) :\n  let (size1, _) := solve_alternating_array n (List.replicate n 0)\n  let (size2, _) := solve_alternating_array n (List.replicate n 1)\n  (n/2 ≤ size1 ∧ size1 ≤ n/2 + 1 ∧ \n   n/2 ≤ size2 ∧ size2 ≤ n/2 + 1) := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0095", "language": "lean", "source": "fvapps", "source-id": "fvapps_000095", "source-notes": "", "vc-description": "/-\nPetya has come to the math exam and wants to solve as many problems as possible. He prepared and carefully studied the rules by which the exam passes.\n\nThe exam consists of $n$ problems that can be solved in $T$ minutes. Thus, the exam begins at time $0$ and ends at time $T$. Petya can leave the exam at any integer time from $0$ to $T$, inclusive.\n\nAll problems are divided into two types:   easy problems — Petya takes exactly $a$ minutes to solve any easy problem;  hard problems — Petya takes exactly $b$ minutes ($b > a$) to solve any hard problem. \n\nThus, if Petya starts solving an easy problem at time $x$, then it will be solved at time $x+a$. Similarly, if at a time $x$ Petya starts to solve a hard problem, then it will be solved at time $x+b$.\n\nFor every problem, Petya knows if it is easy or hard. Also, for each problem is determined time $t_i$ ($0 \\le t_i \\le T$) at which it will become mandatory (required). If Petya leaves the exam at time $s$ and there is such a problem $i$ that $t_i \\le s$ and he didn't solve it, then he will receive $0$ points for the whole exam. Otherwise (i.e if he has solved all such problems for which $t_i \\le s$) he will receive a number of points equal to the number of solved problems. Note that leaving at time $s$ Petya can have both \"mandatory\" and \"non-mandatory\" problems solved.\n\nFor example, if $n=2$, $T=5$, $a=2$, $b=3$, the first problem is hard and $t_1=3$ and the second problem is easy and $t_2=2$. Then:  if he leaves at time $s=0$, then he will receive $0$ points since he will not have time to solve any problems;  if he leaves at time $s=1$, he will receive $0$ points since he will not have time to solve any problems;  if he leaves at time $s=2$, then he can get a $1$ point by solving the problem with the number $2$ (it must be solved in the range from $0$ to $2$);  if he leaves at time $s=3$, then he will receive $0$ points since at this moment both problems will be mandatory, but he will not be able to solve both of them;  if he leaves at time $s=4$, then he will receive $0$ points since at this moment both problems will be mandatory, but he will not be able to solve both of them;  if he leaves at time $s=5$, then he can get $2$ points by solving all problems. \n\nThus, the answer to this test is $2$.\n\nHelp Petya to determine the maximal number of points that he can receive, before leaving the exam.\n\n-----Input-----\n\nThe first line contains the integer $m$ ($1 \\le m \\le 10^4$) — the number of test cases in the test.\n\nThe next lines contain a description of $m$ test cases. \n\nThe first line of each test case contains four integers $n, T, a, b$ ($2 \\le n \\le 2\\cdot10^5$, $1 \\le T \\le 10^9$, $1 \\le a < b \\le 10^9$) — the number of problems, minutes given for the exam and the time to solve an easy and hard problem, respectively.\n\nThe second line of each test case contains $n$ numbers $0$ or $1$, separated by single space: the $i$-th number means the type of the $i$-th problem. A value of $0$ means that the problem is easy, and a value of $1$ that the problem is hard.\n\nThe third line of each test case contains $n$ integers $t_i$ ($0 \\le t_i \\le T$), where the $i$-th number means the time at which the $i$-th problem will become mandatory.\n\nIt is guaranteed that the sum of $n$ for all test cases does not exceed $2\\cdot10^5$.\n\n-----Output-----\n\nPrint the answers to $m$ test cases. For each set, print a single integer — maximal number of points that he can receive, before leaving the exam.\n\n-----Example-----\nInput\n10\n3 5 1 3\n0 0 1\n2 1 4\n2 5 2 3\n1 0\n3 2\n1 20 2 4\n0\n16\n6 20 2 5\n1 1 0 1 0 0\n0 8 2 9 11 6\n4 16 3 6\n1 0 1 1\n8 3 5 6\n6 20 3 6\n0 1 0 0 1 0\n20 11 3 20 16 17\n7 17 1 6\n1 1 0 1 0 0 0\n1 7 0 11 10 15 10\n6 17 2 6\n0 0 1 0 0 1\n7 6 3 7 10 12\n5 17 2 5\n1 1 1 1 0\n17 11 10 6 4\n1 1 1 2\n0\n1\n\nOutput\n3\n2\n1\n0\n1\n4\n0\n1\n2\n1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_exam_problems (n : Nat) (T : Nat) (a : Nat) (b : Nat) (tasks : Tasks) (total_a total_b : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_exam_problems_bounds {n T a b : Nat} {tasks : Tasks} {total_a total_b : Nat}\n  (n_pos : n > 0) (T_pos : T > 0) (a_pos : a > 0) (b_pos : b > 0) :\n  let result := solve_exam_problems n T a b tasks total_a total_b\n  result ≤ total_a + total_b ∧ result ≥ 0 :=\nsorry\n\ntheorem solve_empty_tasks {n T a b : Nat}\n  (n_pos : n > 0) (T_pos : T > 0) (a_pos : a > 0) (b_pos : b > 0) :\n  solve_exam_problems n T a b [] 0 0 = 0 :=\nsorry\n\ntheorem solve_zero_time {n a b : Nat} {tasks : Tasks}\n  (n_pos : n > 0) (a_pos : a > 0) (b_pos : b > 0) :\n  solve_exam_problems n 0 a b tasks 1 0 = 0 :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval solve_exam_problems 3 5 1 3 list(zip(t, types)) sum((1 for x in types if x == 0)) sum((1 for x in types if x == 1))\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve_exam_problems 2 5 2 3 list(zip(t, types)) sum((1 for x in types if x == 0)) sum((1 for x in types if x == 1))\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval solve_exam_problems 1 20 2 4 list(zip(t, types)) sum((1 for x in types if x == 0)) sum((1 for x in types if x == 1))", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0105", "language": "lean", "source": "fvapps", "source-id": "fvapps_000105", "source-notes": "", "vc-description": "/-\nChaneka has a hobby of playing with animal toys. Every toy has a different fun value, a real number. Chaneka has four boxes to store the toys with specification:   The first box stores toys with fun values in range of $(-\\infty,-1]$.  The second box stores toys with fun values in range of $(-1, 0)$.  The third box stores toys with fun values in range of $(0, 1)$.  The fourth box stores toys with fun value in range of $[1, \\infty)$. \n\nChaneka has $A$, $B$, $C$, $D$ toys in the first, second, third, and fourth box, respectively. One day she decides that she only wants one toy, a super toy. So she begins to create this super toy by sewing all the toys she has.\n\nWhile the number of toys Chaneka has is more than 1, she takes two different toys randomly and then sews them together, creating a new toy. The fun value of this new toy is equal to the multiplication of fun values of the sewn toys. She then puts this new toy in the appropriate box. She repeats this process until she only has one toy. This last toy is the super toy, and the box that stores this toy is the special box.\n\nAs an observer, you only know the number of toys in each box initially but do not know their fun values. You also don't see the sequence of Chaneka's sewing. Determine which boxes can be the special box after Chaneka found her super toy.\n\n-----Input-----\n\nThe first line has an integer $T$ $(1 \\le T \\le 5 \\cdot 10^4)$, the number of test cases.\n\nEvery case contains a line with four space-separated integers $A$ $B$ $C$ $D$ $(0 \\le A, B, C, D \\le 10^6, A + B + C + D > 0)$, which denotes the number of toys in the first, second, third, and fourth box, respectively.\n\n-----Output-----\n\nFor each case, print four space-separated strings. Each string represents the possibility that the first, second, third, and fourth box can be the special box from left to right.\n\nFor each box, print \"Ya\" (Without quotes, Indonesian for yes) if that box can be the special box. Print \"Tidak\" (Without quotes, Indonesian for No) otherwise.\n\n-----Example-----\nInput\n2\n1 2 0 1\n0 1 0 0\n\nOutput\nYa Ya Tidak Tidak\nTidak Ya Tidak Tidak\n\n-----Note-----\n\nFor the first case, here is a scenario where the first box is the special box:   The first box had toys with fun values $\\{-3\\}$.  The second box had toys with fun values $\\{ -0.5, -0.5 \\}$  The fourth box had toys with fun values $\\{ 3 \\}$ \n\nThe sewing sequence:   Chaneka sews the toy with fun $-0.5$ and $-0.5$ to a toy with fun $0.25$ and then put it in the third box.  Chaneka sews the toy with fun $-3$ and $0.25$ to a toy with fun $-0.75$ and then put it in the second box.  Chaneka sews the toy with fun $-0.75$ and $3$ to a toy with fun $-1.25$ and then put it in the first box, which then became the special box. \n\nHere is a scenario where the second box ends up being the special box:   The first box had toys with fun values $\\{-3\\}$  The second box had toys with fun values $\\{ -0.33, -0.25 \\}$.  The fourth box had toys with fun values $\\{ 3 \\}$. \n\nThe sewing sequence:   Chaneka sews the toy with fun $-3$ and $-0.33$ to a toy with fun $0.99$ and then put it in the third box.  Chaneka sews the toy with fun $0.99$ and $3$ to a toy with fun $2.97$ and then put in it the fourth box.  Chaneka sews the toy with fun $2.97$ and $-0.25$ to a toy with fun $-0.7425$ and then put it in the second box, which then became the special box.  There is only one toy for the second case, so Chaneka does not have to sew anything because that toy, by definition, is the super toy.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_toy_boxes (a b c d : Nat) : Array YaNot := sorry\n\ntheorem always_contains_four_parts (a b c d : Nat) :\n  (solve_toy_boxes a b c d).size = 4 ∧\n  ∀ x ∈ solve_toy_boxes a b c d, x = YaNot.ya ∨ x = YaNot.tidak := sorry", "vc-theorems": "theorem parity_constraints (a b c d : Nat) :\n  ((a + b) % 2 = 0 → (solve_toy_boxes a b c d)[0]! = YaNot.tidak ∧ (solve_toy_boxes a b c d)[1]! = YaNot.tidak) ∧\n  ((a + b) % 2 ≠ 0 → (solve_toy_boxes a b c d)[2]! = YaNot.tidak ∧ (solve_toy_boxes a b c d)[3]! = YaNot.tidak) := sorry\n\ntheorem zero_small_box_constraints (b c : Nat) :\n  (solve_toy_boxes 0 b c 0)[0]! = YaNot.tidak ∧ (solve_toy_boxes 0 b c 0)[3]! = YaNot.tidak := sorry\n\ntheorem zero_large_box_constraints (a d : Nat) :\n  (solve_toy_boxes a 0 0 d)[1]! = YaNot.tidak ∧ (solve_toy_boxes a 0 0 d)[2]! = YaNot.tidak := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0112", "language": "lean", "source": "fvapps", "source-id": "fvapps_000112", "source-notes": "", "vc-description": "/-\nYou play a computer game. In this game, you lead a party of $m$ heroes, and you have to clear a dungeon with $n$ monsters. Each monster is characterized by its power $a_i$. Each hero is characterized by his power $p_i$ and endurance $s_i$.\n\nThe heroes clear the dungeon day by day. In the beginning of each day, you choose a hero (exactly one) who is going to enter the dungeon this day.\n\nWhen the hero enters the dungeon, he is challenged by the first monster which was not defeated during the previous days (so, if the heroes have already defeated $k$ monsters, the hero fights with the monster $k + 1$). When the hero fights the monster, there are two possible outcomes:\n\n  if the monster's power is strictly greater than the hero's power, the hero retreats from the dungeon. The current day ends;  otherwise, the monster is defeated. \n\nAfter defeating a monster, the hero either continues fighting with the next monster or leaves the dungeon. He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day (so, the $i$-th hero cannot defeat more than $s_i$ monsters during each day), or if all monsters are defeated — otherwise, he fights with the next monster. When the hero leaves the dungeon, the current day ends.\n\nYour goal is to defeat the last monster. What is the minimum number of days that you need to achieve your goal? Each day you have to use exactly one hero; it is possible that some heroes don't fight the monsters at all. Each hero can be used arbitrary number of times.\n\n-----Input-----\n\nThe first line contains one integer $t$ ($1 \\le t \\le 10^5$) — the number of test cases. Then the test cases follow.\n\nThe first line of each test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the number of monsters in the dungeon.\n\nThe second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\le a_i \\le 10^9$), where $a_i$ is the power of the $i$-th monster.\n\nThe third line contains one integer $m$ ($1 \\le m \\le 2 \\cdot 10^5$) — the number of heroes in your party.\n\nThen $m$ lines follow, each describing a hero. Each line contains two integers $p_i$ and $s_i$ ($1 \\le p_i \\le 10^9$, $1 \\le s_i \\le n$) — the power and the endurance of the $i$-th hero.\n\nIt is guaranteed that the sum of $n + m$ over all test cases does not exceed $2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each test case print one integer — the minimum number of days you have to spend to defeat all of the monsters (or $-1$ if it is impossible).\n\n-----Example-----\nInput\n2\n6\n2 3 11 14 1 8\n2\n3 2\n100 1\n5\n3 5 100 2 3\n2\n30 5\n90 1\n\nOutput\n5\n-1\n-/", "vc-preamble": "def maxList (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => List.foldl (fun acc y => max acc y) x xs", "vc-helpers": "", "vc-definitions": "def solve_dungeon_game (monsters : List Nat) (heroes : List Hero) : Nat := sorry\n\ntheorem dungeon_game_basic_properties\n  (monsters : List Nat) (heroes : List Hero)\n  (h1 : monsters.length > 0)\n  (h2 : heroes.length > 0)\n  (h3 : ∀ m ∈ monsters, m ≥ 1 ∧ m ≤ 1000)\n  (h4 : ∀ h ∈ heroes, h.power ≥ 1 ∧ h.power ≤ 1000 ∧ h.endurance ≥ 1 ∧ h.endurance ≤ 1000) :\n  let result := solve_dungeon_game monsters heroes\n  (result = 0 ∨ result ≥ 1) ∧\n  (result ≠ 0 → (\n    (∃ h ∈ heroes, h.power ≥ maxList monsters) ∧\n    result ≤ monsters.length\n  )) := sorry", "vc-theorems": "theorem dungeon_game_weak_monsters\n  (monsters : List Nat)\n  (heroes : List Hero)\n  (h1 : monsters.length > 0)\n  (h2 : heroes.length > 0)\n  (h3 : ∀ m ∈ monsters, m = 1)\n  (h4 : ∀ h ∈ heroes, h.power = 2 ∧ h.endurance = 1) :\n  solve_dungeon_game monsters heroes = monsters.length := sorry\n\ntheorem dungeon_game_super_hero\n  (monsters : List Nat)\n  (hero_endurance : Nat)\n  (h1 : monsters.length > 0)\n  (h2 : ∀ m ∈ monsters, m ≥ 1 ∧ m ≤ 10)\n  (h3 : hero_endurance ≥ 1) :\n  let max_monster := maxList monsters\n  let heroes := [Hero.mk (max_monster + 1) hero_endurance]\n  let result := solve_dungeon_game monsters heroes\n  (if hero_endurance ≥ monsters.length\n   then result = 1\n   else result = (monsters.length + hero_endurance - 1) / hero_endurance) := sorry\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval solve_dungeon_game [2, 3, 11, 14, 1, 8] [(3, 2), (100, 1)]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval solve_dungeon_game [3, 5, 100, 2, 3] [(30, 5), (90, 1)]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval solve_dungeon_game [1, 2, 3] [(5, 3)]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0113", "language": "lean", "source": "fvapps", "source-id": "fvapps_000113", "source-notes": "", "vc-description": "/-\nPolycarp plays a computer game (yet again). In this game, he fights monsters using magic spells.\n\nThere are two types of spells: fire spell of power $x$ deals $x$ damage to the monster, and lightning spell of power $y$ deals $y$ damage to the monster and doubles the damage of the next spell Polycarp casts. Each spell can be cast only once per battle, but Polycarp can cast them in any order.\n\nFor example, suppose that Polycarp knows three spells: a fire spell of power $5$, a lightning spell of power $1$, and a lightning spell of power $8$. There are $6$ ways to choose the order in which he casts the spells:\n\n  first, second, third. This order deals $5 + 1 + 2 \\cdot 8 = 22$ damage;  first, third, second. This order deals $5 + 8 + 2 \\cdot 1 = 15$ damage;  second, first, third. This order deals $1 + 2 \\cdot 5 + 8 = 19$ damage;  second, third, first. This order deals $1 + 2 \\cdot 8 + 2 \\cdot 5 = 27$ damage;  third, first, second. This order deals $8 + 2 \\cdot 5 + 1 = 19$ damage;  third, second, first. This order deals $8 + 2 \\cdot 1 + 2 \\cdot 5 = 20$ damage. \n\nInitially, Polycarp knows $0$ spells. His spell set changes $n$ times, each time he either learns a new spell or forgets an already known one. After each change, calculate the maximum possible damage Polycarp may deal using the spells he knows.\n\n-----Input-----\n\nThe first line contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the number of changes to the spell set.\n\nEach of the next $n$ lines contains two integers $tp$ and $d$ ($0 \\le tp_i \\le 1$; $-10^9 \\le d \\le 10^9$; $d_i \\neq 0$) — the description of the change. If $tp_i$ if equal to $0$, then Polycarp learns (or forgets) a fire spell, otherwise he learns (or forgets) a lightning spell.\n\nIf $d_i > 0$, then Polycarp learns a spell of power $d_i$. Otherwise, Polycarp forgets a spell with power $-d_i$, and it is guaranteed that he knew that spell before the change.\n\nIt is guaranteed that the powers of all spells Polycarp knows after each change are different (Polycarp never knows two spells with the same power).\n\n-----Output-----\n\nAfter each change, print the maximum damage Polycarp can deal with his current set of spells.\n\n-----Example-----\nInput\n6\n1 5\n0 10\n1 -5\n0 5\n1 11\n0 -10\n\nOutput\n5\n25\n10\n15\n36\n21\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_max_damage (spells : List Spell) : List Int := sorry\n\ntheorem length_preservation (spells : List Spell) :\n  List.length (calculate_max_damage spells) = List.length spells := sorry", "vc-theorems": "theorem output_are_ints (spells : List Spell) (i : Nat) (h : i < List.length spells) :\n  ∃ n : Int, (calculate_max_damage spells).get ⟨i, by rw [length_preservation]; exact h⟩ = n := sorry\n\ntheorem type0_positive_running_sum (spells : List Spell) \n  (h_type : ∀ s ∈ spells, s.spellType = 0)\n  (h_damage : ∀ s ∈ spells, s.damage > 0) \n  (i : Nat) (h : i < List.length spells) :\n  (calculate_max_damage spells).get ⟨i, by rw [length_preservation]; exact h⟩ = \n  (spells.take (i+1)).foldl (fun acc s => acc + s.damage) 0 := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0140", "language": "lean", "source": "fvapps", "source-id": "fvapps_000140", "source-notes": "", "vc-description": "/-\nGiven a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.\n\nA subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\n\nThe input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.\n\nExample 1:\n\nInput: \"aba\", \"cdc\", \"eae\"\nOutput: 3\n\nNote:\n\nAll the given strings' lengths will not exceed 10.\nThe length of the given list will be in the range of [2, 50].\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_longest_uncommon_subseq (strs : List String) : Int := sorry\n\ntheorem find_longest_uncommon_subseq_output_type_and_range\n  (strs : List String)\n  (h : strs.length > 0) :\n  let result := find_longest_uncommon_subseq strs\n  result = -1 ∨ result ≥ 0 := sorry", "vc-theorems": "theorem find_longest_uncommon_subseq_bounded_by_max_length\n  (strs : List String)\n  (h : strs.length > 0) :\n  find_longest_uncommon_subseq strs ≤ (strs.map String.length).maximum?.getD 0 := sorry\n\ntheorem find_longest_uncommon_subseq_single_string\n  (s : String)\n  (strs : List String)\n  (h : strs = [s]) :\n  find_longest_uncommon_subseq strs = s.length := sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval find_longest_uncommon_subseq [\"aba\", \"cdc\", \"eae\"]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval find_longest_uncommon_subseq [\"aaa\", \"aaa\", \"aa\"]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval find_longest_uncommon_subseq [\"aabb\", \"aabb\", \"ab\"]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0151", "language": "lean", "source": "fvapps", "source-id": "fvapps_000151", "source-notes": "", "vc-description": "/-\nRemember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\n\n Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.\n\nExample 1:\n\nInput: [1,1,2,2,2]\nOutput: true\n\nExplanation: You can form a square with length 2, one side of the square came two sticks with length 1.\n\nExample 2:\n\nInput: [3,3,3,3,4]\nOutput: false\n\nExplanation: You cannot find a way to form a square with all the matchsticks.\n\nNote:\n\nThe length sum of the given matchsticks is in the range of 0 to 10^9.\nThe length of the given matchstick array will not exceed 15.\n-/", "vc-preamble": "def List.sum (l: List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x::xs => x + List.sum xs", "vc-helpers": "", "vc-definitions": "def makesquare (nums: List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem makesquare_min_length \n  (nums: List Nat) (h: nums.length < 4) : \n  makesquare nums = false := \n  sorry\n\ntheorem makesquare_sum_not_div_four\n  (nums: List Nat) (h: (List.sum nums % 4) ≠ 0) :\n  makesquare nums = false := \n  sorry\n\ntheorem makesquare_element_too_large \n  (nums: List Nat) (h: ∃ x ∈ nums, x > List.sum nums / 4) :\n  makesquare nums = false :=\n  sorry\n\ntheorem makesquare_equal_elements \n  (n: Nat) (nums: List Nat) \n  (h1: nums.length % 4 = 0)\n  (h2: ∀ x ∈ nums, x = n) :\n  makesquare nums = true :=\n  sorry \n\ntheorem makesquare_identical_elements\n  (n: Nat) :\n  makesquare [n,n,n,n] = true :=\n  sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval makesquare [1, 1, 2, 2, 2]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval makesquare [3, 3, 3, 3, 4]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval makesquare [1, 2, 3, 4, 5]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0175", "language": "lean", "source": "fvapps", "source-id": "fvapps_000175", "source-notes": "", "vc-description": "/-\nGiven an unsorted array of integers, find the length of longest increasing subsequence.\n\nExample:\n\nInput: [10,9,2,5,3,7,101,18]\nOutput: 4 \nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. \n\nNote: \n\n       There may be more than one LIS combination, it is only necessary for you to return the length.\n       Your algorithm should run in O(n2) complexity.\n\nFollow up: Could you improve it to O(n log n) time complexity?\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem output_size_bounds {nums : List Int} :\n  longest_increasing_subsequence nums ≤ nums.length ∧ \n  longest_increasing_subsequence nums ≥ 0 := sorry\n\n/- For a strictly increasing sequence of unique elements, result equals length -/  \n\ntheorem strictly_increasing_equals_length {nums : List Int} (h: nums.Nodup) : \n  (∀ i j, i < j → j < nums.length → nums.get! i < nums.get! j) →\n  longest_increasing_subsequence nums = nums.length := sorry\n\n/- For a strictly decreasing sequence of unique elements, result is 1 -/\n\ntheorem strictly_decreasing_equals_one {nums : List Int} (h: nums.Nodup) : \n  (∀ i j, i < j → j < nums.length → nums.get! i > nums.get! j) →\n  longest_increasing_subsequence nums = 1 := sorry\n\n/- Max result of sequence and its reverse are equal -/\n\ntheorem reverse_order_max {nums : List Int} :\n  max (longest_increasing_subsequence nums) (longest_increasing_subsequence nums.reverse) =\n  longest_increasing_subsequence nums ∨\n  max (longest_increasing_subsequence nums) (longest_increasing_subsequence nums.reverse) =\n  longest_increasing_subsequence nums.reverse := sorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval longest_increasing_subsequence [10, 9, 2, 5, 3, 7, 101, 18]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval longest_increasing_subsequence []\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval longest_increasing_subsequence [1, 2, 3, 4, 5]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0180", "language": "lean", "source": "fvapps", "source-id": "fvapps_000180", "source-notes": "", "vc-description": "/-\nGiven two arrays nums1 and nums2.\nReturn the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.\nA subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).\n\nExample 1:\nInput: nums1 = [2,1,-2,5], nums2 = [3,0,-6]\nOutput: 18\nExplanation: Take subsequence [2,-2] from nums1 and subsequence [3,-6] from nums2.\nTheir dot product is (2*3 + (-2)*(-6)) = 18.\nExample 2:\nInput: nums1 = [3,-2], nums2 = [2,-6,7]\nOutput: 21\nExplanation: Take subsequence [3] from nums1 and subsequence [7] from nums2.\nTheir dot product is (3*7) = 21.\nExample 3:\nInput: nums1 = [-1,-1], nums2 = [1,1]\nOutput: -1\nExplanation: Take subsequence [-1] from nums1 and subsequence [1] from nums2.\nTheir dot product is -1.\n\nConstraints:\n\n1 <= nums1.length, nums2.length <= 500\n-1000 <= nums1[i], nums2[i] <= 1000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_dot_product (nums1 nums2 : List Int) : Int := sorry\n\ntheorem max_dot_product_bounds \n  (nums1 nums2 : List Int) :\n  let min_product := (List.map (fun x => List.map (fun y => x * y) nums2) nums1).join.minimum?\n  let max_product := (List.map (fun x => List.map (fun y => x * y) nums2) nums1).join.maximum?\n  match min_product, max_product with\n  | some min, some max => \n    max_dot_product nums1 nums2 ≥ min ∧ \n    max_dot_product nums1 nums2 ≤ nums1.length * max\n  | _, _ => True := sorry", "vc-theorems": "theorem max_dot_product_reverse_invariant\n  (nums1 nums2 : List Int) :\n  max_dot_product nums1 nums2 = max_dot_product nums1.reverse nums2.reverse := sorry\n\ntheorem max_dot_product_neg_invariant\n  (nums1 nums2 : List Int) :\n  max_dot_product nums1 nums2 = \n    - (max_dot_product (nums1.map (fun x => -x)) (nums2.map (fun x => -x))) := sorry\n\ntheorem max_dot_product_monotonic\n  (nums1 nums2 : List Int) :\n  let big_num := max (nums1.maximum?.getD 0) (nums2.maximum?.getD 0) + 100\n  max_dot_product (nums1 ++ [big_num]) (nums2 ++ [big_num]) ≥ \n    max_dot_product nums1 nums2 := sorry\n\n/-\ninfo: 18\n-/\n-- #guard_msgs in\n-- #eval max_dot_product [2, 1, -2, 5] [3, 0, -6]\n\n/-\ninfo: 21\n-/\n-- #guard_msgs in\n-- #eval max_dot_product [3, -2] [2, -6, 7]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval max_dot_product [-1, -1] [1, 1]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0182", "language": "lean", "source": "fvapps", "source-id": "fvapps_000182", "source-notes": "", "vc-description": "/-\nGiven a binary string s and an integer k.\nReturn True if every binary code of length k is a substring of s. Otherwise, return False.\n\nExample 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nExplanation: The binary codes of length 2 are \"00\", \"01\", \"10\" and \"11\". They can be all found as substrings at indicies 0, 1, 3 and 2 respectively.\n\nExample 2:\nInput: s = \"00110\", k = 2\nOutput: true\n\nExample 3:\nInput: s = \"0110\", k = 1\nOutput: true\nExplanation: The binary codes of length 1 are \"0\" and \"1\", it is clear that both exist as a substring. \n\nExample 4:\nInput: s = \"0110\", k = 2\nOutput: false\nExplanation: The binary code \"00\" is of length 2 and doesn't exist in the array.\n\nExample 5:\nInput: s = \"0000000001011100\", k = 4\nOutput: false\n\nConstraints:\n\n1 <= s.length <= 5 * 10^5\ns consists of 0's and 1's only.\n1 <= k <= 20\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def has_all_codes (s : String) (k : Nat) : Bool := sorry\n\ntheorem empty_string_always_false {k : Nat} (h : k ≥ 1) :\n  has_all_codes \"\" k = false := sorry", "vc-theorems": "theorem binary_sequence_length_requirement {k : Nat} (h : k ≥ 1) (h2 : k ≤ 4) :\n  ∀ s, s.length < 2^k + k - 1 → has_all_codes s k = false := sorry \n\ntheorem has_all_codes_returns_bool (s : String) (k : Nat) (h : k ≥ 1) :\n  has_all_codes s k = true ∨ has_all_codes s k = false := sorry\n\ntheorem complete_sequence_true {k : Nat} (h : k ≥ 1) (h2 : k ≤ 4) :\n  let seq := String.mk (List.join (List.map (fun i => (toString i).data) (List.range (2^k))))\n  has_all_codes (seq ++ (seq.take (k-1))) k = true := sorry\n\ntheorem substring_property (s : String) (k : Nat) (h : k ≥ 1) :\n  has_all_codes s k = true →\n  (has_all_codes (s ++ \"0\") k = true ∧ has_all_codes (\"0\" ++ s) k = true) := sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval has_all_codes \"00110110\" 2\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval has_all_codes \"0110\" 2\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval has_all_codes \"0110\" 1", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0185", "language": "lean", "source": "fvapps", "source-id": "fvapps_000185", "source-notes": "", "vc-description": "/-\nYou are given a list of preferences for n friends, where n is always even.\nFor each person i, preferences[i] contains a list of friends sorted in the order of preference. In other words, a friend earlier in the list is more preferred than a friend later in the list. Friends in each list are denoted by integers from 0 to n-1.\nAll the friends are divided into pairs. The pairings are given in a list pairs, where pairs[i] = [xi, yi] denotes xi is paired with yi and yi is paired with xi.\nHowever, this pairing may cause some of the friends to be unhappy. A friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y, and\nu prefers x over v.\n\nReturn the number of unhappy friends.\n\nExample 1:\nInput: n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]\nOutput: 2\nExplanation:\nFriend 1 is unhappy because:\n- 1 is paired with 0 but prefers 3 over 0, and\n- 3 prefers 1 over 2.\nFriend 3 is unhappy because:\n- 3 is paired with 2 but prefers 1 over 2, and\n- 1 prefers 3 over 0.\nFriends 0 and 2 are happy.\n\nExample 2:\nInput: n = 2, preferences = [[1], [0]], pairs = [[1, 0]]\nOutput: 0\nExplanation: Both friends 0 and 1 are happy.\n\nExample 3:\nInput: n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]\nOutput: 4\n\nConstraints:\n\n2 <= n <= 500\nn is even.\npreferences.length == n\npreferences[i].length == n - 1\n0 <= preferences[i][j] <= n - 1\npreferences[i] does not contain i.\nAll values in preferences[i] are unique.\npairs.length == n/2\npairs[i].length == 2\nxi != yi\n0 <= xi, yi <= n - 1\nEach person is contained in exactly one pair.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def unhappyFriends (n: Nat) (preferences: List (List Nat)) (pairs: List (List Nat)) : Nat :=\nsorry", "vc-theorems": "theorem unhappyFriends_output_is_nat (n: Nat) (preferences: List (List Nat)) (pairs: List (List Nat)) :\n  n % 2 = 0 →\n  n ≥ 2 → \n  n ≤ 6 →\n  (∀ p ∈ preferences, p.length = n - 1) →\n  (∀ p ∈ preferences, ∀ i, i ∈ p → i < n ∧ i ≠ preferences.indexOf p) →\n  (∀ p ∈ pairs, p.length = 2) →\n  (∀ p ∈ pairs, ∀ i ∈ p, i < n) →\n  ∃ result, result = unhappyFriends n preferences pairs ∧ result ≤ n :=\nsorry\n\ntheorem unhappyFriends_output_nonnegative (n: Nat) (preferences: List (List Nat)) (pairs: List (List Nat)) :\n  n % 2 = 0 →\n  n ≥ 2 →\n  n ≤ 6 →\n  (∀ p ∈ preferences, p.length = n - 1) →\n  (∀ p ∈ preferences, ∀ i, i ∈ p → i < n ∧ i ≠ preferences.indexOf p) →\n  (∀ p ∈ pairs, p.length = 2) →\n  (∀ p ∈ pairs, ∀ i ∈ p, i < n) →\n  unhappyFriends n preferences pairs ≥ 0 :=\nsorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval unhappyFriends 4 [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]] [[0, 1], [2, 3]]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval unhappyFriends 2 [[1], [0]] [[1, 0]]\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval unhappyFriends 4 [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]] [[1, 3], [0, 2]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0188", "language": "lean", "source": "fvapps", "source-id": "fvapps_000188", "source-notes": "", "vc-description": "/-\nThere are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:\n\nIn each step, you will choose any 3 piles of coins (not necessarily consecutive).\nOf your choice, Alice will pick the pile with the maximum number of coins.\nYou will pick the next pile with maximum number of coins.\nYour friend Bob will pick the last pile.\nRepeat until there are no more piles of coins.\n\nGiven an array of integers piles where piles[i] is the number of coins in the ith pile.\nReturn the maximum number of coins which you can have.\n\nExample 1:\nInput: piles = [2,4,1,2,7,8]\nOutput: 9\nExplanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.\nChoose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.\nThe maximum number of coins which you can have are: 7 + 2 = 9.\nOn the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.\n\nExample 2:\nInput: piles = [2,4,5]\nOutput: 4\n\nExample 3:\nInput: piles = [9,8,7,6,5,1,2,3,4]\nOutput: 18\n\nConstraints:\n\n3 <= piles.length <= 10^5\npiles.length % 3 == 0\n1 <= piles[i] <= 10^4\n-/", "vc-preamble": "def List.sum (l : List Nat) : Nat :=\n  l.foldl (· + ·) 0\n\ndef List.sort (l : List Nat) : List Nat :=\n  sorry\n\ndef List.perm (l1 l2 : List Nat) : Prop :=\n  sorry\n\ndef List.takeNth (l : List Nat) (n : Nat) : List Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def maxCoins (piles : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem maxcoins_minimal :\n  maxCoins [1,1,1] = 1 :=\nsorry\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval maxCoins [2, 4, 1, 2, 7, 8]\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval maxCoins [2, 4, 5]\n\n/-\ninfo: 18\n-/\n-- #guard_msgs in\n-- #eval maxCoins [9, 8, 7, 6, 5, 1, 2, 3, 4]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0190", "language": "lean", "source": "fvapps", "source-id": "fvapps_000190", "source-notes": "", "vc-description": "/-\nGiven an array of integers nums and a positive integer k, find whether it's possible to divide this array into k non-empty subsets whose sums are all equal.\n\nExample 1:\n\nInput: nums = [4, 3, 2, 3, 5, 2, 1], k = 4\nOutput: True\nExplanation: It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\n\nNote:\n1 .\n0 < nums[i] < 10000.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + List.sum xs\n\ndef getMaximum (l : List Nat) (h : l.length > 0) : Nat :=\n  match l with\n  | [] => 0 \n  | [x] => x\n  | (x::xs) => x -- simplified version to avoid proof complexity", "vc-helpers": "", "vc-definitions": "def can_partition_k_subsets (nums : List Nat) (k : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem partition_k_eq_one {nums : List Nat} (h : nums.length > 0) :\n  can_partition_k_subsets nums 1 = true :=\n  sorry\n\ntheorem partition_k_gt_length {nums : List Nat} {k : Nat} \n  (h : k > nums.length) :\n  can_partition_k_subsets nums k = false :=\n  sorry\n\ntheorem partition_sum_not_div_k {nums : List Nat} {k : Nat} \n  (h : k > 0) (h2 : nums.length > 0)\n  (h3 : (List.sum nums % k) ≠ 0) :\n  can_partition_k_subsets nums k = false :=\n  sorry\n\ntheorem partition_max_too_large {nums : List Nat} {k : Nat}\n  (h : k > 0) (h2 : nums.length > 0)\n  (h3 : getMaximum nums h2 > List.sum nums / k) :\n  can_partition_k_subsets nums k = false :=\n  sorry\n\ntheorem identical_elements {n k : Nat} (h : k > 0) :\n  can_partition_k_subsets (List.replicate n n) k = (n % k = 0) :=\n  sorry\n\ntheorem single_element_k_one :\n  can_partition_k_subsets [1] 1 = true :=\n  sorry\n\ntheorem single_element_k_two :\n  can_partition_k_subsets [1] 2 = false :=\n  sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval can_partition_k_subsets [4, 3, 2, 3, 5, 2, 1] 4\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval can_partition_k_subsets [1, 2, 3, 4] 3\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval can_partition_k_subsets [2, 2, 2, 2] 2", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0198", "language": "lean", "source": "fvapps", "source-id": "fvapps_000198", "source-notes": "", "vc-description": "/-\nLet's call any (contiguous) subarray B (of A) a mountain if the following properties hold:\n\nB.length >= 3\nThere exists some 0 < i < B.length - 1 such that B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]\n\n(Note that B could be any subarray of A, including the entire array A.)\nGiven an array A of integers, return the length of the longest mountain. \nReturn 0 if there is no mountain.\nExample 1:\nInput: [2,1,4,7,3,2,5]\nOutput: 5\nExplanation: The largest mountain is [1,4,7,3,2] which has length 5.\n\nExample 2:\nInput: [2,2,2]\nOutput: 0\nExplanation: There is no mountain.\n\nNote:\n\n0 <= A.length <= 10000\n0 <= A[i] <= 10000\n\nFollow up:\n\nCan you solve it using only one pass?\nCan you solve it in O(1) space?\n-/", "vc-preamble": "def longestMountain (arr : Array Int) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def isSorted (arr : Array Int) : Bool :=\n  sorry", "vc-theorems": "theorem mountain_length_min_or_zero {arr : Array Int} :\n  let result := longestMountain arr\n  result = 0 ∨ result ≥ 3\n  := sorry\n\ntheorem mountain_length_bounded {arr : Array Int} :\n  longestMountain arr ≤ arr.size\n  := sorry\n\ntheorem flat_sequence_no_mountain {arr : Array Int} :\n  let doubled := arr.concatMap (fun x => #[x, x]) \n  longestMountain doubled = 0\n  := sorry\n\ntheorem single_element_no_mountain {x : Int} :\n  longestMountain #[x] = 0\n  := sorry\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval longestMountain #[2, 1, 4, 7, 3, 2, 5]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval longestMountain #[2, 2, 2]\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval longestMountain #[1, 2, 3, 4, 5, 4, 3, 2, 1]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0205", "language": "lean", "source": "fvapps", "source-id": "fvapps_000205", "source-notes": "", "vc-description": "/-\nThere are N piles of stones arranged in a row.  The i-th pile has stones[i] stones.\nA move consists of merging exactly K consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these K piles.\nFind the minimum cost to merge all piles of stones into one pile.  If it is impossible, return -1.\n\nExample 1:\nInput: stones = [3,2,4,1], K = 2\nOutput: 20\nExplanation: \nWe start with [3, 2, 4, 1].\nWe merge [3, 2] for a cost of 5, and we are left with [5, 4, 1].\nWe merge [4, 1] for a cost of 5, and we are left with [5, 5].\nWe merge [5, 5] for a cost of 10, and we are left with [10].\nThe total cost was 20, and this is the minimum possible.\n\nExample 2:\nInput: stones = [3,2,4,1], K = 3\nOutput: -1\nExplanation: After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.\n\nExample 3:\nInput: stones = [3,5,1,2,6], K = 3\nOutput: 25\nExplanation: \nWe start with [3, 5, 1, 2, 6].\nWe merge [5, 1, 2] for a cost of 8, and we are left with [3, 8, 6].\nWe merge [3, 8, 6] for a cost of 17, and we are left with [17].\nThe total cost was 25, and this is the minimum possible.\n\nNote:\n\n1 <= stones.length <= 30\n2 <= K <= 30\n1 <= stones[i] <= 100\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | x::xs => x + List.sum xs", "vc-helpers": "", "vc-definitions": "def merge_stones (stones : List Nat) (k : Nat) : Int :=\n  sorry", "vc-theorems": "theorem merge_stones_impossible (stones : List Nat) (k : Nat)\n  (h : (stones.length - 1) % (k - 1) ≠ 0) :\n  merge_stones stones k = -1 :=\n  sorry\n\ntheorem merge_stones_possible_nonneg (stones : List Nat) (k : Nat) \n  (h : (stones.length - 1) % (k - 1) = 0) :\n  merge_stones stones k ≥ 0 :=\n  sorry\n\ntheorem merge_stones_bounded (stones : List Nat) (k : Nat)\n  (h : (stones.length - 1) % (k - 1) = 0) :\n  ∃ bound : Nat, merge_stones stones k ≤ bound :=\n  sorry\n\ntheorem merge_stones_single_stone (k : Nat) :\n  merge_stones [1] k = 0 :=\n  sorry\n\ntheorem merge_stones_two_stones :\n  merge_stones [1,1] 2 = 2 :=\n  sorry\n\n/-\ninfo: 20\n-/\n-- #guard_msgs in\n-- #eval merge_stones [3, 2, 4, 1] 2\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval merge_stones [3, 2, 4, 1] 3\n\n/-\ninfo: 25\n-/\n-- #guard_msgs in\n-- #eval merge_stones [3, 5, 1, 2, 6] 3", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0235", "language": "lean", "source": "fvapps", "source-id": "fvapps_000235", "source-notes": "", "vc-description": "/-\nWe have a set of items: the i-th item has value values[i] and label labels[i].\nThen, we choose a subset S of these items, such that:\n\n|S| <= num_wanted\nFor every label L, the number of items in S with label L is <= use_limit.\n\nReturn the largest possible sum of the subset S.\n\nExample 1:\nInput: values = [5,4,3,2,1], labels = [1,1,2,2,3], num_wanted = 3, use_limit = 1\nOutput: 9\nExplanation: The subset chosen is the first, third, and fifth item.\n\nExample 2:\nInput: values = [5,4,3,2,1], labels = [1,3,3,3,2], num_wanted = 3, use_limit = 2\nOutput: 12\nExplanation: The subset chosen is the first, second, and third item.\n\nExample 3:\nInput: values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 1\nOutput: 16\nExplanation: The subset chosen is the first and fourth item.\n\nExample 4:\nInput: values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 2\nOutput: 24\nExplanation: The subset chosen is the first, second, and fourth item.\n\nNote:\n\n1 <= values.length == labels.length <= 20000\n0 <= values[i], labels[i] <= 20000\n1 <= num_wanted, use_limit <= values.length\n-/", "vc-preamble": "def largest_vals_from_labels (values: List Int) (labels: List Int) (numWanted: Nat) (useLimit: Nat) : Int :=\n  sorry\n\ndef List.sum : List Int → Int \n  | [] => 0\n  | x::xs => x + List.sum xs\n\ndef myMax (a b : Int) : Int :=\n  if a ≥ b then a else b", "vc-helpers": "", "vc-definitions": "def List.maximum : List Int → Int\n  | [] => 0\n  | [x] => x\n  | x::xs => myMax x (List.maximum xs)", "vc-theorems": "theorem largest_vals_sum_bound (values: List Int) (labels: List Int) (numWanted: Nat) (useLimit: Nat)\n  (h1: values.length = labels.length)\n  (h2: numWanted > 0)\n  (h3: useLimit > 0) :\n  largest_vals_from_labels values labels numWanted useLimit ≤ \n    (List.sum (values.filter (λ x => x > 0))) :=\n  sorry\n\ntheorem largest_vals_nonneg (values: List Int) (labels: List Int) (numWanted: Nat) (useLimit: Nat)\n  (h1: values.length = labels.length)\n  (h2: numWanted > 0)\n  (h3: useLimit > 0)\n  (h4: ∀ x ∈ values, x ≥ 0) :\n  largest_vals_from_labels values labels numWanted useLimit ≥ 0 :=\n  sorry\n\ntheorem largest_vals_use_limit (values: List Int) (labels: List Int) (numWanted: Nat) (useLimit: Nat)\n  (h1: values.length = labels.length)\n  (h2: numWanted > 0)\n  (h3: useLimit > 0)\n  (label: Int) : \n  let filtered := (values.zip labels).filter (λ p => p.1 = label)\n  filtered.length ≤ useLimit :=\n  sorry\n\ntheorem largest_vals_single_label (values: List Int) (h: values.length > 0) :\n  largest_vals_from_labels values (List.replicate values.length 0) 1 1 = List.maximum values :=\n  sorry\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval largest_vals_from_labels [5, 4, 3, 2, 1] [1, 1, 2, 2, 3] 3 1\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval largest_vals_from_labels [5, 4, 3, 2, 1] [1, 3, 3, 3, 2] 3 2\n\n/-\ninfo: 16\n-/\n-- #guard_msgs in\n-- #eval largest_vals_from_labels [9, 8, 8, 7, 6] [0, 0, 0, 1, 1] 3 1", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0237", "language": "lean", "source": "fvapps", "source-id": "fvapps_000237", "source-notes": "", "vc-description": "/-\nOn an infinite plane, a robot initially stands at (0, 0) and faces north.  The robot can receive one of three instructions:\n\n\"G\": go straight 1 unit;\n\"L\": turn 90 degrees to the left;\n\"R\": turn 90 degress to the right.\n\nThe robot performs the instructions given in order, and repeats them forever.\nReturn true if and only if there exists a circle in the plane such that the robot never leaves the circle.\n\nExample 1:\nInput: \"GGLLGG\"\nOutput: true\nExplanation: \nThe robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).\nWhen repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.\n\nExample 2:\nInput: \"GG\"\nOutput: false\nExplanation: \nThe robot moves north indefinitely.\n\nExample 3:\nInput: \"GL\"\nOutput: true\nExplanation: \nThe robot moves from (0, 0) -> (0, 1) -> (-1, 1) -> (-1, 0) -> (0, 0) -> ...\n\nNote:\n\n1 <= instructions.length <= 100\ninstructions[i] is in {'G', 'L', 'R'}\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_robot_bounded (instructions : String) : Bool := sorry\n\ntheorem robot_boolean_output (instructions : String) :\n  is_robot_bounded instructions = true ∨ is_robot_bounded instructions = false := sorry", "vc-theorems": "theorem empty_string_bounded :\n  is_robot_bounded \"\" = true := sorry\n\ntheorem left_rotation_four_times (instructions : String) :\n  is_robot_bounded (\"LLLL\" ++ instructions) = is_robot_bounded instructions := sorry\n\ntheorem right_rotation_four_times (instructions : String) :\n  is_robot_bounded (\"RRRR\" ++ instructions) = is_robot_bounded instructions := sorry\n\ntheorem left_right_cancel (instructions : String) :\n  is_robot_bounded (\"LR\" ++ instructions) = is_robot_bounded instructions := sorry\n\ntheorem north_unbounded :\n  ∀ n : Nat, n > 0 → is_robot_bounded (String.mk (List.replicate n 'G')) = false := sorry\n\ntheorem turns_only_bounded (n : Nat) :\n  is_robot_bounded (String.mk (List.join (List.replicate n ['L', 'R']))) = true := sorry\n\ntheorem full_rotation_bounded :\n  is_robot_bounded \"LLLL\" = true ∧ is_robot_bounded \"RRRR\" = true := sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval is_robot_bounded \"GGLLGG\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval is_robot_bounded \"GG\"\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval is_robot_bounded \"GL\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0240", "language": "lean", "source": "fvapps", "source-id": "fvapps_000240", "source-notes": "", "vc-description": "/-\nGiven a number s in their binary representation. Return the number of steps to reduce it to 1 under the following rules:\n\nIf the current number is even, you have to divide it by 2.\n\nIf the current number is odd, you have to add 1 to it.\n\nIt's guaranteed that you can always reach to one for all testcases.\n\nExample 1:\nInput: s = \"1101\"\nOutput: 6\nExplanation: \"1101\" corressponds to number 13 in their decimal representation.\nStep 1) 13 is odd, add 1 and obtain 14. \nStep 2) 14 is even, divide by 2 and obtain 7.\nStep 3) 7 is odd, add 1 and obtain 8.\nStep 4) 8 is even, divide by 2 and obtain 4.  \nStep 5) 4 is even, divide by 2 and obtain 2. \nStep 6) 2 is even, divide by 2 and obtain 1.  \n\nExample 2:\nInput: s = \"10\"\nOutput: 1\nExplanation: \"10\" corressponds to number 2 in their decimal representation.\nStep 1) 2 is even, divide by 2 and obtain 1.  \n\nExample 3:\nInput: s = \"1\"\nOutput: 0\n\nConstraints:\n\n1 <= s.length <= 500\ns consists of characters '0' or '1'\ns[0] == '1'\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def num_steps (s : String) : Nat := sorry\n\ntheorem num_steps_non_negative (s : String) (h : s.startsWith \"1\") : \n  num_steps s ≥ 0 := sorry", "vc-theorems": "theorem single_one_zero_steps : \n  num_steps \"1\" = 0 := sorry\n\ntheorem min_steps_lower_bound (s : String) (h : s.startsWith \"1\") :\n  num_steps s ≥ s.length - 1 := sorry\n\ntheorem ten_pattern_steps :\n  num_steps \"10\" = 1 := sorry\n\ntheorem alternating_pattern_bound (n : Nat) (h : n ≥ 2) :\n  let s := \"1\" ++ String.mk (List.join (List.replicate n ['0', '1']));\n  num_steps s ≥ s.length := sorry\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval num_steps \"1101\"\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval num_steps \"10\"\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval num_steps \"1\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0245", "language": "lean", "source": "fvapps", "source-id": "fvapps_000245", "source-notes": "", "vc-description": "/-\nA 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\nGiven a row x col grid of integers, how many 3 x 3 \"magic square\" subgrids are there?  (Each subgrid is contiguous).\n\nExample 1:\n\nInput: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\n\nwhile this one is not:\n\nIn total, there is only one magic square inside the given grid.\n\nExample 2:\nInput: grid = [[8]]\nOutput: 0\n\nExample 3:\nInput: grid = [[4,4],[3,3]]\nOutput: 0\n\nExample 4:\nInput: grid = [[4,7,8],[9,5,1],[2,3,6]]\nOutput: 0\n\nConstraints:\n\nrow == grid.length\ncol == grid[i].length\n1 <= row, col <= 10\n0 <= grid[i][j] <= 15\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def numMagicSquaresInside (grid : List (List Int)) : Int := sorry\ndef isMagicSquare (square : List (List Int)) : Bool := sorry", "vc-theorems": "theorem numMagicSquaresInside_small_grid\n  (grid : List (List Int))\n  (h1 : grid.length < 3 ∨ grid.head!.length < 3) :\n  numMagicSquaresInside grid = 0 := sorry\n\ntheorem isMagicSquare_returns_bool (square : List (List Int)) :\n  isMagicSquare square = true ∨ isMagicSquare square = false := sorry\n\ntheorem isMagicSquare_invalid_range\n  (square : List (List Int))\n  (h1 : ∃ x, x ∈ square.join ∧ (x > 9 ∨ x < 1)) : \n  isMagicSquare square = false := sorry\n\ntheorem numMagicSquaresInside_empty_grid\n  (rows cols : Nat)\n  (h1 : rows ≥ 3)\n  (h2 : cols ≥ 3) :\n  numMagicSquaresInside (List.replicate rows (List.replicate cols 0)) ≥ 0 := sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval numMagicSquaresInside [[4, 3, 8, 4], [9, 5, 1, 9], [2, 7, 6, 2]]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval numMagicSquaresInside [[8]]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval numMagicSquaresInside [[4, 7, 8], [9, 5, 1], [2, 3, 6]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0252", "language": "lean", "source": "fvapps", "source-id": "fvapps_000252", "source-notes": "", "vc-description": "/-\nKoko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours.\nKoko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour.\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.\nReturn the minimum integer K such that she can eat all the bananas within H hours.\n\nExample 1:\nInput: piles = [3,6,7,11], H = 8\nOutput: 4\nExample 2:\nInput: piles = [30,11,23,4,20], H = 5\nOutput: 30\nExample 3:\nInput: piles = [30,11,23,4,20], H = 6\nOutput: 23\n\nConstraints:\n\n1 <= piles.length <= 10^4\npiles.length <= H <= 10^9\n1 <= piles[i] <= 10^9\n-/", "vc-preamble": "def List.maximum (l: List Nat) : Nat :=\nmatch l with\n| [] => 0\n| (x::xs) => xs.foldl Nat.max x\n\ndef List.sum (l: List Nat) : Nat :=\nmatch l with\n| [] => 0\n| (x::xs) => x + xs.sum", "vc-helpers": "", "vc-definitions": "def min_eating_speed (piles : List Nat) (h : Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_eating_speed_bounds {piles : List Nat} {h : Nat} (hpiles : piles ≠ []) \n  (hpile_bounds : ∀ x ∈ piles, 1 ≤ x ∧ x ≤ 10^4) (hh : 1 ≤ h ∧ h ≤ 10^4)\n  (hlen : piles.length ≤ h) :\n  let k := min_eating_speed piles h\n  1 ≤ k ∧ k ≤ List.maximum piles :=\nsorry\n\ntheorem min_eating_speed_finishes {piles : List Nat} {h : Nat} (hpiles : piles ≠ [])\n  (hlen : piles.length ≤ h) :\n  let k := min_eating_speed piles h\n  let hours_needed := List.sum (piles.map (fun p => (p + k - 1) / k))\n  hours_needed ≤ h :=\nsorry\n\ntheorem min_eating_speed_minimal {piles : List Nat} {h : Nat} (hpiles : piles ≠ [])\n  (hlen : piles.length ≤ h) :\n  let k := min_eating_speed piles h\n  k > 1 →\n  let slower := k - 1\n  let hours_slower := List.sum (piles.map (fun p => (p + slower - 1) / slower))\n  hours_slower > h :=\nsorry\n\ntheorem min_eating_speed_truly_minimal {piles : List Nat} {h : Nat} \n  (hpiles : piles ≠ []) (hlen : piles.length ≤ h)\n  (hpile_bounds : ∀ x ∈ piles, 1 ≤ x ∧ x ≤ 100) (hh : 1 ≤ h ∧ h ≤ 5) :\n  let k := min_eating_speed piles h\n  ∀ i, 1 ≤ i → i < k →\n  let hours := List.sum (piles.map (fun p => (p + i - 1) / i))\n  hours > h :=\nsorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval min_eating_speed [3, 6, 7, 11] 8\n\n/-\ninfo: 30\n-/\n-- #guard_msgs in\n-- #eval min_eating_speed [30, 11, 23, 4, 20] 5\n\n/-\ninfo: 23\n-/\n-- #guard_msgs in\n-- #eval min_eating_speed [30, 11, 23, 4, 20] 6", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0265", "language": "lean", "source": "fvapps", "source-id": "fvapps_000265", "source-notes": "", "vc-description": "/-\nGiven n boxes, each box is given in the format [status, candies, keys, containedBoxes] where:\n\nstatus[i]: an integer which is 1 if box[i] is open and 0 if box[i] is closed.\ncandies[i]: an integer representing the number of candies in box[i].\nkeys[i]: an array contains the indices of the boxes you can open with the key in box[i].\ncontainedBoxes[i]: an array contains the indices of the boxes found in box[i].\n\nYou will start with some boxes given in initialBoxes array. You can take all the candies in any open box and you can use the keys in it to open new boxes and you also can use the boxes you find in it.\nReturn the maximum number of candies you can get following the rules above.\n\nExample 1:\nInput: status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0]\nOutput: 16\nExplanation: You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2. Box 1 is closed and you don't have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2.\nIn box 1, you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed.\nTotal number of candies collected = 7 + 4 + 5 = 16 candy.\n\nExample 2:\nInput: status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0]\nOutput: 6\nExplanation: You have initially box 0. Opening it you can find boxes 1,2,3,4 and 5 and their keys. The total number of candies will be 6.\n\nExample 3:\nInput: status = [1,1,1], candies = [100,1,100], keys = [[],[0,2],[]], containedBoxes = [[],[],[]], initialBoxes = [1]\nOutput: 1\n\nExample 4:\nInput: status = [1], candies = [100], keys = [[]], containedBoxes = [[]], initialBoxes = []\nOutput: 0\n\nExample 5:\nInput: status = [1,1,1], candies = [2,3,2], keys = [[],[],[]], containedBoxes = [[],[],[]], initialBoxes = [2,1,0]\nOutput: 7\n\nConstraints:\n\n1 <= status.length <= 1000\nstatus.length == candies.length == keys.length == containedBoxes.length == n\nstatus[i] is 0 or 1.\n1 <= candies[i] <= 1000\n0 <= keys[i].length <= status.length\n0 <= keys[i][j] < status.length\nAll values in keys[i] are unique.\n0 <= containedBoxes[i].length <= status.length\n0 <= containedBoxes[i][j] < status.length\nAll values in containedBoxes[i] are unique.\nEach box is contained in one box at most.\n0 <= initialBoxes.length <= status.length\n0 <= initialBoxes[i] < status.length\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + sum xs\n\nstructure Box where\n  n : Nat\n  status : List Bool\n  candies : List Nat\n  keys : List (List Nat)\n  contained_boxes : List (List Nat)\n  initial_boxes : List Nat", "vc-helpers": "", "vc-definitions": "def maxCandies (status : List Bool) (candies : List Nat) (keys : List (List Nat))\n  (contained_boxes : List (List Nat)) (initial_boxes : List Nat) : Nat :=\n  sorry\n\n-- Result should be non-negative", "vc-theorems": "theorem maxCandies_nonnegative \n  (status : List Bool) (candies : List Nat) (keys : List (List Nat))\n  (contained_boxes : List (List Nat)) (initial_boxes : List Nat) :\n  maxCandies status candies keys contained_boxes initial_boxes ≥ 0 := sorry\n\n-- Result should not exceed sum of all candies\n\ntheorem maxCandies_upper_bound \n  (status : List Bool) (candies : List Nat) (keys : List (List Nat))\n  (contained_boxes : List (List Nat)) (initial_boxes : List Nat) :\n  maxCandies status candies keys contained_boxes initial_boxes ≤ List.sum candies := sorry\n\n-- Result should be zero if no boxes are unlocked\n\ntheorem maxCandies_all_locked \n  (status : List Bool) (candies : List Nat) (keys : List (List Nat))\n  (contained_boxes : List (List Nat)) (initial_boxes : List Nat) :\n  (∀ s ∈ status, s = false) → \n  maxCandies status candies keys contained_boxes initial_boxes = 0 := sorry\n\n/-\ninfo: 16\n-/\n-- #guard_msgs in\n-- #eval maxCandies [1, 0, 1, 0] [7, 5, 4, 100] [[], [], [1], []] [[1, 2], [3], [], []] [0]\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval maxCandies [1, 0, 0, 0, 0, 0] [1, 1, 1, 1, 1, 1] [[1, 2, 3, 4, 5], [], [], [], [], []] [[1, 2, 3, 4, 5], [], [], [], [], []] [0]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval maxCandies [1, 1, 1] [100, 1, 100] [[], [0, 2], []] [[], [], []] [1]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0267", "language": "lean", "source": "fvapps", "source-id": "fvapps_000267", "source-notes": "", "vc-description": "/-\nGiven an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.\n\nExample 1:\nInput: nums = [8,2,4,7], limit = 4\nOutput: 2 \nExplanation: All subarrays are: \n[8] with maximum absolute diff |8-8| = 0 <= 4.\n[8,2] with maximum absolute diff |8-2| = 6 > 4. \n[8,2,4] with maximum absolute diff |8-2| = 6 > 4.\n[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.\n[2] with maximum absolute diff |2-2| = 0 <= 4.\n[2,4] with maximum absolute diff |2-4| = 2 <= 4.\n[2,4,7] with maximum absolute diff |2-7| = 5 > 4.\n[4] with maximum absolute diff |4-4| = 0 <= 4.\n[4,7] with maximum absolute diff |4-7| = 3 <= 4.\n[7] with maximum absolute diff |7-7| = 0 <= 4. \nTherefore, the size of the longest subarray is 2.\n\nExample 2:\nInput: nums = [10,1,2,4,7,2], limit = 5\nOutput: 4 \nExplanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.\n\nExample 3:\nInput: nums = [4,2,2,2,4,4,2,2], limit = 0\nOutput: 3\n\nConstraints:\n\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n0 <= limit <= 10^9\n-/", "vc-preamble": "def maxEqualSeq : List Int → Nat \n  | [] => 1\n  | [x] => 1 \n  | x::y::xs => if x = y \n                then 1 + maxEqualSeq (y::xs)\n                else max 1 (maxEqualSeq (y::xs))", "vc-helpers": "", "vc-definitions": "def longestSubarray (nums : List Int) (limit : Nat) : Nat := sorry\n\ntheorem longestSubarray_result_bounds \n  {nums : List Int} {limit : Nat} (h : nums ≠ []) : \n  1 ≤ (longestSubarray nums limit) ∧ (longestSubarray nums limit) ≤ nums.length := sorry\n\n/- There exists a valid subarray of length equal to the result -/", "vc-theorems": "theorem longestSubarray_exists_valid_window\n  {nums : List Int} {limit : Nat} (h : nums ≠ []) :\n  ∃ i, i + (longestSubarray nums limit) ≤ nums.length ∧ \n    let window := nums.take (i + (longestSubarray nums limit)) |>.drop i\n    (window.maximum? |>.getD 0) - (window.minimum? |>.getD 0) ≤ limit := sorry\n\n/- No larger valid window exists -/\n\ntheorem longestSubarray_optimal\n  {nums : List Int} {limit : Nat} (h : nums ≠ []) :\n  ∀ i len, i + len ≤ nums.length → len > (longestSubarray nums limit) →\n    let window := nums.take (i + len) |>.drop i\n    (window.maximum? |>.getD 0) - (window.minimum? |>.getD 0) > limit := sorry\n\n/- For zero limit, result equals longest sequence of equal numbers -/\n\ntheorem longestSubarray_zero_limit\n  {nums : List Int} (h : nums ≠ []) :\n  longestSubarray nums 0 = maxEqualSeq nums := sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval longestSubarray [8, 2, 4, 7] 4\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval longestSubarray [10, 1, 2, 4, 7, 2] 5\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval longestSubarray [4, 2, 2, 2, 4, 4, 2, 2] 0", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0279", "language": "lean", "source": "fvapps", "source-id": "fvapps_000279", "source-notes": "", "vc-description": "/-\nGiven 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i. \nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nWe want to calculate the probability that the two boxes have the same number of distinct balls.\n\nExample 1:\nInput: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1\n\nExample 2:\nInput: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equale probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667\n\nExample 3:\nInput: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6\n\nExample 4:\nInput: balls = [3,2,1]\nOutput: 0.30000\nExplanation: The set of balls is [1, 1, 1, 2, 2, 3]. It is hard to display all the 60 possible random shuffles of this set but it is easy to check that 18 of them will have the same number of distinct colors in each box.\nProbability = 18 / 60 = 0.3\n\nExample 5:\nInput: balls = [6,6,6,6,6,6]\nOutput: 0.90327\n\nConstraints:\n\n1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.\nAnswers within 10^-5 of the actual value will be accepted as correct.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (h :: t) => h + sum t", "vc-helpers": "", "vc-definitions": "def get_probability (balls : List Nat) : Float := sorry\n\ntheorem probability_bounds {balls : List Nat} \n  (h1 : balls.length ≥ 2)\n  (h2 : balls.length ≤ 4) \n  (h3 : ∀ x ∈ balls, 1 ≤ x ∧ x ≤ 3)\n  (h4 : (List.sum balls) % 2 = 0) :\n  0 ≤ get_probability balls ∧ get_probability balls ≤ 1 := sorry", "vc-theorems": "theorem symmetric_cases {balls : List Nat}\n  (h1 : balls.length ≥ 2)\n  (h2 : balls.length ≤ 4)\n  (h3 : ∀ x ∈ balls, 1 ≤ x ∧ x ≤ 3) \n  (h4 : (List.sum balls) % 2 = 0) :\n  get_probability balls = get_probability balls.reverse := sorry\n\ntheorem edge_cases_one :\n  get_probability [1, 1] = 1 := sorry\n\ntheorem edge_cases_two :\n  get_probability [2, 2] = 1 := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0295", "language": "lean", "source": "fvapps", "source-id": "fvapps_000295", "source-notes": "", "vc-description": "/-\nGiven the coordinates of four points in 2D space, return whether the four points could construct a square.\n\nThe coordinate (x,y) of a point is represented by an integer array with two integers.\n\nExample:\n\nInput: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\nOutput: True\n\n Note: \n\nAll the input integers are in the range [-10000, 10000].\nA valid square has four equal sides with positive length and four equal angles (90-degree angles).\nInput points have no order.\n-/", "vc-preamble": "def distance (p1 p2 : Point) : Int :=\n  (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y)", "vc-helpers": "", "vc-definitions": "def validSquare (p1 p2 p3 p4 : Point) : Bool :=\n  sorry\n\n-- If validSquare returns true, then fundamental properties of a square hold", "vc-theorems": "theorem valid_square_properties (p1 p2 p3 p4 : Point) :\n  validSquare p1 p2 p3 p4 = true →\n  ∃ side diag : Int,\n    -- All sides have equal length\n    (distance p1 p2 = side ∧\n     distance p2 p3 = side ∧\n     distance p3 p4 = side ∧\n     distance p4 p1 = side) ∧\n    -- Both diagonals have equal length\n    (distance p1 p3 = diag ∧\n     distance p2 p4 = diag) ∧\n    -- Diagonals are longer than sides\n    diag > side ∧\n    -- Side length is positive\n    side > 0 :=\n  sorry\n\n-- Four identical points cannot form a valid square\n\ntheorem degenerate_case (p : Point) :\n  validSquare p p p p = false :=\n  sorry\n\n-- Unit square is valid\n\ntheorem unit_square_valid :\n  validSquare ⟨0,0⟩ ⟨1,0⟩ ⟨1,1⟩ ⟨0,1⟩ = true :=\n  sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval validSquare [0, 0] [1, 1] [1, 0] [0, 1]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval validSquare [0, 0] [2, 0] [2, 1] [0, 1]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval validSquare [0, 0] [0, 0] [0, 0] [0, 0]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0307", "language": "lean", "source": "fvapps", "source-id": "fvapps_000307", "source-notes": "", "vc-description": "/-\nYou are given two strings s1 and s2 of equal length consisting of letters \"x\" and \"y\" only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].\nReturn the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.\n\nExample 1:\nInput: s1 = \"xx\", s2 = \"yy\"\nOutput: 1\nExplanation: \nSwap s1[0] and s2[1], s1 = \"yx\", s2 = \"yx\".\nExample 2: \nInput: s1 = \"xy\", s2 = \"yx\"\nOutput: 2\nExplanation: \nSwap s1[0] and s2[0], s1 = \"yy\", s2 = \"xx\".\nSwap s1[0] and s2[1], s1 = \"xy\", s2 = \"xy\".\nNote that you can't swap s1[0] and s1[1] to make s1 equal to \"yx\", cause we can only swap chars in different strings.\nExample 3:\nInput: s1 = \"xx\", s2 = \"xy\"\nOutput: -1\n\nExample 4:\nInput: s1 = \"xxyyxyxyxx\", s2 = \"xyyxyxxxyx\"\nOutput: 4\n\nConstraints:\n\n1 <= s1.length, s2.length <= 1000\ns1, s2 only contain 'x' or 'y'.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def minimumSwap (s1 s2 : List XY) : Int := sorry\n\ntheorem string_length_equal (s1 s2 : List XY) :\n  minimumSwap s1 s2 ≠ -1 → s1.length = s2.length := sorry", "vc-theorems": "theorem result_bounds (s1 s2 : List XY) : \n  let result := minimumSwap s1 s2\n  result ≠ -1 → 0 ≤ result ∧ result ≤ s1.length := sorry\n\ntheorem invalid_case_parity (s1 s2 : List XY) :\n  let xy := (List.zip s1 s2).filter (fun p => decide (p.1 = XY.x) && decide (p.2 = XY.y)) |>.length\n  let yx := (List.zip s1 s2).filter (fun p => decide (p.1 = XY.y) && decide (p.2 = XY.x)) |>.length\n  (xy + yx) % 2 = 1 → minimumSwap s1 s2 = -1 := sorry\n\ntheorem identical_strings_no_swaps (s : List XY) :\n  minimumSwap s s = 0 := sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval minimumSwap \"xx\" \"yy\"\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval minimumSwap \"xy\" \"yx\"\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval minimumSwap \"xx\" \"xy\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0325", "language": "lean", "source": "fvapps", "source-id": "fvapps_000325", "source-notes": "", "vc-description": "/-\nGiven a string s and an array of integers cost where cost[i] is the cost of deleting the ith character in s.\nReturn the minimum cost of deletions such that there are no two identical letters next to each other.\nNotice that you will delete the chosen characters at the same time, in other words, after deleting a character, the costs of deleting other characters will not change.\n\nExample 1:\nInput: s = \"abaac\", cost = [1,2,3,4,5]\nOutput: 3\nExplanation: Delete the letter \"a\" with cost 3 to get \"abac\" (String without two identical letters next to each other).\n\nExample 2:\nInput: s = \"abc\", cost = [1,2,3]\nOutput: 0\nExplanation: You don't need to delete any character because there are no identical letters next to each other.\n\nExample 3:\nInput: s = \"aabaa\", cost = [1,2,3,4,1]\nOutput: 2\nExplanation: Delete the first and the last character, getting the string (\"aba\").\n\nConstraints:\n\ns.length == cost.length\n1 <= s.length, cost.length <= 10^5\n1 <= cost[i] <= 10^4\ns contains only lowercase English letters.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def min_cost (s : String) (cost : List Nat) : Nat := sorry\n\ndef is_valid_result (s : String) (cost : List Nat) (result : Nat) : Bool := sorry", "vc-theorems": "theorem min_cost_properties {s : String} {cost : List Nat} \n  (h : cost.length = s.length) :\n  let result := min_cost s cost\n  (result ≥ 0) ∧ \n  (result ≤ List.sum cost) ∧\n  (is_valid_result s cost result = true) :=\nsorry\n\ntheorem same_chars_cost {s : String} {cost : List Nat}\n  (h1 : cost.length = s.length)\n  (h2 : ∀ (i j : String.Pos), s.get i = s.get j)\n  (h3 : ∀ (i : Fin cost.length), cost.get i = i.val + 1) :\n  min_cost s cost = List.sum (cost.take (cost.length - 1)) :=\nsorry\n\ntheorem unique_chars_zero_cost {s : String} {cost : List Nat}\n  (h1 : cost.length = s.length) \n  (h2 : ∀ (i j : String.Pos), i ≠ j → s.get i ≠ s.get j)\n  (h3 : ∀ (i : Fin cost.length), cost.get i = i.val + 1) :\n  min_cost s cost = 0 :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval min_cost \"abaac\" [1, 2, 3, 4, 5]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval min_cost \"abc\" [1, 2, 3]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval min_cost \"aabaa\" [1, 2, 3, 4, 1]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0326", "language": "lean", "source": "fvapps", "source-id": "fvapps_000326", "source-notes": "", "vc-description": "/-\nYou are installing a billboard and want it to have the largest height.  The billboard will have two steel supports, one on each side.  Each steel support must be an equal height.\nYou have a collection of rods which can be welded together.  For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.\nReturn the largest possible height of your billboard installation.  If you cannot support the billboard, return 0.\n\nExample 1:\nInput: [1,2,3,6]\nOutput: 6\nExplanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.\n\nExample 2:\nInput: [1,2,3,4,5,6]\nOutput: 10\nExplanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.\n\nExample 3:\nInput: [1,2]\nOutput: 0\nExplanation: The billboard cannot be supported, so we return 0.\n\nNote:\n\n0 <= rods.length <= 20\n1 <= rods[i] <= 1000\nThe sum of rods is at most 5000.\n-/", "vc-preamble": "def List.sum : List Int → Int \n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def List.sort (xs : List Int) : List Int := sorry\n\ndef tallestBillboard (rods: List Int) : Int := sorry\n\n/- The result of tallestBillboard is non-negative -/", "vc-theorems": "theorem tallestBillboard_nonneg {rods: List Int}\n  (h: ∀ x ∈ rods, x > 0) : \n  tallestBillboard rods ≥ 0 := sorry\n\n/- The result cannot exceed half the sum of all rods -/\n\ntheorem tallestBillboard_upper_bound {rods: List Int}\n  (h: ∀ x ∈ rods, x > 0) :\n  2 * tallestBillboard rods ≤ List.sum rods := sorry\n\n/- The result is invariant under sorting -/\n\ntheorem tallestBillboard_sort_invariant {rods: List Int}\n  (h: ∀ x ∈ rods, x > 0) :\n  tallestBillboard rods = tallestBillboard (List.sort rods) := sorry\n\n/- Empty input results in 0 -/\n\ntheorem tallestBillboard_empty :\n  tallestBillboard [] = 0 := sorry\n\n/- Single input results in 0 -/\n\ntheorem tallestBillboard_singleton (x: Int)\n  (h: x > 0) :\n  tallestBillboard [x] = 0 := sorry\n\n/- For input of length 2, result is input value if equal, 0 otherwise -/\n\ntheorem tallestBillboard_pair (x y: Int)\n  (hx: x > 0) (hy: y > 0) :\n  tallestBillboard [x, y] = (if x = y then x else 0) := sorry\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval tallestBillboard [1, 2, 3, 6]\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval tallestBillboard [1, 2, 3, 4, 5, 6]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval tallestBillboard [1, 2]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0336", "language": "lean", "source": "fvapps", "source-id": "fvapps_000336", "source-notes": "", "vc-description": "/-\nGiven an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.\n\nNote:\nIf n is the length of array, assume the following constraints are satisfied:\n\n1 ≤ n ≤ 1000\n1 ≤ m ≤ min(50, n)\n\nExamples: \n\nInput:\nnums = [7,2,5,10,8]\nm = 2\n\nOutput:\n18\n\nExplanation:\nThere are four ways to split nums into two subarrays.\nThe best way is to split it into [7,2,5] and [10,8],\nwhere the largest sum among the two subarrays is only 18.\n-/", "vc-preamble": "def splitArray (nums : List Nat) (m : Nat) : Nat := sorry\n\ndef listSum : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + listSum xs", "vc-helpers": "", "vc-definitions": "def listMax : List Nat → Nat \n  | [] => 0\n  | [x] => x\n  | (x::xs) => max x (listMax xs)", "vc-theorems": "theorem splitArray_bounds (nums : List Nat) (m : Nat) (h1 : nums ≠ []) (h2 : m > 0) :\n  let m' := min m (List.length nums)\n  let result := splitArray nums m'\n  result ≥ (listMax nums) ∧ result ≤ (listSum nums) := sorry\n\ntheorem splitArray_m_one (nums : List Nat) (h1 : nums ≠ []) :\n  splitArray nums 1 = listSum nums := sorry\n\ntheorem splitArray_m_len (nums : List Nat) (h1 : nums ≠ []) :\n  splitArray nums (List.length nums) = listMax nums := sorry\n\ntheorem splitArray_valid_split (nums : List Nat) (m : Nat) (h1 : nums ≠ []) (h2 : m > 0) :\n  let m' := min m (List.length nums)\n  let maxSum := splitArray nums m'\n  ∃ splits : Nat, splits ≤ m' ∧\n    ∃ partitions : List (List Nat),\n      List.length partitions = splits ∧\n      List.join partitions = nums ∧\n      (∀ p ∈ partitions, listSum p ≤ maxSum) := sorry\n\n/-\ninfo: 18\n-/\n-- #guard_msgs in\n-- #eval split_array #[7, 2, 5, 10, 8] 2\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval split_array #[1, 2, 3, 4, 5] 2\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval split_array #[1, 4, 4] 3", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0340", "language": "lean", "source": "fvapps", "source-id": "fvapps_000340", "source-notes": "", "vc-description": "/-\nGiven an array nums of integers, you can perform operations on the array.\n\nIn each operation, you pick any nums[i] and delete it to earn nums[i] points.  After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.\n\nYou start with 0 points.  Return the maximum number of points you can earn by applying such operations.\n\nExample 1:\n\nInput: nums = [3, 4, 2]\nOutput: 6\nExplanation: \nDelete 4 to earn 4 points, consequently 3 is also deleted.\nThen, delete 2 to earn 2 points. 6 total points are earned.\n\nExample 2:\n\nInput: nums = [2, 2, 3, 3, 3, 4]\nOutput: 9\nExplanation: \nDelete 3 to earn 3 points, deleting both 2's and the 4.\nThen, delete 3 again to earn 3 points, and 3 again to earn 3 points.\n9 total points are earned.\n\nNote:\nThe length of nums is at most 20000.\nEach element nums[i] is an integer in the range [1, 10000].\n-/", "vc-preamble": "def delete_and_earn (nums : List Nat) : Nat := sorry\n\ndef List.sum : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + List.sum xs\n\ndef List.maximum' : List Nat → Nat \n  | [] => 0\n  | [x] => x\n  | (x::xs) => max x (List.maximum' xs)\n\ndef isConsecutive (nums : List Nat) : Bool := sorry\n\ndef sumByParity (nums : List Nat) (isOdd : Bool) : Nat := \n  List.sum (List.filter (fun n => n % 2 = if isOdd then 1 else 0) nums)", "vc-helpers": "", "vc-definitions": "def isSpaced (nums : List Nat) : Bool := sorry\n\ntheorem spaced_numbers (nums : List Nat) (h : nums.length ≥ 2) :\n  isSpaced nums = true →\n  delete_and_earn nums = List.sum nums := sorry", "vc-theorems": "theorem delete_and_earn_properties (nums : List Nat) :\n  let result := delete_and_earn nums;\n  (nums = [] → result = 0) ∧\n  (nums ≠ [] →\n    let max_num := List.maximum' nums;\n    let max_count := (List.filter (fun x => x = max_num) nums).length;\n    result ≥ max_num * max_count) ∧\n  result ≤ List.sum nums := sorry\n\ntheorem consecutive_numbers (nums : List Nat) (h : nums ≠ []) :\n  isConsecutive nums = true →\n  delete_and_earn nums = max (sumByParity nums true) (sumByParity nums false) := sorry\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval delete_and_earn [3, 4, 2]\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval delete_and_earn [2, 2, 3, 3, 3, 4]\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval delete_and_earn [2, 3, 4]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0347", "language": "lean", "source": "fvapps", "source-id": "fvapps_000347", "source-notes": "", "vc-description": "/-\nWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n\n       Integers in each row are sorted from left to right.\n       The first integer of each row is greater than the last integer of the previous row.\n\nExample 1:\n\nInput:\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 3\nOutput: true\n\nExample 2:\n\nInput:\nmatrix = [\n  [1,   3,  5,  7],\n  [10, 11, 16, 20],\n  [23, 30, 34, 50]\n]\ntarget = 13\nOutput: false\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def searchMatrix (matrix : List (List Int)) (target : Int) : Bool := sorry\n\ndef is_sorted_matrix (matrix : List (List Int)) : Bool := sorry", "vc-theorems": "theorem search_empty_matrix (target : Int) :\n  searchMatrix [] target = false ∧ \n  searchMatrix [[]] target = false :=\n  sorry\n\ntheorem search_sorted_matrix_exists (rows cols base : Nat) \n  (h1 : 0 < rows) (h2 : 0 < cols) :\n  ∀ (matrix : List (List Int)),\n  is_sorted_matrix matrix →\n  ∀ (i : Nat), i < rows * cols →\n  let row := i / cols\n  let col := i % cols\n  searchMatrix matrix (((matrix.get! row).get!) col) = true :=\n  sorry\n\ntheorem search_sorted_matrix_between (rows cols base : Nat)\n  (h1 : 0 < rows) (h2 : 0 < cols) (h3 : rows * cols > 1) :\n  ∀ (matrix : List (List Int)),\n  is_sorted_matrix matrix →\n  ∀ (i : Nat), i + 1 < rows * cols →\n  let flat := matrix.join\n  let curr := flat.get! i \n  let next := flat.get! (i+1)\n  next - curr > 1 →\n  searchMatrix matrix (curr + 1) = false :=\n  sorry\n\ntheorem search_consistent_matrix (matrix : List (List Int)) (target : Int)\n  (h1 : ∀ row ∈ matrix, row.length = matrix.head!.length) :\n  is_sorted_matrix matrix →\n  searchMatrix matrix target = \n    matrix.any (List.contains · target) :=\n  sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval searchMatrix [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] 3\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval searchMatrix [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]] 13\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval searchMatrix [[]] 1", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0349", "language": "lean", "source": "fvapps", "source-id": "fvapps_000349", "source-notes": "", "vc-description": "/-\nTo some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).\nEach replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing.\nFor example, if we have S = \"abcd\" and we have some replacement operation i = 2, x = \"cd\", y = \"ffff\", then because \"cd\" starts at position 2 in the original string S, we will replace it with \"ffff\".\nUsing another example on S = \"abcd\", if we have both the replacement operation i = 0, x = \"ab\", y = \"eee\", as well as another replacement operation i = 2, x = \"ec\", y = \"ffff\", this second operation does nothing because in the original string S[2] = 'c', which doesn't match x[0] = 'e'.\nAll these operations occur simultaneously.  It's guaranteed that there won't be any overlap in replacement: for example, S = \"abc\", indexes = [0, 1], sources = [\"ab\",\"bc\"] is not a valid test case.\nExample 1:\nInput: S = \"abcd\", indexes = [0,2], sources = [\"a\",\"cd\"], targets = [\"eee\",\"ffff\"]\nOutput: \"eeebffff\"\nExplanation: \"a\" starts at index 0 in S, so it's replaced by \"eee\".\n\"cd\" starts at index 2 in S, so it's replaced by \"ffff\".\n\nExample 2:\nInput: S = \"abcd\", indexes = [0,2], sources = [\"ab\",\"ec\"], targets = [\"eee\",\"ffff\"]\nOutput: \"eeecd\"\nExplanation: \"ab\" starts at index 0 in S, so it's replaced by \"eee\". \n\"ec\" doesn't starts at index 2 in the original S, so we do nothing.\n\nNotes:\n\n0 <= indexes.length = sources.length = targets.length <= 100\n0 < indexes[i] < S.length <= 1000\nAll characters in given inputs are lowercase letters.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_replace_string (s: String) (indexes: List Nat) (sources targets: List String) : String :=\n  sorry", "vc-theorems": "theorem output_is_string {s: String} {indexes: List Nat} {sources targets: List String}:\n  find_replace_string s indexes sources targets = (find_replace_string s indexes sources targets) := by\n  sorry\n\ntheorem unchanged_on_non_matches {s: String} {indexes: List Nat} {sources targets: List String}:\n  ∀ (i: Nat) (src tgt: String),\n  (i ∈ indexes) →\n  (sources.getD (indexes.indexOf i) \"\" = src) → \n  (targets.getD (indexes.indexOf i) \"\" = tgt) →\n  (i < s.length) →\n  (String.take (String.drop s i) src.length ≠ src) →\n  (find_replace_string s indexes sources targets).all (fun c => ¬tgt.contains c) := by\n  sorry\n\n/-\ninfo: 'eeebffff'\n-/\n-- #guard_msgs in\n-- #eval find_replace_string \"abcd\" [0, 2] [\"a\", \"cd\"] [\"eee\", \"ffff\"]\n\n/-\ninfo: 'eeecd'\n-/\n-- #guard_msgs in\n-- #eval find_replace_string \"abcd\" [0, 2] [\"ab\", \"ec\"] [\"eee\", \"ffff\"]\n\n/-\ninfo: 'baa'\n-/\n-- #guard_msgs in\n-- #eval find_replace_string \"aaa\" [0] [\"a\"] [\"b\"]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0350", "language": "lean", "source": "fvapps", "source-id": "fvapps_000350", "source-notes": "", "vc-description": "/-\nGiven a square array of integers A, we want the minimum sum of a falling path through A.\nA falling path starts at any element in the first row, and chooses one element from each row.  The next row's choice must be in a column that is different from the previous row's column by at most one.\n\nExample 1:\nInput: [[1,2,3],[4,5,6],[7,8,9]]\nOutput: 12\nExplanation: \nThe possible falling paths are:\n\n[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]\n[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]\n[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]\n\nThe falling path with the smallest sum is [1,4,7], so the answer is 12.\n\nConstraints:\n\n1 <= A.length == A[0].length <= 100\n-100 <= A[i][j] <= 100\n-/", "vc-preamble": "def Matrix (α : Type) := List (List α)\n\ndef List.sum (xs : List Int) : Int := \n  match xs with\n  | [] => 0\n  | (x::xs) => x + xs.sum\n\ndef minFallingPathSum (matrix : Matrix Int) : Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def isValidMatrix (matrix : Matrix Int) : Bool :=\n  match matrix with\n  | [] => false\n  | r::_ => let n := r.length\n            matrix.all (fun row => row.length == n)", "vc-theorems": "theorem min_falling_path_sum_bounded_by_row_extremes {matrix : Matrix Int} \n  (h : isValidMatrix matrix = true) :\n  minFallingPathSum matrix ≤ (matrix.map (fun row => row.maximum?.getD 0)).sum ∧ \n  minFallingPathSum matrix ≥ (matrix.map (fun row => row.minimum?.getD 0)).sum :=\nsorry\n\ntheorem single_column_matrix_sum {matrix : Matrix Int}\n  (h1 : matrix.all (fun row => row.length = 1) = true)\n  (h2 : matrix.length > 0) :\n  minFallingPathSum matrix = (matrix.map (fun row => row.head!)).sum :=\nsorry\n\ntheorem falling_path_bounded_by_first_last_rows {matrix : Matrix Int}\n  (h : isValidMatrix matrix = true) \n  (h2 : matrix.length > 0) :\n  minFallingPathSum matrix ≥ \n    (matrix.head!.minimum?.getD 0) + \n    (matrix.tail.map (fun row => row.minimum?.getD 0)).sum ∧\n  minFallingPathSum matrix ≤ \n    (matrix.head!.maximum?.getD 0) + \n    (matrix.dropLast.tail.map (fun row => row.maximum?.getD 0)).sum +\n    (matrix.getLast?.getD []).maximum?.getD 0 :=\nsorry\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval min_falling_path_sum [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval min_falling_path_sum [[1]]\n\n/-\ninfo: 13\n-/\n-- #guard_msgs in\n-- #eval min_falling_path_sum [[2, 1, 3], [6, 5, 4], [7, 8, 9]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0351", "language": "lean", "source": "fvapps", "source-id": "fvapps_000351", "source-notes": "", "vc-description": "/-\nA conveyor belt has packages that must be shipped from one port to another within D days.\nThe i-th package on the conveyor belt has a weight of weights[i].  Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.\n\nExample 1:\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\nOutput: 15\nExplanation: \nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\n1st day: 1, 2, 3, 4, 5\n2nd day: 6, 7\n3rd day: 8\n4th day: 9\n5th day: 10\n\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \n\nExample 2:\nInput: weights = [3,2,2,4,1,4], D = 3\nOutput: 6\nExplanation: \nA ship capacity of 6 is the minimum to ship all the packages in 3 days like this:\n1st day: 3, 2\n2nd day: 2, 4\n3rd day: 1, 4\n\nExample 3:\nInput: weights = [1,2,3,1,1], D = 4\nOutput: 3\nExplanation: \n1st day: 1\n2nd day: 2\n3rd day: 3\n4th day: 1, 1\n\nConstraints:\n\n1 <= D <= weights.length <= 50000\n1 <= weights[i] <= 500\n-/", "vc-preamble": "def List.sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def ship_within_days (weights : List Nat) (days : Nat) : Nat := sorry\n\ntheorem ship_within_days_one_day (weights : List Nat) \n  (h : weights ≠ []) :\n  ship_within_days weights 1 = List.sum weights :=\n  sorry", "vc-theorems": "theorem ship_within_days_max_days (weights : List Nat)\n  (h : weights ≠ []) :\n  ship_within_days weights (List.length weights) ≥ (List.maximum? weights).getD 0 :=\n  sorry\n\ntheorem ship_within_days_monotonic (weights : List Nat) \n  (d1 d2 : Nat)\n  (h1 : List.length weights ≥ 2)\n  (h2 : d1 ≤ d2) :\n  ship_within_days weights d1 ≥ ship_within_days weights d2 :=\n  sorry\n\n/-\ninfo: 15\n-/\n-- #guard_msgs in\n-- #eval ship_within_days [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 5\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval ship_within_days [3, 2, 2, 4, 1, 4] 3\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval ship_within_days [1, 2, 3, 1, 1] 4", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0360", "language": "lean", "source": "fvapps", "source-id": "fvapps_000360", "source-notes": "", "vc-description": "/-\nGiven a m x n binary matrix mat. In one step, you can choose one cell and flip it and all the four neighbours of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighboors if they share one edge.\nReturn the minimum number of steps required to convert mat to a zero matrix or -1 if you cannot.\nBinary matrix is a matrix with all cells equal to 0 or 1 only.\nZero matrix is a matrix with all cells equal to 0.\n\nExample 1:\n\nInput: mat = [[0,0],[0,1]]\nOutput: 3\nExplanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown.\n\nExample 2:\nInput: mat = [[0]]\nOutput: 0\nExplanation: Given matrix is a zero matrix. We don't need to change it.\n\nExample 3:\nInput: mat = [[1,1,1],[1,0,1],[0,0,0]]\nOutput: 6\n\nExample 4:\nInput: mat = [[1,0,0],[1,0,0]]\nOutput: -1\nExplanation: Given matrix can't be a zero matrix\n\nConstraints:\n\nm == mat.length\nn == mat[0].length\n1 <= m <= 3\n1 <= n <= 3\nmat[i][j] is 0 or 1.\n-/", "vc-preamble": "def minFlips (mat: Matrix) : Int :=\n  sorry\n\ndef isZeroMatrix (m: Matrix) : Bool :=\n  match m with\n  | Matrix.mk rows => rows.all (fun row => row.all (fun x => x = 0))\n\ndef flipCells (mat: Matrix) (state: Nat) : Matrix :=\n  sorry", "vc-helpers": "", "vc-definitions": "def isOnesMatrix (m: Matrix) : Bool := \n  match m with\n  | Matrix.mk rows => rows.all (fun row => row.all (fun x => x = 1))", "vc-theorems": "theorem minflips_result_valid (mat: Matrix) : \n  minFlips mat ≥ -1 :=\n  sorry\n\ntheorem minflips_zero_matrix (mat: Matrix)\n  (h: isZeroMatrix mat = true) :\n  minFlips mat = 0 :=\n  sorry\n\ntheorem minflips_minus_one_means_impossible (mat: Matrix)\n  (h: minFlips mat = -1) :\n  ∀ state, ¬ isZeroMatrix (flipCells mat state) :=\n  sorry\n\ntheorem minflips_ones_matrix_valid (mat: Matrix)\n  (h: isOnesMatrix mat = true) :\n  minFlips mat ≥ -1 :=\n  sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval minFlips [[0, 0], [0, 1]]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval minFlips [[0]]\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval minFlips [[1, 1, 1], [1, 0, 1], [0, 0, 0]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0365", "language": "lean", "source": "fvapps", "source-id": "fvapps_000365", "source-notes": "", "vc-description": "/-\nGiven an array A of strings, find any smallest string that contains each string in A as a substring.\nWe may assume that no string in A is substring of another string in A.\n\nExample 1:\nInput: [\"alex\",\"loves\",\"leetcode\"]\nOutput: \"alexlovesleetcode\"\nExplanation: All permutations of \"alex\",\"loves\",\"leetcode\" would also be accepted.\n\nExample 2:\nInput: [\"catg\",\"ctaagt\",\"gcta\",\"ttca\",\"atgcatc\"]\nOutput: \"gctaagttcatgcatc\"\n\nNote:\n\n1 <= A.length <= 12\n1 <= A[i].length <= 20\n-/", "vc-preamble": "def List.sum [Add α] (xs : List α) : α :=\n  match xs with\n  | [] => sorry\n  | x :: xs => x + xs.sum", "vc-helpers": "", "vc-definitions": "def shortest_superstring (strings : List (List Char)) : List Char :=\n  sorry", "vc-theorems": "theorem superstring_contains_all_inputs (strings : List (List Char)) \n  (h : strings ≠ []) : \n  ∀ s ∈ strings, ∃ i, strings.get ⟨i, sorry⟩ = s :=\nsorry\n\ntheorem superstring_length_less_than_sum (strings : List (List Char))\n  (h : strings ≠ []) :\n  (shortest_superstring strings).length ≤ List.sum (strings.map List.length) :=\nsorry\n\ntheorem superstring_handles_overlaps (strings : List (List Char)) \n  (h₁ : strings ≠ [])\n  (h₂ : strings.length ≥ 2) :\n  (shortest_superstring strings).length ≤ List.sum (strings.map List.length) :=\nsorry\n\ntheorem superstring_identity_single (s : List Char) :\n  shortest_superstring [s] = s :=\nsorry\n\ntheorem superstring_basic_example :\n  (shortest_superstring [['a','b','c'], ['b','c','d']]).length ≤ 4 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0369", "language": "lean", "source": "fvapps", "source-id": "fvapps_000369", "source-notes": "", "vc-description": "/-\nGiven a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n\nNote:\n\nEach of the array element will not exceed 100.\nThe array size will not exceed 200.\n\nExample 1:\n\nInput: [1, 5, 11, 5]\n\nOutput: true\n\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n\nExample 2:\n\nInput: [1, 2, 3, 5]\n\nOutput: false\n\nExplanation: The array cannot be partitioned into equal sum subsets.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def canPartition (nums : List Nat) : Bool := sorry\n\ndef List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + List.sum xs", "vc-theorems": "theorem canPartition_returns_bool (nums : List Nat) :\n  canPartition nums = true ∨ canPartition nums = false :=\nsorry\n\ntheorem canPartition_odd_sum_false (nums : List Nat) :\n  (List.sum nums % 2 ≠ 0) → canPartition nums = false :=\nsorry \n\ntheorem canPartition_same_nums_even_length (n : Nat) (len : Nat) :\n  len % 2 = 0 →\n  canPartition (List.replicate len n) = true :=\nsorry\n\ntheorem canPartition_singleton_false (n : Nat) :\n  canPartition [n] = false :=\nsorry\n\ntheorem canPartition_pair_same_true (n : Nat) :\n  canPartition [n, n] = true :=\nsorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval can_partition [1, 5, 5, 11]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval can_partition [1, 2, 3, 5]\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval can_partition [2, 2, 2, 2]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0397", "language": "lean", "source": "fvapps", "source-id": "fvapps_000397", "source-notes": "", "vc-description": "/-\nGiven a balanced parentheses string S, compute the score of the string based on the following rule:\n\n() has score 1\nAB has score A + B, where A and B are balanced parentheses strings.\n(A) has score 2 * A, where A is a balanced parentheses string.\n\nExample 1:\nInput: \"()\"\nOutput: 1\n\nExample 2:\nInput: \"(())\"\nOutput: 2\n\nExample 3:\nInput: \"()()\"\nOutput: 2\n\nExample 4:\nInput: \"(()(()))\"\nOutput: 6\n\nNote:\n\nS is a balanced parentheses string, containing only ( and ).\n2 <= S.length <= 50\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def score_parentheses (s : ParenString) : Nat :=\n  sorry", "vc-theorems": "theorem nested_pairs_score {n : Nat} (h : 0 < n) (h2 : n ≤ 10) :\n  let s : ParenString := ⟨\"(())\"⟩\n  score_parentheses s = 2^(n-1) :=\n  sorry\n\ntheorem sequential_nested_score {depths : List Nat}\n  (h1 : ∀ x ∈ depths, 0 < x ∧ x ≤ 3)\n  (h2 : depths.length ≥ 1)\n  (h3 : depths.length ≤ 5) :\n  let s : ParenString := ⟨\"(())(())\"⟩\n  score_parentheses s = depths.foldl (fun acc d => acc + 2^(d-1)) 0 :=\n  sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval score_parentheses \"()\"\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval score_parentheses \"(())\"\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval score_parentheses \"(()(()))\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0414", "language": "lean", "source": "fvapps", "source-id": "fvapps_000414", "source-notes": "", "vc-description": "/-\nYou are given two images img1 and img2 both of size n x n, represented as binary, square matrices of the same size. (A binary matrix has only 0s and 1s as values.)\nWe translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image.  After, the overlap of this translation is the number of positions that have a 1 in both images.\n(Note also that a translation does not include any kind of rotation.)\nWhat is the largest possible overlap?\n\nExample 1:\n\nInput: img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]]\nOutput: 3\nExplanation: We slide img1 to right by 1 unit and down by 1 unit.\n\nThe number of positions that have a 1 in both images is 3. (Shown in red)\n\nExample 2:\nInput: img1 = [[1]], img2 = [[1]]\nOutput: 1\n\nExample 3:\nInput: img1 = [[0]], img2 = [[0]]\nOutput: 0\n\nConstraints:\n\nn == img1.length\nn == img1[i].length\nn == img2.length \nn == img2[i].length\n1 <= n <= 30\nimg1[i][j] is 0 or 1.\nimg2[i][j] is 0 or 1.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def largest_overlap (img1 img2 : Matrix) : Nat :=\n  sorry", "vc-theorems": "theorem square_matrix_property \n  (n : Nat) (img1 img2 : Matrix)\n  (h1 : img1.length = n)\n  (h2 : img2.length = n) \n  (h3 : ∀ row, row ∈ img1 → row.length = n)\n  (h4 : ∀ row, row ∈ img2 → row.length = n)\n  (h5 : ∀ row ∈ img1, ∀ x ∈ row, x ≤ 1)\n  (h6 : ∀ row ∈ img2, ∀ x ∈ row, x ≤ 1) :\n  let result := largest_overlap img1 img2\n  result ≥ 0 ∧ result ≤ n * n :=\nsorry\n\ntheorem zero_overlap_property (n : Nat) (h : n > 0) :\n  let ones_matrix := List.replicate n (List.replicate n 1)\n  let zeros_matrix := List.replicate n (List.replicate n 0)\n  largest_overlap ones_matrix zeros_matrix = 0 :=\nsorry\n\ntheorem symmetry_property\n  (n : Nat) (img1 img2 : Matrix)\n  (h1 : img1.length = n)\n  (h2 : img2.length = n)\n  (h3 : ∀ row, row ∈ img1 → row.length = n)\n  (h4 : ∀ row, row ∈ img2 → row.length = n)\n  (h5 : ∀ row ∈ img1, ∀ x ∈ row, x ≤ 1)\n  (h6 : ∀ row ∈ img2, ∀ x ∈ row, x ≤ 1) :\n  largest_overlap img1 img2 = largest_overlap img2 img1 :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval largest_overlap [[1, 1, 0], [0, 1, 0], [0, 1, 0]] [[0, 0, 0], [0, 1, 1], [0, 0, 1]]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval largest_overlap [[1]] [[1]]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval largest_overlap [[0]] [[0]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0418", "language": "lean", "source": "fvapps", "source-id": "fvapps_000418", "source-notes": "", "vc-description": "/-\nWe are given a 2-dimensional grid. \".\" is an empty cell, \"#\" is a wall, \"@\" is the starting point, (\"a\", \"b\", ...) are keys, and (\"A\", \"B\", ...) are locks.\nWe start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can't walk over a lock unless we have the corresponding key.\nFor some 1 <= K <= 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys.  If it's impossible, return -1.\n\nExample 1:\nInput: [\"@.a.#\",\"###.#\",\"b.A.B\"]\nOutput: 8\n\nExample 2:\nInput: [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6\n\nNote:\n\n1 <= grid.length <= 30\n1 <= grid[0].length <= 30\ngrid[i][j] contains only '.', '#', '@', 'a'-'f' and 'A'-'F'\nThe number of keys is in [1, 6].  Each key has a different letter and opens exactly one lock.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidGrid (grid : List String) : Bool := sorry\n\ndef shortestPathAllKeys (grid : List String) : Int := sorry", "vc-theorems": "theorem shortestPathAllKeys_non_negative_or_neg1 (grid : List String) \n  (h: isValidGrid grid = true) :\n  let res := shortestPathAllKeys grid\n  res = -1 ∨ res ≥ 0 := sorry\n\ntheorem shortestPathAllKeys_geq_keycount (grid : List String) \n  (h: isValidGrid grid = true) :\n  let res := shortestPathAllKeys grid\n  let keyCount := (grid.map (λ row => row.toList.filter Char.isLower)).join.length\n  res = -1 ∨ res ≥ keyCount := sorry\n\ntheorem shortestPathAllKeys_empty_grid (grid : List String)\n  (h1: grid = [\"@\"]) :\n  shortestPathAllKeys grid = 0 := sorry\n\ntheorem shortestPathAllKeys_simple_grid (grid : List String)\n  (h1: grid = [\"@.\", \"..\"]) :\n  shortestPathAllKeys grid = 0 := sorry\n\n/-\ninfo: 8\n-/\n-- #guard_msgs in\n-- #eval shortest_path_all_keys [\"@.a.#\", \"###.#\", \"b.A.B\"]\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval shortest_path_all_keys [\"@..aA\", \"..B#.\", \"....b\"]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0419", "language": "lean", "source": "fvapps", "source-id": "fvapps_000419", "source-notes": "", "vc-description": "/-\nYou are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called \"bulls\") and how many digits match the secret number but locate in the wrong position (called \"cows\"). Your friend will use successive guesses and hints to eventually derive the secret number.\n\nWrite a function to return a hint according to the secret number and friend's guess, use A to indicate the bulls and B to indicate the cows. \n\nPlease note that both secret number and friend's guess may contain duplicate digits.\n\nExample 1:\n\nInput: secret = \"1807\", guess = \"7810\"\n\nOutput: \"1A3B\"\n\nExplanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.\n\nExample 2:\n\nInput: secret = \"1123\", guess = \"0111\"\n\nOutput: \"1A1B\"\n\nExplanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.\n\nNote: You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.\n-/", "vc-preamble": "def get_hint (secret: String) (guess: String) : String :=\n  sorry\n\ndef countMatches (s1 s2: String) : Nat :=\n  sorry\n\ndef natToString (n: Nat) : String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def splitHint (hint: String) : HintResult :=\n  sorry", "vc-theorems": "theorem hint_format {secret guess: String} (h: secret.length = guess.length):\n  let hint := get_hint secret guess \n  let bulls_cows := hint.dropRight 1\n  let parts := bulls_cows.split (λc => c = 'A')\n  (hint.takeRight 1 = \"B\" ∧ \n   parts.length = 2 ∧\n   parts[0]!.all Char.isDigit ∧\n   parts[1]!.all Char.isDigit)\n  := sorry\n\ntheorem hint_counts_valid {secret guess : String} (h: secret.length = guess.length):\n  let hint := get_hint secret guess\n  let result := splitHint hint\n  (result.bulls + result.cows ≤ secret.length ∧\n   result.bulls ≤ countMatches secret guess)\n  := sorry\n\ntheorem identical_strings_hint {s : String}:\n  get_hint s s = natToString s.length ++ \"A0B\"\n  := sorry\n\ntheorem hint_symmetry {secret guess : String} (h: secret.length = guess.length):\n  let hint1 := get_hint secret guess\n  let hint2 := get_hint guess secret\n  (splitHint hint1).bulls = (splitHint hint2).bulls\n  := sorry\n\n/-\ninfo: '1A3B'\n-/\n-- #guard_msgs in\n-- #eval get_hint \"1807\" \"7810\"\n\n/-\ninfo: '1A1B'\n-/\n-- #guard_msgs in\n-- #eval get_hint \"1123\" \"0111\"\n\n/-\ninfo: '0A0B'\n-/\n-- #guard_msgs in\n-- #eval get_hint \"1234\" \"5678\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0435", "language": "lean", "source": "fvapps", "source-id": "fvapps_000435", "source-notes": "", "vc-description": "/-\nGiven an array nums, you are allowed to choose one element of nums and change it by any value in one move.\nReturn the minimum difference between the largest and smallest value of nums after perfoming at most 3 moves.\n\nExample 1:\nInput: nums = [5,3,2,4]\nOutput: 0\nExplanation: Change the array [5,3,2,4] to [2,2,2,2].\nThe difference between the maximum and minimum is 2-2 = 0.\nExample 2:\nInput: nums = [1,5,0,10,14]\nOutput: 1\nExplanation: Change the array [1,5,0,10,14] to [1,1,0,1,1]. \nThe difference between the maximum and minimum is 1-0 = 1.\n\nExample 3:\nInput: nums = [6,6,0,1,1,4,6]\nOutput: 2\n\nExample 4:\nInput: nums = [1,5,6,14,15]\nOutput: 1\n\nConstraints:\n\n1 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n-/", "vc-preamble": "def min_difference (nums : List Int) : Int := sorry\n\ntheorem min_difference_small_list {nums : List Int} (h : nums.length ≤ 4) : \n  min_difference nums = 0 := sorry", "vc-helpers": "", "vc-definitions": "def isSorted (nums : List Int) : Bool := sorry\n\ntheorem min_difference_sort_invariant {nums : List Int} :\n  min_difference nums = min_difference (List.filter (fun x => true) nums) := sorry", "vc-theorems": "theorem min_difference_nonnegative {nums : List Int} :\n  min_difference nums ≥ 0 := sorry\n\ntheorem min_difference_bounded {nums : List Int} (h : nums.length > 0) :\n  min_difference nums ≤ (nums.maximum? |>.getD 0) - (nums.minimum? |>.getD 0) := sorry\n\ntheorem min_difference_large_lists {nums : List Int} (h : nums.length ≥ 5) :\n  ∃ d1 d2 d3 d4 : Int, min_difference nums = min d1 (min d2 (min d3 d4)) := sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval min_difference [2, 3, 4, 5]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval min_difference [1, 5, 0, 10, 14]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval min_difference [6, 6, 0, 1, 1, 4, 6]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0448", "language": "lean", "source": "fvapps", "source-id": "fvapps_000448", "source-notes": "", "vc-description": "/-\nGiven an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.\nReturn the length of the smallest subarray that you need to remove, or -1 if it's impossible.\nA subarray is defined as a contiguous block of elements in the array.\n\nExample 1:\nInput: nums = [3,1,4,2], p = 6\nOutput: 1\nExplanation: The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6.\n\nExample 2:\nInput: nums = [6,3,5,2], p = 9\nOutput: 2\nExplanation: We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9.\n\nExample 3:\nInput: nums = [1,2,3], p = 3\nOutput: 0\nExplanation: Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything.\n\nExample 4:\nInput: nums = [1,2,3], p = 7\nOutput: -1\nExplanation: There is no way to remove a subarray in order to get a sum divisible by 7.\n\nExample 5:\nInput: nums = [1000000000,1000000000,1000000000], p = 3\nOutput: 0\n\nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n1 <= p <= 109\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.sum [Add α] (l : List α) : α := sorry \n\ndef minSubarray (nums : List Nat) (p : Nat) : Int := sorry", "vc-theorems": "theorem minSubarray_bounds\n  (nums : List Nat)\n  (p : Nat)\n  (h1 : ∀ n ∈ nums, 1 ≤ n ∧ n ≤ 1000)\n  (h2 : 1 ≤ p ∧ p ≤ 1000)\n  : -1 ≤ minSubarray nums p ∧ minSubarray nums p ≤ nums.length := sorry \n\ntheorem minSubarray_neg_one_valid\n  (nums : List Nat)\n  (p : Nat)\n  (h : minSubarray nums p = -1)\n  : ∀ (i j : Nat), i ≤ nums.length → j ≤ nums.length - i →\n    (List.take i nums ++ List.drop (i + j) nums).sum % p ≠ 0 := sorry\n\ntheorem minSubarray_zero_valid\n  (nums : List Nat) \n  (p : Nat)\n  (h : minSubarray nums p = 0)\n  : nums.sum % p = 0 := sorry\n\ntheorem minSubarray_positive_valid\n  (nums : List Nat)\n  (p : Nat)\n  (h1 : 0 < minSubarray nums p)\n  (h2 : minSubarray nums p < nums.length)\n  : ∃ (i : Nat), i + (minSubarray nums p).toNat ≤ nums.length ∧ \n    (List.take i nums ++ List.drop (i + (minSubarray nums p).toNat) nums).sum % p = 0 := sorry\n\ntheorem minSubarray_small_values\n  (nums : List Nat)\n  (p : Nat)\n  (h1 : ∀ n ∈ nums, 0 ≤ n ∧ n ≤ 10)\n  (h2 : 1 ≤ p ∧ p ≤ 10)\n  (h3 : minSubarray nums p ≥ 0)\n  : ∃ (i : Nat), i + (minSubarray nums p).toNat ≤ nums.length ∧\n    (List.take i nums ++ List.drop (i + (minSubarray nums p).toNat) nums).sum % p = 0 := sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval min_subarray [3, 1, 4, 2] 6\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval min_subarray [6, 3, 5, 2] 9\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval min_subarray [1, 2, 3] 7", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0458", "language": "lean", "source": "fvapps", "source-id": "fvapps_000458", "source-notes": "", "vc-description": "/-\nGiven two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nExample 1:\n\nInput: numerator = 1, denominator = 2\nOutput: \"0.5\"\n\nExample 2:\n\nInput: numerator = 2, denominator = 1\nOutput: \"2\"\n\nExample 3:\n\nInput: numerator = 2, denominator = 3\nOutput: \"0.(6)\"\n-/", "vc-preamble": "def toFloat (s: String) : Float :=\n  sorry\n\ndef intToFloat (n: Int) : Float :=\n  sorry", "vc-helpers": "", "vc-definitions": "def fraction_to_decimal (n: Int) (d: Int) : DecimalRepr :=\n  sorry", "vc-theorems": "theorem positive_fraction_valid_format (n d: Int)\n  (hn: 0 < n) (hd: 0 < d) (hdn: n ≤ 10^6 ∧ d ≤ 10^6) :\n  (fraction_to_decimal n d).isValid = true :=\n  sorry\n\ntheorem positive_fraction_matches_value (n d: Int)\n  (hn: 0 < n) (hd: 0 < d) (hdn: n ≤ 10^6 ∧ d ≤ 10^6) :\n  (((toFloat (fraction_to_decimal n d).value) - ((intToFloat n) / (intToFloat d))).abs < 1e-10) :=\n  sorry\n\ntheorem whole_numbers_no_decimals (n: Int)\n  (hn: -10^6 ≤ n ∧ n ≤ 10^6) (hnz: n ≠ 0) :\n  let res := (fraction_to_decimal n 1).value\n  ¬res.contains '.' ∧ ¬res.contains '(' ∧ res.toInt! = n :=\n  sorry\n\ntheorem zero_numerator (d: Int)\n  (hd: 0 < d) (hdb: d ≤ 10^6) :\n  (fraction_to_decimal 0 d).value = \"0\" :=\n  sorry\n\n/-\ninfo: '0.5'\n-/\n-- #guard_msgs in\n-- #eval fraction_to_decimal 1 2\n\n/-\ninfo: '2'\n-/\n-- #guard_msgs in\n-- #eval fraction_to_decimal 2 1\n\n/-\ninfo: '0.(6)'\n-/\n-- #guard_msgs in\n-- #eval fraction_to_decimal 2 3", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0459", "language": "lean", "source": "fvapps", "source-id": "fvapps_000459", "source-notes": "", "vc-description": "/-\nYou have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.\nIf node i has no left child then leftChild[i] will equal -1, similarly for the right child.\nNote that the nodes have no values and that we only use the node numbers in this problem.\n\nExample 1:\n\nInput: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]\nOutput: true\n\nExample 2:\n\nInput: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]\nOutput: false\n\nExample 3:\n\nInput: n = 2, leftChild = [1,0], rightChild = [-1,-1]\nOutput: false\n\nExample 4:\n\nInput: n = 6, leftChild = [1,-1,-1,4,-1,-1], rightChild = [2,-1,-1,5,-1,-1]\nOutput: false\n\nConstraints:\n\n1 <= n <= 10^4\nleftChild.length == rightChild.length == n\n-1 <= leftChild[i], rightChild[i] <= n - 1\n-/", "vc-preamble": "def validate_binary_tree_nodes (n : Nat) (leftChild : List Int) (rightChild : List Int) : Bool :=\n  sorry\n\n-- Predicate for valid list input", "vc-helpers": "", "vc-definitions": "def is_valid_list (n : Nat) (lst : List Int) : Bool :=\n  sorry\n\n-- Property: Result must be of type Bool", "vc-theorems": "theorem validate_returns_bool (n : Nat) (leftChild rightChild : List Int) :\n  ∃ (b : Bool), validate_binary_tree_nodes n leftChild rightChild = b :=\n  sorry\n\n-- Property: If result is True, each node has exactly one parent except root\n\ntheorem valid_tree_parent_counts {n : Nat} {leftChild rightChild : List Int} \n  (h : validate_binary_tree_nodes n leftChild rightChild = true) :\n  ∃ (parent_count : List Nat),\n    parent_count.length = n ∧ \n    (parent_count.filter (· = 1)).length = n - 1 ∧\n    (parent_count.filter (· = 0)).length = 1 :=\n  sorry\n\n-- Property: Empty trees are only valid for n = 1\n\ntheorem empty_tree_validity {n : Nat} \n  (h_left : leftChild = List.replicate n (-1))\n  (h_right : rightChild = List.replicate n (-1)) :\n  validate_binary_tree_nodes n leftChild rightChild = (n = 1) :=\n  sorry\n\n-- Property: Invalid node references result in false\n\ntheorem invalid_references {n : Nat} {leftChild rightChild : List Int}\n  (h : ¬(is_valid_list n leftChild ∧ is_valid_list n rightChild)) :\n  validate_binary_tree_nodes n leftChild rightChild = false :=\n  sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval validate_binary_tree_nodes 4 [1, -1, 3, -1] [2, -1, -1, -1]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval validate_binary_tree_nodes 4 [1, -1, 3, -1] [2, 3, -1, -1]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval validate_binary_tree_nodes 2 [1, 0] [-1, -1]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0460", "language": "lean", "source": "fvapps", "source-id": "fvapps_000460", "source-notes": "", "vc-description": "/-\nGiven an integer array A, and an integer target, return the number of tuples i, j, k  such that i < j < k and A[i] + A[j] + A[k] == target.\nAs the answer can be very large, return it modulo 109 + 7.\n\nExample 1:\nInput: A = [1,1,2,2,3,3,4,4,5,5], target = 8\nOutput: 20\nExplanation: \nEnumerating by the values (A[i], A[j], A[k]):\n(1, 2, 5) occurs 8 times;\n(1, 3, 4) occurs 8 times;\n(2, 2, 4) occurs 2 times;\n(2, 3, 3) occurs 2 times.\n\nExample 2:\nInput: A = [1,1,2,2,2,2], target = 5\nOutput: 12\nExplanation: \nA[i] = 1, A[j] = A[k] = 2 occurs 12 times:\nWe choose one 1 from [1,1] in 2 ways,\nand two 2s from [2,2,2,2] in 6 ways.\n\nConstraints:\n\n3 <= A.length <= 3000\n0 <= A[i] <= 100\n0 <= target <= 300\n-/", "vc-preamble": "def threeSumMulti (arr : List Nat) (target : Nat) : Nat := sorry\n\ndef MOD := 1000000007", "vc-helpers": "", "vc-definitions": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + List.sum xs", "vc-theorems": "theorem output_range (arr : List Nat) (target : Nat)\n  (h1 : arr.length ≥ 1)\n  (h2 : arr.length ≤ 3000)\n  (h3 : ∀ x ∈ arr, x ≤ 100)\n  (h4 : target ≤ 300) :\n  threeSumMulti arr target < MOD := sorry\n\ntheorem zero_target (arr : List Nat)\n  (h1 : arr.length ≥ 1)\n  (h2 : arr.length ≤ 3000)\n  (h3 : ∀ x ∈ arr, x ≤ 100)\n  (h4 : arr.length ≥ 3) :\n  threeSumMulti (List.replicate arr.length 0) 0 > 0 := sorry\n\ntheorem identical_elements (arr : List Nat) (target : Nat)\n  (h1 : arr.length ≥ 3)\n  (h2 : arr.length ≤ 3000)\n  (h3 : target % 3 = 0)\n  (h4 : target / 3 ≤ 100) :\n  threeSumMulti (List.replicate arr.length (target / 3)) target > 0 := sorry\n\ntheorem small_arrays (arr : List Nat)\n  (h1 : arr.length = 3)\n  (h2 : ∀ x ∈ arr, x ≤ 100) :\n  threeSumMulti arr (List.sum arr) ≥ 1 := sorry\n\ntheorem order_independence (arr arr' : List Nat) (target : Nat)\n  (h1 : arr.length ≥ 1)\n  (h2 : arr.length ≤ 3000)\n  (h3 : ∀ x ∈ arr, x ≤ 100)\n  (h4 : target ≤ 300)\n  (h5 : arr.length = arr'.length)\n  (h6 : ∀ n, (arr.count n) = (arr'.count n)) :\n  threeSumMulti arr target = threeSumMulti arr' target := sorry\n\n/-\ninfo: 20\n-/\n-- #guard_msgs in\n-- #eval three_sum_multi [1, 1, 2, 2, 3, 3, 4, 4, 5, 5] 8\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval three_sum_multi [1, 1, 2, 2, 2, 2] 5\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval three_sum_multi [2, 2, 2] 6", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0461", "language": "lean", "source": "fvapps", "source-id": "fvapps_000461", "source-notes": "", "vc-description": "/-\nGiven a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\nExample 1:\n\nInput:\n11110\n11010\n11000\n00000\n\nOutput: 1\n\nExample 2:\n\nInput:\n11000\n11000\n00100\n00011\n\nOutput: 3\n-/", "vc-preamble": "def isValidGrid (grid: Grid) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def countIslands (grid: Grid) : Nat :=\n  sorry", "vc-theorems": "theorem count_islands_basic_properties (grid: Grid) \n  (h: isValidGrid grid) : \n  let result := countIslands grid\n  result ≥ 0 ∧ result ≤ grid.length * (grid.head!.length) := by\n  sorry\n\ntheorem count_islands_preserves_grid (grid origGrid: Grid)\n  (h: isValidGrid grid) (h2: grid = origGrid) :\n  grid.length = origGrid.length ∧ \n  ∀ i < grid.length, grid[i]!.length = origGrid[i]!.length := by\n  sorry\n\ntheorem zero_grid_has_no_islands (grid: Grid)\n  (h: isValidGrid grid)\n  (h2: ∀ i j, i < grid.length → j < (grid.head!.length) → \n        grid[i]![j]! = '0') :\n  countIslands grid = 0 := by\n  sorry\n\ntheorem no_adjacent_ones_after_counting (grid: Grid) (i j: Nat)\n  (h: isValidGrid grid)\n  (h2: i < grid.length) (h3: j < (grid.head!.length))\n  (h4: grid[i]![j]! = '1') :\n  let adjacent := [Pos.mk (i+1) j, Pos.mk (i-1) j, Pos.mk i (j+1), Pos.mk i (j-1)]\n  ∀ p ∈ adjacent,\n    p.row < grid.length → p.col < (grid.head!.length) →\n    grid[p.row]![p.col]! ≠ '1' := by\n  sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval count_islands [[\"1\", \"1\", \"1\", \"1\", \"0\"], [\"1\", \"1\", \"0\", \"1\", \"0\"], [\"1\", \"1\", \"0\", \"0\", \"0\"], [\"0\", \"0\", \"0\", \"0\", \"0\"]]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval count_islands [[\"1\", \"1\", \"0\", \"0\", \"0\"], [\"1\", \"1\", \"0\", \"0\", \"0\"], [\"0\", \"0\", \"1\", \"0\", \"0\"], [\"0\", \"0\", \"0\", \"1\", \"1\"]]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval count_islands [[\"0\", \"0\", \"0\"], [\"0\", \"0\", \"0\"], [\"0\", \"0\", \"0\"]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0468", "language": "lean", "source": "fvapps", "source-id": "fvapps_000468", "source-notes": "", "vc-description": "/-\nGiven a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.\n\nNote:\n\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n\nExample 1:\n\nInput: [2,2,3,2]\nOutput: 3\n\nExample 2:\n\nInput: [0,1,0,1,0,1,99]\nOutput: 99\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def single_number (nums : List Int) : Int :=\n  sorry", "vc-theorems": "theorem single_number_minimal (val : Int) :\n  val ≥ -1000 → val ≤ 1000 →\n  single_number ([val, val, val, val + 1]) = val + 1 :=\nsorry\n\ntheorem single_number_reorder_invariant (single_val : Int) (others : List Int) :\n  single_number (single_val :: (others.map (λ x => [x,x,x])).join) = \n  single_number ((others.map (λ x => [x,x,x])).join ++ [single_val]) :=\nsorry\n\ntheorem single_number_triple_plus_one (val : Int) :\n  val ≥ -1000 → val ≤ 1000 →\n  let nums := (List.replicate 3 val) ++ [val + 1]\n  (single_number nums = val + 1) ∧ \n  (nums.count (single_number nums) = 1) ∧\n  (∀ x, x ∈ nums → x ≠ single_number nums → nums.count x = 3) :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval single_number [2, 2, 3, 2]\n\n/-\ninfo: 99\n-/\n-- #guard_msgs in\n-- #eval single_number [0, 1, 0, 1, 0, 1, 99]\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval single_number [1, 1, 1, 5]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0473", "language": "lean", "source": "fvapps", "source-id": "fvapps_000473", "source-notes": "", "vc-description": "/-\nGiven n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n\nNote: You may not slant the container and n is at least 2.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxArea (heights : List Nat) : Nat := sorry\n\ntheorem maxArea_nonnegative (heights : List Nat) :\n  heights.length ≥ 2 → maxArea heights ≥ 0 := sorry", "vc-theorems": "theorem maxArea_upper_bound (heights : List Nat) :\n  heights.length ≥ 2 → \n  maxArea heights ≤ (List.maximum? heights).getD 0 * (heights.length - 1) := sorry\n\ntheorem maxArea_is_maximum (heights : List Nat) (i j : Nat) (hi : i < heights.length) (hj : j < heights.length) :\n  heights.length ≥ 2 →\n  i < j →\n  maxArea heights ≥ min (heights.get ⟨i, hi⟩) (heights.get ⟨j, hj⟩) * (j - i) := sorry\n\ntheorem maxArea_symmetric (heights : List Nat) :\n  heights.length ≥ 2 →\n  maxArea heights = maxArea heights.reverse := sorry\n\ntheorem maxArea_uniform (value length : Nat) : \n  length ≥ 2 →\n  maxArea (List.replicate length value) = value * (length - 1) := sorry\n\ntheorem maxArea_interpolation (heights : List Nat) :\n  heights.length ≥ 2 →\n  let interpolated := heights.take 1 ++ List.replicate (heights.length - 2) 0 ++ heights.drop (heights.length - 1)\n  maxArea heights ≥ maxArea interpolated := sorry\n\n/-\ninfo: 49\n-/\n-- #guard_msgs in\n-- #eval max_area [1, 8, 6, 2, 5, 4, 8, 3, 7]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval max_area [1, 1]\n\n/-\ninfo: 16\n-/\n-- #guard_msgs in\n-- #eval max_area [4, 3, 2, 1, 4]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0482", "language": "lean", "source": "fvapps", "source-id": "fvapps_000482", "source-notes": "", "vc-description": "/-\nYou are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\n\nFind out how many ways to assign symbols to make sum of integers equal to target S.  \n\nExample 1:\n\nInput: nums is [1, 1, 1, 1, 1], S is 3. \nOutput: 5\nExplanation: \n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\nThere are 5 ways to assign symbols to make the sum of nums be target 3.\n\nNote:\n\nThe length of the given array is positive and will not exceed 20. \nThe sum of elements in the given array will not exceed 1000.\nYour output answer is guaranteed to be fitted in a 32-bit integer.\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | h :: t => h + List.sum t\n\ndef Int.abs (n : Int) : Int :=\n  if n ≥ 0 then n else -n\n\ndef List.sort (xs : List Nat) : List Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def find_target_sum_ways (nums : List Nat) (target : Int) : Nat :=\n  sorry", "vc-theorems": "theorem output_bounds_nonnegative {nums : List Nat} {target : Int} :\n  find_target_sum_ways nums target ≥ 0 := sorry\n\ntheorem output_bounds_impossible {nums : List Nat} {target : Int} :\n  ((nums.sum : Int) < target.abs) → find_target_sum_ways nums target = 0 := sorry\n\ntheorem invariant_permutation {nums : List Nat} {target : Int} :\n  find_target_sum_ways nums target = find_target_sum_ways (List.sort nums) target := sorry\n\ntheorem invariant_odd_sum {nums : List Nat} {target : Int} :\n  ((nums.sum : Int) + target) % 2 = 1 → find_target_sum_ways nums target = 0 := sorry\n\ntheorem all_ones_symmetric {n : Nat} {nums : List Nat} :\n  (∀ x ∈ nums, x = 1) →\n  find_target_sum_ways nums (n / 2) = find_target_sum_ways nums (-n / 2) := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0486", "language": "lean", "source": "fvapps", "source-id": "fvapps_000486", "source-notes": "", "vc-description": "/-\nWe have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\nYou're given the startTime , endTime and profit arrays, you need to output the maximum profit you can take such that there are no 2 jobs in the subset with overlapping time range.\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.\n\nExample 1:\n\nInput: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\nOutput: 120\nExplanation: The subset chosen is the first and fourth job. \nTime range [1-3]+[3-6] , we get profit of 120 = 50 + 70.\n\nExample 2:\n\nInput: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\nOutput: 150\nExplanation: The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n\nExample 3:\n\nInput: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\nOutput: 6\n\nConstraints:\n\n1 <= startTime.length == endTime.length == profit.length <= 5 * 10^4\n1 <= startTime[i] < endTime[i] <= 10^9\n1 <= profit[i] <= 10^4\n-/", "vc-preamble": "def List.sum (xs: List Int) : Int :=\n  match xs with\n  | [] => 0\n  | x::rest => x + sum rest", "vc-helpers": "", "vc-definitions": "def jobScheduling (startTimes endTimes profits: List Int) : Int :=\n  sorry", "vc-theorems": "theorem job_scheduling_basic_properties \n  (startTimes endTimes profits: List Int)\n  (h1: startTimes.length = endTimes.length)\n  (h2: endTimes.length = profits.length)\n  (h3: ∀ i, i < startTimes.length → startTimes[i]! > 0)\n  (h4: ∀ i, i < endTimes.length → endTimes[i]! > startTimes[i]!)\n  (h5: ∀ i, i < profits.length → profits[i]! > 0) :\n  let result := jobScheduling startTimes endTimes profits\n  -- Result is non-negative\n  result ≥ 0 ∧\n  -- Result doesn't exceed sum of profits  \n  result ≤ List.sum profits :=\n  sorry\n\ntheorem job_scheduling_single_job\n  (startTime endTime profit: Int)\n  (h1: startTime > 0)\n  (h2: endTime > startTime)\n  (h3: profit > 0) :\n  jobScheduling [startTime] [endTime] [profit] = profit :=\n  sorry\n\n/-\ninfo: 120\n-/\n-- #guard_msgs in\n-- #eval jobScheduling [1, 2, 3, 3] [3, 4, 5, 6] [50, 10, 40, 70]\n\n/-\ninfo: 150\n-/\n-- #guard_msgs in\n-- #eval jobScheduling [1, 2, 3, 4, 6] [3, 5, 10, 6, 9] [20, 20, 100, 70, 60]\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval jobScheduling [1, 1, 1] [2, 3, 4] [5, 6, 4]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0487", "language": "lean", "source": "fvapps", "source-id": "fvapps_000487", "source-notes": "", "vc-description": "/-\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n\nExample 1:\n\nInput: [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),\n             because they are adjacent houses.\n\nExample 2:\n\nInput: [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\n             Total amount you can rob = 1 + 3 = 4.\n-/", "vc-preamble": "def List.sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + List.sum xs", "vc-helpers": "", "vc-definitions": "def rob_houses (nums: List Nat) : Nat := sorry\n\ntheorem rob_houses_non_negative (nums: List Nat) :\n  rob_houses nums ≥ 0 := sorry", "vc-theorems": "theorem rob_houses_maximum_possible (nums: List Nat) :\n  rob_houses nums ≤ List.sum nums := sorry \n\ntheorem rob_houses_empty :\n  rob_houses [] = 0 := sorry\n\ntheorem rob_houses_single (x: Nat) :\n  rob_houses [x] = x := sorry\n\ntheorem rob_houses_two_equal (x: Nat) :\n  rob_houses [x, x] = x := sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval rob_houses [2, 3, 2]\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval rob_houses [1, 2, 3, 1]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval rob_houses [1]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0495", "language": "lean", "source": "fvapps", "source-id": "fvapps_000495", "source-notes": "", "vc-description": "/-\nImplement atoi which converts a string to an integer.\n\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.\n\nThe string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.\n\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.\n\nIf no valid conversion could be performed, a zero value is returned.\n\nNote:\n\n       Only the space character ' ' is considered as whitespace character.\n       Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.\n\nExample 1:\n\nInput: \"42\"\nOutput: 42\n\nExample 2:\n\nInput: \"   -42\"\nOutput: -42\nExplanation: The first non-whitespace character is '-', which is the minus sign.\n             Then take as many numerical digits as possible, which gets 42.\n\nExample 3:\n\nInput: \"4193 with words\"\nOutput: 4193\nExplanation: Conversion stops at digit '3' as the next character is not a numerical digit.\n\nExample 4:\n\nInput: \"words and 987\"\nOutput: 0\nExplanation: The first non-whitespace character is 'w', which is not a numerical \n             digit or a +/- sign. Therefore no valid conversion could be performed.\n\nExample 5:\n\nInput: \"-91283472332\"\nOutput: -2147483648\nExplanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer.\n             Thefore INT_MIN (−231) is returned.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def myAtoi (s : String) : Int := sorry\n\ntheorem myAtoi_within_bounds (s : String) :\n  -2147483648 ≤ myAtoi s ∧ myAtoi s ≤ 2147483647 := sorry", "vc-theorems": "theorem myAtoi_leading_whitespace (s : String) :\n  myAtoi (\"   \" ++ s) = myAtoi s := sorry\n\ntheorem myAtoi_signs_positive (n : Int) \n  (h : 0 ≤ n ∧ n ≤ 2147483647) :\n  myAtoi (\"+\" ++ toString n) = n := sorry\n\ntheorem myAtoi_signs_negative (n : Int)\n  (h : 0 ≤ n ∧ n ≤ 2147483647) :\n  myAtoi (\"-\" ++ toString n) = -min n 2147483648 := sorry\n\n/-\ninfo: 42\n-/\n-- #guard_msgs in\n-- #eval myAtoi \"42\"\n\n/-\ninfo: -42\n-/\n-- #guard_msgs in\n-- #eval myAtoi \"   -42\"\n\n/-\ninfo: 4193\n-/\n-- #guard_msgs in\n-- #eval myAtoi \"4193 with words\"\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval myAtoi \"words and 987\"\n\n/-\ninfo: -2147483648\n-/\n-- #guard_msgs in\n-- #eval myAtoi \"-91283472332\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0496", "language": "lean", "source": "fvapps", "source-id": "fvapps_000496", "source-notes": "", "vc-description": "/-\nGiven a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once. \n\nExample 1:\n\nInput: [1,1,2,3,3,4,4,8,8]\nOutput: 2\n\nExample 2:\n\nInput: [3,3,7,7,10,11,11]\nOutput: 10\n\nNote:\nYour solution should run in O(log n) time and O(1) space.\n-/", "vc-preamble": "def find_single_element (arr : List Int) : Int :=\n  sorry\n\ndef is_valid_input (arr : List Int) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def list_duplicate (x : Int) : List Int := [x, x]\n\ntheorem find_single_element_sorted {nums : List Int} \n  (h₁ : nums.length ≥ 2)\n  (h₂ : ∀ i, i + 1 < nums.length → nums[i]! ≤ nums[i+1]!)\n  (h₃ : ∀ x ∈ nums, x ≥ -1000 ∧ x ≤ 1000) :\n  let doubles := (nums.take (nums.length - 1)).map list_duplicate |>.join\n  let last := nums[nums.length - 1]!\n  let result := doubles ++ [last]\n  find_single_element result = last := \n  sorry", "vc-theorems": "theorem find_single_element_position {nums : List Int} \n  (h₁ : nums.length > 0)\n  (h₂ : nums.length ≤ 9)\n  (h₃ : ∀ i, i + 1 < nums.length → nums[i]! ≤ nums[i+1]!)\n  (h₄ : ∀ x ∈ nums, x ≥ -1000 ∧ x ≤ 1000)\n  (i : Nat)\n  (h₅ : i < nums.length) :\n  let before := (nums.take i).map list_duplicate |>.join\n  let single := [nums[i]'h₅]\n  let after := (nums.drop (i+1)).map list_duplicate |>.join\n  let result := before ++ single ++ after\n  is_valid_input result →\n  find_single_element result = nums[i]'h₅ :=\n  sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval find_single_element [1, 1, 2, 3, 3, 4, 4, 8, 8]\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval find_single_element [3, 3, 7, 7, 10, 11, 11]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval find_single_element [1, 1, 2, 2, 3]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0499", "language": "lean", "source": "fvapps", "source-id": "fvapps_000499", "source-notes": "", "vc-description": "/-\nYou are given a string S of length N consisting of lowercase English letters.\nProcess Q queries of the following two types:\n - Type 1: change the i_q-th character of S to c_q. (Do nothing if the i_q-th character is already c_q.)\n - Type 2: answer the number of different characters occurring in the substring of S between the l_q-th and r_q-th characters (inclusive).\n\n-----Constraints-----\n - N, Q, i_q, l_q, and r_q are integers.\n - S is a string consisting of lowercase English letters.\n - c_q is a lowercase English letter.\n - 1 \\leq N \\leq 500000\n - 1 \\leq Q \\leq 20000\n - |S| = N\n - 1 \\leq i_q \\leq N\n - 1 \\leq l_q \\leq r_q \\leq N\n - There is at least one query of type 2 in each testcase.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN\nS\nQ\nQuery_1\n\\vdots\nQuery_Q\n\nHere, Query_i in the 4-th through (Q+3)-th lines is one of the following:\n1 i_q c_q\n\n2 l_q r_q\n\n-----Output-----\nFor each query of type 2, print a line containing the answer.\n\n-----Sample Input-----\n7\nabcdbbd\n6\n2 3 6\n1 5 z\n2 1 1\n1 4 a\n1 7 d\n2 1 7\n\n-----Sample Output-----\n3\n1\n5\n\nIn the first query, cdbb contains three kinds of letters: b , c , and d, so we print 3.\nIn the second query, S is modified to abcdzbd.\nIn the third query, a contains one kind of letter: a, so we print 1.\nIn the fourth query, S is modified to abcazbd.\nIn the fifth query, S does not change and is still abcazbd.\nIn the sixth query, abcazbd contains five kinds of letters: a, b, c, d, and z, so we print 5.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def process_string_queries (s : String) (queries : List Query) : List Nat :=\n  sorry", "vc-theorems": "theorem process_string_queries_no_queries (s : String) :\n  process_string_queries s [] = [] := sorry\n\ntheorem process_string_queries_only_substring_queries (s : String) (queries : List Query) \n  (h : ∀ q ∈ queries, q.queryType = 2 ∧ q.position ≤ s.length) :\n  let result := process_string_queries s queries\n  result.length = queries.length ∧ \n  (∀ x ∈ result, 0 ≤ x ∧ x ≤ 26) := sorry \n\ntheorem process_string_queries_only_change_queries (s : String) (queries : List Query)\n  (h : ∀ q ∈ queries, q.queryType = 1 ∧ q.position ≤ s.length) :\n  process_string_queries s queries = [] := sorry\n\ntheorem process_string_queries_single_char (s : String) (i : Nat)\n  (h1 : s.length > 0)\n  (h2 : i ≤ s.length) :\n  process_string_queries s [⟨2, i, (i, 'a')⟩] = [1] := sorry\n\ntheorem process_string_queries_change_then_query (s : String) (pos : Nat) (new_char : Char)\n  (h1 : s.length > 0)\n  (h2 : pos ≤ s.length) :\n  process_string_queries s [⟨1, pos, (pos, new_char)⟩, ⟨2, pos, (pos, new_char)⟩] = [1] := sorry\n\n/-\ninfo: [3, 1, 5]\n-/\n-- #guard_msgs in\n-- #eval process_string_queries \"abcdbbd\" [(2, 3, 6), (1, 5, \"z\"), (2, 1, 1), (1, 4, \"a\"), (1, 7, \"d\"), (2, 1, 7)]\n\n/-\ninfo: [3, 3]\n-/\n-- #guard_msgs in\n-- #eval process_string_queries \"abc\" [(2, 1, 3), (1, 2, \"d\"), (2, 1, 3)]\n\n/-\ninfo: [1, 2]\n-/\n-- #guard_msgs in\n-- #eval process_string_queries \"aaa\" [(2, 1, 3), (1, 2, \"b\"), (2, 1, 3)]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0509", "language": "lean", "source": "fvapps", "source-id": "fvapps_000509", "source-notes": "", "vc-description": "/-\nWrite a program that takes in a letterclass ID of a ship and display the equivalent string class description of the given ID. Use the table below.\n\nClass ID Ship ClassB or bBattleShipC or cCruiserD or dDestroyerF or fFrigate\n\n-----Input-----\n\nThe first line contains an integer T, the total number of testcases. Then T lines follow, each line contains a character. \n\n-----Output-----\nFor each test case, display the Ship Class depending on ID, in a new line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n\n-----Example-----\nInput\n\n3 \nB\nc\nD\n\nOutput\nBattleShip\nCruiser\nDestroyer\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_ship_class (c : Char) : ShipClass := sorry\n\ntheorem get_ship_class_returns_valid_type (c : Char) :\n  get_ship_class c = ShipClass.BattleShip ∨ \n  get_ship_class c = ShipClass.Cruiser ∨\n  get_ship_class c = ShipClass.Destroyer ∨ \n  get_ship_class c = ShipClass.Frigate :=\nsorry", "vc-theorems": "theorem get_ship_class_case_insensitive_B (c : Char) :\n  (c = 'B' ∨ c = 'b') → get_ship_class c = ShipClass.BattleShip :=\nsorry\n\ntheorem get_ship_class_case_insensitive_C (c : Char) :\n  (c = 'C' ∨ c = 'c') → get_ship_class c = ShipClass.Cruiser :=\nsorry\n\ntheorem get_ship_class_case_insensitive_D (c : Char) :\n  (c = 'D' ∨ c = 'd') → get_ship_class c = ShipClass.Destroyer :=\nsorry\n\ntheorem get_ship_class_default (c : Char) :\n  (c.toUpper ≠ 'B' ∧ c.toUpper ≠ 'C' ∧ c.toUpper ≠ 'D') → \n  get_ship_class c = ShipClass.Frigate :=\nsorry\n\n/-\ninfo: 'BattleShip'\n-/\n-- #guard_msgs in\n-- #eval get_ship_class \"b\"\n\n/-\ninfo: 'Frigate'\n-/\n-- #guard_msgs in\n-- #eval get_ship_class \"F\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0517", "language": "lean", "source": "fvapps", "source-id": "fvapps_000517", "source-notes": "", "vc-description": "/-\nShashank is playing a game with his friends.\nThere are n sticks located in a row at points $a_1,a_2, ...,a_n$. Each stick has a height- $h_i$. A person can chop a stick down, after which it takes over one of the regions [$a_i$ - $h_i$, $a_i$] or [$a_i$, $a_i$ + $h_i$]. The stick that is not chopped remains at the point $a_i$. A person can chop a stick in a particular direction if the region to be taken up by the chopped stick does not overlap with an already existing point. The winner $($s$)$ of the game will be one or more people who can answer the question: What is the maximum number of sticks that can be chopped?\nShashank wants to win the game and hence he needs needs your help in finding out what is the maximum number of sticks that can be chopped down.\n\n-----Input:-----\n- The first line of each input contains a single integer n.\n- n lines follow. Each of the n lines contain a pair of integers: $a_i,h_i$.\n\n-----Output:-----\nOutput in a single line answer- the maximum number of sticks that can be chopped down.\n\n-----Constraints-----\n- $1 \\leq n \\leq 10^5$\n- $1 \\leq a_i,h_i \\leq 10^9$\n- The pairs are given in the order of ascending $a_i$. No two sticks are located at the same point.\n\n-----Sample Input 1:-----\n5\n1 2\n2 1\n5 10\n10 9\n19 1\n\n-----Sample Input 2:-----\n5\n1 2\n2 1\n5 10\n10 9\n20 1\n\n-----Sample Output 1:-----\n3\n\n-----Sample Output 2:-----\n4\n\n-----EXPLANATION:-----\nIn the first example you can fell the sticks as follows:\n- chop the stick 1 to the left — now it will take over the region $[ - 1;1]$\n- chop the stick 2 to the right — now it will take over the region $[2;3]$\n- spare the stick 3— it will take over the point $5$\n- spare the stick 4— it will take over the point $10$\n- chop the stick 5 to the right — now it will take over the region $[19;20]$\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Stick := Nat × Nat\n\ndef max_sticks_chopped (sticks : List Stick) : Nat :=\n  sorry", "vc-theorems": "theorem output_is_valid_integer (sticks : List Stick) (h : sticks ≠ []) : \n  let result := max_sticks_chopped sticks\n  1 ≤ result ∧ result ≤ sticks.length :=\nsorry\n\ntheorem single_stick_returns_one (pos height : Nat) (h₁ : pos ≥ 1) (h₂ : height ≥ 1) :\n  max_sticks_chopped [(pos, height)] = 1 :=\nsorry\n\ntheorem spreading_sticks_improves_result (sticks : List Stick) (h : sticks.length ≥ 2) :\n  let spread_sticks := sticks.enum.map (fun (i, stick) => (i * 100, stick.2))\n  max_sticks_chopped spread_sticks ≥ max_sticks_chopped sticks :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval max_sticks_chopped [(1, 2), (2, 1), (5, 10), (10, 9), (19, 1)]\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval max_sticks_chopped [(1, 2), (2, 1), (5, 10), (10, 9), (20, 1)]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval max_sticks_chopped [(1, 2)]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0519", "language": "lean", "source": "fvapps", "source-id": "fvapps_000519", "source-notes": "", "vc-description": "/-\nThe chef is playing a game of long distance. Chef has a number K and he wants to find the longest distance between the index of the first and the last occurrence of K in a given array of N numbers.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains two lines of input.\n- Next line with Two integers in one line $K, N$.\n- Next line with $N$ space-separated integers.\n\n-----Output:-----\nFor each test case, output in a single line answer as the index of first and last occurrence of K in the given array.\nNote: Here Indexing is from 1 not  0 based.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq k \\leq 10^5$\n- $1 \\leq N \\leq 10^5$\n\n-----Sample Input:-----\n2\n2 6\n2 3 4 2 1 6\n4 6\n2 3 4 2 1 6\n\n-----Sample Output:-----\n3\n0\n\n-----EXPLANATION:-----\nFor 1) Index of First and last occurrence of 2 in the given array is at 1 and 4, i.e. distance is 3. \nFor 2) 4 occurs only once in the given array hence print 0.\n-/", "vc-preamble": "def find_longest_distance (k : Int) (arr : List Int) : Int := sorry\n\n-- Value not in array gives 0 distance", "vc-helpers": "", "vc-definitions": "def findLastIndex (p : α → Bool) (l : List α) : Option Nat :=\n  let indexed := List.enumFrom 0 l\n  (indexed.find? (fun (i, x) => p x)).map Prod.fst\n\n-- Distance equals last occurrence minus first occurrence", "vc-theorems": "theorem missing_value_distance \n  {k : Int} {arr : List Int} \n  (h : ¬ k ∈ arr) : \n  find_longest_distance k arr = 0 := sorry\n\n-- Distance is always non-negative  \n\ntheorem distance_non_negative\n  (k : Int) (arr : List Int) :\n  find_longest_distance k arr ≥ 0 := sorry\n\n-- Distance is bounded by array length minus 1\n\ntheorem distance_upper_bound \n  (k : Int) (arr : List Int) :\n  find_longest_distance k arr ≤ max (arr.length - 1) 0 := sorry\n\n-- Function to find last index\n\ntheorem distance_matches_occurrences \n  (k : Int) (arr : List Int) :\n  find_longest_distance k arr = \n    let first := arr.findIdx? (· = k)\n    let last := findLastIndex (· = k) arr\n    match first, last with\n    | some i, some j => j - i \n    | _, _ => 0 := sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval find_longest_distance 2 [2, 3, 4, 2, 1, 6]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval find_longest_distance 4 [2, 3, 4, 2, 1, 6]\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval find_longest_distance 1 [1, 2, 3, 1, 2, 3, 1]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0522", "language": "lean", "source": "fvapps", "source-id": "fvapps_000522", "source-notes": "", "vc-description": "/-\n2021 was approaching and the world was about to end. So 2 gods Saurabhx and Saurabhy (from Celesta) created the Cyberverse. But this time disappointed with humans both the gods decided not to have humans in this world. So they created a world of cyborgs. A world without humans. Isn’t it interesting? So let us dive into the cyberverse and have a look at their problems.\nThere are $N$ kid cyborgs with Chief Cyborg '100gods' and he has $K$ weapons with him. He wants to distribute those $K$ weapons among $N$ kid cyborgs. Since all the kid cyborgs are very good friends, so they set a rule among themselves for taking those weapons. The rule states that the difference between kid cyborg having the maximum weapons and the kid cyborg having minimum weapons should be less than or equal to $1$.\n\nFind the value of the minimum number of weapons a kid cyborg can have when all the $K$ weapons are distributed among them.\n\n-----Input:-----\n- The first line contains an integer $T$, denoting the number of test cases.\n- Each of the next $T$ lines will contain two space-separated integers denoting $N$ and $K$ respectively.\n\n-----Output:-----\n- For each test case ,output a single line containing an integer $X$ denoting the minimum number of weapons a kid cyborg can have in that test case.  \n\n-----Constraints:-----\n- $1 \\leq T \\leq 10^5$\n- $1 \\leq N \\leq 10^5$\n- $1 \\leq K \\leq 10^9$\n\n-----Sample Input:-----\n1\n5 8\n\n-----Expected Output:-----\n1\n\n-----Explanation-----\n- There are $5$ kids and $8$ weapons.  \n- Hence we will distribute the weapons such that $3$ kids have $2$ weapons each and the remaining $2$ kids have $1$ weapon each.  \n- Hence the minimum number of weapons a kid cyborg has is $1$. (  That is, $min(1,2)$ = $1$ )\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_min_weapons (n k : Nat) : Nat :=\nsorry", "vc-theorems": "theorem min_weapons_div (n k : Nat) (h : n > 0) :\n  calculate_min_weapons n k = k / n :=\nsorry\n\ntheorem min_weapons_nonneg (n k : Nat) (h : n > 0) :\n  calculate_min_weapons n k ≥ 0 :=\nsorry\n\ntheorem min_weapons_times_n_le (n k : Nat) (h : n > 0) :\n  (calculate_min_weapons n k) * n ≤ k :=\nsorry\n\ntheorem min_weapons_plus_one_gt (n k : Nat) (h : n > 0) (h2 : k % n ≠ 0) :\n  (calculate_min_weapons n k + 1) * n > k :=\nsorry\n\ntheorem min_weapons_zero (n : Nat) (h : n > 0) :\n  calculate_min_weapons n 0 = 0 :=\nsorry\n\ntheorem min_weapons_zero_n (k : Nat) :\n  calculate_min_weapons 0 k = 0 ∨ calculate_min_weapons 0 k = undefined :=\nsorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval calculate_min_weapons 5 8\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval calculate_min_weapons 3 7\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval calculate_min_weapons 10 25", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0524", "language": "lean", "source": "fvapps", "source-id": "fvapps_000524", "source-notes": "", "vc-description": "/-\nSebi goes to school daily with his father. They cross a big highway in the car to reach to the school. Sebi sits in front seat beside his father at driving seat. To kill boredom, they play a game of guessing speed of other cars on the highway. Sebi makes a guess of other car's speed being SG kph, his father FG kph. \n\nThe highway is usually empty, so the drivers use cruise control, i.e. vehicles run at a constant speed. There are markers on the highway at a gap of 50 meters. Both father-son duo wants to check the accuracy of their guesses. For that, they start a timer at the instant at which their car and the other car (which speed they are guessing) are parallel to each other (they need not to be against some marker, they can be in between the markers too). After some T seconds, they observe that both the cars are next to some markers and the number of markers in between the markers of their car and the other car is D - 1 (excluding the markers next to both the cars). Also, they can observe these markers easily because the other car is faster than their. Speed of Sebi's father's car is S. Using this information, one can find the speed of the other car accurately.\n\nAn example situation when Sebi's father starts the timer. Notice that both the car's are parallel to each other.\n\nExample situation after T seconds. The cars are next to the markers. Here the value of D is 1. The green car is Sebi's and the other car is of blue color.\n\nSebi's a child, he does not know how to find the check whose guess is close to the real speed of the car. He does not trust his father as he thinks that he might cheat. Can you help to resolve this issue between them by telling whose guess is closer. If Sebi's guess is better, output \"SEBI\". If his father's guess is better, output \"FATHER\". If both the guess are equally close, then output \"DRAW\".\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. \nEach of the next T lines contain five space separated integers S, SG, FG, D, T corresponding to the Sebi's car speed, Sebi's guess, his father's guess, D as defined in the statement and the time at which both the cars at against the markers (in seconds), respectively.\n\n-----Output-----\nOutput description.\nFor each test case, output a single line containing \"SEBI\", \"FATHER\" or \"DRAW\" (without quotes) denoting whose guess is better.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10000\n- 0 ≤ S ≤ 130\n- 0 ≤ SG, FG ≤ 300\n- 1 ≤ D ≤ 30\n- 1 ≤ T ≤ 300\n-  The other car speed doesn't exceed 300 kph.\n\n-----Example-----\nInput:\n2\n100 180 200 20 60\n130 131 132 1 72\n\nOutput:\nSEBI\nFATHER\n\n-----Explanation-----\nExample case 1.\nThere are total 20 - 1 = 19 markers in between the Sebi's car and the other car. So, the distance between those cars at time T is 20 * 50 = 1000 meters = 1 km.\nAs T = 60 seconds, i.e. 1 minutes. So, the other car goes 1 km more than Sebi's car in 1 minute. So, the other car will go 60 km more than Sebi's car in 1 hour. So, its speed is 60 kmph more than Sebi's car, i.e. 160 kmph.\nSebi had made a guess of 180 kmph, while his father of 200 kmph. Other car's real speed is 160 kmph. So, Sebi's guess is better than his father. Hence he wins the game.\nExample case 2.\n\nThe situation of this example is depicted in the image provided in the statement. You can find the speed of other car and see that Father's guess is more accurate.\n-/", "vc-preamble": "def determine_winner (S : Nat) (SG : Nat) (FG : Nat) (D : Nat) (T : Nat) : Winner :=\n  sorry\n\ndef abs (n : Nat) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def nat_minus (a b : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem determine_winner_valid (S SG FG D T : Nat) :\n  ∃ w : Winner, determine_winner S SG FG D T = w\n  := sorry\n\ntheorem determine_winner_draw_when_equidistant (S SG FG D T : Nat) :\n  let actual_speed := (D * 50 * 3600)/(T * 1000) + S\n  nat_minus (abs (nat_minus SG actual_speed)) (abs (nat_minus FG actual_speed)) = 0 →\n  determine_winner S SG FG D T = Winner.DRAW\n  := sorry\n\ntheorem determine_winner_father_when_further (S SG FG D T : Nat) :\n  let actual_speed := (D * 50 * 3600)/(T * 1000) + S\n  nat_minus (abs (nat_minus SG actual_speed)) (abs (nat_minus FG actual_speed)) > 0 →\n  determine_winner S SG FG D T = Winner.FATHER\n  := sorry\n\ntheorem determine_winner_sebi_when_closer (S SG FG D T : Nat) :\n  let actual_speed := (D * 50 * 3600)/(T * 1000) + S\n  nat_minus (abs (nat_minus SG actual_speed)) (abs (nat_minus FG actual_speed)) < 0 →\n  determine_winner S SG FG D T = Winner.SEBI\n  := sorry\n\ntheorem determine_winner_same_guess_draw (S G D T : Nat) :\n  determine_winner S G G D T = Winner.DRAW\n  := sorry\n\n/-\ninfo: 'SEBI'\n-/\n-- #guard_msgs in\n-- #eval determine_winner 100 180 200 20 60\n\n/-\ninfo: 'FATHER'\n-/\n-- #guard_msgs in\n-- #eval determine_winner 130 131 132 1 72\n\n/-\ninfo: 'DRAW'\n-/\n-- #guard_msgs in\n-- #eval determine_winner 100 150 150 10 30", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0527", "language": "lean", "source": "fvapps", "source-id": "fvapps_000527", "source-notes": "", "vc-description": "/-\n\"Humankind cannot gain anything without first giving something in return. To obtain, something of equal value must be lost. That is alchemy's first law of Equivalent Exchange. In those days, we really believed that to be the world's one, and only truth.\"\n-- Alphonse Elric\nNow, here we have an equivalent exchange law for triangles which states that two right-angled isosceles triangles of the same color can be made into a square of the same color using Alchemy.\nYou are given N$N$ right-angled isosceles colored triangles numbered from 1$1$ to N$N$. For each triangle, the two equal sides have a length of 1$1$ unit. The Color of i$i$-th triangle is given by Ci$C_i$.\nTo create a tower, we choose some consecutive (2×k)+1$2 \\times k)+1$ triangles for any k≥0$k \\geq 0$. We then pick some 2×k$2 \\times k$ of them (these need not be consecutive), and form k$k$ pairs of triangles such that both triangles in pair have the same color. Also, each of the 2×k$2 \\times k$ should be in exactly one pair. Then the two triangles in each pair are joined using Alchemy (following the law of equivalent exchange for triangles) to form squares and these k$k$ squares are placed one upon other. The one remaining triangle is placed as a roof to the tower. This results in a tower of the height of k$k$.\nFind the maximum height of the tower that can be formed. \nIn other words, you should select the largest consecutive segment of triangles, such that you can form a tower using every single one of those triangles. In particular, you leave out one triangle, which will form the roof, and the other triangles should all be paired up such that both triangles in a pair have the same colour.\n\n-----Input:-----\n- The first line contains T$T$, the number of test cases. Then the test cases follow. \n- For every test case, the first line contains N$N$ denoting the number of triangles.\n- For every test case, the second line contains N$N$ space-separated integers Ci$C_{i}$ denoting the color of the triangles. ( 1≤i≤N$1 \\leq i \\leq N$).\n\n-----Output:-----\nFor every test case, output a single integer denoting the maximum height of the tower that can be formed.\n\n-----Constraints-----\n- 1≤T≤100$1 \\leq T \\leq 100$ \n- 1≤N≤105$1 \\leq N \\leq 10^{5}$ \n- 1≤Ci≤30$1 \\leq C_{i} \\leq 30$ \n- Sum of N$N$ over all test cases doesn't exceed 5×105$5\\times 10^{5}$ \n\n-----Sample Input:-----\n4\n14\n5 4 2 2 3 2 1 3 2 7 4 9 9 9\n3\n1 2 1\n3\n1 1 1\n5\n1 2 3 4 1\n\n-----Sample Output:-----\n3\n1\n1\n0\n\n-----EXPLANATION:-----\n- #1$1$: The subarray [2,2,3,2,1,3,2]$[2, 2, 3, 2, 1, 3, 2]$ results in a tower of height 3$3$.\n- #2$2$: The subarray [1,2,1]$[ 1, 2, 1 ]$ results in a tower of height 1$1$.\n- #3$3$: The subarray [1,1,1]$[ 1, 1, 1 ]$ results in a tower of height 1$1$. \n- #4$4$: The subarrays [1]$[ 1 ]$, [2]$[ 2 ]$ , [3]$[ 3 ]$, [4]$[ 4 ]$ and [1]$[ 1 ]$ all results in a tower of height 0$0$.\n\nThe above tower is possible by subarray [2,2,3,2,1,3,2]$[2, 2, 3, 2, 1, 3, 2]$ resulting in a height of 3$3$ in test case 1$1$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_tower_height (triangles : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem find_max_tower_height_non_negative (triangles : List Nat) \n  (h : ∀ x ∈ triangles, x > 0) : \n  find_max_tower_height triangles ≥ 0 :=\nsorry\n\ntheorem find_max_tower_height_upper_bound (triangles : List Nat)\n  (h : ∀ x ∈ triangles, x > 0) :\n  find_max_tower_height triangles ≤ triangles.length / 2 :=\nsorry\n\ntheorem find_max_tower_height_singleton (triangles : List Nat)\n  (h : triangles.length = 1) \n  (h2 : ∀ x ∈ triangles, x > 0) :\n  find_max_tower_height triangles = 0 :=\nsorry\n\ntheorem find_max_tower_height_composition \n  (triangle_lists : List (List Nat))\n  (h : ∀ l ∈ triangle_lists, ∀ x ∈ l, x > 0)\n  (h2 : triangle_lists ≠ []) :\n  find_max_tower_height (List.join triangle_lists) ≥ \n  (triangle_lists.map find_max_tower_height).maximum?.get! :=\nsorry\n\ntheorem find_max_tower_height_pairs (triangles : List Nat)\n  (h : triangles.length ≥ 2)\n  (h2 : ∀ x ∈ triangles, x > 0) :\n  find_max_tower_height triangles ≥ \n  (List.zip (triangles.take (triangles.length - 1)) (triangles.tail!)\n    |>.filter (fun p => p.1 = p.2)\n    |>.length) / 2 :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval find_max_tower_height [5, 4, 2, 2, 3, 2, 1, 3, 2, 7, 4, 9, 9, 9]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval find_max_tower_height [1, 2, 1]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval find_max_tower_height [1, 1, 1]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0537", "language": "lean", "source": "fvapps", "source-id": "fvapps_000537", "source-notes": "", "vc-description": "/-\nChef has gone shopping with his 5-year old son. They have bought N items so far. The items are numbered from 1 to N, and the item i weighs Wi grams.\n\nChef's son insists on helping his father in carrying the items. He wants his dad to give him a few items. Chef does not want to burden his son. But he won't stop bothering him unless he is given a few items to carry. So Chef decides to give him some items. Obviously, Chef wants to give the kid less weight to carry.\n\nHowever, his son is a smart kid. To avoid being given the bare minimum weight to carry, he suggests that the items are split into two groups, and one group contains exactly K items. Then Chef will carry the heavier group, and his son will carry the other group.\n\nHelp the Chef in deciding which items should the son take. Your task will be simple. Tell the Chef the maximum possible difference between the weight carried by him and the weight carried by the kid.\n\n-----Input:-----\nThe first line of input contains an integer T, denoting the number of test cases. Then T test cases follow. The first line of each test contains two space-separated integers N and K. The next line contains N space-separated integers W1, W2, ..., WN.\n\n-----Output:-----\nFor each test case, output the maximum possible difference between the weights carried by both in grams.\n\n-----Constraints:-----\n- 1 ≤ T ≤ 100\n- 1 ≤ K < N ≤ 100\n- 1 ≤ Wi ≤ 100000 (105)\n\n-----Example:-----\nInput:\n2\n5 2\n8 4 5 2 10\n8 3\n1 1 1 1 1 1 1 1\n\nOutput:\n17\n2\n\n-----Explanation:-----\nCase #1: The optimal way is that Chef gives his son K=2 items with weights 2 and 4. Chef carries the rest of the items himself. Thus the difference is: (8+5+10) − (4+2) = 23 − 6 = 17.\n\nCase #2: Chef gives his son 3 items and he carries 5 items himself.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + sum xs\n\ndef List.sort (l : List Nat) : List Nat :=\nsorry\n\ndef abs (n : Nat) : Nat :=\n  if n ≥ 0 then n else 0", "vc-helpers": "", "vc-definitions": "def get_max_weight_difference (N : Nat) (K : Nat) (weights : List Nat) : Int :=\nsorry", "vc-theorems": "theorem reverse_invariant {N K : Nat} {weights : List Nat} :\n  weights.length = N →\n  K ≤ N →\n  get_max_weight_difference N K weights = get_max_weight_difference N K weights.reverse :=\nsorry\n\ntheorem complement_invariant {N K : Nat} {weights : List Nat} :\n  weights.length = N →\n  K ≤ N →\n  get_max_weight_difference N K weights = get_max_weight_difference N (N-K) weights :=\nsorry \n\ntheorem sort_preserves_sum {weights : List Nat} :\n  List.sum weights = List.sum (List.sort weights) :=\nsorry\n\ntheorem identical_weights_property {N K w : Nat} {weights : List Nat} :\n  weights = List.replicate N w →\n  K ≤ N →\n  get_max_weight_difference N K weights = if 2*K ≥ N \n    then Int.ofNat ((2*K - N)*w)\n    else Int.ofNat ((N - 2*K)*w) :=\nsorry\n\n/-\ninfo: 17\n-/\n-- #guard_msgs in\n-- #eval get_max_weight_difference 5 2 [8, 4, 5, 2, 10]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval get_max_weight_difference 8 3 [1, 1, 1, 1, 1, 1, 1, 1]\n\n/-\ninfo: 13\n-/\n-- #guard_msgs in\n-- #eval get_max_weight_difference 4 1 [5, 2, 7, 3]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0542", "language": "lean", "source": "fvapps", "source-id": "fvapps_000542", "source-notes": "", "vc-description": "/-\nProf. Sergio Marquina is a mathematics teacher at the University of Spain. Whenever he comes across any good question(with complexity k), he gives that question to students within roll number range i and j.\nAt the start of the semester he assigns a score of 10 to every student in his class if a student submits a question of complexity k, his score gets multiplied by k.\nThis month he gave M questions and he is wondering what will be mean of maximum scores of all the students. He is busy planning a tour of the Bank of Spain for his students, can you help him?\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains the first line of input, two integers N, M i.e. Number of students in the class and number of questions given in this month.\n- Next M lines contain 3 integers -i,j,k i.e. starting roll number, end roll number, and complexity of the question\n\n-----Output:-----\n- For each test case, output in a single line answer - floor value of Mean of the maximum possible score for all students.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq N, M \\leq 105$\n- $1 \\leq i \\leq j \\leq N$\n- $1 \\leq k \\leq 100$\n\n-----Sample Input:-----\n1\n5 3\n1 3 5\n2 5 2\n3 4 7\n\n-----Sample Output:-----\n202\n\n-----EXPLANATION:-----\nInitial score of students will be : [10,10,10,10,10]\nafter solving question 1 scores will be: [50,50,50,10,10]\nafter solving question 2 scores will be: [50,100,100,20,20]\nafter solving question 1 scores will be: [50,100,700,140,20]\nHence after all questions mean of maximum scores will (50+100+700+140+20)/5=202\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_professor_scores (n m : Nat) (questions : List (Nat × Nat × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem result_is_nonnegative (n m : Nat) (questions : List (Nat × Nat × Nat)) :\n  solve_professor_scores n m questions ≥ 0 := sorry\n\ntheorem result_bounded_by_max (n m : Nat) (questions : List (Nat × Nat × Nat)) :\n  solve_professor_scores n m questions ≤ 10 * (10 ^ questions.length) := sorry\n\ntheorem all_students_same_k (n k : Nat) :\n  n > 0 → k > 0 → k ≤ 10 → solve_professor_scores n 1 [(1,n,k)] = 10 * k := sorry\n\nend ProfessorScores\n\n/-\ninfo: 202\n-/\n-- #guard_msgs in\n-- #eval solve_professor_scores 5 3 [(1, 3, 5), (2, 5, 2), (3, 4, 7)]\n\n/-\ninfo: 50\n-/\n-- #guard_msgs in\n-- #eval solve_professor_scores 1 1 [(1, 1, 5)]\n\n/-\ninfo: 60\n-/\n-- #guard_msgs in\n-- #eval solve_professor_scores 3 2 [(1, 3, 2), (1, 3, 3)]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0546", "language": "lean", "source": "fvapps", "source-id": "fvapps_000546", "source-notes": "", "vc-description": "/-\nThis time minions are celebrating Diwali Festival. There are N minions in total. Each of them owns a house. On this Festival, Each of them wants to decorate their house. But none of them have enough money to do that. One of the minion, Kevin, requested Gru for money. Gru agreed for money distribution but he will be giving money to a minion if and only if demanded money is less than or equal to the money Gru have. Now Gru wonders if he can spend all the money or not.\n\n-----Input-----\nFirst line have number of test cases T. Each test case consist of Two Lines. First line contains two space separated integers N and K i.e. Number of minions and Amount of Money Gru have. Next line contains N space separated integers A1,A2,A3,.....,AN representing amount of money demanded by ith minion.\n\n-----Output-----\nOutput YES if Gru can spend his all of the money on minions i.e. after distribution Gru have zero amount of money else NO.\n\n-----Constraints-----\n- 1 ≤ T ≤ 105\n- 1 ≤ N ≤ 102\n- 1 ≤ K,Ai ≤ 109\n\n-----Example-----\nInput:\n2 \n4 9\n5 2 2 4\n4 9\n5 2 18 3\n\nOutput:\nYES\nNO\n\n-----Explanation-----\nExample case 1.At first Gru is having 9 Rs. If he gives 5 Rs. to first minion then remaining 4 Rs. can be given to 2nd and 3rd minion or to the 4th minion. Which will leave zero amount of money in the hands of Gru.\nExample case 2.At first Gru is having 9 Rs. If he gives 5 Rs. to the first minion then from remaining 4 Rs. either he can give 2 Rs. to the 2nd minion or 3 Rs. to the fourth minion. Which will leave either 2 Rs. or 1 Rs. in the hands of Gru.\n-/", "vc-preamble": "def List.sum : List Nat → Nat\n  | [] => 0\n  | (x::xs) => x + List.sum xs", "vc-helpers": "", "vc-definitions": "def List.sort : List Nat → List Nat := sorry\n\ndef can_spend_all_money (n : Nat) (k : Nat) (demands : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem can_spend_all_money_sum_too_large {n : Nat} {k : Nat} {demands : List Nat} :\n  k > List.sum demands → can_spend_all_money n k demands = false :=\n  sorry\n\ntheorem can_spend_all_money_sort_invariant {n : Nat} {k : Nat} {demands : List Nat} :\n  can_spend_all_money n k (List.sort demands) = can_spend_all_money n k demands :=\n  sorry\n\ntheorem can_spend_individual_demands {n : Nat} {demands : List Nat} :\n  ∀ d ∈ demands, can_spend_all_money n d demands = true :=\n  sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval can_spend_all_money 4 9 [5, 2, 2, 4]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval can_spend_all_money 4 9 [5, 2, 18, 3]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0548", "language": "lean", "source": "fvapps", "source-id": "fvapps_000548", "source-notes": "", "vc-description": "/-\nThe land of Programmers Army is surrounded by many islands. A unique number is associated with each island. The king of the islands is a very generous person, he donates a certain amount of gold coins to travelers for visiting each island that they visited to.\nNow, you are appointed as a traveler, who will travel to all these(or some) islands as many times as the Army wants, and you will collect gold coins from the king of the island.\nIn each trip, you will be asked to give the total sum of gold coins you have collected.\n\n-----Input:-----\n- The first line of the input contains a single integer $T$. $T$ denoting the number of test cases. The description of $T$ test cases is as follows.\n- The next line of the input contains a single integer $N$. $N$ denotes the total number of Islands.\n- The next line of the input contains $N$ space-separated integers $A1, A2, A3...An$ where $ith$ number denotes the maximum number of coins that the king of $ith$ island can donate.\n- Next line contains a single integer $Q$. $Q$ denotes the total number of times traveler have to go for the trip.\n- Next $Q$ lines contains, two space-separated integers $Q1,Q2$ denoting the start and end number of islands, i.e. traveler will start the trip from $Q1th$ island and will go till $Q2th$ island, in each trip.\nNote: islands are numbered from $1$ to $N$.\n\n-----Output:-----\n- For each trip print the total number of gold coins, traveler will collect(each on a new line).\n\n-----Constraints:-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq N \\leq 10^4$\n- $1 \\leq A1, A2, A3...An \\leq 10^5$\n- $1 \\leq Q \\leq 10^3$\n- $1 \\leq Q1,Q2 \\leq N$\n\n-----Sample Input:-----\n1\n4\n10 2 5 50\n2\n1 3\n2 4\n\n-----Sample Output:-----\n17\n57\n\n-----Explanation:-----\n- \nIn 1st Trip, traveler will go from 1st Island to 3rd Island, hence the total number of coins traveler can collect is 10+2+5 = 17\n- \nIn 2 d Trip, traveler will go from 2nd Island to 4th Island, hence the total number of coins traveler can collect is 2+5+50 = 57\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.sum (l : List Nat) : Nat := l.foldl (·+·) 0\n\ndef solveIslandRewards (N : Nat) (coins : List Nat) (queries : List (Nat × Nat)) : List Nat := sorry", "vc-theorems": "theorem island_rewards_result_length \n  (N : Nat) (coins : List Nat) (queries : List (Nat × Nat))  \n  (h1 : N > 0) (h2 : coins.length = N)\n  (h3 : ∀ q ∈ queries, q.1 ≤ N ∧ q.2 ≤ N) :\n  (solveIslandRewards N coins queries).length = queries.length := sorry\n\ntheorem island_rewards_sum_correct\n  (N : Nat) (coins : List Nat) (queries : List (Nat × Nat))\n  (h1 : N > 0) (h2 : coins.length = N)\n  (h3 : ∀ q ∈ queries, q.1 ≤ N ∧ q.2 ≤ N)\n  (h4 : ∀ c ∈ coins, c ≥ 0)\n  (i : Nat) (hi : i < queries.length) :\n  let q := queries.get ⟨i, hi⟩\n  let result := (solveIslandRewards N coins queries).get ⟨i, by rw [island_rewards_result_length N coins queries h1 h2 h3]; exact hi⟩\n  result = List.sum ((coins.take q.2).drop (q.1 - 1)) := sorry\n\ntheorem island_rewards_non_negative\n  (N : Nat) (coins : List Nat) (queries : List (Nat × Nat))\n  (h1 : N > 0) (h2 : coins.length = N)\n  (h3 : ∀ q ∈ queries, q.1 ≤ N ∧ q.2 ≤ N)\n  (h4 : ∀ c ∈ coins, c ≥ 0) :\n  ∀ r ∈ solveIslandRewards N coins queries, r ≥ 0 := sorry\n\ntheorem island_rewards_empty_range\n  (N : Nat) (coins : List Nat) (queries : List (Nat × Nat))\n  (h1 : N > 0) (h2 : coins.length = N)\n  (h3 : ∀ q ∈ queries, q.1 ≤ N ∧ q.2 ≤ N)\n  (i : Nat) (hi : i < queries.length) :\n  let q := queries.get ⟨i, hi⟩\n  q.1 > q.2 → (solveIslandRewards N coins queries).get ⟨i, by rw [island_rewards_result_length N coins queries h1 h2 h3]; exact hi⟩ = 0 := sorry\n\ntheorem island_rewards_deterministic\n  (N : Nat) (coins : List Nat) (queries : List (Nat × Nat))\n  (h1 : N > 0) (h2 : coins.length = N)\n  (h3 : ∀ q ∈ queries, q.1 ≤ N ∧ q.2 ≤ N) :\n  solveIslandRewards N coins queries = solveIslandRewards N coins queries := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0578", "language": "lean", "source": "fvapps", "source-id": "fvapps_000578", "source-notes": "", "vc-description": "/-\nYou are given a sequence of integers $A_1,A_2,…,A_N$ and a magical non-zero integer $x$\nYou have to select a subsegment of sequence A (possibly empty), and replace the elements in that subsegment after dividing them by x.\nFormally, replace any one subsegment $A_l, A_{l+1}, ..., A_r$ with $A_l/x, A_{l+1}/x, ..., A_r/x$ where $l \\leq r$\nWhat is the minimum possible sum you can obtain?\nNote: The given operation can only be performed once\n\n-----Input -----\n- The first line of the input contains two positive integer n denoting the size of array, and x\ndenoting the magical integer\n- Next line contains $N$ space separated integers\n\n-----Output-----\nSingle line containing one real number, denoting the minimum possible sum you can obtain. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-2}$\n\n-----Constraints-----\n- $1 \\leq n \\leq 10^3$\n- $1 \\leq |x| \\leq 10^3$\n- $ |A_i| \\leq 10^3$\n\n-----Sample Input-----\n3 2\n1 -2 3\n\n-----Sample Output-----\n0.5\n\n-----Explanation-----\nArray 1 -2 3, selecting subsegment {3}, you get 1 -2 1.5, which gives $sum=0.5$\n-/", "vc-preamble": "def List.sum (l : List Int) : Int := \n  match l with\n  | [] => 0\n  | x :: xs => x + List.sum xs\n\ndef List.sumFloat (l : List Float) : Float :=\n  match l with\n  | [] => 0\n  | x :: xs => x + List.sumFloat xs", "vc-helpers": "", "vc-definitions": "def min_sum_after_division (n : Nat) (x : Nat) (arr : List Int) : Float := sorry\n\ntheorem min_sum_properties_le_orig_sum {n : Nat} {x : Nat} {arr : List Int} \n  (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0) \n  (h4 : x ≠ 0) :\n  min_sum_after_division n x arr ≤ Float.ofInt (List.sum arr) := sorry", "vc-theorems": "theorem min_sum_properties_exists_real {n : Nat} {x : Nat} {arr : List Int}\n  (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0) \n  (h4 : x ≠ 0) :\n  ∃ r : Float, min_sum_after_division n x arr = r := sorry\n\ntheorem min_sum_properties_le_divided_sum {n : Nat} {x : Nat} {arr : List Int} {i j : Nat}\n  (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0)\n  (h4 : i ≤ j) (h5 : j < arr.length) (h6 : x ≠ 0) :\n  let divided_section := (arr.drop i).take (j-i+1) |>.map (fun a => Float.ofInt a / Float.ofNat x)\n  let divided_sum := Float.ofInt (List.sum (arr.take i)) + \n                    List.sumFloat divided_section +\n                    Float.ofInt (List.sum (arr.drop (j+1)))\n  min_sum_after_division n x arr ≤ divided_sum := sorry\n\ntheorem positive_array_nonneg {n : Nat} {x : Nat} {arr : List Int}\n  (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0)\n  (h4 : ∀ a ∈ arr, a ≥ 0) (h5 : x ≠ 0) :\n  min_sum_after_division n x arr ≥ 0 := sorry \n\ntheorem positive_array_le_sum {n : Nat} {x : Nat} {arr : List Int}\n  (h1 : x ≥ 2) (h2 : arr.length = n) (h3 : arr.length > 0) \n  (h4 : ∀ a ∈ arr, a ≥ 0) (h5 : x ≠ 0) :\n  min_sum_after_division n x arr ≤ Float.ofInt (List.sum arr) := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0591", "language": "lean", "source": "fvapps", "source-id": "fvapps_000591", "source-notes": "", "vc-description": "/-\nAbhi Ram analyses london stock exchange and invests in a software company C-.gate . He wants to sell his shares after 5 weeks.\n\nGiven the investment  m, increase or decrease of share prices of 5 weeks(+/- pi) , help him to calculate his net profit or loss percentage(n%) of his investment to establish his own company KMC.\n\n-----Input:-----\n\n- The first line contains an integer T which denotes the number of test cases.\n- Each test case comprises of two lines: the first line contains the integer m which denotes the amount invested.\n\nThe second line consists of five space separated integers(p1, p2, p3, p4, p5) each preceeded by + (increase) or - (decrease) which give the percentage of change in share prices over 5 weeks.\n.\n\n-----Output:-----\nThe output contains a single number n which gives the percentage of profit or loss preceeded by + (profit) or - (loss).\n\n-----Constraints:-----\n- 1 ≤ T ≤ 100\n- 1 ≤ m ≤ 105\n- -100 ≤ pi ≤ 100\n\n-----Example:-----\nInput:\n2\n10000\n+5 -3 -2 +10 +15\n6256250\n-24 +22 +4 -16 +20\n\nOutput:\n+26.2634\n-2.79977\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_profit_loss (investment : Nat) (changes : List Int) : String :=\n  sorry", "vc-theorems": "theorem calculate_profit_loss_format \n  (investment : Nat) \n  (changes : List Int)\n  (h1 : 1 ≤ investment ∧ investment ≤ 10^7)\n  (h2 : changes.length ≥ 1 ∧ changes.length ≤ 100) \n  (h3 : ∀ x ∈ changes, -99 ≤ x ∧ x ≤ 99) :\n  let result := calculate_profit_loss investment changes\n  (result.get 0 = '+' ∨ result.get 0 = '-' ∨ result = \"0\") :=\n  sorry\n\ntheorem calculate_profit_loss_precision\n  (investment : Nat)\n  (changes : List Int) \n  (h1 : 1 ≤ investment ∧ investment ≤ 10^7)\n  (h2 : changes.length ≥ 1 ∧ changes.length ≤ 100)\n  (h3 : ∀ x ∈ changes, -99 ≤ x ∧ x ≤ 99)\n  (h4 : calculate_profit_loss investment changes ≠ \"0\") :\n  let result := calculate_profit_loss investment changes\n  String.length result ≤ 6 :=\n  sorry\n\ntheorem zero_changes_result\n  (investment : Nat)\n  (changes : List Int)\n  (h1 : 1 ≤ investment ∧ investment ≤ 10^7) \n  (h2 : changes.length ≥ 1 ∧ changes.length ≤ 100)\n  (h3 : ∀ x ∈ changes, x = 0) :\n  calculate_profit_loss investment changes = \"0\" :=\n  sorry\n\ntheorem single_change_calculation\n  (investment : Nat)\n  (change : Int)\n  (h1 : 1 ≤ investment ∧ investment ≤ 10^7)\n  (h2 : -99 ≤ change ∧ change ≤ 99) :\n  let result := calculate_profit_loss investment [change]\n  let resultNum := String.toInt! result\n  (resultNum - change).natAbs ≤ 1 :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0599", "language": "lean", "source": "fvapps", "source-id": "fvapps_000599", "source-notes": "", "vc-description": "/-\nThere are $M$ levels for a building numbered from $1$ to $M$ from top to bottom, each level having $N$ parking spots numbered from $1$ to $N$ from left to right. Some spots might have a car while other may be empty, the information of which is given in form of two dimensional character array $C$ ($C_{i, j}$ denote parking spot at $j$-th position on $i$-th level).\nThere is a thief who wants to unlock all the cars. Now, he is skilled such that for the first time, he can directly reach in any parking spot in no time. Basically he can reach the first car to be stolen in 0 time.\nNow, he can move within the parking lot only in following manner, each taking 1 unit of time:\n- Move down a level. That is, if current position is $(i, j)$, then he reaches $(i+1, j)$\n- If current position is $(i, j)$ and if\n- $i$ is odd, then he can move from $(i, j)$ to $(i, j+1)$\n- $i$ is even, then he can move from $(i, j)$ to $(i, j-1)$\nNote that he wants to unlock the cars in minimum time and the car is unlocked as soon as the thief reaches that parking spot.If the parking lot is empty, then the time taken is considered to be 0.  \nFind the minimum time when all the cars would be unlocked. Note that once all cars are unlocked, the thief can escape instantly, so this time does not count.\n\n-----Input :-----\n- The first line of input contains a single integer $T$ (number of test cases).\n- First liine of each test case contains $M$ and $N$(number of levels and spots per each level)  \n- Next $M$ line contains $N$ space separated characters $C_{i, 1}, C_{i, 2} \\ldots C_{i, N}$  where $(1\\leq i\\leq M)$ and $C_{i, j}$ is either $'P'$ or $'N'$ (without quotes).\nIf the spot contains $'P'$, then a car is parked there. else, it’s not parked.\n\n-----Output :-----\nFor each test case print a single integer, the minimum time in which thief can unlock all cars.\n\n-----Constraints :-----\n- $1\\leq T \\leq100.$ \n- $1\\leq M,N \\leq300$ \n\n-----Subtasks :-----\n- \nSubtask 1 (20 points): $1\\leq M \\leq2.$ \n- \nSubtask 2 (80 points): Original Constraints\n\n-----Sample Input :-----\n2\n4 5\nN P N N P\nN N P N N\nN P N N N\nP N N N N\n3 3\nN P P\nP P P \nP P N\n\n-----Sample Output :-----\n10\n6\n\n-----Explanation:-----\nIn the first case, He will select the spot $(1,2)$ and the path he takes will be $(1,2)→(1,3)→(1,4)→(1,5)→(2,5)→(2,4)→(2,3)→(2,2)→(3,2)→(4,2)→(4,1)$\n\nSo, he takes 10 steps to unlock all the cars.\nIn the second case, He will select the spot $(1,2)$ and the path he takes will be $(1,2)→(1,3)→(2,3)→(2,2)→(2,1)→(3,1)→(3,2)$.\nSo, he takes 6 steps.\n-/", "vc-preamble": "def solve_parking_thief (m n : Nat) (grid : List (List Char)) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def updateList {α} (xs : List α) (i : Nat) (v : α) : List α :=\n  sorry", "vc-theorems": "theorem empty_grid_zero (m n : Nat) (h1 : m > 0) (h2 : n > 0) :\n  let grid := List.replicate m (List.replicate n 'N')\n  solve_parking_thief m n grid = 0 := by\n  sorry\n\ntheorem single_row_min_distance (m n : Nat) (p_positions : List Nat) \n  (h1 : m > 0) (h2 : n > 0) (h3 : ∀ p ∈ p_positions, p < n) :\n  let grid := List.replicate m (List.replicate n 'N')\n  let grid_with_p := updateList grid 0 \n    (p_positions.foldl (fun row p => updateList row p 'P') (List.replicate n 'N'))\n  p_positions ≠ [] →\n  solve_parking_thief m n grid_with_p ≥ \n    (List.maximum? p_positions).getD 0 - (List.minimum? p_positions).getD 0 := by\n  sorry\n\ntheorem single_row_no_p_zero (m n : Nat) (h1 : m > 0) (h2 : n > 0) :\n  let grid := List.replicate m (List.replicate n 'N')\n  solve_parking_thief m n grid = 0 := by\n  sorry\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval solve_parking_thief 4 5 [[\"N\", \"P\", \"N\", \"N\", \"P\"], [\"N\", \"N\", \"P\", \"N\", \"N\"], [\"N\", \"P\", \"N\", \"N\", \"N\"], [\"P\", \"N\", \"N\", \"N\", \"N\"]]\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval solve_parking_thief 3 3 [[\"N\", \"P\", \"P\"], [\"P\", \"P\", \"P\"], [\"P\", \"P\", \"N\"]]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval solve_parking_thief 2 3 [[\"N\", \"N\", \"N\"], [\"N\", \"N\", \"N\"]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0600", "language": "lean", "source": "fvapps", "source-id": "fvapps_000600", "source-notes": "", "vc-description": "/-\nWe all know that Share market is place where drastic change occurs within moments. So we have one Stockholder, Isabella, who wants to maximize her profit by selling her shares. She has $N$ shares of a Doofenshmirtz Corporation which is represented by $N$ different lines where each line contains two space separated integers $a_i$ , $b_i$ corresponding to initial and final values of the share prize. Isabella can sell any number of shares. But, she will sell those shares only if the following condition is satisfied - \n- for any pair $(i,j)$ of shares that she choses to sell, $a_i \\leq a_j$  and $b_i < b_j$ must be satisfied. \nYou need to tell Isabella the maximum number of Shares she can sell.\n\n-----Input:-----\n- First line will contain $T$, number of test cases. \n- Each test case has the following format:\n- First line of each test case contain single integer $N$, the number of shares of Isabella.  \n- Next $N$ lines of each test case contain two space separated integers $a_i$, $b_i$ (initial and final value of share prize respectively) for each $1 \\leq i \\leq N$.\n\n-----Output:-----\nFor each test case output a single integer: the maximum number of shares that can be sold by Isabella.\n\n-----Constraints-----\n- $1 \\leq T \\leq 5$\n- $1 \\leq N \\leq 10^5$\n- $1 \\leq a_i , b_i \\leq 10^9 , for  each $1$ \\leq $i$ \\leq $N \n\n-----Sample Input:-----\n$1$\n$4$ \n$1$ $2$\n$4$ $3$\n$3$ $5$ \n$2$ $4$ \n\n-----Sample Output:-----\n$3$   \n\n-----Explanation:-----\nHere, Isabella decided to sell share 1, share 3 and share 4 as any two pair of \nchosen share hold the given condition.\n-/", "vc-preamble": "def find_max_shares_to_sell (shares: List Share) : Nat :=\n  sorry\n\ndef is_unique_shares (shares: List Share) : Bool :=\n  sorry\n\ndef is_strictly_increasing (l: List Nat) : Bool :=\n  match l with\n  | [] => true\n  | [_] => true\n  | x :: y :: xs => x < y && is_strictly_increasing (y :: xs)\n\ndef is_strictly_decreasing (l: List Nat) : Bool :=\n  match l with\n  | [] => true\n  | [_] => true\n  | x :: y :: xs => x > y && is_strictly_decreasing (y :: xs)", "vc-helpers": "", "vc-definitions": "def sorted_shares (shares: List Share) : List Share :=\n  sorry", "vc-theorems": "theorem max_shares_bounds {shares: List Share} (h: shares ≠ []) :\n  1 ≤ find_max_shares_to_sell shares ∧ find_max_shares_to_sell shares ≤ shares.length :=\nsorry\n\ntheorem max_shares_sort_invariant (shares: List Share) :\n  find_max_shares_to_sell shares = find_max_shares_to_sell (sorted_shares shares) :=\nsorry\n\ntheorem strictly_increasing_max_shares {shares: List Share} (h1: shares ≠ []) \n  (h2: is_strictly_increasing (shares.map Share.value)) :\n  find_max_shares_to_sell (sorted_shares shares) = shares.length :=\nsorry\n\ntheorem strictly_decreasing_max_shares {shares: List Share} (h1: shares ≠ [])\n  (h2: is_strictly_decreasing (shares.map Share.value)) :\n  find_max_shares_to_sell (sorted_shares shares) = 1 :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval find_max_shares_to_sell [[1, 2], [4, 3], [3, 5], [2, 4]]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval find_max_shares_to_sell [[1, 2], [2, 3], [3, 4]]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval find_max_shares_to_sell [[5, 1], [4, 2], [3, 3], [2, 4], [1, 5]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0601", "language": "lean", "source": "fvapps", "source-id": "fvapps_000601", "source-notes": "", "vc-description": "/-\nDexter, being irritated by DD, gave her a lucrative game to play to keep her busy.\nThere are $N$ bags numbered $1$ to $N$. The $i_{th}$ bag contains $A_i$ coins. The bags are placed in a circular order such that the $N_{th}$ bag is adjacent to the $1^{st}$ bag. \nDD can select $K$ consecutive adjacent bags and take all the coins in them.   Help her find the maximum number of coins she can take by making the ideal choice.\nNote that the selected bags must be consecutive. Since they are placed in circular order, bag number $1$ and $N$ are considered to be consecutive.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- First-line contains $N$ and $K$.\n- Second-line contains $N$ numbers $A_1, A_2,...,A_N$,  \n\n-----Output:-----\nFor each test case, output in a single line, the maximum money that can be collected by DD.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $5 \\leq N \\leq 10^5$\n- $1 \\leq K < N$\n- $1 \\leq A_i \\leq 10^5$\nSum of $N$ over all test cases is less than $10^6$\n\n-----Sample Input:-----\n1\n5 3\n8 6 9 4 10\n\n-----Sample Output:-----\n24\n\n-----EXPLANATION:-----\nThe ideal choice would be to take the last bag with $10$ coins and the first $2$ bags with $8$ and $6$ coins.\n-/", "vc-preamble": "def List.sum (xs : List Int) : Int :=\nmatch xs with\n| [] => 0\n| h :: t => h + List.sum t\n\ndef max_list (xs : List Int) : Int :=\nmatch xs with\n| [] => 0\n| [x] => x\n| x::xs => max x (max_list xs)", "vc-helpers": "", "vc-definitions": "def find_max_coins (n k : Nat) (arr : List Int) : Int :=\nsorry", "vc-theorems": "theorem find_max_coins_k_exceeds_n {n k : Nat} {arr : List Int} \n  (h1 : arr.length = n)\n  (h2 : k > n) :\n  find_max_coins n k arr = 0 :=\nsorry\n\ntheorem find_max_coins_k_equals_n {n k : Nat} {arr : List Int}\n  (h1 : arr.length = n)\n  (h2 : k = n)\n  (h3 : n > 0) :\n  find_max_coins n k arr = List.sum arr :=\nsorry\n\ntheorem find_max_coins_sliding_window {n k : Nat} {arr : List Int}\n  (h1 : arr.length = n)\n  (h2 : k > 0)\n  (h3 : k ≤ n) :\n  find_max_coins n k arr = max_list ((List.range n).map (fun i => \n    List.sum (List.take k (List.drop i (arr ++ arr)))\n  )) :=\nsorry\n\ntheorem find_max_coins_monotonic {n k : Nat} {arr : List Int}\n  (h1 : arr.length = n)\n  (h2 : k ≤ n)\n  (h3 : k > 1)\n  (h4 : ∀x ∈ arr, x ≥ 0) :\n  find_max_coins n k arr ≥ find_max_coins n (k-1) arr :=\nsorry\n\n/-\ninfo: 24\n-/\n-- #guard_msgs in\n-- #eval find_max_coins 5 3 [8, 6, 9, 4, 10]\n\n/-\ninfo: 18\n-/\n-- #guard_msgs in\n-- #eval find_max_coins 6 4 [1, 2, 3, 4, 5, 6]\n\n/-\ninfo: 90\n-/\n-- #guard_msgs in\n-- #eval find_max_coins 5 2 [10, 20, 30, 40, 50]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0613", "language": "lean", "source": "fvapps", "source-id": "fvapps_000613", "source-notes": "", "vc-description": "/-\nSheldon is a little geek living in Texas. While his friends like to play outside, little Sheldon likes to play around with ICs and lasers in his house. He decides to build N clap activated toggle machines each with one power inlet and one outlet. Each machine works when its power source inlet is receiving power. When the machine is in 'ON' state and is receiving power at its inlet, it makes power available at its power outlet to which a bulb or another ToGgLe machine could be attached.\n\nSuppose Sheldon attached 2 such machines to one another with the power inlet of the first machine attached to a power source at his house and the outlet of the second machine to a bulb. Initially both machines are in 'OFF' state and power source to first machine is off too. Now the power source is switched on. The first machine receives power but being in the 'OFF' state it does not transmit any power. Now on clapping the first ToGgLe machine toggles to 'ON' and the second machine receives power. On clapping once more the first toggles to 'OFF' and the second toggles to 'ON'. But since the second ToGgLe machine receives no power the bulb does not light up yet. On clapping once more, the first machine which is still receiving power from the source toggles to 'ON' and the second which was already 'ON' does not toggle since it was not receiving power. So both the machine are in 'ON' state and the bulb lights up and little Sheldon is happy.\n\nBut when Sheldon goes out for a while, his evil twin sister attaches N such ToGgLe machines (after making sure they were all in 'OFF' state) and attaches the first to a power source (the power source is initially switched off) and the last ToGgLe machine to a bulb. Sheldon is horrified to find that his careful arrangement has been disturbed.\n\nCoders, help the poor boy by finding out if clapping k times for the N ToGgLe machines (all in 'OFF' state with the first one connected to a switched off power source and last one to a bulb) would light the bulb. Hurry before Sheldon has a nervous breakdown!\n\n-----Input-----\nFirst line has number of test cases, T.\n\nFollowing T lines have N, k separated by a single space where N is the number of \nToGgLe machines and k is the number of times Sheldon clapped.\n\n-----Output-----\nT lines with cach line of the form: \"ON\" (just the word on without the double quotes) if the bulb is 'ON' for the \ntest case numbered n and \"OFF\" (just the word off without the double quotes) if the bulb is 'OFF' for the test case numbered n.\n\n-----Example-----\nInput:\n4\n4 0\n4 47\n1 0\n1 1\n\nOutput:\nOFF\nON\nOFF\nON\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_toggle_machines (N: Nat) (k: Nat) : State :=\n  sorry", "vc-theorems": "theorem toggle_base_case_one : \n  solve_toggle_machines 1 1 = State.ON :=\n  sorry\n\ntheorem toggle_base_case_zero :\n  solve_toggle_machines 1 0 = State.OFF :=\n  sorry\n\ntheorem toggle_output_is_binary (N k: Nat) (h1: N > 0) (h2: N ≤ 10) :\n  (solve_toggle_machines N k = State.ON) ∨ (solve_toggle_machines N k = State.OFF) :=\n  sorry\n\ntheorem initial_state_is_off (N: Nat) (h: N > 0) (h2: N ≤ 10) :\n  solve_toggle_machines N 0 = State.OFF :=\n  sorry\n\ntheorem power_of_two_pattern (N k: Nat) (h1: N > 0) (h2: N ≤ 10) :\n  (k + 1) % (2^N) = 0 → solve_toggle_machines N k = State.ON :=\n  sorry\n\ntheorem power_of_two_pattern_converse (N k: Nat) (h1: N > 0) (h2: N ≤ 10) :\n  (k + 1) % (2^N) ≠ 0 → solve_toggle_machines N k = State.OFF :=\n  sorry\n\n/-\ninfo: 'OFF'\n-/\n-- #guard_msgs in\n-- #eval solve_toggle_machines 4 0\n\n/-\ninfo: 'ON'\n-/\n-- #guard_msgs in\n-- #eval solve_toggle_machines 4 47\n\n/-\ninfo: 'OFF'\n-/\n-- #guard_msgs in\n-- #eval solve_toggle_machines 1 0\n\n/-\ninfo: 'ON'\n-/\n-- #guard_msgs in\n-- #eval solve_toggle_machines 1 1", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0616", "language": "lean", "source": "fvapps", "source-id": "fvapps_000616", "source-notes": "", "vc-description": "/-\nChef is given a sequence of prime numbers $A_1, A_2, \\ldots, A_N$. This sequence has exactly $2^N$ subsequences. A subsequence of $A$ is good if it does not contain any two identical numbers; in particular, the empty sequence is good.\nChef has to find the number of good subsequences which contain at most $K$ numbers. Since he does not know much about subsequences, help him find the answer. This number could be very large, so compute it modulo $1,000,000,007$.\n\n-----Input-----\n- The first line of the input contains two space-separated integers $N$ and $K$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nPrint a single line containing one integer ― the number of good subsequences with size at most $K$, modulo $1,000,000,007$.\n\n-----Constraints-----\n- $1 \\le K \\le N \\le 10^5$\n- $2 \\le A_i \\le 8,000$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (40 points): $A_1, A_2, \\ldots, A_N$ are pairwise distinct\nSubtask #2 (60 points): original constraints\n\n-----Example Input-----\n5 3\n2 2 3 3 5\n\n-----Example Output-----\n18\n\n-----Explanation-----\nThere is $1$ good subsequence with length $0$, $5$ good subsequences with length $1$, $8$ good subsequences with length $2$ and $4$ good subsequences with length $3$.\n-/", "vc-preamble": "def List.sum : List Nat → Nat\n| [] => 0\n| (h::t) => h + List.sum t\n\ndef solve (arr : List Nat) (n k : Nat) : Nat :=\n  sorry\n\ndef windowSum (arr : List Nat) (start len : Nat) : Nat :=\n  (arr.take (start + len)).drop start |>.sum", "vc-helpers": "", "vc-definitions": "def countWindows (arr : List Nat) (n k : Nat) : Nat :=\n  let windows := List.range (n - k + 1)\n  windows.filter (fun i => windowSum arr i k = k) |>.length", "vc-theorems": "theorem solve_basic_properties \n  (arr : List Nat) \n  (n k : Nat)\n  (h1 : ∀ x ∈ arr, x ≤ 1)\n  (h2 : k ≤ n)\n  (h3 : n = arr.length) :\n  let result := solve arr n k\n  -- Result is non-negative\n  (result ≥ 0) ∧ \n  -- Result does not exceed max possible windows\n  (result ≤ n - k + 1) ∧\n  -- For k=1, result equals sum of array\n  (k = 1 → result = List.sum arr) ∧\n  -- For array of all 1s, result equals n-k+1\n  ((∀ x ∈ arr, x = 1) → result = n - k + 1) :=\n  sorry\n\ntheorem solve_equals_manual_count\n  (arr : List Nat)\n  (n k : Nat) \n  (h1 : ∀ x ∈ arr, x ≤ 1)\n  (h2 : k ≤ n)\n  (h3 : n = arr.length)\n  (h4 : n > 0) :\n  solve arr n k = countWindows arr n k :=\n  sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval solve [1, 1, 0, 1] 4 2\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve [1, 1, 1] 3 2\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval solve [1, 1, 1, 1, 1, 0, 1, 1, 1, 1] 10 3", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0622", "language": "lean", "source": "fvapps", "source-id": "fvapps_000622", "source-notes": "", "vc-description": "/-\nA key feature of the Siruseri railway network is that it has exactly one route between any pair of stations.\nThe government has chosen three contractors to run the canteens at the stations on the railway network. To ensure that there are no disputes between the contractors it has been decided that if two stations, say $A$ and $B$, are assigned to a particular contractor then all the stations that lie on the route from $A$ to $B$ will also be awarded to the same contractor.\nThe government would like the assignment of stations to the contractors to be as equitable as possible. The government has data on the number of passengers who pass through each station each year. They would like to assign stations so that the maximum number of passengers passing through any contractor's collection of stations is minimized.\nFor instance, suppose the railway network is as follows, where the volume of passenger traffic is indicated by the side of each station.\n\nOne possible assignment would to award stations $1$ and $3$ to one contractor (there by giving him a traffic of $35$ passengers), station $2$ to the second contractor (traffic of $20$) and stations $4, 5$ and $6$ to the third contractor (traffic of $100$). In this assignment, the maximum traffic for any one contractor is 100. On the other hand if we assigned stations $1, 2$ and $3$ to one contractor, station $4$ and $6$ to the second contractor and station $5$ to the third contractor the maximum traffic for any one contractor is $70$. You can check that you cannot do better. (The assignment $1$, $2$ and $3$ to one contractor, $4$ to the second contractor, and $5$ and $6$ to the third contractor has a lower value for the maximum traffic ($55$) but it is not a valid assignment as the route from $5$ to $6$ passes through $4$.)\n\n-----Input:-----\nThe first line of the input contains one integer $N$ indicating the number of railways stations in the network. The stations are numbered $1,2,..., N$. This is followed by $N$ lines of input, lines $2,3,...,N+1$, indicating the volume of traffic at each station. The volume of traffic at station $i$, $1 \\leq i \\leq N$, is given by a single integer in line $i+1$. The next $N-1$ lines of input, lines $N+2, N+3, ..., 2 \\cdot N$, describe the railway network. Each of these lines contains two integers, denoting a pair of stations that are neighbours.\n\n-----Output:-----\nThe output should be a single integer, corresponding to the minimum possible value of the maximum traffic of any contractor among all valid assignment of the stations to the three contractors.\n\n-----Constraints:-----\n- $1 \\leq N \\leq 3000$.\n\n-----Sample Input-----\n6\n10\n20\n25\n40\n30\n30\n4 5\n1 3\n3 4\n2 3\n6 4\n\n-----Sample Output-----\n70\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | x :: xs => x + xs.sum\n\ndef find_min_max_traffic (n: Nat) (traffic: List Nat) (edges: List (Nat × Nat)) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def abs (n : Nat) : Nat :=\n  n", "vc-theorems": "theorem min_max_traffic_bounds {n: Nat} {traffic: List Nat} {edges: List (Nat × Nat)}\n  (h₁: n ≥ 3)\n  (h₂: traffic.length = n)\n  (h₃: edges.length = n - 1) :\n  let result := find_min_max_traffic n traffic edges\n  result ≤ traffic.sum ∧ \n  result ≥ Option.get! (List.maximum? traffic) ∧\n  result * 3 ≥ traffic.sum := by\n  sorry\n\ntheorem min_max_traffic_symmetric {n: Nat} {traffic: List Nat} {edges: List (Nat × Nat)} \n  (h₁: n ≥ 3)\n  (h₂: traffic.length = n)\n  (h₃: edges.length = n - 1) :\n  let reversed_edges := edges.map (fun (e: Nat × Nat) => (e.2, e.1))\n  find_min_max_traffic n traffic edges = find_min_max_traffic n traffic reversed_edges := by\n  sorry\n\ntheorem min_max_traffic_balanced_line {n: Nat}\n  (h: n ≥ 3) :\n  let traffic := List.replicate n 100\n  let edges := (List.range (n-1)).map (fun i => (i+1, i+2))\n  let result := find_min_max_traffic n traffic edges\n  let expected := (n * 100) / 3\n  abs (result - expected) ≤ 100 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0625", "language": "lean", "source": "fvapps", "source-id": "fvapps_000625", "source-notes": "", "vc-description": "/-\nThere are $N$ friends in a group. Each of them have $A_{i}$ candies.\nCan they share all of these candies among themselves such that each one of them have equal no. of candies.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- First line of each testcase contains of a single line of input, an integer $N$ denoting no. of friends in the group. \n- Next line contains $N$ space separated integers $A_{i}$  denoting the no. candies  $i^{th}$ friend has.\n\n-----Output:-----\nFor each testcase, output $\"Yes\"$ if it is possible to share equally else $\"No\"$ (without \" \").\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 100$\n- $0 \\leq A_{i} \\leq 1000$\n\n-----Sample Input:-----\n1\n\n3\n\n1 2 3\n\n-----Sample Output:-----\nYes\n\n-----EXPLANATION:-----\nEach of them have $2$ candies after sharing.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n| [] => 0\n| (h :: t) => h + sum t", "vc-helpers": "", "vc-definitions": "def can_share_candies (n_friends : Nat) (candies : List Nat) : String := sorry\n\ntheorem can_share_candies_valid_output (n_friends : Nat) (candies : List Nat) \n  (h1 : n_friends > 0) (h2 : candies.length > 0) :\n  (can_share_candies n_friends candies = \"Yes\" ∨ \n   can_share_candies n_friends candies = \"No\") := sorry", "vc-theorems": "theorem can_share_candies_yes_iff_divisible (n_friends : Nat) (candies : List Nat)\n  (h1 : n_friends > 0) (h2 : candies.length > 0) :\n  can_share_candies n_friends candies = \"Yes\" ↔ \n  (List.sum candies % n_friends = 0) := sorry\n\ntheorem single_friend_always_yes (candies : List Nat) (h : candies.length > 0) :\n  can_share_candies 1 candies = \"Yes\" := sorry\n\ntheorem zero_list_evenly_divisible (n_friends : Nat) (h : n_friends > 1) :\n  can_share_candies n_friends [0] = \"Yes\" := sorry\n\n/-\ninfo: 'Yes'\n-/\n-- #guard_msgs in\n-- #eval can_share_candies 3 [1, 2, 3]\n\n/-\ninfo: 'No'\n-/\n-- #guard_msgs in\n-- #eval can_share_candies 2 [1, 2]\n\n/-\ninfo: 'Yes'\n-/\n-- #guard_msgs in\n-- #eval can_share_candies 4 [2, 2, 2, 2]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0631", "language": "lean", "source": "fvapps", "source-id": "fvapps_000631", "source-notes": "", "vc-description": "/-\nChef is the event manager of his college. He has been assigned the task to manage the upcoming tech fest. There are $K$ rooms where the event can take place, and at a particular time only one event can be organized in a room for a particular time interval.\nEach event coordinator has their strictly preferred room $P_i$, and if the room is already occupied he simply cancels that event.Chef wants to maximize the total number of events,and so he allows or disallows certain events in order to achieve the task . Chef is busy handling his events so the chef needs your help .\nGiven a list of $N$ events with their start time $S_i$,end time $E_i$ and preferred room $P_i$,you need to calculate the maximum number of events that can take place.\nNote that the $i$th event wants to occupy the $p_i$ room from [$s_i$, $f_i$) .\n\n-----Input:-----\nThe first line contains an integer $T$ denoting the number of test cases . Each of the next $T$ lines contains two integers $N$ and $K$ , the number of events and the number of rooms respectively . Each of the next $N$ lines contains three integers $s_i$ ,$e_i$ and $p_i$,the start time ,end time and the preferred room of ith event.\n\n-----Output:-----\nPrint the maximum number of events that can take place.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq N \\leq 10^3$\n- $1 \\leq  K \\leq 10^5$\n- $1 \\leq  Si <  Ei \\leq 10^9$\n- $1 \\leq Pi \\leq K$\n\n-----Sample Input:-----\n1\n\n4 2\n1 10 1\n10 20 2\n15 50 2\n20 30 2\n\n-----Sample Output:-----\n3\n\n-----EXPLANATION:-----\nChef can allow events 1st ,2nd and 4th,to get the maximum 3.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_events (n k : Nat) (events : List Event) : Nat :=\n  sorry", "vc-theorems": "theorem solve_events_basic_properties {n k : Nat} {events : List Event}\n  (h1 : n > 0)\n  (h2 : k > 0)\n  (h3 : n ≤ 100)\n  (h4 : k ≤ 100)\n  (h5 : ∀ e ∈ events, e.room ≥ 1 ∧ e.room ≤ k)\n  (h6 : ∀ e ∈ events, e.start < e.stop)\n  (h7 : ∀ e ∈ events, e.start ≤ 10^5-1)\n  (h8 : ∀ e ∈ events, e.stop ≤ 10^5) :\n  let result := solve_events n k events\n  result ≥ 0 ∧ result ≤ events.length ∧ result ≤ n :=\n  sorry\n\ntheorem solve_events_empty (n k : Nat)\n  (h1 : n > 0)\n  (h2 : k > 0)\n  (h3 : n ≤ 100)\n  (h4 : k ≤ 100) :\n  solve_events n k [] = 0 :=\n  sorry\n\ntheorem solve_events_single (n k start duration : Nat)\n  (h1 : n > 0)\n  (h2 : k > 0)\n  (h3 : n ≤ 100)\n  (h4 : k ≤ 100)\n  (h5 : start > 0)\n  (h6 : start ≤ 10^5-1)\n  (h7 : duration > 0)\n  (h8 : duration ≤ 100) :\n  solve_events n k [{start := start, stop := start + duration, room := 1}] = 1 :=\n  sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval solve_events 4 2 [[1, 10, 1], [10, 20, 2], [15, 50, 2], [20, 30, 2]]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval solve_events 2 1 [[1, 5, 1], [2, 3, 1]]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval solve_events 3 2 [[1, 2, 1], [2, 3, 1], [1, 3, 2]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0632", "language": "lean", "source": "fvapps", "source-id": "fvapps_000632", "source-notes": "", "vc-description": "/-\nIn these quarantine days, Chef and Chefina are getting bored. So, Chef came up with a game for her. He gets a pack of cards with numbers written on them. Chef then asks her to remove cards from the pack in the following manner: Chefina can choose any 3 cards at a time, having unique values, and remove the smallest and largest of them, and put back the middle one. For example, say Chefina chooses 3 cards that have numbers $x$, $y$, $z$ on them, such that $x <= y <= z$. Then she can throw away cards with number $x$ and $z$, but has to put the card with number $y$ on it back into the pack. Chefina can repeat this process any number of times. As soon as the pack contains cards with unique numbers, the game ends. If Chefina can determine the count of cards that will remain in the end, and tell it to Chef beforehand, she wins the game. Chefina asks for your help to win this game. Given the number written on the cards, help her find the count of cards in the pack when she wins.\n$Note:$ You need to maximize the array length or the number of unique elements\n\n-----Input:-----\n- The first line of the input consists of a single integer $T$, denoting the number of test cases. Description of $T$ test cases follow.\n- The first line of each test case consists of a single integer $N$, denoting the number of cards in the pack\n- The next line consists of $N$ space separated numbers $A1$, $A2$ … $An$. For each valid $i (1 <= i <= N)$, the $i$-th card has the number $Ai$ written on it.\n\n-----Output:-----\n- For each test case, print the count of the cards that remain in the end.\n\n-----Constraints-----\n- $1 \\leq T \\leq 500$\n- $1 \\leq N \\leq 10^6$\n- $1 \\leq Ai \\leq N$\n\n-----Subtasks-----\n- 30 points : $1 \\leq T \\leq 20$; $ 1 \\leq N \\leq 5*10^5$\n- 70 points : Original constraints\n\n-----Sample Input:-----\n2\n5\n1 2 2 3 5\n9\n1 2 2 3 3 5 8 8 9\n\n-----Sample Output:-----\n3\n5\n\n-----EXPLANATION:-----\nTest case 1:\nChefina chooses the cards with number: 2, 3, 5, throws away 2 & 5, and puts back 3. So, the pack now contains cards with numbers: 1, 2, 3. Since the pack contains cards with unique numbers only, these are the 3 final cards. \nTest case 2:\nChefina chooses the cards with number: 2, 3, 8, throws away 2 & 8,  and puts back 3. Now the pack contains cards with numbers: 1, 2, 3, 3, 5, 8, 9. Next, she chooses cards with number: 3, 5, 8 throws away 3 & 8, and puts back 5. Now the pack contains cards with number: 1, 2, 3, 5, 9. Since the pack contains cards with unique numbers only, these are the 5 final cards.\nNote: There might be multiple options to choose the 3 cards from the pack in any turn\n-/", "vc-preamble": "def List.sum (l : List Nat) : Nat :=\n  match l with \n  | [] => 0\n  | h :: t => h + sum t\n\ndef List.sort (l : List Nat) : List Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def solve_card_game (input : String) : Int :=\n  sorry", "vc-theorems": "theorem solve_card_game_upper_bound {n k : Nat} {cards : List Nat} \n  (h1 : k ≤ n) (h2 : cards.length = n) :\n  solve_card_game s!\"${n} ${k} ${cards}\" ≤ cards.sum :=\n  sorry\n\ntheorem solve_card_game_lower_bound {n k : Nat} {cards : List Nat}\n  (h1 : k ≤ n) (h2 : cards.length = n) :\n  solve_card_game s!\"${n} ${k} ${cards}\" ≥ (cards.sort.reverse.take k).sum :=\n  sorry\n\ntheorem solve_card_game_nonneg {n k : Nat} {cards : List Nat}\n  (h1 : k ≤ n) (h2 : cards.length = n) :\n  solve_card_game s!\"${n} ${k} ${cards}\" ≥ 0 :=\n  sorry\n\ntheorem solve_card_game_single_card {n : Nat} :\n  solve_card_game s!\"1 1 ${n}\" = n :=\n  sorry\n\ntheorem solve_card_game_invalid_empty :\n  solve_card_game \"\" = 0 :=\n  sorry\n\ntheorem solve_card_game_invalid_format :\n  solve_card_game \"a b c\" = 0 :=\n  sorry\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval solve_card_game \"4 2 1 2 3 4\"\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval solve_card_game test2\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval solve_card_game test3", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0633", "language": "lean", "source": "fvapps", "source-id": "fvapps_000633", "source-notes": "", "vc-description": "/-\nShubham recently learned the lexicographical order in strings.\n\nNow, he has two strings s1  and  s2  of the equal size and Shubham wants to compare those two strings lexicographically.\n\nHelp Shubham with the strings comparison.\n\nNote:\n\nLetters are case insensitive. \n\n-----Input-----\n\nFirst line contains a integer T denoting the number of test cases. Each test case contains two strings of equal size in two separate lines.\n\n-----Output-----\n\nFor each test case,\n\nIf s1 < s2, print \"first\".\n\nIf s1 > s2, print \"second\".\n\nIf s1=s2, print \"equal\".\n\nin separate lines.\n\n-----Constraints-----\n\n- 1 ≤ T ≤ 10^2\n- 1 ≤ Length of the string ≤ 500\n\n-----Example-----\nInput:\n2\nabc\nacb\nAB\nba\n\nOutput:\nfirst\nfirst\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def compare_strings (s1 s2 : String) : ComparisonResult := sorry\n\ntheorem compare_strings_reflexive (s : String) :\n  s.length > 0 → compare_strings s s = ComparisonResult.equal := sorry", "vc-theorems": "theorem compare_strings_inverse (s1 s2 : String) :\n  s1.length > 0 → s2.length > 0 →\n  match compare_strings s1 s2 with\n  | ComparisonResult.first => compare_strings s2 s1 = ComparisonResult.second\n  | ComparisonResult.second => compare_strings s2 s1 = ComparisonResult.first\n  | ComparisonResult.equal => compare_strings s2 s1 = ComparisonResult.equal\n  := sorry\n\ntheorem compare_strings_ascii_order (s1 s2 : String) :\n  s1.length > 0 → s2.length > 0 →\n  (if s1.take (min s1.length s2.length) < s2.take (min s1.length s2.length) then\n    compare_strings (s1.take (min s1.length s2.length)) (s2.take (min s1.length s2.length)) = ComparisonResult.first\n  else if s1.take (min s1.length s2.length) > s2.take (min s1.length s2.length) then  \n    compare_strings (s1.take (min s1.length s2.length)) (s2.take (min s1.length s2.length)) = ComparisonResult.second\n  else\n    compare_strings (s1.take (min s1.length s2.length)) (s2.take (min s1.length s2.length)) = ComparisonResult.equal)\n  := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0636", "language": "lean", "source": "fvapps", "source-id": "fvapps_000636", "source-notes": "", "vc-description": "/-\nChef had a sequence of positive integers with length $N + K$. He managed to calculate the arithmetic average of all elements of this sequence (let's denote it by $V$), but then, his little brother deleted $K$ elements from it. All deleted elements had the same value.\nChef still knows the remaining $N$ elements — a sequence $A_1, A_2, \\ldots, A_N$. Help him with restoring the original sequence by finding the value of the deleted elements or deciding that there is some mistake and the described scenario is impossible.\nNote that the if it is possible for the deleted elements to have the same value, then it can be proven that it is unique. Also note that this value must be a positive integer.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains three space-separated integers $N$, $K$ and $V$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the value of the deleted elements, or $-1$ if there is a mistake.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le N, K \\le 100$\n- $1 \\le V \\le 10^5$\n- $1 \\le A_i \\le 10^5$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (100 points): original constraints\n\n-----Example Input-----\n3\n3 3 4\n2 7 3\n3 1 4\n7 6 5\n3 3 4\n2 8 3\n\n-----Example Output-----\n4\n-1\n-1\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def find_deleted_value (n k v : Nat) (arr : List Nat) : Int :=\nsorry", "vc-theorems": "theorem find_deleted_value_output_valid {n k v : Nat} {arr : List Nat} :\n  let result := find_deleted_value n k v arr\n  result = -1 ∨ result > 0 :=\nsorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval find_deleted_value 3 3 4 [2, 7, 3]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval find_deleted_value 3 1 4 [7, 6, 5]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval find_deleted_value 3 3 4 [2, 8, 3]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0638", "language": "lean", "source": "fvapps", "source-id": "fvapps_000638", "source-notes": "", "vc-description": "/-\nYou will be given a two-dimensional array with row consisting values 0 or 1.  \nA move consists of choosing any column or row, and toggling all the 0’s as 1’s and 1’s as 0’s.  \nAfter making the required moves, every row represents a binary number and the score of the matrix will be sum of all the numbers represented as binary numbers in each row.  \nFind the highest possible score.  \n$Example:$ \nInput:\n\n0 0 1 1\n\n1 0 1 0\n\n1 1 0 0  \nOutput:\n\n39\nExplanation:\n\nToggled to\n\n1 1 1 1\n\n1 0 0 1\n\n1 1 1 1  \n0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n\n-----Input:-----\n- First line will contains $m$, $n$ for the size of the 2-D array. \n- Contains $m$ lines of $n$ space-separated values each. \n\n-----Output:-----\nSingle integer which is the maximum score obtained by the sum of binary numbers.\n\n-----Constraints-----\n- $1 \\leq m, n \\leq 20$\n- $A[i][j] = 1$ or $0$ \n\n-----Sample Input:-----\n3 4  \n0 0 1 1  \n1 0 1 0  \n1 1 0 0  \n\n-----Sample Output:-----\n39\n-/", "vc-preamble": "def matrix_score (m : BinaryMatrix) : Nat :=\n  sorry\n\n-- Define helper function to check if first element of each row is 1", "vc-helpers": "", "vc-definitions": "def allFirstOne (m : BinaryMatrix) : Bool :=\n  sorry", "vc-theorems": "theorem matrix_score_positive (m : BinaryMatrix) : \n  matrix_score m > 0 := \n  sorry\n\ntheorem matrix_score_bounded_above {rows cols : Nat} (m : BinaryMatrix)\n  (h1 : m.length = rows) (h2 : ∀ r, r ∈ m → r.length = cols) :\n  matrix_score m ≤ ((2^cols) - 1) * rows := \n  sorry\n\ntheorem matrix_score_bounded_below {rows cols : Nat} (m : BinaryMatrix)\n  (h1 : m.length = rows) (h2 : ∀ r, r ∈ m → r.length = cols) :\n  matrix_score m ≥ 2^(cols-1) * rows :=\n  sorry\n\ntheorem matrix_score_idempotent (m : BinaryMatrix) :\n  matrix_score m = matrix_score m :=\n  sorry\n\n-- Helper theorem to ensure matrix elements are binary\n\ntheorem matrix_elements_binary (m : BinaryMatrix) :\n  ∀ r ∈ m, ∀ x ∈ r, x = 0 ∨ x = 1 :=\n  sorry\n\n/-\ninfo: 39\n-/\n-- #guard_msgs in\n-- #eval matrix_score [[0, 0, 1, 1], [1, 0, 1, 0], [1, 1, 0, 0]]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval matrix_score [[0]]\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval matrix_score [[1, 1], [1, 1], [0, 0]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0640", "language": "lean", "source": "fvapps", "source-id": "fvapps_000640", "source-notes": "", "vc-description": "/-\nBinod is a youtuber and he is busy in the fame of social media so he asked you to help him solve a problem.\nYou have been given an array of $positive$ $integers$ $a_{1},a_{2},a_{3},...,a_{i},...,a_{n}$ of size n.You have to find the smallest length of the subarray such that the length of the subarray must be $strictly$ greater than k and it's sum also must be $strictly$ greater than s. \n\n-----Input Format :------\n- The first line of input contains three space-separated integers n, k and s\n- The second line contains n space-separated integers,describing the array a \n\n-----Output Format:-----\n- Print a single integer :- The smallest length of subarray if exists, Otherwise print \"-1\" (without quotes) \n\n-----Constraints:------\n- $1 \\leq n, k \\leq 10^{6}$\n- $1 \\leq  a_{1},a_{2},a_{3},...,a_{i},...,a_{n}\\leq 10^{9}$ \n- $1 \\leq s \\leq 10^{15}$ Subtask #1 (30 points):\n- $1 \\leq n, k \\leq 10^{3}$ Subtask #2 (70 points):\n$Original$ $Constraints$ \n\n-----Sample Test Cases:------\n\n-----Example 1:-----\n5 1 5\n\n1 2 3 4 5 \n\n-----Output :-----\n2 \n\n-----Explanation-----\n$\\textbf{There are two possibles answers} :$ \n- Index starts at 3 and ends at 4 have a sum of 7 which is strictly greater than 5 and has a length of subarray greater than 1.  \n- Index starts at 4 and ends at 5 have a sum of 9 which is strictly greater than 5 and has a length of subarray greater than 1.\nAny of the possible scenarios gives the same answer.\n\n-----Example 2:-----\n3 2 1\n\n9 9 1 \n\n-----Output :-----\n3\n\n-----Explanation :-----\n- Each value in array index satisfies the condition sum greater than 1 but to satisfy the condition of length greater than 2 choose the subarray of length 3\n-/", "vc-preamble": "def List.sum : List Int → Int \n  | [] => 0\n  | x::xs => x + sum xs \n\ndef find_subarray_length (n : Nat) (k : Nat) (s : Int) (arr : List Int) : Int :=\nsorry", "vc-helpers": "", "vc-definitions": "def Int.abs (i : Int) : Int :=\n  if i < 0 then -i else i", "vc-theorems": "theorem subarray_length_n_leq_k {n k : Nat} {s : Int} {arr : List Int} \n  (h : n ≤ k) : \n  find_subarray_length n k s arr = -1 := \nsorry\n\ntheorem subarray_length_valid {n k : Nat} {s : Int} {arr : List Int}\n  (h : find_subarray_length n k s arr ≠ -1) :\n  find_subarray_length n k s arr > k := \nsorry\n\ntheorem exists_subarray_sum {n k : Nat} {s : Int} {arr : List Int}\n  (h : find_subarray_length n k s arr ≠ -1) :\n  ∃ i : Nat, i + find_subarray_length n k s arr ≤ n ∧ \n    (List.sum (List.take (find_subarray_length n k s arr).toNat (List.drop i arr)) > s) :=\nsorry\n\ntheorem no_smaller_length {n k : Nat} {s : Int} {arr : List Int} \n  (h : find_subarray_length n k s arr ≠ -1)\n  (len : Nat)\n  (h1 : k < len)\n  (h2 : len < (find_subarray_length n k s arr).toNat) :\n  ∀ i : Nat, i + len ≤ n → \n    List.sum (List.take len (List.drop i arr)) ≤ s :=\nsorry\n\ntheorem positive_arr_negative_s {n k : Nat} {s : Int} {arr : List Int}\n  (h1 : ∀ x ∈ arr, 0 ≤ x)\n  (h2 : s < 0)\n  (h3 : n > k) :\n  find_subarray_length n k s arr = k + 1 :=\nsorry\n\ntheorem sum_too_high {n k : Nat} {s : Int} {arr : List Int}\n  (h : s > List.sum (List.map Int.abs arr)) :\n  find_subarray_length n k s arr = -1 :=\nsorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval find_subarray_length 5 1 5 [1, 2, 3, 4, 5]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval find_subarray_length 3 2 1 [9, 9, 1]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval find_subarray_length 4 3 100 [1, 2, 3, 4]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0657", "language": "lean", "source": "fvapps", "source-id": "fvapps_000657", "source-notes": "", "vc-description": "/-\nThere is an event in DUCS where boys get a chance to show off their skills to impress girls. The boy who impresses the maximum number of girls will be honoured with the title “Charming Boy of the year”.\nThere are $N$ girls in the department. Each girl gives the name of a boy who impressed her the most. You need to find the name of a boy who will be honoured with the title. \nIf there are more than one possible winners, then the one with the lexicographically smallest name is given the title. \nIt is guaranteed that each boy participating in the event has a unique name.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows. \n- The first line of each test case contains an integer $N$ denoting the number of girls.\n- The second line contains $N$ space-separated strings $S_1, S_2, \\ldots, S_N$, denoting the respective names given by the girls.\n\n-----Output-----\nFor each test case, print a single line containing a string — the name of the boy who impressed the maximum number of girls. In case of a tie, print the lexicographically smallest name.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq N \\leq 10^5$\n- $1 \\leq |S_i| \\leq 10$, for each valid $i$\n$(|S_i|$ is the length of the string $S_i)$\n- For each valid $i$, $S_i$ contains only lowercase English alphabets\n- Sum of $N$ over all the test cases is $\\leq 10^6$\n\n-----Subtasks-----\n- 30 points: $1 \\leq N \\leq 100$\n- 70 points: original constraints\n\n-----Sample Input-----\n2\n\n10\n\njohn berry berry thomas thomas john john berry thomas john\n\n4\n\nramesh suresh suresh ramesh   \n\n-----Sample Output-----\njohn\n\nramesh\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_charming_boy (n : Nat) (votes : List String) : String :=\n  sorry", "vc-theorems": "theorem find_charming_boy_in_votes (n : Nat) (votes : List String) :\n  votes ≠ [] → find_charming_boy n votes ∈ votes :=\n  sorry\n\ntheorem find_charming_boy_is_top_voted (n : Nat) (votes : List String) :\n  votes ≠ [] →\n  let result := find_charming_boy n votes \n  let count := votes.countP (· = result)\n  let max_count := (votes.map (λ v => votes.countP (· = v))).maximum?.get!\n  count = max_count :=\n  sorry\n\ntheorem find_charming_boy_is_lex_min (n : Nat) (votes : List String) :\n  votes ≠ [] →\n  let result := find_charming_boy n votes\n  let count := votes.countP (· = result)\n  ∀ v ∈ votes, votes.countP (· = v) = count → result ≤ v :=\n  sorry\n\ntheorem find_charming_boy_order_independent (n : Nat) (votes₁ votes₂ : List String) :\n  votes₁.length = n →\n  votes₂.length = n →\n  (∀ v, votes₁.countP (· = v) = votes₂.countP (· = v)) →\n  find_charming_boy n votes₁ = find_charming_boy n votes₂ :=\n  sorry\n\ntheorem find_charming_boy_duplicate_invariant (n : Nat) (votes : List String) :\n  votes.length = n →\n  find_charming_boy n votes = find_charming_boy (2*n) (votes ++ votes) :=\n  sorry\n\n/-\ninfo: 'john'\n-/\n-- #guard_msgs in\n-- #eval find_charming_boy 10 \"john berry berry thomas thomas john john berry thomas john\".split()\n\n/-\ninfo: 'ramesh'\n-/\n-- #guard_msgs in\n-- #eval find_charming_boy 4 \"ramesh suresh suresh ramesh\".split()\n\n/-\ninfo: 'andy'\n-/\n-- #guard_msgs in\n-- #eval find_charming_boy 5 \"andy bob bob andy charlie\".split()", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0658", "language": "lean", "source": "fvapps", "source-id": "fvapps_000658", "source-notes": "", "vc-description": "/-\nComputation of the date either previous or forthcoming dates is quiet easy. But it is quiet difficult to calculate the day from a particular given date. \nYou are required to find a day from a particular date given to you.\n\n-----Input-----\nIt consists of a single line entry consisting of date in format dd mm yyyy.\ni.e. the input line consists of the three numbers written in order followed by spaces.\nEg. Input for 18-12-1990 is be written as 18 12 1990\n\n-----Output-----\nIt consists of single line output showing the day for that particular date.\n\n-----Example-----\nInput:\n14 3 2012\n\nOutput:\nWednesday\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValidDate (d : Date) : Bool := sorry\n\ndef get_day_for_date (day month year : Nat) : Option Weekday := sorry", "vc-theorems": "theorem get_day_for_date_valid_output \n  {day month year : Nat}\n  (h1: 1 ≤ day ∧ day ≤ 31)\n  (h2: 1 ≤ month ∧ month ≤ 12) \n  (h3: 1 ≤ year ∧ year ≤ 9999)\n  (h4: isValidDate ⟨day, month, year⟩ = true) :\n  ∃ w : Weekday, get_day_for_date day month year = some w :=\nsorry\n\ntheorem get_day_for_date_invalid_dates :\n  get_day_for_date 31 2 2023 = none :=\nsorry\n\ntheorem get_day_for_date_invalid_zero\n  {day month year : Nat}\n  (h1: day = 0 ∨ month = 0) :\n  get_day_for_date day month year = none :=\nsorry\n\n/-\ninfo: 'Wednesday'\n-/\n-- #guard_msgs in\n-- #eval get_day_for_date 14 3 2012\n\n/-\ninfo: 'Saturday'\n-/\n-- #guard_msgs in\n-- #eval get_day_for_date 1 1 2000\n\n/-\ninfo: 'Monday'\n-/\n-- #guard_msgs in\n-- #eval get_day_for_date 25 12 2023", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0673", "language": "lean", "source": "fvapps", "source-id": "fvapps_000673", "source-notes": "", "vc-description": "/-\nThere is crazy man named P29892P. He always tries to do crazy things as he thinks. One day he invented a machine and named it as ANGEN. The ANGEN is used to perform range operations. The range operation means performing operations on range values from {L..R}. At any time it performs operations on values in between L to R.\nANGEN can perform following operations\nU I V - Update the value present at I  with value V\nA L R - Find the sum between range L and R\nM L R - Find the maximum number between L and R\nm L R - Find the minimum number between L and R\nS L R - Find second maximum value in between L and R\ns L R - Find second mimimum value in between L and R\nIf it is not possible perform operation ANGEN returns “NA” with out quotes.\nFor Invalid operations ANGEN returns “!!!” with out quotes.\nNow P29892P challenging his friends and you too, to build his invention with yourown code. So it's your time to defeat P29892P by implementing his invention with your own ability. Let's go and solve the problem.\n\n-----Input-----\nInput description.\n- The first line of the input contains an integer N denoting the number of integers. \n- The next line contains N space separated integers.\"\n- The next line contains a single integer Q denoting the number of Questions.\n-  The next Q lines contains T Question type , L and R.\n\n-----Output-----\nPrint output for each question in separate line.\n\n-----Constraints-----\nShould contain all the constraints on the input data that you may have. Format it like:\n- 1 ≤ N ≤ 100000\n- 1 ≤ values[i] ≤ 1000000000\n- 1 ≤ Q ≤ 10000\n- T in { A..Z, a..z }\n- 1 ≤ L ≤ R ≤ N\n\n-----Example-----\nInput:\n6\n1 2 5 3 10 6\n6\nA 1 5\nM 1 3\nm 5 6\ns 3 6\nU 1 7\nS 1 2\n\nOutput:\n21\n5\n6\n5\n2\n\n-----Explanation-----\n...\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def process_angen_operations (nums: List Int) (operations: List (Char × String × String)) : List String :=\n  sorry", "vc-theorems": "theorem process_operations_basic_props \n  (nums: List Int) \n  (operations: List (Char × String × String))\n  (h1: nums.length ≥ 1)\n  (h2: ∀ op ∈ operations, \n    (toString op.1 = \"U\" ∨ toString op.1 = \"A\" ∨ toString op.1 = \"M\" ∨ \n     toString op.1 = \"m\" ∨ toString op.1 = \"S\" ∨ toString op.1 = \"s\") ∧\n    ((String.toNat! op.2.1) ≤ nums.length) ∧  \n    ((String.toNat! op.2.2) ≤ nums.length) ∧\n    ((String.toNat! op.2.1) ≤ (String.toNat! op.2.2))) :\n  let results := process_angen_operations nums operations\n  ∀ r ∈ results, r.length > 0 :=\nsorry\n\ntheorem process_operations_arithmetic \n  (nums: List Int)\n  (operations: List (Char × String × String))\n  (h1: nums.length ≥ 1)\n  (op: Char × String × String)\n  (h2: op ∈ operations)\n  (h3: op.1 = 'A' ∨ op.1 = 'M' ∨ op.1 = 'm') :\n  let l := (String.toNat! op.2.1) - 1\n  let r := String.toNat! op.2.2\n  let subarray := nums.take r |>.drop l\n  let result := (process_angen_operations nums operations)[operations.indexOf op]!\n  match op.1 with\n  | 'A' => result = toString (subarray.foldl (· + ·) 0)\n  | 'M' => result = toString (List.maximum? subarray |>.get!)\n  | 'm' => result = toString (List.minimum? subarray |>.get!)\n  | _ => True :=\nsorry\n\ntheorem process_invalid_operations\n  (nums: List Int)\n  (operations: List (Char × String × String))\n  (h1: nums.length ≥ 1)\n  (h2: ∀ op ∈ operations, \n    op.1 ≠ 'U' ∧ op.1 ≠ 'A' ∧ op.1 ≠ 'M' ∧ \n    op.1 ≠ 'm' ∧ op.1 ≠ 'S' ∧ op.1 ≠ 's') :\n  let results := process_angen_operations nums operations\n  ∀ r ∈ results, r = \"!!!\" :=\nsorry\n\ntheorem process_second_extremes\n  (nums: List Int)\n  (operations: List (Char × String × String))\n  (h1: nums.length ≥ 1) \n  (op: Char × String × String)\n  (h2: op ∈ operations)\n  (h3: op.1 = 'S' ∨ op.1 = 's')\n  (h4: (String.toNat! op.2.1) ≤ nums.length)\n  (h5: (String.toNat! op.2.2) ≤ nums.length)\n  (h6: (String.toNat! op.2.1) ≤ (String.toNat! op.2.2)) :\n  let l := (String.toNat! op.2.1) - 1\n  let r := String.toNat! op.2.2\n  let subarray := nums.take r |>.drop l\n  let result := (process_angen_operations nums operations)[operations.indexOf op]!\n  (List.length subarray < 2 → result = \"NA\") ∧\n  (List.length subarray ≥ 2 →\n    match op.1 with\n    | 's' => result.toInt? |>.map (λ x => x ≥ (List.minimum? subarray |>.get!)) |>.getD false\n    | 'S' => result.toInt? |>.map (λ x => x ≤ (List.maximum? subarray |>.get!)) |>.getD false\n    | _ => True) :=\nsorry\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval process_angen_operations [1, 2, 5, 3, 10, 6] [(\"A\", \"1\", \"5\"), (\"M\", \"1\", \"3\"), (\"m\", \"5\", \"6\"), (\"s\", \"3\", \"6\"), (\"U\", \"1\", \"7\"), (\"S\", \"1\", \"2\")]\n\n/-\ninfo: ['!!!']\n-/\n-- #guard_msgs in\n-- #eval process_angen_operations [1, 2, 3] [(\"X\", \"1\", \"2\")]\n\n/-\ninfo: ['NA']\n-/\n-- #guard_msgs in\n-- #eval process_angen_operations [1, 1, 1] [(\"s\", \"1\", \"3\")]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0680", "language": "lean", "source": "fvapps", "source-id": "fvapps_000680", "source-notes": "", "vc-description": "/-\nChef wants to host some Division-3 contests. Chef has $N$ setters who are busy creating new problems for him. The $i^{th}$ setter has made $A_i$ problems where $1 \\leq i \\leq N$.    \nA Division-3 contest should have exactly $K$ problems. Chef wants to plan for the next $D$ days using the problems that they have currently. But Chef cannot host more than one Division-3 contest in a day.\nGiven these constraints, can you help Chef find the maximum number of Division-3 contests that can be hosted in these $D$ days?\n\n-----Input:-----\n- The first line of input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains three space-separated integers - $N$, $K$ and $D$ respectively.\n- The second line of each test case contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$ respectively. \n\n-----Output:-----\nFor each test case, print a single line containing one integer ― the maximum number of Division-3 contests Chef can host in these $D$ days.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^3$\n- $1 \\leq N \\leq 10^2$\n- $1 \\le K \\le 10^9$ \n- $1 \\le D \\le 10^9$\n- $1 \\le A_i \\le 10^7$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (40 points):\n- $N = 1$\n- $1 \\le A_1 \\le 10^5$\nSubtask #2 (60 points): Original constraints\n\n-----Sample Input:-----\n5\n1 5 31\n4\n1 10 3\n23\n2 5 7\n20 36\n2 5 10\n19 2\n3 3 300\n1 1 1\n\n-----Sample Output:-----\n0\n2\n7\n4\n1\n\n-----Explanation:-----\n- \nExample case 1: Chef only has $A_1 = 4$ problems and he needs $K = 5$ problems for a Division-3 contest. So Chef won't be able to host any Division-3 contest in these 31 days. Hence the first output is $0$.\n- \nExample case 2: Chef has $A_1 = 23$ problems and he needs $K = 10$ problems for a Division-3 contest. Chef can choose any $10+10 = 20$ problems and host $2$ Division-3 contests in these 3 days. Hence the second output is $2$.\n- \nExample case 3: Chef has $A_1 = 20$ problems from setter-1 and $A_2 = 36$ problems from setter-2, and so has a total of $56$ problems. Chef needs $K = 5$ problems for each Division-3 contest. Hence Chef can prepare $11$ Division-3 contests. But since we are planning only for the next $D = 7$ days and Chef cannot host more than $1$ contest in a day, Chef cannot host more than $7$ contests. Hence the third output is $7$.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + sum xs", "vc-helpers": "", "vc-definitions": "def solve_division3_contests (N K D : Nat) (A : List Nat) : Nat := sorry\n\ntheorem result_bounded_by_D (N K D : Nat) (A : List Nat) (h1 : N ≥ 1) (h2 : K ≥ 1) (h3 : D ≥ 1) :\n  solve_division3_contests N K D A ≤ D := sorry", "vc-theorems": "theorem result_is_nonnegative (N K D : Nat) (A : List Nat) (h1 : N ≥ 1) (h2 : K ≥ 1) (h3 : D ≥ 1) :\n  solve_division3_contests N K D A ≥ 0 := sorry\n\ntheorem zero_days_gives_zero (N K : Nat) (A : List Nat) (h1 : N ≥ 1) (h2 : K ≥ 1) :\n  solve_division3_contests N K 0 A = 0 := sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval solve_division3_contests 1 5 31 [4]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve_division3_contests 1 10 3 [23]\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval solve_division3_contests 2 5 7 [20, 36]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0695", "language": "lean", "source": "fvapps", "source-id": "fvapps_000695", "source-notes": "", "vc-description": "/-\nIt's John's birthday; he has brought some candies in distribute among N of his friends. Being a good friend, he decided to distribute all of his candies equally among his friend and he don't want to keep any for himself. He left the task of distributing candies up to his friends, but his friends haven't done a great job in distributing them and now they all have unequal amount of candies.\nHe asked all of his friends to keep all the candies in their hands (A[1] to A[N]) so that he can redistribute the candies. Taking a candy away from someone makes them sad and makes the person who gets it happy. Thus, you do not want to do many operations on the number of candies.\nHere each operation stands for, taking away 1 candy from someone and giving it to somebody else.\nAfter applying the operations, he might not be able to distribute all the candies among all of your friends, and you might need to buy some more candies as well. Buying each candy will be counted as 1 operation as well. John is saving up for his birthday party in the evening and so he wants to spend the least amount of money on candies as possible.\nThus, he asks for your help. You have to find the minimum number of operations required to make the distributions equal.\n\n-----Input:-----\n- The first line consists of the number T representing the number of test cases.\n- Each test case consists of 2 lines.\n- The first line contains of the number N representing the number of friends.\n- The second line contains space separated numbers (A[1] to A[N]) representing the number of candies each friend currently has.\n\n-----Output:-----\nFor each test case, you much print the minimum number of operations.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 10^5$\n- $0 \\leq A[i] \\leq 10^9$\n\n-----Sample Input:-----\n3\n\n4\n\n7 8 6 4\n\n6\n\n7 3 10 2 3 8\n\n1\n\n10   \n\n-----Sample Output:-----\n4\n\n10\n\n0\n-/", "vc-preamble": "def List.sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum xs\n\ninductive Perm {α : Type} : List α → List α → Prop where\n  | nil : Perm [] []\n  | cons : ∀ (x : α) (l₁ l₂ : List α), Perm l₁ l₂ → Perm (x::l₁) (x::l₂)\n  | swap : ∀ (x y : α) (l : List α), Perm (x::y::l) (y::x::l)\n  | trans : ∀ {l₁ l₂ l₃ : List α}, Perm l₁ l₂ → Perm l₂ l₃ → Perm l₁ l₃", "vc-helpers": "", "vc-definitions": "def calc_min_operations (n : Nat) (candies : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem single_box_zero_ops {val : Nat} :\n  calc_min_operations 1 [val] = 0 :=\nsorry\n\ntheorem min_ops_nonnegative {n : Nat} (candies : List Nat) :\n  calc_min_operations n candies ≥ 0 :=\nsorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval calc_min_operations 4 [7, 8, 6, 4]\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval calc_min_operations 6 [7, 3, 10, 2, 3, 8]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval calc_min_operations 1 [10]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0699", "language": "lean", "source": "fvapps", "source-id": "fvapps_000699", "source-notes": "", "vc-description": "/-\nThe chef is trying to decode some pattern problems, Chef wants your help to code it. Chef has one number K to form a new pattern. Help the chef to code this pattern problem.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, one integer $K$. \n\n-----Output:-----\nFor each test case, output as the pattern.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq K \\leq 10$\n\n-----Sample Input:-----\n4\n1\n2\n3\n4\n\n-----Sample Output:-----\n0 \n0 \n1 1 \n0 \n1 1 \n2 3 5 \n0 \n1 1 \n2 3 5 \n8 13 21 34  \n\n-----EXPLANATION:-----\nNo need, else pattern can be decode easily.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pattern_sequence (k: Nat) : String := sorry\n\ndef parseInts (s: String) : List Int := \n  (s.splitOn \" \").filterMap String.toInt?", "vc-theorems": "theorem pattern_sequence_line_count {k: Nat} (hk: k > 0) :\n  ((pattern_sequence k).splitOn \"\\n\").length = k := sorry\n\ntheorem pattern_sequence_numbers_per_line {k: Nat} (hk: k > 0) :\n  let lines := (pattern_sequence k).splitOn \"\\n\"\n  ∀ i : Nat, i < lines.length → \n  ((lines[i]!).splitOn \" \").length = i.succ := sorry\n\ntheorem pattern_sequence_valid_ints {k: Nat} (hk: k > 0) :\n  let lines := (pattern_sequence k).splitOn \"\\n\"\n  ∀ line ∈ lines,\n  ∀ num ∈ line.splitOn \" \",\n  String.toInt? num ≠ none := sorry\n\ntheorem pattern_sequence_fibonacci {k: Nat} (hk: k > 0) :\n  let lines := (pattern_sequence k).splitOn \"\\n\"\n  let nums := lines.bind (λ line => parseInts line)\n  ∀ i, i ≥ 2 → i < nums.length →\n    nums[i]! = nums[i-1]! + nums[i-2]! := sorry\n\n/-\ninfo: '0'\n-/\n-- #guard_msgs in\n-- #eval pattern_sequence 1\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval pattern_sequence 2\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval pattern_sequence 3", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0711", "language": "lean", "source": "fvapps", "source-id": "fvapps_000711", "source-notes": "", "vc-description": "/-\nEvery Friday Chef and his N - 1 friends go for a party. At these parties, they play board games. This Friday, they are playing a game named \"Boats! Boats! Boats!\". In this game players have to transport cookies between Venice and Constantinople. Each player has a personal storage. The players are numbered from 1 to N, Chef is numbered 1. Rules for determining a winner are very difficult, therefore Chef asks you to write a program, which will determine who is a winner. \n\nThere are 6 types of cookies. For each cookie in the storage player gets 1 point. Also player gets additional points if he packs his cookies in some boxes as follows: \n\n- A box containing 4 different types of cookies fetches 1 additional point.\n- A box containing 5 different types of cookies fetches 2 additional points.\n- A box containing 6 different types of cookies fetches 4 additional points.\n\nObviously a cookie can be put into a single box.\n\nFor each player, you know the number of cookies in his storage (denoted by c[i]), also the types of cookies in the storage given denoted by type[i][j].\n\nYour task is to determine the winner of this game. Output \"tie\" if there are two or more players with same maximum score, \"chef\" if only Chef has a maximum score, winner's index in all other cases.\n\n-----Input-----\n\nThe first line of input contains a single integer T denoting the number of test cases. This will be followed by T test cases.\nThe first line of each test case contains an integer N denoting the number of players.\nThe second line of each test case contains an integer c[i] denoting the number of cookies in the i-th storage, followed by c[i] space-separated integers type[i][j] which denote the type if j-th cookie in the storage i-th.\n\n-----Output-----\nFor each test case, output a single line containing the answer as specified in the statement.\n\n-----Constraints and Subtasks-----Subtask #1 : (20 points)  \n\n- 1 ≤ T ≤ 10 \n- 1 ≤  N  ≤ 100  \n- 1 ≤  c[i]  ≤  100  \n- 1 ≤  type[i][j]  ≤  3   \nSubtask #2 : (80 points)  \n\n- 1 ≤ T ≤ 10 \n- 1 ≤  N  ≤ 100  \n- 1 ≤  c[i]  ≤  100  \n- 1 ≤  type[i][j]  ≤  6  \n\n-----Example-----\nInput:\n3\n2\n6 1 2 3 4 5 6\n9 3 3 3 4 4 4 5 5 5\n2\n5 2 3 4 5 6\n7 1 1 2 2 3 3 4\n3\n4 1 1 2 3\n4 1 2 2 3\n4 1 2 3 3\nOutput:\nchef\n2\ntie\n\n-----Explanation-----\nExample case 1.\nChef has total 6 cookie, so he gets 6 points for that. Also, he can put all his cookies (as they are all distinct) in a bag of size 6. It will fetch him additional 4 points. So, Chef's total points will be 10.\nThe second player has 9 cookies, he gets 9 points for that. Other than this, he can't create a bag with either 4, 5 or 6 distinct cookies. So, his final score is 9.\n10 > 9 - Chef wins.\nExample case 2.\nChef has 5 + 2 (a bag with 5 different cookies) = 7.\nThe second player has 7 + 1(a bag with 4 different cookies) = 8.\n7 < 8 - the second player wins.\nExample case 3.\nEvery player has 4 cookies and can't create any bag of sweets. So, it's a tie.\n-/", "vc-preamble": "def cookieStorageStr (num : Nat) (types : List Nat) : String := sorry\n\ndef determineWinner (n : Nat) (storages : List String) : String := sorry\n\nstructure ScoreData where\n  score: Nat\n  uniqueTypes: Nat", "vc-helpers": "", "vc-definitions": "def calculateScore (cookies : List Nat) : Nat :=\n  let score := cookies.head!\n  let types := cookies.tail!.eraseDups\n  let numTypes := types.length\n  match numTypes with\n  | n => if n ≥ 6 then score + 4\n         else if n ≥ 5 then score + 2\n         else if n ≥ 4 then score + 1\n         else score", "vc-theorems": "theorem winner_validity (n : Nat) (storages : List String) :\n  let result := determineWinner n storages\n  (result = \"tie\" ∨ result = \"chef\" ∨ result.toNat? ≠ none) ∧ \n  (result.toNat?.isSome → 1 ≤ result.toNat! ∧ result.toNat! ≤ n) := sorry\n\ntheorem winner_has_highest_score (n : Nat) (storages : List String) :\n  let result := determineWinner n storages\n  let scores := storages.map (λ s => \n    let cookies := (s.split (· = ' ')).map String.toNat!\n    calculateScore cookies)\n  let maxScore := scores.maximum?\n  match result with \n  | \"tie\" => maxScore.isSome ∧ (scores.filter (· = maxScore!)).length ≥ 2 \n  | \"chef\" => maxScore.isSome ∧ scores.head! = maxScore! ∧ \n              (scores.filter (· = maxScore!)).length = 1\n  | _ => maxScore.isSome ∧ \n         scores[result.toNat! - 1]! = maxScore! ∧\n         (scores.filter (· = maxScore!)).length = 1 := sorry\n\n/-\ninfo: 'chef'\n-/\n-- #guard_msgs in\n-- #eval determine_winner 2 [\"6 1 2 3 4 5 6\", \"9 3 3 3 4 4 4 5 5 5\"]\n\n/-\ninfo: '2'\n-/\n-- #guard_msgs in\n-- #eval determine_winner 2 [\"5 2 3 4 5 6\", \"7 1 1 2 2 3 3 4\"]\n\n/-\ninfo: 'tie'\n-/\n-- #guard_msgs in\n-- #eval determine_winner 3 [\"4 1 1 2 3\", \"4 1 2 2 3\", \"4 1 2 3 3\"]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0712", "language": "lean", "source": "fvapps", "source-id": "fvapps_000712", "source-notes": "", "vc-description": "/-\n-----Indian National Olympiad in Informatics 2014-----\nNikhil’s slogan has won the contest conducted by Drongo Airlines and he is entitled to a free ticket between any two destinations served by the airline. All cities served by Drongo Airlines can be reached from each other by some sequence of connecting flights. Nikhil is allowed to take as many connecting flights as needed, but he must take the cheapest route between his chosen destinations.\nEach direct flight between two cities has a fixed price. All pairs of cities connected by direct flights have flights in both directions and the price is the same in either direction. The price for a sequence of connecting flights is the sum of the prices of the direct flights along the route.\nNikhil has information about the cost of each direct flight. He would like to maximize the value of his prize, so he would like to choose a pair of cities on the network for which the cost of the cheapest route is as high as possible.\nFor instance, suppose the network consists of four cities {1, 2, 3, 4}, connected as shown on the right.\nIn this case, Nikhil should choose to travel between 1 and 4, where the cheapest route has cost 19. You can check that for all other pairs of cities, the cheapest route has a smaller cost. For instance, notice that though the direct flight from 1 to 3 costs 24, there is a cheaper route of cost 12 from 1 to 2 to 3.\n\n-----Input Format:-----\n- Line 1 : Two space-separated integers, C and F . C is the number of cities on the network, numbered 1, 2, . . . , C. F is the number of pairs of cities connected by a direct flight\n- Lines 2 to F + 1 : Each line describes one direct flight between a pair of cities and consists of three integers, x, y and p, where x and y are the two cities connected by this flight and p is the price of this\nFor all direct flights, $x \\neq y$, and no pair of cities is connected by more than one direct flight. If there is a direct flight from x to y with price p, there is also a flight from y to x with price p and exactly one of these two will be listed.\n\n-----Output Format-----\n- The output consists of a single integer, the maximum cost among the cheapest routes between all pairs of cities across the airline’s network.\n\n-----Test Data-----\nThe testdata is grouped into three subtasks. In all subtasks, 2 ≤ C ≤ 230 and 1 ≤ F ≤ 23665. In addition, each subtask has the following constraints on the inputs.\n- Subtask 1 (20 marks) : F = C − 1 (that is, the airline network is a tree) and p = 1 for each direct flight.\n- Subtask 2 (30 marks) : There is no constraint on the shape of the network, but for each direct flight, p = 1.\n- Subtask 3 (50 marks) : There is no constraint on the shape of the network, but for each direct flight, 0 ≤ p ≤ $10^5$.\n\n-----Sample Input-----\n4 5\n1 2 10\n1 3 24\n2 3 2\n2 4 15\n3 4 7\n\n-----Sample Output-----\n19\n\nNote: Your program should not print anything other than what is specified in the output format. Please remove all diagnostic print statements before making your final submission. A program with extraneous output will be treated as incorrect!\n-/", "vc-preamble": "def find_max_route_cost (n : Nat) (edges : List Edge) : Nat := sorry\n\ndef exists_path (edges : List Edge) (u v : Nat) : Bool := sorry", "vc-helpers": "", "vc-definitions": "def shortest_path_cost (edges : List Edge) (u v : Nat) : Nat := sorry\n\ntheorem small_graph_path_costs {n : Nat} {edges : List Edge} \n  (h1 : n = 3)\n  (h2 : ∀ e ∈ edges, e.src ≤ 3 ∧ e.dst ≤ 3)\n  (h3 : ∀ e ∈ edges, e.cost ≤ 100)\n  (h4 : edges.length ≤ 3)\n  (h5 : edges.length ≥ 2)\n  (h6 : ∀ e ∈ edges, e.src ≠ e.dst) :\n  ∀ u v : Nat, u < n → v < n → u ≠ v →\n    if exists_path edges u v then\n      shortest_path_cost edges u v ≤ find_max_route_cost n edges\n    else True := sorry", "vc-theorems": "theorem symmetry_property {n : Nat} {edges : List Edge}\n  (h1 : n = 3)\n  (h2 : ∀ e ∈ edges, e.src ≤ 3 ∧ e.dst ≤ 3)\n  (h3 : ∀ e ∈ edges, e.cost ≤ 100)\n  (h4 : edges.length ≤ 3)\n  (h5 : edges.length ≥ 2)\n  (h6 : ∀ e ∈ edges, e.src ≠ e.dst) :\n  find_max_route_cost n edges = \n  find_max_route_cost n (edges.map (λ e => ⟨e.dst, e.src, e.cost⟩)) := sorry\n\n/-\ninfo: 19\n-/\n-- #guard_msgs in\n-- #eval find_max_route_cost 4 [(1, 2, 10), (1, 3, 24), (2, 3, 2), (2, 4, 15), (3, 4, 7)]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval find_max_route_cost 4 [(1, 2, 1), (2, 3, 1), (3, 4, 1)]\n\n/-\ninfo: 15\n-/\n-- #guard_msgs in\n-- #eval find_max_route_cost 3 [(1, 2, 5), (2, 3, 10), (3, 1, 20)]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0728", "language": "lean", "source": "fvapps", "source-id": "fvapps_000728", "source-notes": "", "vc-description": "/-\nChef received a new sequence $A_1, A_2, \\ldots, A_N$. He does not like arbitrarily ordered sequences, so he wants to permute the elements of $A$ in such a way that it would satisfy the following condition: there is an integer $p$ ($1 \\le p \\le N$) such that the first $p$ elements of the new (permuted) sequence are strictly increasing and the last $N-p+1$ elements are strictly decreasing.\nHelp Chef and find a permutation of the given sequence which satisfies this condition or determine that no such permutation exists. If there are multiple solutions, you may find any one.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output-----\nFor each test case:\n- If there is no permutation of $A$ that satisfies the given condition, print a single line containing the string \"NO\" (without quotes).\n- Otherwise, print two lines.\n- The first of these lines should contain the string \"YES\" (without quotes).\n- The second line should contain $N$ space-separated integers ― the elements of your permuted sequence.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le N \\le 10^5$\n- $1 \\le A_i \\le 2 \\cdot 10^5$ for each valid $i$\n- the sum of $N$ over all test cases does not exceed $10^6$\n\n-----Subtasks-----\nSubtask #1 (50 points):\n- $N \\le 10^3$\n- $A_i \\le 2 \\cdot 10^3$ for each valid $i$\n- the sum of $N$ over all test cases does not exceed $10^4$\nSubtask #2 (50 points): original constraints\n\n-----Example Input-----\n5\n4\n1 3 2 4\n4\n1 3 2 4\n6\n1 10 10 10 20 15\n5\n1 1 2 2 3\n4\n1 2 3 3\n\n-----Example Output-----\nYES\n1 2 3 4\nYES\n4 3 2 1\nNO\nYES\n1 2 3 2 1\nNO\n-/", "vc-preamble": "def List.countElem (x : α) (xs : List α) [BEq α] : Nat :=\nxs.filter (· == x) |>.length\n\ndef List.uniqueElems (xs : List α) [BEq α] : List α :=\nxs.eraseDups", "vc-helpers": "", "vc-definitions": "def process_sequence (n : Nat) (arr : List Nat) : String × List Nat :=\nsorry", "vc-theorems": "theorem process_sequence_valid_result (n : Nat) (arr : List Nat) :\n  let (result, output) := process_sequence n arr\n  (result = \"YES\" ∨ result = \"NO\") ∧ output.length ≥ 0 :=\nsorry\n\ntheorem process_sequence_yes_properties (n : Nat) (arr : List Nat) \n  (h : arr.length > 0) (h2 : ∀ x ∈ arr, x > 0 ∧ x ≤ 1000) :\n  let (result, output) := process_sequence n arr\n  result = \"YES\" →\n  -- Length properties\n  output.length ≥ arr.uniqueElems.length ∧\n  -- Maximum occurs once\n  (let max := output.maximum?.getD 0\n   output.countElem max = 1) ∧\n  -- Each element occurs at most twice\n  (∀ x ∈ output, output.countElem x ≤ 2) ∧\n  -- First half unique\n  (let firstHalf := output.take (arr.uniqueElems.length)\n   firstHalf.uniqueElems.length = firstHalf.length) ∧\n  -- Second half descending\n  (let secondHalf := output.drop (arr.uniqueElems.length)\n   ∀ i < secondHalf.length - 1,\n     secondHalf[i]?.getD 0 ≥ secondHalf[i+1]?.getD 0) ∧\n  -- Input elements preserved\n  arr.uniqueElems.length = output.uniqueElems.length :=\nsorry\n\ntheorem process_sequence_no_properties (n : Nat) (arr : List Nat)\n  (h : arr.length > 0) (h2 : ∀ x ∈ arr, x > 0 ∧ x ≤ 1000) :\n  let (result, output) := process_sequence n arr\n  result = \"NO\" →\n  output = [] ∧\n  -- Any element occurs more than twice or max occurs more than once\n  (∃ x ∈ arr, arr.countElem x > 2) ∨\n  (let max := arr.maximum?.getD 0\n   arr.countElem max > 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0741", "language": "lean", "source": "fvapps", "source-id": "fvapps_000741", "source-notes": "", "vc-description": "/-\nSereja has a string A consisting of n lower case English letters. \n\nSereja calls two strings X and Y each of length n similar if they can be made equal by applying the following operation at most once in each of them.\n\n- Chose any two position i, j in the string (i can be equal to j too). Swap the characters at position i with character at position j.\n\nFor example strings \"abcd\" and \"acbd\" are similar, strings \"ab\" and \"ab\" are similar, but strings \"abcde\" and \"bcdea\" are not similar. Note that strings  \"abc\" and \"cab\" are also similar, as you can swap 'a' and 'c' in the first string to get \"cba\" and 'a' and 'b' in the second string to get \"cba\". \n\nNow Sereja is interested in finding number of ordered pairs of non similar strings X and Y such that they can be constructed from a given string A by permutation of its characters. As answer could be large, please output your answer modulo  (109 + 7).\n\nNote \n\nA string s (of size n) is said to be constructed from string t (also of size n) by permutation of its characters if there exists a permutation P (of length n), such that s[i] = t[P[i]] for each i from 1 to n.\n\n-----Input-----\n- First line contain integer T - number of test cases. \n- For each of the next T lines: \n\n- Each line contains a string A as defined in the problem.\n\n-----Output-----\nFor each test case, output answer modulo 1000000007 (109 + 7) in separate line. \n\n-----Constraints-----\n- 1 ≤ T ≤  10 \n- 1 ≤ n ≤  10^5 \n\n-----Constraints-----\n- Subtask #1: 1 ≤ n ≤  10  (25 points)\n- Subtask #2: 1 ≤ n ≤  100  (25 points)\n- Subtask #3: 1 ≤ n ≤  1000  (25 points)\n- Subtask #4: original constraints (25 points)\n\n-----Example-----\nInput:\n2\nz\nabcd\n\nOutput:\n0\n144\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_string_similarity (s : String) : Nat :=\n  if s.length = 0 then panic! \"Empty string not allowed\"\n  else sorry", "vc-theorems": "theorem solve_string_similarity_non_negative {s : String} (h : s.length > 0) : \n  solve_string_similarity s ≥ 0 := by sorry\n\ntheorem solve_string_similarity_bounded {s : String} (h : s.length > 0) :\n  solve_string_similarity s < 10^9 + 7 := by sorry\n\ntheorem single_char_string {s : String} (h1 : s.length = 1) :\n  solve_string_similarity s = 0 := by sorry\n\ntheorem same_char_string {s : String} (h1 : s.length > 0) \n  (h2 : ∀ (i j : String.Pos), s.get i = s.get j) :\n  solve_string_similarity s = 0 := by sorry\n\ntheorem repeated_char_string (n : Nat) (h : n > 0) :\n  solve_string_similarity (String.mk (List.replicate n 'a')) = 0 := by sorry\n\ntheorem alternating_string_bounded (n : Nat) (h : 0 < n) :\n  let s := String.mk (List.join (List.replicate n ['a', 'b']))\n  0 ≤ solve_string_similarity s ∧ solve_string_similarity s < 10^9 + 7 := by sorry\n\ntheorem unique_chars_bounded (n : Nat) (h : 0 < n) :\n  let s := String.mk (List.map (fun i => Char.ofNat (Char.toNat 'a' + i)) (List.range n))\n  0 ≤ solve_string_similarity s ∧ solve_string_similarity s < 10^9 + 7 := by sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval solve_string_similarity \"z\"\n\n/-\ninfo: 144\n-/\n-- #guard_msgs in\n-- #eval solve_string_similarity \"abcd\"\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval solve_string_similarity \"aaaa\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0743", "language": "lean", "source": "fvapps", "source-id": "fvapps_000743", "source-notes": "", "vc-description": "/-\nThe chef is trying to decode some pattern problems, Chef wants your help to code it. Chef has one number K to form a new pattern. Help the chef to code this pattern problem.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, one integer $K$. \n\n-----Output:-----\nFor each test case, output as the pattern.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq K \\leq 100$\n\n-----Sample Input:-----\n4\n1\n2\n3\n4\n\n-----Sample Output:-----\n1 \n1 01 \n11 001 \n1 01 11 \n001 101 011 \n111 0001 1001 \n1 01 11 001 \n101 011 111 0001 \n1001 0101 1101 0011 \n1011 0111 1111 00001 \n\n-----EXPLANATION:-----\nNo need, else pattern can be decode easily.\n-/", "vc-preamble": "def generate_pattern (k: Nat) : List (List String) := sorry\n\ntheorem pattern_dimensions {k: Nat} (h: k > 0) :\n  let pattern := generate_pattern k\n  List.length pattern = k ∧ \n  pattern.all (fun row => List.length row = k) := sorry", "vc-helpers": "", "vc-definitions": "def is_binary_string (s: String) : Bool := sorry\n\ndef binary_to_nat (s: String) : Nat := sorry", "vc-theorems": "theorem pattern_elements {k: Nat} (h: k > 0) :\n  let pattern := generate_pattern k\n  pattern.all (fun row => \n    row.all (fun elem => \n      is_binary_string elem ∧ binary_to_nat elem > 0\n    )\n  ) := sorry\n\ntheorem pattern_sequence {k: Nat} (h: k > 0) :\n  let pattern := generate_pattern k\n  let flattened := List.join pattern\n  let nums := List.range (k * k) |>.map (· + 1)\n  flattened.map binary_to_nat = nums := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0751", "language": "lean", "source": "fvapps", "source-id": "fvapps_000751", "source-notes": "", "vc-description": "/-\nYou are given an array $a$ of length $n$. A subsequence of this array is valid, if it satisfies these two conditions:\n- There shouldn't be any two even numbers within a distance of $K$, both which have been chosen in the subsequence. i.e. there shouldn't be two indices $i, j$ such that $a_i$ and $a_j$ are even, $|i - j| \\leq K$ and $a_i$ and $a_j$ are in the subsequence. \n- Similarly, there shouldn't be any two odd numbers within a distance of $K$, both which have been chosen in the subsequence\nThe sum of a subsequence is the sum of all the numbers in it. Your task is find the maximum sum possible in a valid subsequence of the given array. Print this maximum sum.\n\n-----Input-----\n- The first line of the input contains an integer $T$ denoting the number of test cases. The description of the test cases follows.\n- The first line of each test case contains two space-separated integers $n, k$.\n- The second line of each test case contains $n$ space-separated integers denoting the array $a$.\n\n-----Output-----\nFor each test case, output an integer corresponding to the answer of the problem.\n\n-----Constraints-----\n- $1 \\le T \\le 10^5$\n- $1 \\le n \\leq 10^5$\n- $1 \\le k \\leq  n$\n- $1 \\le a_i \\leq 10^9$\n- Sum of $n$ over all the test cases doesn't exceed $10^6$\n\n-----Example Input-----\n3\n1 1\n3\n2 1\n2 2\n5 2\n1 2 3 4 6\n\n-----Example Output-----\n3\n2\n11\n\n-----Explanation:-----\nTestcase 2: Only one of the two 2s can be chosen. Hence the answer is 2.\nTestcase 3: The subsequence containing the second, third and fifth numbers is a valid subsequence, and its sum is 2+3+6 = 11. You can check that this is the maximum possible, and hence is the answer.\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat :=\nmatch xs with\n| [] => 0\n| x :: xs => x + List.sum xs", "vc-helpers": "", "vc-definitions": "def solve_max_subsequence (n : Nat) (k : Nat) (arr : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_max_subsequence_basic_properties \n  (n k : Nat)\n  (arr : List Nat) \n  (h1 : n > 0)\n  (h2 : k > 0)\n  (h3 : n = arr.length) :\n  let result := solve_max_subsequence n k arr\n  -- Result is non-negative\n  (result ≥ 0) ∧\n  -- Result doesn't exceed array sum  \n  (result ≤ arr.sum) ∧ \n  -- Result positive unless all zeros\n  (result > 0 ∨ arr.all (·= 0)) ∧\n  -- Result respects even/odd sum\n  (result ≤ (arr.filter (·%2 = 0)).sum + (arr.filter (·%2 = 1)).sum) :=\nsorry\n\ntheorem solve_max_subsequence_single_element\n  (n : Nat)\n  (h : n > 0) :\n  solve_max_subsequence 1 1 [n] = n :=\nsorry\n\ntheorem solve_max_subsequence_consecutive\n  (arr : List Nat)\n  (h1 : arr.length ≥ 2) :\n  let n := arr.length\n  let result := solve_max_subsequence n 1 arr\n  let max_consecutive := (List.range (n-1)).foldl (fun acc i => \n    max acc (arr[i]! + arr[i+1]!)) 0\n  result ≥ max_consecutive / 2 :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval solve_max_subsequence 1 1 [3]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve_max_subsequence 2 1 [2, 2]\n\n/-\ninfo: 11\n-/\n-- #guard_msgs in\n-- #eval solve_max_subsequence 5 2 [1, 2, 3, 4, 6]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0752", "language": "lean", "source": "fvapps", "source-id": "fvapps_000752", "source-notes": "", "vc-description": "/-\nSultan, the freestyle wrestler, you all know him. He broke multiple records in the history of all wrestling leagues. Now 20 years have passed, Sultan has grown old. He has two sons, he wants them to be like him. Sultan being orthodox goes to his astrologer, where he is told that his sons shall be invincible like him. \nSultan starts to train them. After training, his son Multan & Fultan, having strengths are M and F respectively, decide to fight. They can defeat if the strength of challengers Si is a positive integer multiple of their strength else they lose. Multan fights first, then Fultan. A challenger once knocked out cannot challenge them again. Sultan's sons are still not very good wrestlers. Sultan considers them wrestlers if they both combined are able to win at least 70% of the all the fights. Also, he wants to know who is a better wrestler of the two. Your task is to help Sultan in this venture. Print \"Yes\" (without quotes) if they are able to win, else print \"No\" (without quotes). If yes, also name whether, \"Multan\" or \"Fultan\" is a better wrestler, if both win equally print “Both”.\n\n-----Input-----\n- First line contains single integer T denoting test cases.\n- Second Line contains single integer N for number of challengers.\n- Third Line contains space separated two integer denoting strength M & F\n- Next Line contains strength space separated N integer ith of which denoting Si of N challengers respectively.\n\n-----Output-----\n- Yes or No corresponding the result.\n- Also, if Yes, print, Multan, Fultan, Both accordingly. \n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N ≤ 1000\n- 1 ≤ M, F ≤ 109\n- 0 ≤ Si ≤ 109\n\n-----Example-----\nInput:\n2\n7\n2 3\n4 5 7 8 9 10 14\n6\n5 7\n1 2 8 9 10 11\n\nOutput:\nYes\nMultan\nNo\n\n-----Explanation-----\nExample case 1.\n\nMultan (M) defeats total 4 challengers with strengths 4, 8, 10, 14 and Fultan (F) defeats 1 challenger with strength 9. Their total wins are 5 out of 7 and win accuracy of 71.4%. Hence, 'Yes' and since Multan is better wrestler so 'Multan'\n\nExample case 2.\nMultan defeats 1 and Fultan defeat 0 challengers. Total wins 1 out of 6 with accuracy 16.67% Hence, No.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_wrestling_challenge (n m f : Nat) (challengers : List Nat) : Result := sorry\n\ntheorem wrestling_challenge_no_none_if_yes {n m f : Nat} {challengers : List Nat} :\n  solve_wrestling_challenge n m f challengers = Result.Yes city →\n  city ∈ [\"Multan\", \"Fultan\", \"Both\"] := sorry", "vc-theorems": "theorem wrestling_challenge_valid_result {n m f : Nat} {challengers : List Nat} :\n  solve_wrestling_challenge n m f challengers = Result.Yes city ∨\n  solve_wrestling_challenge n m f challengers = Result.No := sorry\n\ntheorem wrestling_challenge_all_zeros {n m f : Nat} : \n  solve_wrestling_challenge n m f (List.replicate n 0) = Result.No := sorry\n\ntheorem wrestling_challenge_win_percentage {n m f : Nat} {challengers : List Nat} :\n  (challengers.length = n) →\n  let wins := (challengers.filter (λ x => x > 0 ∧ (x % m = 0 ∨ x % f = 0))).length\n  let win_percentage := (wins * 100) / n\n  win_percentage ≥ 70 ↔ ∃ city, solve_wrestling_challenge n m f challengers = Result.Yes city := sorry\n\n/-\ninfo: ('Yes', 'Multan')\n-/\n-- #guard_msgs in\n-- #eval solve_wrestling_challenge 7 2 3 [4, 5, 7, 8, 9, 10, 14]\n\n/-\ninfo: ('No', None)\n-/\n-- #guard_msgs in\n-- #eval solve_wrestling_challenge 6 5 7 [1, 2, 8, 9, 10, 11]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0776", "language": "lean", "source": "fvapps", "source-id": "fvapps_000776", "source-notes": "", "vc-description": "/-\nThere's an array A consisting of N non-zero integers A1..N. A subarray of A is called alternating if any two adjacent elements in it have different signs (i.e. one of them should be negative and the other should be positive).\n\nFor each x from 1 to N, compute the length of the longest alternating subarray that starts at x - that is, a subarray Ax..y for the maximum possible y ≥ x. The length of such a subarray is y-x+1.\n\n-----Input-----\n- The first line of the input contains an integer T - the number of test cases.\n- The first line of each test case contains N.\n- The following line contains N space-separated integers A1..N.\n\n-----Output-----\nFor each test case, output one line with N space-separated integers - the lengths of the longest alternating subarray starting at x, for each x from 1 to N.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 105\n- -109 ≤ Ai ≤ 109\n\n-----Example-----\nInput:\n3\n4\n1 2 3 4\n4\n1 -5 1 -5\n6\n-5 -1 -1 2 -2 -3\n\nOutput:\n1 1 1 1\n4 3 2 1\n1 1 3 2 1 1\n\n-----Explanation-----\nExample case 1. No two elements have different signs, so any alternating subarray may only consist of a single number.\nExample case 2. Every subarray is alternating.\nExample case 3. The only alternating subarray of length 3 is A3..5.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longestAlternatingSubarrays (cases: List (List Int)) : List String := sorry\n\ndef stringToNat (s: String) : Nat := sorry", "vc-theorems": "theorem output_format (cases : List (List Int))\n  (h1 : ∀ (l : List Int), List.elem l cases → l.length > 0) : \n  let result := longestAlternatingSubarrays cases\n  ∀ (r : String), List.elem r result →\n    ∃ nums : List Nat,\n    nums.length = (cases.get! (result.indexOf r)).length ∧ \n    ∀ (n : Nat), List.elem n nums → 1 ≤ n ∧ n ≤ (cases.get! (result.indexOf r)).length := sorry\n\ntheorem alternating_property (cases : List (List Int))\n  (h1 : ∀ (l : List Int), List.elem l cases → l.length > 0) :\n  let result := longestAlternatingSubarrays cases\n  ∀ (case : List Int) (r : String) (i : Nat),\n    List.elem case cases → List.elem r result →\n    i < case.length →\n    let len := stringToNat (result.get! (cases.indexOf case))\n    len > 1 →\n    ∀ j, i ≤ j ∧ j < i + len - 1 →\n    (case.get! j) * (case.get! (j+1)) < 0 := sorry\n\ntheorem identical_elements (cases : List (List Int))\n  (h1 : ∀ (l : List Int), List.elem l cases → ∀ (x : Int), List.elem x l → x = 1) :\n  let result := longestAlternatingSubarrays cases\n  ∀ (case : List Int) (r : String),\n    List.elem case cases → List.elem r result →\n    r = String.intercalate \" \" (List.replicate case.length \"1\") := sorry\n\ntheorem alternating_signs (cases : List (List Int))\n  (h1 : ∀ (l : List Int), List.elem l cases → l.length ≥ 2)\n  (h2 : ∀ (l : List Int), List.elem l cases → ∀ (x : Int), List.elem x l → x ≠ 0) :\n  let result := longestAlternatingSubarrays cases\n  ∀ (case : List Int) (r : String) (i : Nat),\n    List.elem case cases → List.elem r result →\n    i < case.length - 1 →\n    (case.get! i) * (case.get! (i+1)) < 0 →\n    stringToNat ((r.split (· = ' ')).get! i) > 1 := sorry\n\n/-\ninfo: ['1 1 1 1']\n-/\n-- #guard_msgs in\n-- #eval longest_alternating_subarrays [test1]\n\n/-\ninfo: ['4 3 2 1']\n-/\n-- #guard_msgs in\n-- #eval longest_alternating_subarrays [test2]\n\n/-\ninfo: ['1 1 3 2 1 1']\n-/\n-- #guard_msgs in\n-- #eval longest_alternating_subarrays [test3]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0778", "language": "lean", "source": "fvapps", "source-id": "fvapps_000778", "source-notes": "", "vc-description": "/-\nZonal Computing Olympiad 2013, 10 Nov 2012\n\nLittle Red Riding Hood is carrying a basket with berries through the forest to her grandmother's house.  The forest is arranged in the form of a square N × N grid of cells.  The top left corner cell, where Little Red Riding Hood starts her journey, is numbered (1,1) and the bottom right corner cell, where her grandmother lives, is numbered (N,N).  In each step, she can move either one position right or one position down.\n\nThe forest is full of dangerous wolves and she is looking for a safe path to reach her destination.  Little Red Riding Hood's fairy godmother has placed some special anti-wolf magical charms in some of the cells in the grid.  Each charm has a strength.  If the charm in cell (i,j) has strength k then its zone of influence is all the cells within k steps of (i,j); that is, all cells (i',j') such that |i - i'| + |j - j'| ≤ k.  A cell within the zone of influence of a charm is safe from wolves.  A safe path from (1,1) to (N,N) is one in which every cell along the path is safe.\n\nLittle Red Riding Hood is carrying a basket with berries. In each cell, she drops some berries while pushing her way through the thick forest.  However, sometimes she is also able to pick up fresh berries.  Each cell is labelled with an integer that indicates the net change in the number of berries in her basket on passing through the cell; that is, the number of berries she picks up in that cell minus the number of berries she drops.  You can assume that there are enough berries in her basket to start with so that the basket never becomes empty.\n\nLittle Red Riding Hood knows the positions and strengths of all the magic charms and is looking for a safe path along which the number of berries she has in the basket when she reaches her grandmother's house is maximized.\n\nAs an example consider the following grid:\n\n3  3  2  4  3 \n2  1 -1 -2  2  \n-1  2  4  3 -3  \n-2  2  3  2  1  \n3 -1  2 -1  2  \n\nSuppose there are 3 magic charms, at position (1,2) with strength 2, at position (4,5) with strength 2 and one at position (4,2) with strength 1.  The positions within the zone of influence of these three charms are indicated in the three grids below using X's.  \n\nX  X  X  X  .         .  .  .  .  .         .  .  .  .  .\nX  X  X  .  .         .  .  .  .  X         .  .  .  .  .\n.  X  .  .  .         .  .  .  X  X         .  X  .  .  .\n.  .  .  .  .         .  .  X  X  X         X  X  X  .  .\n.  .  .  .  .         .  .  .  X  X         .  X  .  .  .\n\nPutting these together, the cells that are under the zone of influence of at least one charm are marked with X below.\n\nX  X  X  X  .\nX  X  X  .  X\n.  X  .  X  X\nX  X  X  X  X\n.  X  .  X  X\n\nHere are two examples of safe paths in this grid, marked using Y's.  \n\nY  Y  X  X  .          Y  X  X  X  .\nX  Y  X  .  X          Y  Y  X  .  X\n.  Y  .  X  X          .  Y  .  X  X\nX  Y  Y  Y  Y          X  Y  Y  Y  X\n.  X  .  X  Y          .  X  .  Y  Y\n\nAlong the first path, she accumulates 19 berries while on the second path she collects 16 berries.  You can verify that among all safe paths, the maximum number of berries she can collect is 19. \n\nYour task is to help Little Red Riding Hood find out if there is at least one safe path and, if so, compute the maximum number of berries she can collect among all safe paths (which may be a negative number, in which case it is the minimum number of berries she will lose among all safe paths).\n\n-----Input format-----\nLine 1: Two space separated integers N and M, giving the dimension of the grid and the number of magic charms, respectively\n\nLines 2 to N+1: These N lines desribe the grid.  Line i+1 contains N space separated integers, describing the net change in berries in the N cells along row i of the grid.\n\nLines N+2 to N+M+1: These M lines describe the magic charms.  Each of these lines has 3 integers: the first two integers describe the position of the charm in the grid and the third integer describes its strength.\n\n-----Output format-----\nThe first line of output must either consist of the word YES, if there are safe paths, or the word NO, if there are no safe paths. If the output on the first line is YES then the second line should contain a single integer giving the maximum number of berries Little Red Riding Hood can collect among all safe paths.  \n\n-----Sample Input-----\n5 3\n3 3 2 4 3 \n2 1 -1 -2 2  \n-1 2 4 3 -3  \n-2 2 3 2 1  \n3 -1 2 -1 2  \n1 2 2\n4 5 2\n4 2 1\n\n-----Sample Output-----\nYES\n19\n\n-----Test data-----\nIn all subtasks, you may assume that 2 ≤ N ≤ 500.  Each value on the grid is guaranteed to have absolute value not more than 1000. \nLet K denote the maximum strength among all the magic charms.\n- Subtask 1 (30 marks) : 1 ≤ M ≤ 10, 1 ≤ K ≤ 1,000.\n- Subtask 2 (70 marks) : 1 ≤ M ≤ 10,000, 1 ≤ K ≤ 10.\n\n-----Live evaluation data-----\n- Subtask 1: Testcases 0,1,2,3,4.\n- Subtask 2: Testcases 5,6,7,8.\n-/", "vc-preamble": "def Matrix := List (List Int)\n\ndef hasValidPath (matrix : Matrix) (charms : List Charm) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def solve_red_riding_hood (n m : Nat) (matrix : Matrix) (charms : List Charm) : (String × Int) :=\n  sorry", "vc-theorems": "theorem path_exists_property (n m : Nat) (matrix : Matrix) (charms : List Charm) \n  (hn : n > 0) (hm : m > 0) (hmatrix : matrix.length = n) :\n  let result := solve_red_riding_hood n m matrix charms\n  if hasValidPath matrix charms then result.1 = \"YES\" else result.1 = \"NO\" :=\n  sorry\n\ntheorem no_charms_property (n m : Nat) (matrix : Matrix)\n  (hn : n > 0) (hm : m > 0) (hmatrix : matrix.length = n) :\n  (solve_red_riding_hood n m matrix []).1 = \"NO\" :=\n  sorry\n\ntheorem all_positive_path_property (n m val : Nat)\n  (hn : n > 0) (hm : m > 0) (hval : val > 0) :\n  let matrix : Matrix := List.replicate n (List.replicate n (Int.ofNat val))\n  let charms := [⟨⟨0,0⟩, 2*n⟩]\n  let result := solve_red_riding_hood n m matrix charms\n  result.1 = \"YES\" ∧ result.2 = Int.ofNat (val * (2*n - 1)) :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0783", "language": "lean", "source": "fvapps", "source-id": "fvapps_000783", "source-notes": "", "vc-description": "/-\nIn poker, you have 5 cards. There are 10 kinds of poker hands (from highest to lowest):\n\n-  royal flush - ace, king, queen, jack and ten, all in the same suit\n\n-  straight flush - five cards of the same suit in sequence, such\nas 10,9,8,7,6 of clubs; ace can be counted both as the highest card or as the\nlowest card - A,2,3,4,5 of hearts is a straight flush. But 4,3,2,A,K of hearts is not a straight flush - it's just a flush.\n\n-  four of a kind - four cards of the same rank, such as four kings.\n\n-  full house - three cards of one rank plus two cards of another rank\n\n-  flush - five cards of the same suit (but not a straight flush)\n\n-  straight - five cards in order - just like the straight flush, but mixed suits\n\n-  three of a kind - three cards of one rank and two other cards\n\n-  two pairs - two cards of one rank, two cards of another rank, and one more card\n\n-  pair - two cards of the same rank\n\n-  high card - none of the above\n\nWrite a program that will help you play poker by telling you what kind of hand you have.\n\n-----Input-----\n\nThe first line of input contains the number of test cases (no more than 20). Each test case consists of one line - five space separated cards. Each card is represented by a two-letter (or digit) word. The first character is the rank (A,K,Q,J,T,9,8,7,6,5,4,3 or 2), the second character is the suit (S,H,D,C standing for spades, hearts, diamonds and clubs). The cards can be in any order (but they will not repeat).\n\n-----Output-----\n\nFor each test case output one line describing the type of a hand, exactly like in the list above.\n\n-----Example-----\nInput:\n3\nAH KH QH TH JH\nKH 5S 3C 5C 7D\nQH QD 2S QC 2C\n\nOutput:\nroyal flush\npair\nfull house\n-/", "vc-preamble": "def Rank.toNat : Rank → Nat \n  | Ace => 14\n  | Two => 2\n  | Three => 3\n  | Four => 4\n  | Five => 5\n  | Six => 6\n  | Seven => 7\n  | Eight => 8\n  | Nine => 9\n  | Ten => 10\n  | Jack => 11\n  | Queen => 12\n  | King => 13\n\ninductive HandResult where\n  | RoyalFlush\n  | StraightFlush\n  | FourOfAKind\n  | FullHouse\n  | Flush\n  | Straight\n  | ThreeOfAKind\n  | TwoPairs\n  | Pair\n  | HighCard\n  deriving BEq, Repr\n\nstructure Card where\n  rank : Rank\n  suit : Suit\n  deriving BEq\n\nabbrev Hand := List Card", "vc-helpers": "", "vc-definitions": "def evaluate_poker_hand (h : Hand) : HandResult := \n  sorry", "vc-theorems": "theorem evaluate_poker_hand_returns_valid_result (h : Hand) \n  (h5 : h.length = 5) (hunique : h.Nodup) :\n  ∃ (result : HandResult), evaluate_poker_hand h = result :=\nsorry\n\ntheorem royal_flush_requires_specific_cards (h : Hand)\n  (h5 : h.length = 5) (hunique : h.Nodup) :\n  evaluate_poker_hand h = HandResult.RoyalFlush →\n  (∃ (s : Suit), ∀ (c : Card), c ∈ h → c.suit = s) ∧\n  h.map Card.rank = [Rank.Ace, Rank.King, Rank.Queen, Rank.Jack, Rank.Ten] :=\nsorry\n\ntheorem straight_consecutive_ranks (h : Hand)\n  (h5 : h.length = 5) (hunique : h.Nodup) :\n  evaluate_poker_hand h = HandResult.Straight ∨ \n  evaluate_poker_hand h = HandResult.StraightFlush →\n  let ranks := (h.map Card.rank).map Rank.toNat\n  ∃ (min : Nat), ranks = [min, min+1, min+2, min+3, min+4] ∨ \n                 ranks = [14, 2, 3, 4, 5] :=\nsorry\n\ntheorem flush_same_suit (h : Hand)\n  (h5 : h.length = 5) (hunique : h.Nodup) :\n  evaluate_poker_hand h = HandResult.Flush ∨ \n  evaluate_poker_hand h = HandResult.StraightFlush ∨\n  evaluate_poker_hand h = HandResult.RoyalFlush →\n  ∃ (s : Suit), ∀ (c : Card), c ∈ h → c.suit = s :=\nsorry\n\ntheorem four_of_kind_has_four_same_rank (h : Hand)\n  (h5 : h.length = 5) (hunique : h.Nodup) :\n  evaluate_poker_hand h = HandResult.FourOfAKind →\n  ∃ r : Rank, (h.filter (fun c ↦ c.rank == r)).length = 4 :=\nsorry\n\ntheorem three_of_kind_has_three_same_rank (h : Hand)\n  (h5 : h.length = 5) (hunique : h.Nodup) :\n  evaluate_poker_hand h = HandResult.ThreeOfAKind →\n  ∃ r : Rank, (h.filter (fun c ↦ c.rank == r)).length = 3 ∧\n  ¬∃ r : Rank, (h.filter (fun c ↦ c.rank == r)).length = 2 :=\nsorry\n\ntheorem two_pairs_has_two_pairs (h : Hand)\n  (h5 : h.length = 5) (hunique : h.Nodup) :\n  evaluate_poker_hand h = HandResult.TwoPairs →\n  ∃ r1 r2 : Rank, r1 ≠ r2 ∧\n  (h.filter (fun c ↦ c.rank == r1)).length = 2 ∧\n  (h.filter (fun c ↦ c.rank == r2)).length = 2 :=\nsorry\n\n/-\ninfo: 'royal flush'\n-/\n-- #guard_msgs in\n-- #eval evaluate_poker_hand [\"AH\", \"KH\", \"QH\", \"TH\", \"JH\"]\n\n/-\ninfo: 'pair'\n-/\n-- #guard_msgs in\n-- #eval evaluate_poker_hand [\"KH\", \"5S\", \"3C\", \"5C\", \"7D\"]\n\n/-\ninfo: 'full house'\n-/\n-- #guard_msgs in\n-- #eval evaluate_poker_hand [\"QH\", \"QD\", \"2S\", \"QC\", \"2C\"]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0786", "language": "lean", "source": "fvapps", "source-id": "fvapps_000786", "source-notes": "", "vc-description": "/-\nJohn was learning mathematics and was very bored. Jane his best friend gave him a problem to solve. \nThe description of the problem was as follows:- \nYou are given a decimal number $N$(1<=$N$<=$10^9$) and three integers $A$, $B$, $C$. \nSteps to perform:\n1) You have to create a $LIST$. \n2) You have to initialize the $LIST$ by adding N to the $LIST$ as its first element. \n3) Divide$N$ by $A$ and if the first digit of the fractional part is Non-Zero then add this digit to the  $LIST$ otherwise add the first digit of the integral part(Leftmost digit).\n(The integer part or integral part of a decimal is the integer written to the left of the decimal separator.  The part from the decimal separator i.e to the right is the fractional part. )\n4) Update $N$  by Last element of the $LIST$. \nN = Last element of $LIST$\n5) You have to perform the same process from step 3 on $N$ for $B$ and $C$ respectively \n6) Repeat from step 3 \nYou have to answer$Q$(1 <= $Q$<= 100 ) queries\nFor each query you are given an integer $i$ (0 <= $i$ <= $10^9$ ). You have to print the element present at the ith position of the $LIST$. \nHelp John solve this problem.\n\n-----Input:-----\n- The First Line of input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The First Line of each test case contains the  integer $N$.\n- The second line of each test case contains three integers $A$, $B$, and $C$ separated by a space\n- The third line of each test case contains an integer $Q$.\n- Then the next $Q$ line follows.  \n- An integer $i$ (0 <= $i$ <= 10^9 )\n\n-----Output:-----\nYou have to answer the $Q$ queries in the next $Q$ lines. \n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 10^9$\n- $2 \\leq A \\leq 10$\n- $2 \\leq B \\leq 10$\n- $2 \\leq C \\leq 10$\n- $2 \\leq Q \\leq 100$\n- $0 \\leq i \\leq 10^9$\n\n-----Sample Input:-----\n1\n56\n3 5 7\n4\n0\n1\n2\n3\n\n-----Sample Output:-----\n56\n6\n2\n2\n\n-----EXPLANATION:-----\nThis list is :\n$N$ = 56 and $A$ = 3, $B$ = 5, $C$ = 7. \nInitially $LIST$ = $[ 56 ]$\n$N$$/$$A$ =  56/3 = 18.666666666666668 \nAdd 6 to the $LIST$ \n$LIST$ = $[ 56, 6 ]$\n$N$ = 6 \n$N$$/$$B$ = 6/5 = 1.2 \nAdd 2 to the$LIST$ \n$LIST$ = $[ 56, 6, 2 ]$\nN = 2 \n$N$$/$$C$ = 2/7 =0. 2857142857142857\nAdd 2 to the $LIST$.  \n$LIST$ = $[ 56, 6, 2, 2 ]$\n$N$  = 2\nWe have to keep repeating this process. If any of the numbers got by $N$ dividing by either $A$, $B$, $C$ have 0 after the decimal point then we have to take the first digit of the number. \nfor example: if we got 12.005 then here we take 1 and add it to the list and then assign N = 1 \nNow the queries ask for the elements at index 0, 1, 2, 3 of the $LIST$ which is 56,6, 2, 2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_list_pattern (n : Nat) (a b c : Nat) (queries : List Nat) : List Nat :=\nsorry\n\n/- Output list length matches query list length -/", "vc-theorems": "theorem solve_list_pattern_length {n a b c : Nat} {queries : List Nat} \n  (h1 : n ≥ 1) (h2 : n ≤ 10^9)\n  (h3 : a ≥ 1) (h4 : a ≤ 100)\n  (h5 : b ≥ 1) (h6 : b ≤ 100) \n  (h7 : c ≥ 1) (h8 : c ≤ 100)\n  (h9 : queries.length ≥ 1) (h10 : queries.length ≤ 100)\n  (h11 : ∀ q ∈ queries, q ≥ 0 ∧ q ≤ 100) :\n  (solve_list_pattern n a b c queries).length = queries.length :=\nsorry\n\n/- All output values are single digits except possibly first -/\n\ntheorem solve_list_pattern_range {n a b c : Nat} {queries : List Nat}\n  (h1 : n ≥ 1) (h2 : n ≤ 10^9)\n  (h3 : a ≥ 1) (h4 : a ≤ 100)\n  (h5 : b ≥ 1) (h6 : b ≤ 100)\n  (h7 : c ≥ 1) (h8 : c ≤ 100)\n  (h9 : queries.length ≥ 1) (h10 : queries.length ≤ 100)\n  (h11 : ∀ q ∈ queries, q ≥ 0 ∧ q ≤ 100) :\n  ∀ i ∈ (solve_list_pattern n a b c queries).tail, i ≤ 9 :=\nsorry\n\n/- First query at index 0 returns initial n -/\n\ntheorem solve_list_pattern_init {n a b c : Nat} {queries : List Nat}\n  (h1 : n ≥ 1) (h2 : n ≤ 10^9)\n  (h3 : a ≥ 1) (h4 : a ≤ 100)\n  (h5 : b ≥ 1) (h6 : b ≤ 100)\n  (h7 : c ≥ 1) (h8 : c ≤ 100)\n  (h9 : queries.length ≥ 1) (h10 : queries.length ≤ 100)\n  (h11 : ∀ q ∈ queries, q ≥ 0 ∧ q ≤ 100)\n  (h12 : 0 ∈ queries) :\n  (solve_list_pattern n a b c queries)[queries.indexOf 0]? = some n :=\nsorry\n\n/- Function is idempotent (same inputs produce same outputs) -/\n\ntheorem solve_list_pattern_idempotent {n a b c : Nat} {queries : List Nat}\n  (h1 : n ≥ 1) (h2 : n ≤ 10^9)\n  (h3 : a ≥ 1) (h4 : a ≤ 100)\n  (h5 : b ≥ 1) (h6 : b ≤ 100)\n  (h7 : c ≥ 1) (h8 : c ≤ 100)\n  (h9 : queries.length ≥ 1) (h10 : queries.length ≤ 100)\n  (h11 : ∀ q ∈ queries, q ≥ 0 ∧ q ≤ 100) :\n  solve_list_pattern n a b c queries = solve_list_pattern n a b c queries :=\nsorry\n\n/-\ninfo: [56, 6, 2, 2]\n-/\n-- #guard_msgs in\n-- #eval solve_list_pattern 56 3 5 7 [0, 1, 2, 3]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0791", "language": "lean", "source": "fvapps", "source-id": "fvapps_000791", "source-notes": "", "vc-description": "/-\nIndian National Olympiad in Informatics 2013\nCalvin wakes up early one morning and finds that all his friends in the hostel are asleep. To amuse himself, he decides to play the following game : he draws a sequence of N squares on the ground, numbered 1 to N, and writes an integer in each square. He starts at square k (1 ≤ k ≤ N). The game consists of one forward phase followed by one backward phase.\n- In the forward phase, Calvin makes zero or more moves of the following type : if his current position is p, he can jump to p+1 or p+2 as long as he stays within the N squares.\n- In the backward phase, Calvin makes zero or more moves of the following type : if his current position is p, he can jump to p−1 or p−2 as long as he stays within the N squares.\nHe plays such that he finally ends up at square 1, and then he stops. He starts with a score of 0, and each time he jumps from square i to square j, he adds the integer written in square j to his score. Find the maximum score Calvin can obtain by playing this game. Recall that Calvin must start at square k and end at square 1. The integer on the square where he starts is not included in his score.\nFor example, suppose N = 5 and the numbers in squares are 5, 3, −2, 1, 1. If k = 2, Calvin starts on the second square. He can make a forward move to square 4, another to square 5, a backward move to square 4, another to square 2, and another to square 1. His total score is 1+1+1+3+5 = 11. You can check that this is the maximum score possible.\n\n-----Input format-----\n• Line 1 : Two space-separated integers, N and k, with 1 ≤ k ≤ N.\n• Line 2 : A space-separated sequence of N integers, the numbers in squares 1, 2 . . . , N .\n\n-----Output format-----\nA single line with a single integer, the maximum score Calvin can obtain by playing the game.\n\n-----Test Data-----\nThe testdata is grouped into two subtasks with the following constraints on the inputs.\n• Subtask 1 [30 points] : 1 ≤ N ≤ 3000.\n• Subtask 2 [70 points] : 1 ≤ N ≤ 106.\nIn all subtasks, the number in each square is between −1000 and 1000 inclusive.\n\n-----Example-----\nHere is the sample input and output corresponding to the example above.\n\n-----Sample input-----\n5 2\n5 3 -2 1 1\n\n-----Sample output-----\n11\n\nNote: Your program should not print anything other than what is specified in the output format. Please remove all diagnostic print statements before making your final submission. A program with extraneous output will be treated as incorrect!\n-/", "vc-preamble": "def find_max_score (N : Nat) (K : Nat) (A : List Int) : Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def max_int (a b : Int) : Int :=\n  if a ≥ b then a else b", "vc-theorems": "theorem find_max_score_k_bounds {A : List Int} {K : Nat} {N : Nat} \n  (h1 : A.length = N)\n  (h2 : N > 0)\n  (h3 : K ≤ N)\n  (h4 : ∀ x ∈ A, -1000 ≤ x ∧ x ≤ 1000) :\n  let result := find_max_score N K A\n  let sorted_tail := List.take K (List.reverse (List.mergeSort (. ≤ .) A))\n  let sorted_suffix_sum := List.foldl (· + ·) 0 sorted_tail\n  let positive_sum := List.foldl (· + ·) 0 (List.filter (λ x => x > 0) A)\n  sorted_suffix_sum ≤ result ∧ result ≤ positive_sum :=\n  sorry\n\ntheorem find_max_score_k_equals_n {A : List Int} {N : Nat}\n  (h1 : A.length = N)\n  (h2 : N > 0)\n  (h3 : ∀ x ∈ A, -1000 ≤ x ∧ x ≤ 1000) :\n  find_max_score N N A = List.foldl (· + ·) 0 A :=\n  sorry\n\ntheorem find_max_score_all_positive {A : List Int} {N : Nat}\n  (h1 : A.length = N)\n  (h2 : N > 0)\n  (h3 : ∀ x ∈ A, 0 ≤ x ∧ x ≤ 1000) :\n  let K := if N > 1 then N / 2 else 1\n  find_max_score N K A = List.foldl (· + ·) 0 A :=\n  sorry\n\ntheorem find_max_score_all_negative {A : List Int} {N : Nat}\n  (h1 : A.length = N)\n  (h2 : N > 0)\n  (h3 : ∀ x ∈ A, -1000 ≤ x ∧ x < 0) :\n  let K := if N > 1 then N / 2 else 1\n  let sliding_sums := List.range (N - K + 1) |>.map (λ i => List.foldl (· + ·) 0 (List.take K (List.drop i A)))\n  find_max_score N K A = sliding_sums.foldl max_int (sliding_sums.head!) :=\n  sorry\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval find_max_score 5 2 [5, 3, -2, 1, 1]\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval find_max_score 5 2 [1, 2, 3, -1, -2]\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval find_max_score 3 1 [3, 2, 1]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0800", "language": "lean", "source": "fvapps", "source-id": "fvapps_000800", "source-notes": "", "vc-description": "/-\nThe Little Elephant from the Zoo of Lviv is going to the Birthday Party of  the Big Hippo tomorrow. Now he wants to prepare a gift for the Big Hippo.\n\nHe has N balloons, numbered from 1 to N. The i-th balloon has the color Ci and it costs Pi dollars. The gift for the Big Hippo will be any subset (chosen randomly, possibly empty) of the balloons such that the number of different colors in that subset is at least M.\n\nHelp Little Elephant to find the expected cost of the gift.\n\n-----Input-----\nThe first line of the input contains a single integer T - the number of test cases. T test cases follow. The first line of each test case contains a pair of integers N and M. The next N lines contain N pairs of integers Ci and Pi, one pair per line.\n\n-----Output-----\nIn T lines print T real numbers - the answers for the corresponding test cases. Your answer will considered correct if it has at most 10^-6 absolute or relative error.\n\n-----Constraints-----\n- 1 ≤ T ≤ 40\n- 1 ≤ N,  Ci≤ 40\n- 1 ≤ Pi ≤ 1000000\n- 0 ≤ M ≤ K, where K is the number of different colors in the test case.\n\n-----Example-----\nInput:\n2\n2 2\n1 4\n2 7\n2 1\n1 4\n2 7\n\nOutput:\n11.000000000\n7.333333333\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calc_gift_cost (n m : Nat) (color_prices : List (Nat × Nat)) : Nat := sorry\n\ntheorem gift_cost_positive (n m : Nat) (color_prices : List (Nat × Nat)) :\n  calc_gift_cost n m color_prices > 0 := sorry", "vc-theorems": "theorem gift_cost_bounded (n m : Nat) (color_prices : List (Nat × Nat)) \n  (h1 : color_prices ≠ []) :\n  let prices := List.map Prod.snd color_prices\n  calc_gift_cost n m color_prices ≥ (List.minimum? prices).getD 0 ∧ \n  calc_gift_cost n m color_prices ≤ ((List.maximum? prices).getD 0) * color_prices.length \n  := sorry\n\ntheorem gift_cost_monotonic (n m : Nat) (color_prices : List (Nat × Nat))\n  (h : m > 1) :\n  calc_gift_cost n m color_prices ≥ \n  calc_gift_cost n (m-1) color_prices := sorry\n\ntheorem gift_cost_single_color :\n  calc_gift_cost 1 1 [(1, 10)] = 10 := sorry\n\ntheorem gift_cost_duplicate_color :\n  calc_gift_cost 2 1 [(1, 5), (1, 5)] = 7 := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0802", "language": "lean", "source": "fvapps", "source-id": "fvapps_000802", "source-notes": "", "vc-description": "/-\nDoubleville, a small town in Texas, was attacked by the aliens. They have abducted some of the residents and taken them to the a spaceship orbiting around earth. After some (quite unpleasant) human experiments, the aliens cloned the victims, and released multiple copies of them back in Doubleville. So now it might happen that there are 6 identical person named Hugh F. Bumblebee: the original person and its 5 copies. The Federal Bureau of Unauthorized Cloning (FBUC) charged you with the task of determining how many copies were made from each person. To help you in your task, FBUC have collected a DNA sample from each person. All copies of the same person have the same DNA sequence, and different people have different sequences (we know that there are no identical twins in the town, this is not an issue).\n\n-----Input-----\n\nThe input contains several blocks of test cases. Each case begins with a line containing two integers: the number 1 <= n <= 20000 people, and the length 1 <= m <= 20 of the DNA sequences. The next n lines contain the DNA sequences: each line contains a sequence of m characters, where each character is either 'A', 'C', 'G' or 'T'.\n\nThe input is terminated by a block with n = m = 0 .\n\n-----Output-----\nFor each test case, you have to output n lines, each line containing a single integer. The first line contains the number of different people that were not copied. The second line contains the number of people that were copied only once (i.e., there are two identical copies for each such person.) The third line contains the number of people that are present in three identical copies, and so on: the i -th line contains the number of persons that are present in i identical copies. For example, if there are 11 samples, one of them is from John Smith, and all the others are from copies of Joe Foobar, then you have to print '1' in the first and the tenth lines, and '0' in all the other lines.\n\n-----Example-----\nInput:\n\n9 6\nAAAAAA\nACACAC\nGTTTTG\nACACAC\nGTTTTG\nACACAC\nACACAC\nTCCCCC\nTCCCCC\n0 0\n\nOutput:\n\n1\n2\n0\n1\n0\n0\n0\n0\n0\n-/", "vc-preamble": "def DNA := String\nderiving DecidableEq\n\ndef count_dna_copies (sequences: List DNA) : List Nat :=\n  sorry\n\nabbrev List.sum (xs: List Nat) : Nat :=\n  xs.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def countOccurrences (s : DNA) (sequences : List DNA) : Nat :=\n  sequences.foldl (fun acc x => if x = s then acc + 1 else acc) 0", "vc-theorems": "theorem count_dna_copies_result_length \n    (sequences: List DNA) : \n    (count_dna_copies sequences).length = sequences.length :=\n  sorry\n\ntheorem count_dna_copies_non_negative\n    (sequences: List DNA) :\n    ∀ x ∈ count_dna_copies sequences, x ≥ 0 :=\n  sorry\n\ntheorem count_dna_copies_weighted_sum\n    (sequences: List DNA) :\n    let result := count_dna_copies sequences\n    (List.range result.length).zip result\n    |>.map (fun (i, v) => (i + 1) * v)\n    |>.sum = sequences.length :=\n  sorry\n\ntheorem count_dna_copies_matches_frequency\n    (sequences: List DNA) :\n    let freqs := sequences.map (fun s => countOccurrences s sequences)\n    let freqCounts := (List.range sequences.length).map (fun i =>\n      sequences.filter (fun s => countOccurrences s sequences = i + 1) |>.length\n    )\n    count_dna_copies sequences = freqCounts :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0815", "language": "lean", "source": "fvapps", "source-id": "fvapps_000815", "source-notes": "", "vc-description": "/-\nLittle Egor is a huge movie fan. He likes watching different kinds of movies: from drama movies to comedy movies, from teen movies to horror movies. He is planning to visit cinema this weekend, but he's not sure which movie he should watch.\nThere are n movies to watch during this weekend. Each movie can be characterized by two integers Li and Ri, denoting the length and the rating of the corresponding movie. Egor wants to watch exactly one movie with the maximal value of Li × Ri. If there are several such movies, he would pick a one with the maximal Ri among them. If there is still a tie, he would pick the one with the minimal index among them.\nYour task is to help Egor to pick a movie to watch during this weekend.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases.\nThe first line of the test case description contains an integer n.\nThe second line of the test case description contains n integers L1, L2, ...,Ln. The following line contains n integers R1, R2, ..., Rn.\n\n-----Output-----\nFor each test case, output a single integer i denoting the index of the movie that Egor should watch during this weekend. Note that we follow 1-based indexing.\n\n-----Constraints-----\n- 1 ≤ T ≤ 5\n- 1 ≤ n ≤ 100\n- 1 ≤ Li, Ri ≤ 100\n\n-----Example-----\nInput:\n2\n2\n1 2\n2 1\n4\n2 1 4 1\n2 4 1 4\n\nOutput:\n1\n2\n\n-----Explanation-----\nIn the first example case, both films have the same value of L × R, but the first film has a better rating.\nIn the second example case, the second and the fourth movies are equally good, but the second movie has a smaller index.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def best_movie (lengths ratings : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem best_movie_result_in_bounds {lengths ratings : List Nat} \n  (h1 : lengths.length = ratings.length)\n  (h2 : lengths.length > 0) :\n  1 ≤ best_movie lengths ratings ∧ best_movie lengths ratings ≤ lengths.length :=\nsorry\n\ntheorem best_movie_maximizes_product {lengths ratings : List Nat}\n  (h1 : lengths.length = ratings.length)\n  (h2 : lengths.length > 0) :\n  let result := best_movie lengths ratings - 1\n  let max_prod := lengths[result]! * ratings[result]!\n  ∀ i, i < lengths.length →\n    lengths[i]! * ratings[i]! ≤ max_prod :=\nsorry\n\ntheorem best_movie_highest_rating_on_equal_product {lengths ratings : List Nat}\n  (h1 : lengths.length = ratings.length)\n  (h2 : lengths.length > 0) :\n  let result := best_movie lengths ratings - 1\n  let max_prod := lengths[result]! * ratings[result]!\n  ∀ i, i < lengths.length →\n    lengths[i]! * ratings[i]! = max_prod →\n    ratings[i]! ≤ ratings[result]! :=\nsorry\n\ntheorem best_movie_identical_ratings {lengths : List Nat} \n  (h : lengths.length > 0)\n  (hmax : (List.maximum? lengths).isSome) :\n  let ratings := List.replicate lengths.length 1\n  let result := best_movie lengths ratings - 1\n  lengths[result]! = (List.maximum? lengths).get hmax :=\nsorry\n\ntheorem best_movie_identical_lengths {ratings : List Nat}\n  (h : ratings.length > 0)\n  (hmax : (List.maximum? ratings).isSome) :\n  let lengths := List.replicate ratings.length 1\n  let result := best_movie lengths ratings - 1\n  ratings[result]! = (List.maximum? ratings).get hmax :=\nsorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval best_movie [1, 2] [2, 1]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval best_movie [2, 1, 4, 1] [2, 4, 1, 4]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0818", "language": "lean", "source": "fvapps", "source-id": "fvapps_000818", "source-notes": "", "vc-description": "/-\nDhiraj loves Chocolates.He loves chocolates so much that he can eat up to $1000$ chocolates a day. But his mom is fed up by this habit of him and decides to take things in her hand.\nIts diwali Season and Dhiraj has got a lot of boxes of chocolates and Dhiraj's mom is afraid that dhiraj might eat all boxes of chocolates.\nSo she told Dhiraj that he can eat only exactly $k$ number of chocolates and dhiraj has to finish all the chocolates in box selected by him and then move on to next box of chocolate.Now Dhiraj is confused that whether he will be able to eat $k$ number of chocolates or not. Since dhiraj is weak at maths,he asks for your help to tell him whether he can eat $k$ number of chocolates or not. \nSo given number of chocolates  are $k$ which dhiraj has to eat and the boxes of chocolates each containing some number of chocolates, tell whether dhiraj will be able to eat $k$ number of chocolates or not.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- $k$, representing the number of chocolates dhiraj has to eat.\n- the third line contains $N$ representing the no. of boxes of chocolates.\n- fourth line contains list of $a[]$ size $N$ specifying the number of chocolates in each Box.\n\n-----Output:-----\n- For each testcase, output in a single line answer $0$ or $1$.\n- $0$ if dhiraj cant eat $k$ chocolates from given combination and $1$ if he can eat $k$ chocolates from given combination.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq K \\leq 10^7$\n- $1 \\leq  N \\leq 800$\n- $1 \\leq a[i] \\leq 10^3$\n\n-----Sample Input:-----\n2\n20\n5\n8 7 2 10 5\n11\n4\n6 8 2 10\n\n-----Sample Output:-----\n1\n0\n-/", "vc-preamble": "def sumList (list : List Int) : Int :=\n  sorry\n\ndef isSubsetSum (arr : List Int) (n : Int) (k : Int) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def can_eat_chocolates (k : Int) (n : Int) (arr : List Int) : Int :=\n  sorry", "vc-theorems": "theorem sum_less_than_k_returns_0 (arr : List Int) (k : Int):\n  arr.length > 0 → \n  (∀ x ∈ arr, x > 0 ∧ x ≤ 100) →\n  k > 0 →\n  k ≤ 1000 →\n  sumList arr < k →\n  can_eat_chocolates k arr.length arr = 0 :=\n  sorry\n\ntheorem target_sum_of_array_is_possible (arr : List Int):\n  arr.length > 0 →\n  (∀ x ∈ arr, x > 0 ∧ x ≤ 100) →\n  can_eat_chocolates (sumList arr) arr.length arr = 1 :=\n  sorry\n\ntheorem k_less_than_min_returns_0 (arr : List Int):\n  arr.length > 0 →\n  (∀ x ∈ arr, x > 0 ∧ x ≤ 100) →\n  let k := (arr.minimum?.getD 0) - 1\n  k > 0 →\n  can_eat_chocolates k arr.length arr = 0 :=\n  sorry\n\ntheorem subset_sum_matches_chocolates (arr : List Int) (k : Int):\n  arr.length > 0 →\n  (∀ x ∈ arr, x > 0 ∧ x ≤ 100) →\n  k > 0 →\n  k ≤ 1000 →\n  (can_eat_chocolates k arr.length arr = 1) = isSubsetSum arr arr.length k :=\n  sorry\n\ntheorem single_matching_element_returns_1 (arr : List Int):\n  arr.length > 0 →\n  (∀ x ∈ arr, x > 0 ∧ x ≤ 100) →\n  let k := arr[0]!\n  can_eat_chocolates k arr.length arr = 1 :=\n  sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval can_eat_chocolates 20 5 [8, 7, 2, 10, 5]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval can_eat_chocolates 11 4 [6, 8, 2, 10]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval can_eat_chocolates 15 3 [5, 5, 5]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0849", "language": "lean", "source": "fvapps", "source-id": "fvapps_000849", "source-notes": "", "vc-description": "/-\n\tThe following graph G is called a Petersen graph and its vertices have been numbered from 0 to 9. Some letters have also been assigned to vertices of G, as can be seen from the following picture:\n\n\tLet's consider a walk W in graph G, which consists of L vertices W1, W2, ..., WL, such that Wi is connected with Wi + 1 for 1 ≤ i < L. A string S of L letters 'A'-'E' is realized by walk W if the sequence of letters written along W is equal to S. Vertices can be visited multiple times while walking along W.\n\nFor example, S = 'ABBECCD' is realized by W = (0, 1, 6, 9, 7, 2, 3).\nYour task is to determine whether there is a walk W which realizes a given string S in graph G, and if so, find the lexicographically least such walk.\n\n-----Input-----\n\n\tThe first line of the input contains one integer T denoting the number of testcases to process.\n\n\tThe only line of each testcase contains one string S. It is guaranteed that S only consists of symbols 'A'-'E'.\n\n-----Output-----\n\n\tThe output should contain exactly T lines, one line per each testcase in the order of their appearance. For each testcase, if there is no walk W which realizes S, then output -1. Otherwise, you should output the least lexicographical walk W which realizes S. Since all of the vertices are numbered from 0 to 9, then it can be encoded as a string consisting of symbols '0'-'9' (see the \"Examples\" section for more details).\n\n-----Constraints-----\n1 ≤ T ≤ 8;\n1 ≤ |S| ≤ 100000(105).\n\n-----Examples-----\nInput:\n2\nAAB\nAABE\n\nOutput:\n501\n-1\n-/", "vc-preamble": "def find_petersen_walk : List Letter → Option (List Nat) :=\n  sorry", "vc-helpers": "", "vc-definitions": "def isAdjacent (v1 v2: Nat) : Bool :=\n  match v1, v2 with\n  | 0, n => n = 1 ∨ n = 4 ∨ n = 5\n  | 1, n => n = 0 ∨ n = 2 ∨ n = 6\n  | 2, n => n = 1 ∨ n = 3 ∨ n = 7\n  | 3, n => n = 2 ∨ n = 4 ∨ n = 8\n  | 4, n => n = 0 ∨ n = 3 ∨ n = 9\n  | 5, n => n = 0 ∨ n = 7 ∨ n = 8\n  | 6, n => n = 1 ∨ n = 8 ∨ n = 9\n  | 7, n => n = 2 ∨ n = 5 ∨ n = 9\n  | 8, n => n = 3 ∨ n = 5 ∨ n = 6\n  | 9, n => n = 4 ∨ n = 6 ∨ n = 7\n  | _, _ => false", "vc-theorems": "theorem petersen_walk_properties (input: List Letter) :\n  match find_petersen_walk input with\n  | none => True \n  | some result => \n    -- Length matches\n    result.length = input.length ∧\n    -- First vertex validation\n    (match input.head? with\n     | none => True\n     | some Letter.A => result.head? = some 0 ∨ result.head? = some 5\n     | some Letter.B => result.head? = some 1 ∨ result.head? = some 6 \n     | some Letter.C => result.head? = some 2 ∨ result.head? = some 7\n     | some Letter.D => result.head? = some 3 ∨ result.head? = some 8\n     | some Letter.E => result.head? = some 4 ∨ result.head? = some 9)\n  := sorry\n\ntheorem adjacent_vertices (input: List Letter) :\n  match find_petersen_walk input with\n  | none => True\n  | some result =>\n    input.length ≥ 2 →\n    ∀ i, i < result.length - 1 →\n      match result.get? i, result.get? (i+1) with\n      | some v1, some v2 => isAdjacent v1 v2\n      | _, _ => False\n  := sorry\n\ntheorem minimum_path (input: List Letter) (h: input.length > 0) :\n  match find_petersen_walk input with\n  | none => True\n  | some result =>\n    match input.head?, result.head? with\n    | some Letter.A, some n => n = 0 ∨ n = 5\n    | some Letter.B, some n => n = 1 ∨ n = 6\n    | some Letter.C, some n => n = 2 ∨ n = 7\n    | some Letter.D, some n => n = 3 ∨ n = 8\n    | some Letter.E, some n => n = 4 ∨ n = 9\n    | _, _ => False\n  := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0851", "language": "lean", "source": "fvapps", "source-id": "fvapps_000851", "source-notes": "", "vc-description": "/-\nVanja and Miksi really like games. After playing one game for a long time, they decided to invent another game!\nIn this game, they have a sequence $A_1, A_2, \\dots, A_N$ and two numbers $Z_1$ and $Z_2$. The rules of the game are as follows:\n- The players take turns alternately, starting with Vanja.\n- There is an integer $S$; at the beginning, $S = 0$.\n- In each turn, the current player must choose an arbitrary element of $A$ and either add that number to $S$ or subtract it from $S$. Each element can be selected multiple times.\n- Afterwards, if $S = Z_1$ or $S = Z_2$, the current player (the player who made $S$ equal to $Z_1$ or $Z_2$) is the winner of the game.\n- If the game lasts for $10^{10}$ turns, Vanja and Miksi decide to declare it a tie.\nCan you help the boys determine the winner of the game? Please note that the game can end in a tie (if nobody can make $S = Z_1$ or $S = Z_2$ in the first $10^{10}$ moves).\nBoth players play optimally, i.e. if there is a move which guarantees the current player's victory regardless of the other player's moves, the current player will make such a move. If the current player cannot win and there is a move which guarantees that the game will end in a tie, the current player will make such a move.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains three space-separated integers $N$, $Z_1$ and $Z_2$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\dots, A_N$.\n\n-----Output-----\n- For each test case, print a single line containing one integer — the final result of the game:\n- $1$ if Vanja (the first player) has a winning strategy\n- $2$ if Miksi (the second player) has a winning strategy\n- $0$ if the game ends in a tie\n\n-----Constraints-----\n- $1 \\le T \\le 50$\n- $1 \\le N \\le 50$\n- $|Z_1|, |Z_2| \\le 10^9$\n- $|A_i| \\le 10^9$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (25 points): $N = 2$\nSubtask #2 (75 points): original constraints\n\n-----Example Input-----\n3\n2 6 4\n-4 10\n1 1 -1\n2\n2 0 7\n3 4\n\n-----Example Output-----\n1\n0\n2\n\n-----Explanation-----\nExample case 1: The first player can choose the value $A_1 = -4$, subtract it from $S = 0$ and obtain $S = - (-4) = 4 = Z_2$. The winner is the first player.  \nExample case 2: It can be proven that neither player is able to reach $S = Z_1$ or $S = Z_2$. The result is a tie.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem result_validity \n  (N : Nat) (Z1 Z2 : Int) (A : List Int)\n  (h1 : N > 0) (h2 : N ≤ 100)\n  (h3 : Z1 ≥ -1000) (h4 : Z1 ≤ 1000)\n  (h5 : Z2 ≥ -1000) (h6 : Z2 ≤ 1000)\n  (h7 : ∀ a ∈ A, a ≥ -1000 ∧ a ≤ 1000)\n  (h8 : A.length ≥ 1) (h9 : A.length ≤ 100) :\n  let result := solve_game N Z1 Z2 A\n  result = 0 ∨ result = 1 ∨ result = 2 := sorry\n\n-- Property: Result should be 1 if target is immediately reachable\n\ntheorem immediate_win\n  (N : Nat) (Z : Int) (A : List Int) (a : Int)\n  (h1 : N > 0) (h2 : N ≤ 100)\n  (h3 : Z ≥ -1000) (h4 : Z ≤ 1000)\n  (h5 : a ∈ A)\n  (h6 : A.length ≥ 1) (h7 : A.length ≤ 100)\n  (h8 : Int.natAbs a = Int.natAbs Z) :\n  solve_game N Z (Z + 1) [a] = 1 := sorry\n\n-- Property: Result should be symmetric for negated inputs\n\ntheorem negation_symmetry\n  (N : Nat) (Z1 Z2 : Int) (A : List Int)\n  (h1 : N > 0) (h2 : N ≤ 100)\n  (h3 : Z1 ≥ -1000) (h4 : Z1 ≤ 1000)\n  (h5 : Z2 ≥ -1000) (h6 : Z2 ≤ 1000)\n  (h7 : ∀ a ∈ A, a ≥ -1000 ∧ a ≤ 1000)\n  (h8 : A.length ≥ 1) (h9 : A.length ≤ 100) :\n  solve_game N Z1 Z2 A = solve_game N (-Z1) (-Z2) (A.map (·*(-1))) := sorry\n\n-- Property: Single number case should be deterministic\n\ntheorem single_number\n  (num Z1 Z2 : Int)\n  (h1 : num ≥ -1000) (h2 : num ≤ 1000)\n  (h3 : Z1 ≥ -1000) (h4 : Z1 ≤ 1000)\n  (h5 : Z2 ≥ -1000) (h6 : Z2 ≤ 1000) :\n  let result := solve_game 1 Z1 Z2 [num]\n  (Int.natAbs num = Int.natAbs Z1 ∨ Int.natAbs num = Int.natAbs Z2) → result = 1 ∧\n  ¬(Int.natAbs num = Int.natAbs Z1 ∨ Int.natAbs num = Int.natAbs Z2) → (result = 0 ∨ result = 2) := sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval solve_game 2 6 4 [-4, 10]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval solve_game 1 1 -1 [2]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve_game 2 0 7 [3, 4]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0852", "language": "lean", "source": "fvapps", "source-id": "fvapps_000852", "source-notes": "", "vc-description": "/-\nRachel has some candies and she decided to distribute them among $N$ kids. The ith kid receives $A_i$ candies. The kids are happy iff the difference between the highest and lowest number of candies received is less than $X$.\nFind out if the children are happy or not.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- The first line contains $N$ and $X$. \n- The second line contains $N$ integers $A_1,A_2,...,A_N$. \n\n-----Output:-----\nFor each test case print either \"YES\"(without quotes) if the kids are happy else \"NO\"(without quotes)\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq N, X \\leq 10^5$\n- $1 \\leq A_i \\leq 10^5$\n\n-----Sample Input:-----\n2\n\n5 6\n\n3 5 6 8 1\n\n3 10\n\n5 2 9\n\n-----Sample Output:-----\nNO\n\nYES\n\n-----EXPLANATION:-----\n- Example 1: Difference between maximum and minimum candies received is 8-1=7. 7 is greater than 6, therefore, the kids are not happy.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def areKidsHappy (n : Nat) (x : Nat) (candies : List Nat) : String := sorry\n\ntheorem output_is_yes_or_no {n x : Nat} {candies : List Nat}\n  (h1 : n ≥ 2) (h2 : n ≤ 100) \n  (h3 : x ≥ 1) (h4 : x ≤ 1000)\n  (h5 : candies.length ≥ 2) (h6 : candies.length ≤ 100)\n  (h7 : ∀ c ∈ candies, c ≥ 1 ∧ c ≤ 1000) :\n  areKidsHappy n x candies = \"YES\" ∨ areKidsHappy n x candies = \"NO\" := sorry", "vc-theorems": "theorem happy_condition {n x : Nat} {candies : List Nat}\n  (h1 : n ≥ 2) (h2 : n ≤ 100)\n  (h3 : x ≥ 1) (h4 : x ≤ 1000)\n  (h5 : candies.length ≥ 2) (h6 : candies.length ≤ 100)\n  (h7 : ∀ c ∈ candies, c ≥ 1 ∧ c ≤ 1000) :\n  (candies.maximum? >>= λ max => candies.minimum? >>= λ min => some (max - min < x)) = some true ↔ \n  areKidsHappy n x candies = \"YES\" := sorry\n\ntheorem identical_candies_are_happy {candies : List Nat} {n x : Nat}\n  (h1 : candies.length ≥ 2) (h2 : candies.length ≤ 100)\n  (h3 : ∀ c ∈ candies, c ≥ 1 ∧ c ≤ 1000)\n  (h4 : ∀ i : Fin candies.length, ∀ j : Fin candies.length, candies.get i = candies.get j)\n  (h5 : x = 1)\n  (h6 : n = candies.length) :\n  areKidsHappy n x candies = \"YES\" := sorry\n\n/-\ninfo: 'NO'\n-/\n-- #guard_msgs in\n-- #eval are_kids_happy 5 6 [3, 5, 6, 8, 1]\n\n/-\ninfo: 'YES'\n-/\n-- #guard_msgs in\n-- #eval are_kids_happy 3 10 [5, 2, 9]\n\n/-\ninfo: 'YES'\n-/\n-- #guard_msgs in\n-- #eval are_kids_happy 4 5 [1, 2, 3, 4]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0857", "language": "lean", "source": "fvapps", "source-id": "fvapps_000857", "source-notes": "", "vc-description": "/-\nAs we all know, Chef is cooking string for long days, his new discovery on string is the longest common pattern length. The longest common pattern length between two strings is the maximum number of characters that both strings have in common. Characters are case sensitive, that is, lower case and upper case characters are considered as different. Note that characters can repeat in a string and a character might have one or more occurrence in common between two strings. For example, if Chef has two strings A = \"Codechef\" and B = \"elfedcc\", then the longest common pattern length of A and B is 5 (common characters are c, d, e, e, f).\nChef wants to test you with the problem described above. He will give you two strings of Latin alphabets and digits, return him the longest common pattern length.\n\n-----Input-----\nThe first line of the input contains an integer T, denoting the number of test cases. Then the description of T test cases follows.\nThe first line of each test case contains a string A. The next line contains another character string B.\n\n-----Output-----\nFor each test case, output a single line containing a single integer, the longest common pattern length between A and B.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ |A|, |B| ≤ 10000 (104), where |S| denotes the length of the string S\n- Both of A and B can contain only alphabet characters (both lower and upper case) and digits\n\n-----Example-----\nInput:\n4\nabcd\nxyz\nabcd\nbcda\naabc\nacaa\nCodechef\nelfedcc\n\nOutput:\n0\n4\n3\n5\n\n-----Explanation-----\nExample case 1. There is no common character.\nExample case 2. All the characters are same.\nExample case 3. Three characters (a, a and c) are same.\nExample case 4. This sample is mentioned by the statement.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_longest_common_pattern (s1 s2 : List Char) : Nat :=\n  sorry", "vc-theorems": "theorem symmetric_property (s1 s2 : List Char) :\n  find_longest_common_pattern s1 s2 = find_longest_common_pattern s2 s1 := by\n  sorry\n\ntheorem self_property (s : List Char) :\n  find_longest_common_pattern s s = s.length := by\n  sorry\n\ntheorem length_bounds (s1 s2 : List Char) :\n  find_longest_common_pattern s1 s2 ≤ min s1.length s2.length := by\n  sorry\n\ntheorem non_negative (s1 s2 : List Char) :\n  0 ≤ find_longest_common_pattern s1 s2 := by\n  sorry\n\ntheorem substring_property (s1 s2 s3 : List Char) :\n  find_longest_common_pattern s1 s2 ≤ \n  find_longest_common_pattern (s1 ++ s3) (s2 ++ s3) := by\n  sorry\n\ntheorem empty_string_property (s : List Char) :\n  find_longest_common_pattern ([] : List Char) s = 0 ∧\n  find_longest_common_pattern s ([] : List Char) = 0 := by\n  sorry\n\ntheorem repetition_property (s : List Char) (n : Nat) :\n  find_longest_common_pattern (List.replicate n s).join (List.replicate n s).join =\n  find_longest_common_pattern s s * n := by\n  sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval find_longest_common_pattern \"abcd\" \"xyz\"\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval find_longest_common_pattern \"abcd\" \"bcda\"\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval find_longest_common_pattern \"Codechef\" \"elfedcc\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0870", "language": "lean", "source": "fvapps", "source-id": "fvapps_000870", "source-notes": "", "vc-description": "/-\nZonal Computing Olympiad 2012, 26 Nov 2011\n\nIt's dinner time in Castle Camelot, and the fearsome Knights of the Round Table are clamouring for dessert. You, the chef, are in a soup.  There are N knights, including King Arthur, each with a different preference for dessert, but you cannot afford to make desserts for all of them.\n\nYou are given the cost of manufacturing each Knight's preferred dessert–since it is a round table, the list starts with the cost of King Arthur's dessert, and goes counter-clockwise.\n\nYou decide to pick the cheapest desserts to make, such that for every pair of adjacent Knights, at least one gets his dessert. This will ensure that the Knights do not protest.<p>A strange feature of the Knights is that they will not complain about not getting dessert unless they get support from both their neighbours.  So, you decide to pick the cheapest desserts to make, such that for every pair of adjacent Knights, at least one gets his dessert.</p>\n\nWhat is the minimum cost of tonight's dinner, given this condition?\n\nFor instance, suppose there are 5 Knights and their desserts cost 1, 2, 1, 2 and 2.  In this case, the minimum cost is 4, which you can achieve by feeding the first, third and fourth (or fifth) Knights.  \n\n-----Input format-----\nThere are 2 lines of input.  The first line contains a single integer N, the number of seats at the table. The next line contains N space separated integers, each being the cost of the dessert of a Knight, listed in counterclockwise order around the table, starting with King Arthur.\n\n-----Output format-----\nThe output should be a single line containing a single integer, the minimum possible cost for you, the chef.\n\n-----Testdata-----\nEach Knight's dessert costs strictly more than 0 and strictly less than 1000.  You may assume that 1 ≤ N ≤ 106.  In 30% of the test cases, 1 ≤ N ≤ 103.\n\n- Subtask 1 (30 marks)\n- Subtask 2 (70 marks)\n\n-----Sample Input-----\n5\n1 2 1 2 2\n\n-----Sample Output-----\n4\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n| [] => 0\n| x::xs => x + List.sum xs\n\ndef List.minimum : List Nat → Option Nat\n| [] => none\n| [x] => some x\n| x::xs => match List.minimum xs with\n  | none => some x\n  | some m => some (min x m)\n\ndef min_dessert_cost (n : Nat) (costs : List Nat) : Nat := sorry\n\ntheorem min_dessert_cost_uniform (n : Nat)\n  (h1 : n ≥ 3) :\n  min_dessert_cost n (List.replicate n 1) = (n + 1) / 2 := sorry", "vc-helpers": "", "vc-definitions": "def alternating_sums (costs : List Nat) : Nat × Nat :=\n  let rec helper (xs : List Nat) (isEven : Bool) : Nat × Nat :=\n    match xs with\n    | [] => (0, 0)\n    | x::xs => \n      let (evens, odds) := helper xs (!isEven)\n      if isEven then (evens + x, odds)\n      else (evens, odds + x)\n  helper costs true", "vc-theorems": "/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval min_dessert_cost 5 [1, 2, 1, 2, 2]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval min_dessert_cost 3 [1, 2, 3]\n\n/-\ninfo: 20\n-/\n-- #guard_msgs in\n-- #eval min_dessert_cost 4 [5, 10, 15, 20]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0873", "language": "lean", "source": "fvapps", "source-id": "fvapps_000873", "source-notes": "", "vc-description": "/-\nNote : This question carries $150$ $points$\nThere is an outcry in Middle Earth, as the greatest war between Orgs of Dark Lord Sauron and Frodo Baggins is about to begin. To end the war, Frodo decides to destroy the ring in the volcano of Mordor. There are many ships that lead Frodo to Mordor, and he is confused about which one he should board.  Given two-ship numbers $M$ and $N$, Frodo has to solve a problem to find the ship which he should board.\nFind the number of pairs (x, y), such that $1<=x<=M$ and $1<=y<=N$, for which $x*y + x+ y = string(x)+string(y)$ is true. \nAlso, calculate the number of distinct x satisfying the given condition.  The number of pairs and the number of distinct x will help select Frodo the boat he should board. Help Frodo defeat Sauron. \n\n-----Input :-----\n- First line contains $T$ as number of test cases \n- Each test case contains two integers $M$ and $N$ \n\n-----Output :-----\n- For each test case, print two integers - the number of such pairs (x,y) and the number of distinct x\n\n-----Constraints :-----\n- 1 ≤ T ≤ 5000\n- 1 ≤  M, N ≤ 10^9\n\n-----Sample Input :-----\n1\n1 9\n\n-----Sample Output :-----\n1 1\n\n-----Explanation :-----\nFor test case two M=1 and N=9  Pair (1,9) satisfies the above condition 1*9+1+9= “19” and only x=1 satisfies the equation.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem power_of_10_boundary (m : Nat) (h : 0 < m) (h2 : m ≤ 100) :\n  ∀ i : Nat, 1 ≤ i → i < 5 →\n  solve_frodo_ship m (10^i - 1) = (m*i, m) :=\nsorry\n\ntheorem between_powers (m : Nat) (exp : Nat)\n  (h1 : 0 < m) (h2 : m ≤ 10)\n  (h3 : 0 < exp) (h4 : exp ≤ 4) :\n  solve_frodo_ship m (10^exp - 2) = (m*(exp-1), m) :=\nsorry\n\n/-\ninfo: (1, 1)\n-/\n-- #guard_msgs in\n-- #eval solve_frodo_ship 1 9\n\n/-\ninfo: (4, 2)\n-/\n-- #guard_msgs in\n-- #eval solve_frodo_ship 2 99\n\n/-\ninfo: (9, 3)\n-/\n-- #guard_msgs in\n-- #eval solve_frodo_ship 3 999", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0874", "language": "lean", "source": "fvapps", "source-id": "fvapps_000874", "source-notes": "", "vc-description": "/-\nChef wants to teach a lesson of sharing to the students.\nThere are $N$ students (numbered from $1$ to $N$ from left to right) who are asked to stand in a row. Initially Chef gave $A$$i$ candies to the $i$$th$ child. In one operation any child can give any number of candies to the child standing to his immediate left (i.e. $i$$th$ child can give any amount of candies to the $(i-1)$$th$ child. In particular 1st child cannot give his candies to anyone).  \nHe asked them to minimize the maximum value of candies a student can possess after performing any number of operations (possibly zero). \nHelp the students finding such maximum value.\n\n-----Input:-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- First line of each test case contains a single integer $N$ denoting the number of students.\n- Second line contains $N$ space-separated integers $A$$1$,$A$$2$,$.....$ $A$$N$ denoting the initial amount of candies chef gave to them.\n\n-----Output:-----\n- For each test case, print a single line containing one integer ― maximum value after sharing.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq N \\leq 10^5$\n- $0$ $\\leq$ $A$$i$ $\\leq$ $10^9$\n- Sum of $N$ over all Test Cases does not exceed $10^5$\n\n-----Sample Input-----\n2 \n5 \n1 2 3 4 5 \n5\n5 4 3 2 1\n\n-----Sample Output-----\n3 \n5  \n\n-----Explanation-----\n- \nFor First Test Case:\nThe $5$$th$ student will give $2$ candies to $4$$th$ student and $4$$th$ will give $3$ candies to $3$$rd$ and $3$$rd$ will give $3$ candies to $2$$nd$ and $2$$nd$ will give $2$ candies to $1$$st$. So finally the number of candies that they will have are \n$[3,3,3,3,3]$ and the value of maximum candies is $3$.\n- \nFor Second Test Case:\nSharing to the left student will not change the maximum value as $1$$st$ cannot share to anyone. So the maximum value will remain $5$.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + xs.sum\n\ndef List.maximum : List Nat → Nat\n  | [] => 0\n  | [x] => x \n  | (x::xs) => max x (xs.maximum)", "vc-helpers": "", "vc-definitions": "def solve_candy_sharing (n : Nat) (arr : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_candy_sharing_bounds \n  {n : Nat} {arr : List Nat}\n  (h1 : n > 0)\n  (h2 : arr.length = n)\n  (h3 : ∀ x ∈ arr, x > 0 ∧ x ≤ 1000)\n  : solve_candy_sharing n arr ≥ (arr.sum + n - 1) / n ∧ \n    solve_candy_sharing n arr ≤ arr.maximum :=\n  sorry\n\ntheorem solve_candy_sharing_single\n  (n : Nat)\n  (h1 : n > 0)\n  (h2 : n ≤ 100)\n  : solve_candy_sharing 1 [n] = n :=\n  sorry\n\ntheorem solve_candy_sharing_multiple_elements\n  {n : Nat} {arr : List Nat}\n  (h1 : arr.length = n)\n  (h2 : n ≥ 2)\n  (h3 : ∀ x ∈ arr, x > 0 ∧ x ≤ 1000)\n  : solve_candy_sharing n arr > 0 :=\n  sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval solve_candy_sharing 5 arr1.copy()\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval solve_candy_sharing 5 arr2.copy()\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve_candy_sharing 3 arr3.copy()", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0877", "language": "lean", "source": "fvapps", "source-id": "fvapps_000877", "source-notes": "", "vc-description": "/-\nTweedle-Dee and Tweedle-Dum are playing a fierce match of binary Nim. This novel game is played with $N$ stacks, each of them containing only $1$-s and $0$-s.\nJust like in normal Nim, Tweedle-Dee and Tweedle-Dum alternate turns; in their turn, a player must choose one non-empty stack and remove a positive number of elements from the top of this stack. However, Tweedle-Dee may only choose a stack with $0$ at the top (and remove elements from it afterwards), and similarly, Tweedle-Dum may only choose a stack with $1$ at the top. the player that cannot make a move loses\nSuzumo does not want to wait for the end of the game, so given the starting player he asks you to determine the winner. Remember that Tweedle-Dee and Tweedle-Dum are legendary grandmasters of combinatorial games, so both always play optimally.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains an integer $N$, a string $S$ denoting the number of stacks, the player that starts the game, respectively.\n- Each of the following $N$ lines contains a single binary string $B$ representing a stack; the first character of $B$ corresponds to the top element of the stack and the last character to the bottom element.\n\n-----Output-----\nFor each test case, print a single line containing the string \"Dee\" if Tweedle-Dee wins the match or \"Dum\" if Tweedle-Dum wins.\n\n-----Constraints-----\n- $1 \\le T \\le 500$\n- $1 \\le N \\le 50$\n- $1 \\le |B| \\le 50$\n- each character in $B$ is either '1' or '0'\n- $S$ is either \"Dee\" or \"Dum\"\n\n-----Example Input-----\n2\n2 Dee\n101\n010\n2 Dum\n101\n010\n\n-----Example Output-----\nDum\nDee\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_binary_nim (n : Nat) (starting_player : Player) (stacks : List String) : Player :=\n  sorry", "vc-theorems": "theorem solve_binary_nim_returns_valid_player\n  (n : Nat)\n  (starting_player : Player)\n  (stacks : List String)\n  : (solve_binary_nim n starting_player stacks = Player.Dee) ∨\n    (solve_binary_nim n starting_player stacks = Player.Dum) := sorry\n\ntheorem solve_binary_nim_deterministic\n  (n : Nat)\n  (starting_player : Player)\n  (stacks : List String)\n  : solve_binary_nim n starting_player stacks = \n    solve_binary_nim n starting_player stacks := sorry\n\ntheorem solve_binary_nim_equal_zeros_ones_starting_player_loses\n  (n : Nat)\n  (starting_player : Player)\n  (stacks : List String)\n  (h : (stacks.foldl (fun acc s => acc + (s.toList.filter (· = '0')).length) 0) =\n       (stacks.foldl (fun acc s => acc + (s.toList.filter (· = '1')).length) 0))\n  : solve_binary_nim n starting_player stacks ≠ starting_player := sorry\n\n/-\ninfo: 'Dum'\n-/\n-- #guard_msgs in\n-- #eval solve_binary_nim 2 \"Dee\" [\"101\", \"010\"]\n\n/-\ninfo: 'Dee'\n-/\n-- #guard_msgs in\n-- #eval solve_binary_nim 2 \"Dum\" [\"101\", \"010\"]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0912", "language": "lean", "source": "fvapps", "source-id": "fvapps_000912", "source-notes": "", "vc-description": "/-\nChef loves lucky numbers. Everybody knows that lucky numbers are positive integers whose decimal representation contains only the lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.\n\nLet F(X) equals to the number of lucky digits in decimal representation of X. Chef wants to know the number of such integers X, that L ≤ X ≤ R and F(X) is a lucky number. Help him and calculate that number modulo 109+7.\n\n-----Input-----\nFirst line contains one integer T, the number of test cases. Each of the following T lines contains two space separated positive integers L and R.\n\n-----Output-----\nFor each of the T test cases print one integer, the number of such X, that L ≤ X ≤ R and F(X) is a lucky number, modulo 1000000007.\n\n-----Constraints-----\n\n1 ≤ T ≤ 10\n\n1 ≤ L ≤ R ≤ 101000\n\n-----Example-----\nInput:\n4\n1 100\n1 10000\n1 100000\n4444 4447\n\nOutput:\n0\n16\n640\n2\n\n-----Notes-----\nFirst test case: of course, any number of less than 4 digits can't contain lucky number of lucky digits, so the answer is 0.\n\nSecond test case: 16 required numbers are 4444 4447 4474 4477 4744 4747 4774 4777 7444 7447 7474 7477 7744 7747 7774 7777.\n\nThird test case: there are 640 required lucky numbers. Some of them are 4474, 14747, 41474, 77277, 44407, 74749.\n\nFourth test case: the only two required numbers are 4444 and 4447.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_lucky_numbers (left right : String) : Nat := sorry\n\ntheorem solve_lucky_numbers_range {left right : String} \n  (h1 : ∀ c ∈ left.data, c.isDigit)\n  (h2 : ∀ c ∈ right.data, c.isDigit)\n  (h3 : left.length > 0)\n  (h4 : right.length > 0)\n  (h5 : left.toNat? = some (l : Nat))\n  (h6 : right.toNat? = some (r : Nat))\n  (h7 : l ≤ 10^9)\n  (h8 : r ≤ 10^9)\n  : solve_lucky_numbers left right ≤ 10^9 + 7 := sorry", "vc-theorems": "theorem solve_lucky_numbers_identical_input {n : String}\n  (h1 : ∀ c ∈ n.data, c.isDigit) \n  (h2 : n.length > 0)\n  (h3 : n.toNat? = some (num : Nat))\n  (h4 : num ≤ 10^9)\n  : solve_lucky_numbers n n ≤ 1 := sorry\n\ntheorem solve_lucky_numbers_invalid_input_left {n right : String}\n  (h1 : ∃ c ∈ n.data, !c.isDigit)\n  (h2 : ∀ c ∈ right.data, c.isDigit)\n  : solve_lucky_numbers n right = 0 := sorry\n\ntheorem solve_lucky_numbers_invalid_input_right {left n : String}\n  (h1 : ∀ c ∈ left.data, c.isDigit)\n  (h2 : ∃ c ∈ n.data, !c.isDigit)\n  : solve_lucky_numbers left n = 0 := sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval solve_lucky_numbers \"1\" \"100\"\n\n/-\ninfo: 16\n-/\n-- #guard_msgs in\n-- #eval solve_lucky_numbers \"1\" \"10000\"\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve_lucky_numbers \"4444\" \"4447\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0915", "language": "lean", "source": "fvapps", "source-id": "fvapps_000915", "source-notes": "", "vc-description": "/-\nYou are given $N$ integers in an array: $A[1], A[2], \\ldots, A[N]$. You also have another integer $L$.\nConsider a sequence of indices ($i_1, i_2, \\ldots, i_k$). Note that a particular index can occur multiple times in the sequence, and there is no order in which these indices have to occur. ($i_1, i_2, \\ldots, i_k$) is a sequence of size $k$. It is said to be an $Interesting$ sequence, if $A[i_1] \\ge A[i_2] \\ge \\ldots \\ge A[i_k]$.\nThe $Cost$ of an Interesting sequence ($i_1, i_2, \\ldots, i_k$), is defined to be the minimum absolute difference between any two adjacent indices. In other words, the Cost is $min \\{ |i_2 - i_1|, |i_3 - i_2|, \\ldots, |i_k - i_{k-1}| \\}$.\nYour job is to consider the Costs of all the Interesting sequences of size $L$ associated with the given array, and output the maximum Cost. Note that you can show that there is always at least one Interesting sequence for the given constraints.\n\n-----Input-----\n- The first line contains a single integer, $T$, which is the number of testcases. The description of each testcase follows.\n- The first line of each testcase contains two space separated integers: $N$ and $L$.\n- The second line of each testcase contains $N$ space separated integers: $A[1], A[2], \\ldots, A[N]$.\n\n-----Output-----\n- For each testcase, output the answer in a new line.\n\n-----Constraints-----\n- $1 \\leq T \\leq 3$\n- $1 \\leq A[i] \\leq 10^9$\n- $2 \\leq L \\leq 10^9$\n\n-----Subtasks-----\n- Subtask 1: 7 points\n- It is guaranteed that $A[1] > A[2] > \\ldots > A[N]$\n- Note that the above condition implies that all elements are distinct.\n- $1 \\leq N \\leq 500$\n- Subtask 2: 7 points\n- It is guaranteed that $A[1] \\ge A[2] \\ge \\ldots \\ge A[N]$\n- $1 \\leq N \\leq 500$\n- Subtask 3: 14 points\n- It is guaranteed that all elements are distinct.\n- $1 \\leq N \\leq 500$\n- Subtask 4: 14 points\n- $1 \\leq N \\leq 500$\n- Subtask 5: 25 points\n- It is guaranteed that all elements are distinct.\n- $1 \\leq N \\leq 3000$\n- Subtask 6: 33 points\n- $1 \\leq N \\leq 3000$\n\n-----Sample Input-----\n1\n6 3\n2 4 1 12 3 5\n\n-----Sample Output-----\n3\n\n-----Explanation-----\nWe are looking for Interesting sequences of length 3. Some of them are:\n- (4, 2, 3): This is Interesting because $A[4] \\ge A[2] \\ge A[3]$. Its cost is $min \\{ |2-4|, |3-2|\\} = 1$.\n- (5, 1, 1): Cost is 0.\n- (2, 2, 2): Cost is 0.\n- (6, 1, 3): Cost is 2.\n- (6, 2, 5): Cost is 3.\nThere are other Interesting Sequences of length 3 as well. But if you list them all out, you'll see that the maximum Cost is 3. Hence the answer is 3.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_interesting_sequence (n : Nat) (l : Nat) (arr : List Nat) : Nat := sorry\n\ntheorem sequence_properties {n : Nat} {l : Nat} {arr : List Nat} \n  (hn : n > 0) (hl : l > 0) (harr : arr.length = n) (hbound : ∀ x ∈ arr, x > 0 ∧ x ≤ 100) :\n  let result := solve_interesting_sequence n l arr;\n  -- Result is non-negative\n  result ≥ 0  \n  -- Result is bounded by array length\n  ∧ result ≤ n\n  -- Result is at least the max distance between duplicates\n  ∧ ∀ (x : Nat) (pos₁ pos₂ : Nat),\n    let indices : List (Nat × Nat) := List.enumFrom 1 arr;\n    let positions := List.filterMap (fun p => if p.2 = x then some p.1 else none) indices;\n    pos₁ ∈ positions →\n    pos₂ ∈ positions →\n    pos₁ ≠ pos₂ →\n    result ≥ (max pos₁ pos₂ - min pos₁ pos₂) := by sorry", "vc-theorems": "theorem base_case : solve_interesting_sequence 1 1 [5] = 0 := by sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval solve_interesting_sequence 6 3 [2, 4, 1, 12, 3, 5]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval solve_interesting_sequence 4 2 [5, 5, 5, 5]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve_interesting_sequence 5 3 [1, 2, 3, 4, 5]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0929", "language": "lean", "source": "fvapps", "source-id": "fvapps_000929", "source-notes": "", "vc-description": "/-\nTired of the overpopulated world, Miu - The introverted cat visits a new continent in search for a new house.  \nThere are $N$ houses lying on the X-axis.\n\nTheir positions are given by $X$$i$ , where $i$ refers to the $i$th house. ( $1 <= i <= N$ )\n\nEach of these positions are pairwise distinct \nMiu is supposed to choose one of these houses for herself.\n\nMiu defines a term - The Distance of Peace,  as the minimum distance from her house to any other house.  \nMiu wonders what is maximum Distance of Peace she can obtain. Can you help her?\n\n-----Input:-----\n- The first line of the input consists of a single integer $T$, denoting the number of test cases  \n- The first line of each test case consists of a single integer $N$ \n- The second line of each test case consists of $N$ space-separated integers\n$X$$1$ $X$$2$ $X$$3$ … $X$$N$\n\n-----Output:-----\n- For each test case print the answer in a single line, the maximum Distance of Peace Miu can obtain\n\n-----Constraints-----\n- 1 <= $T$ <= 100  \n- 2 <= $N$ <= 105 \n- -109 <= $X$$i$ <= 109 \n- Sum of $N$ over all test cases does not exceed 106 \n\n-----Subtasks-----\nSubtask #1 (30 points): \n- $N$ <= 103 \nSubtask #2 (70 points): \n- Original Constraints\n\n-----Sample Input:-----\n2\n\n6\n\n7 -1 2 13 -5 15\n\n4\n\n6 10 3 12  \n\n-----Sample Output:-----\n5\n\n3  \n\n-----EXPLANATION:-----\nTest Case 1:\n\nThe $1$st house has the maximum Distance of Peace, which is from the $3$rd house:\n$| 7 - 2 | = 5$\n\nHence, the answer is $5$\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_peace_distance (houses : List Int) : Int := sorry\n\ntheorem peace_distance_nonnegative (houses : List Int) \n  (h : houses.length ≥ 2) :\n  find_max_peace_distance houses ≥ 0 := sorry", "vc-theorems": "theorem peace_distance_upper_bound (houses : List Int)\n  (h : houses.length ≥ 2) :\n  find_max_peace_distance houses ≤ (List.maximum? houses).getD 0 - (List.minimum? houses).getD 0 := sorry\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval find_max_peace_distance [7, -1, 2, 13, -5, 15]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval find_max_peace_distance [6, 10, 3, 12]\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval find_max_peace_distance [-5, 0, 10]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0933", "language": "lean", "source": "fvapps", "source-id": "fvapps_000933", "source-notes": "", "vc-description": "/-\nThe chef has one array of N natural numbers (might be in sorted order). Cheffina challenges chef to find the total number of inversions in the array.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains two lines of input, $N$.\n- N space-separated natural numbers. \n\n-----Output:-----\nFor each test case, output in a single line answer as the total number of inversions.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 10^5$\n- $1 \\leq arr[i] \\leq 10^5$\n\n-----Sample Input:-----\n1\n5\n5 4 1 3 2\n\n-----Sample Output:-----\n8\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countInversions (arr : List Int) : Nat := sorry\n\ntheorem empty_or_single_zero {arr : List Int} :\n  arr.length ≤ 1 → countInversions arr = 0 := sorry", "vc-theorems": "theorem sorted_zero {arr : List Int} (h : Sorted Int arr (. ≤ .)) :\n  countInversions arr = 0 := sorry\n\ntheorem count_nonnegative {arr : List Int} :\n  countInversions arr ≥ 0 := sorry\n\ntheorem count_bounded {arr : List Int} :\n  countInversions arr ≤ (arr.length * (arr.length - 1)) / 2 := sorry\n\ntheorem increasing_zero {arr : List Int} (h : Sorted Int arr (. < .)) :\n  countInversions arr = 0 := sorry\n\ntheorem decreasing_triangular {arr : List Int} (h : Sorted Int arr (fun x y => y < x)) :\n  let n := arr.length - 1\n  countInversions arr = (n * (n + 1)) / 2 := sorry\n\n/-\ninfo: 8\n-/\n-- #guard_msgs in\n-- #eval count_inversions [5, 4, 1, 3, 2]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval count_inversions [1, 2, 3, 4, 5]\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval count_inversions [5, 4, 3, 2, 1]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0938", "language": "lean", "source": "fvapps", "source-id": "fvapps_000938", "source-notes": "", "vc-description": "/-\nSince due to COVID 19, India has undergone a complete 21 day lockdown. So Amol was attending an online lecture where his professor asked him to solve a question. Amol was unable to solve the question so he asked you to solve the question and give him the correct answer. \n\nThe question was asked a such that his professor gave him a number M and a list of integers of length N (i.e. A1, A2,..... AN) and you have to find out all the subsets that add up to M and the total number of subsets will be the final answer. \n\nInput: \n• The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows. \n\n• The first line of each test case contains a single integer N. \n\n• The second line of each test case contains a single integer M. \n\n• The third line contains N space-separated integers A1, A2,..... AN. \n\nOutput: \nFor each test case, print a single line containing one integer ― the no. of subsets that adds upto M.\n\nConstraints: \n• 1≤T≤5\n\n• 1≤N≤100 \n\n• 10≤M≤100 \n\n• 1≤Ai≤100\n\nExampleInput:\n\n2\n\n4\n\n16\n\n2 4 6 10 \n\n4 \n\n20 \n\n2 8 12 10 \n\nOutput:\n\n2\n\n2\n\nExplanation:\nIn the 1st example there are two subsets {2,4,10} and {6,10} that adds upto 16 so the output is 2.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countsubsetsum (target : Nat) (arr : List Nat) : Nat := sorry\n\ndef List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + List.sum xs", "vc-theorems": "theorem zero_sum_always_has_one_solution {arr : List Nat} : \n  countsubsetsum 0 arr = 1 := sorry\n\ntheorem single_element_sums {arr : List Nat} {x : Nat} :\n  x ∈ arr → countsubsetsum x arr ≥ 1 := sorry\n\ntheorem results_non_negative {target : Nat} {arr : List Nat} :\n  countsubsetsum target arr ≥ 0 := sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve_test_case 4 16 [2, 4, 6, 10]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve_test_case 4 20 [2, 8, 12, 10]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0940", "language": "lean", "source": "fvapps", "source-id": "fvapps_000940", "source-notes": "", "vc-description": "/-\nYou might have heard about our new goodie distribution program aka the \"Laddu Accrual System\". This problem is designed to give you a glimpse of its rules. You can read the page once before attempting the problem if you wish, nonetheless we will be providing all the information needed here itself. \n\nLaddu Accrual System is our new goodie distribution program. In this program, we will be distributing Laddus in place of goodies for your winnings and various other activities (described below), that you perform on our system. Once you collect enough number of Laddus, you can then redeem them to get yourself anything from a wide range of CodeChef goodies.  \n\nLet us know about various activities and amount of laddus you get corresponding to them.\n\n- Contest Win (CodeChef’s Long, Cook-Off, LTIME, or any contest hosted with us) : 300 + Bonus (Bonus = 20 - contest rank). Note that if your rank is > 20, then you won't get any bonus.\n- Top Contributor on Discuss : 300\n- Bug Finder\t: 50 - 1000 (depending on the bug severity). It may also fetch you a CodeChef internship! \n- Contest Hosting\t : 50 \n\nYou can do a checkout for redeeming laddus once a month. The minimum laddus redeemable at Check Out are 200 for Indians and 400 for the rest of the world.\n\nYou are given history of various activities of a user. The user has not redeemed any of the its laddus accrued.. Now the user just wants to redeem as less amount of laddus he/she can, so that the laddus can last for as long as possible. Find out for how many maximum number of months he can redeem the laddus.\n\n-----Input-----\n- The first line of input contains a single integer T denoting number of test cases\n- For each test case:\n\n- First line contains an integer followed by a string denoting activities, origin respectively, where activities denotes number of activities of the user, origin denotes whether the user is Indian or the rest of the world. origin can be \"INDIAN\" or \"NON_INDIAN\".\n- For each of the next activities lines, each line contains an activity. \n\n\t\t\tAn activity can be of four types as defined above. \n\n- Contest Win : Input will be of form of CONTEST_WON rank, where rank denotes the rank of the user. \n- Top Contributor : Input will be of form of TOP_CONTRIBUTOR.\n- Bug Finder : Input will be of form of BUG_FOUND severity, where severity denotes the severity of the bug. \n- Contest Hosting : Input will be of form of CONTEST_HOSTED.\n\n-----Output-----\n- For each test case, find out the maximum number of months for which the user can redeem the laddus accrued.\n\n-----Constraints-----\n- 1 ≤ T, activities ≤ 100\n- 1 ≤ rank ≤ 5000\n- 50 ≤ severity ≤ 1000\n\n-----Subtasks-----\nThere is only a single subtask with 100 points.\n\n-----Example-----\nInput:\n2\n4 INDIAN\nCONTEST_WON 1\nTOP_CONTRIBUTOR\nBUG_FOUND 100\nCONTEST_HOSTED\n4 NON_INDIAN\nCONTEST_WON 1\nTOP_CONTRIBUTOR\nBUG_FOUND 100\nCONTEST_HOSTED\n\nOutput:\n3\n1\n\n-----Explanation-----\nIn the first example, \n\n- For winning contest with rank 1, user gets 300 + 20 - 1 = 319 laddus. \n- For top contributor, user gets 300 laddus. \n- For finding a bug with severity of 100, user gets 100 laddus. \n- For hosting a contest, user gets 50 laddus. \n\nSo, overall user gets 319 + 300 + 100 + 50 = 769 laddus.\nNow, the user is an Indian user, he can redeem only 200 laddus per month. So, for first three months, he will redeem 200 * 3 = 600 laddus. The remaining 169 laddus, he can not redeem as he requires at least 200 laddues in a month to redeem. \n\nSo, answer is 3.\n\nIn the second example, user is a non-Indian user, he can redeem 400 laddues per month. So, in the first month, he will redeem 400 laddus. The remaining 369 laddus, he can not redeem as he requires at least 400 laddues in a month to redeem. \n\nSo, answer is 1.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Activity := String × Nat\n\ndef calculate_max_months (input : List String) : List Nat :=\n  sorry", "vc-theorems": "theorem multiple_test_cases_properties\n  (n : Nat)\n  (h : n > 0 ∧ n ≤ 5) :\n  let result := calculate_max_months ([toString n] ++ \n    (List.range n).bind (fun i => \n      [s!\"1 {if i % 2 = 0 then \"INDIAN\" else \"NON_INDIAN\"}\", \n       \"BUG_FOUND 1000\"]))\n  result.length = n ∧\n  (∀ i, i < n → result[i]! > 0) ∧\n  (∀ i, 0 < i → i < n → i % 2 = 1 → result[i]! ≤ result[i-1]!) :=\nsorry\n\ntheorem contest_won_rank_bonus\n  (rank : Nat)\n  (h : rank > 0 ∧ rank ≤ 20) :\n  let result := calculate_max_months [\"1\", \"2 INDIAN\", s!\"CONTEST_WON {rank}\", \"CONTEST_WON 21\"]\n  let worse_result := calculate_max_months [\"1\", \"2 INDIAN\", \"CONTEST_WON 21\", \"CONTEST_WON 21\"]\n  result[0]! ≥ worse_result[0]! :=\nsorry\n\n/-\ninfo: [3, 1]\n-/\n-- #guard_msgs in\n-- #eval calculate_max_months [\"2\", \"4 INDIAN\", \"CONTEST_WON 1\", \"TOP_CONTRIBUTOR\", \"BUG_FOUND 100\", \"CONTEST_HOSTED\", \"4 NON_INDIAN\", \"CONTEST_WON 1\", \"TOP_CONTRIBUTOR\", \"BUG_FOUND 100\", \"CONTEST_HOSTED\"]\n\n/-\ninfo: [3]\n-/\n-- #guard_msgs in\n-- #eval calculate_max_months [\"1\", \"2 INDIAN\", \"CONTEST_WON 5\", \"TOP_CONTRIBUTOR\"]\n\n/-\ninfo: [2]\n-/\n-- #guard_msgs in\n-- #eval calculate_max_months [\"1\", \"1 NON_INDIAN\", \"BUG_FOUND 1000\"]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0945", "language": "lean", "source": "fvapps", "source-id": "fvapps_000945", "source-notes": "", "vc-description": "/-\nMr. Pr and Ms. Ad are at $a$ and $b$ respectively on an infinite number line. Mr. Pr wants to meet Ms. Ad.\nMr. Pr can choose to move  $c$ or $d$ units in 1 second. If Mr. Pr moves $c$ units then Ms. Ad will move $d$ units and vice versa. (Both of them always moved in positive x-direction)\nYou have to determine if Mr. Pr can meet with Ms. Ad after some integral amount of time, given that Mr. Pr chooses optimally. Note that meeting after a fractional amount of time does not count.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains four space separated integers, $a$, $b$, $c$, and $d$.\n\n-----Output:-----\n- For each test case, output a single line containing \"YES\" if Mr. Pr meets with Ms. Ad, otherwise \"NO\".\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^5$\n- $1 \\leq a,b,c,d \\leq 10^9$\n\n-----Sample Input:-----\n2\n3 4 1 2\n10 20 3 7\n\n-----Sample Output:-----\nYES\nNO\n\n-----Explanation:-----\nIn the first test case, Mr. Pr will move 2 units in the first second and Ms. Ad moves 1 unit simultaneously and they meet. \nIn the second test case, it is impossible to meet (fractional time is not allowed).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_meet (pos1 pos2 speed1 speed2 : Int) : String :=\n  sorry", "vc-theorems": "theorem same_positions_always_meets (pos : Int) :\n  can_meet pos pos speed1 speed2 = \"YES\" := by sorry\n\ntheorem same_speeds_never_meets (pos1 pos2 speed : Int) :\n  pos1 ≠ pos2 → can_meet pos1 pos2 speed speed = \"NO\" := by sorry\n\ntheorem meeting_requires_divisible_difference \n  (pos1 pos2 speed1 speed2 : Int)\n  (h1 : speed1 ≠ speed2)\n  (h2 : (pos1 - pos2).natAbs % (speed1 - speed2).natAbs = 0) :\n  can_meet pos1 pos2 speed1 speed2 = \"YES\" := by sorry\n\ntheorem meeting_impossible_if_not_divisible\n  (pos1 pos2 speed1 speed2 : Int)\n  (h1 : speed1 ≠ speed2) \n  (h2 : (pos1 - pos2).natAbs % (speed1 - speed2).natAbs ≠ 0) :\n  can_meet pos1 pos2 speed1 speed2 = \"NO\" := by sorry\n\n/-\ninfo: 'YES'\n-/\n-- #guard_msgs in\n-- #eval can_meet 3 4 1 2\n\n/-\ninfo: 'NO'\n-/\n-- #guard_msgs in\n-- #eval can_meet 10 20 3 7\n\n/-\ninfo: 'YES'\n-/\n-- #guard_msgs in\n-- #eval can_meet 5 5 2 3", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0958", "language": "lean", "source": "fvapps", "source-id": "fvapps_000958", "source-notes": "", "vc-description": "/-\nBack in 2015, Usain Bolt announced that he'll be retiring after the 2017 World Championship. Though his final season did not end gloriously, we all know that he is a true legend and we witnessed his peak during 2008 - 2013. \nPost retirement, Usain Bolt is still leading an adventurous life. He's exploring the unexplored parts of the globe. But sometimes he gets bored, and reads questions asked about him on Quora. One such question he read was, \"Who would win a race between Usain Bolt and a tiger if the race is on a straight line track and the tiger is $distancetoBolt$ meters behind Bolt? The finishing point is $finish$ meters away from Bolt's starting position. The tiger starts with an initial speed of $0$ $meter/second$, and will accelerate itself with $tigerAccelaration$ $m/s^2$. Bolt can run with a constant speed of $boltSpeed$ $m/s$ from start to finish. Given these values, find out who will win the race - Bolt or the tiger? \"\nNote that Bolt will win the race if and only if he touches the finishing line before the tiger touches it. If both of them finish together, the tiger is announced as the winner since Bolt was given an initial advantage. See the figure below for more clarity.\n\nSince Bolt was busy practicing in the tracks during his Physics school classes, he is asking for your help to solve the question. Can you please help him?\nHe just remembers two formulae from the class, and thinks that they will be useful to you:\n$Displacement (S) $ = $ut$ +$ (1/2)at^2$ where $u$ is the initial velocity , #$ $is the acceleration and $t$ is the time taken.\n$Velocity$ = $Displacement /Time$\n\n-----Input:-----\n- The first line will contain $T$, the number of testcases. Then the description of each test case follow. \n- Each test case contains 4 integers $finish, distancetoBolt, tigerAccelaration, boltSpeed$. \n\n-----Output:-----\nFor each testcase, output in a single line, the word \"Bolt\" or \"Tiger\" without quotes, depending on whether Bolt wins or the tiger wins.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100000$\n- $1 \\leq finish\\leq 10^5$\n- $1 \\leq distancetoBolt\\leq 10^5$\n- $1 \\leq tigerAccelaration\\leq 10^5$\n- $1 \\leq boltSpeed\\leq 10^5$\n\n-----Sample Input:-----\n2\n10 100 10 10\n100 10 5 10\n\n-----Sample Output:-----\nBolt\nTiger\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def race_winner (finish : Float) (distance_to_bolt : Float) (tiger_acceleration : Float) (bolt_speed : Float) : String := sorry\n\ntheorem race_winner_returns_valid_result (finish : Float) (distance_to_bolt : Float) (tiger_acceleration : Float) (bolt_speed : Float)\n    (h1 : finish > 0) \n    (h2 : distance_to_bolt > 0)\n    (h3 : tiger_acceleration > 0)\n    (h4 : bolt_speed > 0) :\n    (race_winner finish distance_to_bolt tiger_acceleration bolt_speed = \"Bolt\" ∨\n     race_winner finish distance_to_bolt tiger_acceleration bolt_speed = \"Tiger\") := sorry", "vc-theorems": "theorem race_winner_correct_winner (finish : Float) (distance_to_bolt : Float) (tiger_acceleration : Float) (bolt_speed : Float)\n    (h1 : finish > 0)\n    (h2 : distance_to_bolt > 0)\n    (h3 : tiger_acceleration > 0) \n    (h4 : bolt_speed > 0) :\n    let tiger_time := Float.sqrt (2 * (finish + distance_to_bolt) / tiger_acceleration);\n    let bolt_time := finish / bolt_speed;\n    (race_winner finish distance_to_bolt tiger_acceleration bolt_speed = \"Bolt\" → tiger_time > bolt_time) ∧\n    (race_winner finish distance_to_bolt tiger_acceleration bolt_speed = \"Tiger\" → tiger_time ≤ bolt_time) := sorry\n\ntheorem infinite_acceleration_tiger_wins (finish : Float) (distance_to_bolt : Float) (bolt_speed : Float)\n    (h1 : finish > 0)\n    (h2 : distance_to_bolt > 0)\n    (h3 : bolt_speed > 0)\n    (h4 : tiger_acceleration > 1000000) :\n    race_winner finish distance_to_bolt tiger_acceleration bolt_speed = \"Tiger\" := sorry\n\n/-\ninfo: 'Bolt'\n-/\n-- #guard_msgs in\n-- #eval race_winner 10 100 10 10\n\n/-\ninfo: 'Tiger'\n-/\n-- #guard_msgs in\n-- #eval race_winner 100 10 5 10\n\n/-\ninfo: 'Tiger'\n-/\n-- #guard_msgs in\n-- #eval race_winner 50 50 5 5", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0969", "language": "lean", "source": "fvapps", "source-id": "fvapps_000969", "source-notes": "", "vc-description": "/-\nYou are given an N × N grid initially filled by zeros. Let the rows and columns of the grid be numbered from 1 to N, inclusive. There are two types of operations can be applied to the grid:\n\n- RowAdd R X: all numbers in the row R should be increased by X.\n- ColAdd C X: all numbers in the column C should be increased by X.\n\nNow after performing the sequence of such operations you need to find the maximum element in the grid.\n\n-----Input-----\nThe first line of the input contains two space separated integers N and Q denoting the size of the grid and the number of performed operations respectively. Each of the following Q lines describe an operation in the format described above.\n\n-----Output-----\nOutput a single line containing the maximum number at the grid after performing all the operations.\n\n-----Constraints-----\n- 1 ≤ N ≤ 314159\n- 1 ≤ Q ≤ 314159\n- 1 ≤ X ≤ 3141\n- 1 ≤ R, C ≤ N\n\n-----Example-----\nInput:\n2 4\nRowAdd 1 3\nColAdd 2 1\nColAdd 1 4\nRowAdd 2 1\n\nOutput:\n7\n\n-----Explanation-----\nThe grid changes as follows:\n00  33  34  74  74\n00  00  01  41  52\n\nThe maximum number in the final grid is 7.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_after_operations (n: Nat) (ops: List Operation) : Nat :=\n  sorry", "vc-theorems": "theorem empty_ops_is_zero (n: Nat) : \n  find_max_after_operations n [] = 0 :=\n  sorry\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval find_max_after_operations 2 [\"RowAdd 1 3\", \"ColAdd 2 1\", \"ColAdd 1 4\", \"RowAdd 2 1\"]\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval find_max_after_operations 3 [\"RowAdd 1 5\", \"ColAdd 3 2\", \"RowAdd 2 4\"]\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval find_max_after_operations 1 [\"RowAdd 1 3\", \"ColAdd 1 2\"]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF0986", "language": "lean", "source": "fvapps", "source-id": "fvapps_000986", "source-notes": "", "vc-description": "/-\nChef recently started working at ABC corporation. Let's number weekdays (Monday through Friday) by integers $1$ through $5$. For each valid $i$, the number of hours Chef spent working at the office on weekday $i$ was $A_i$.\nUnfortunately, due to the COVID-19 pandemic, Chef started working from home and his productivity decreased by a considerable amount. As per Chef's analysis, $1$ hour of work done at the office is equivalent to $P$ hours of work done at home.\nNow, in order to complete his work properly, Chef has to spend more hours working from home, possibly at the cost of other things like sleep. However, he does not have to do the same work on each day as he would have in the office ― for each weekday, he can start the work for this day on an earlier day and/or complete it on a later day. The only requirement is that his work does not pile up indefinitely, i.e. he can complete his work for each week during the same week. One day has $24$ hours.\nIf Chef is unable to complete his work for a week during those five weekdays, then he has to work during the weekend too. Chef wishes to know whether he has to work on weekends or if he can complete his work by working only on weekdays. Help him answer that question. (It is possible that Chef would be unable to finish his work even if he worked all the time, but he does not want to know about that.)\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains six space-separated integers $A_1$, $A_2$, $A_3$, $A_4$, $A_5$ and $P$.\n\n-----Output-----\nFor each test case, print a single line containing the string \"Yes\" if Chef has to work on weekends or \"No\" otherwise (without quotes).\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $0 \\le A_i \\le 24$ for each valid $i$\n- $1 \\le P \\le 24$\n\n-----Subtasks-----\nSubtask #1 (100 points): original constraints\n\n-----Example Input-----\n2\n14 10 12 6 18 2\n10 10 10 10 10 3\n\n-----Example Output-----\nNo\nYes\n\n-----Explanation-----\nExample case 1: Here, $P=2$, so the number of hours Chef has to work from home to handle his workload for days $1$ through $5$ is $[28,20,24,12,36]$. If he works for full $24$ hours on each of the five weekdays, he finishes all the work, so he does not have to work on weekends.\nExample case 2: No matter what Chef does, he will have to work on weekends.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def List.sum (xs : List Nat) : Nat := sorry\n\ndef must_work_weekends (hours : List Nat) (productivity : Nat) : Bool := sorry", "vc-theorems": "theorem must_work_weekends_returns_bool (hours : List Nat) (productivity : Nat) :\n  must_work_weekends hours productivity = true ∨ must_work_weekends hours productivity = false := sorry\n\ntheorem zero_hours_no_weekends (productivity : Nat) :\n  must_work_weekends [0,0,0,0,0] productivity = false := sorry\n\ntheorem increasing_productivity_monotone (hours : List Nat) (productivity : Nat) :\n  productivity > 0 →\n  must_work_weekends hours productivity = true →\n  must_work_weekends hours (productivity + 1) = true := sorry\n\ntheorem zero_productivity_no_weekends (hours : List Nat) :\n  must_work_weekends hours 0 = false := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1013", "language": "lean", "source": "fvapps", "source-id": "fvapps_001013", "source-notes": "", "vc-description": "/-\nYou're given an integer N. Write a program to calculate the sum of all the digits of N. \n\n-----Input-----\n\nThe first line contains an integer T, the total number of testcases. Then follow T lines, each line contains an integer N. \n\n-----Output-----\nFor each test case, calculate the sum of digits of N, and display it in a new line.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ N ≤ 1000000\n\n-----Example-----\nInput\n3 \n12345\n31203\n2123\nOutput\n15\n9\n8\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + List.sum xs\n\ndef sumDigits (n : Nat) : Nat :=\n  sorry\n\ndef stringToNat (s : String) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def dropDigits (s : String) (i : Nat) : String :=\n  s.drop i", "vc-theorems": "theorem sum_digits_non_negative (n : Nat) :\n  sumDigits n ≥ 0 := sorry\n\ntheorem sum_digits_upper_bound (n : Nat) :\n  sumDigits n ≤ n * (toString n).length := sorry \n\ntheorem sum_digits_single_digit (n : Nat) (h : n ≤ 9) :\n  sumDigits n = n := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1016", "language": "lean", "source": "fvapps", "source-id": "fvapps_001016", "source-notes": "", "vc-description": "/-\nChef bought a huge (effectively infinite) planar island and built $N$ restaurants (numbered $1$ through $N$) on it. For each valid $i$, the Cartesian coordinates of restaurant $i$ are $(X_i, Y_i)$.\nNow, Chef wants to build $N-1$ straight narrow roads (line segments) on the island. The roads may have arbitrary lengths; restaurants do not have to lie on the roads. The slope of each road must be $1$ or $-1$, i.e. for any two points $(x_1, y_1)$ and $(x_2, y_2)$ on the same road, $|x_1-x_2| = |y_1-y_2|$ must hold.\nLet's denote the minimum distance Chef has to walk from restaurant $i$ to reach a road by $D_i$. Then, let's denote $a = \\mathrm{max}\\,(D_1, D_2, \\ldots, D_N)$; Chef wants this distance to be minimum possible.\nChef is a busy person, so he decided to give you the job of building the roads. You should find a way to build them that minimises $a$ and compute $a \\cdot \\sqrt{2}$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- $N$ lines follow. For each valid $i$, the $i$-th of these lines contains two space-separated integers $X_i$ and $Y_i$.\n\n-----Output-----\nFor each test case, print a single line containing one real number — the minimum distance $a$ multiplied by $\\sqrt{2}$. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $2 \\le N \\le 10^4$\n- $|X_i|, |Y_i| \\le 10^9$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (10 points):\n- $1 \\le T \\le 10$\n- $2 \\le N \\le 5$\n- $|X_i|, |Y_i| \\le 10$ for each valid $i$\n- $a \\cdot \\sqrt{2}$ is an integer\nSubtask #2 (90 points): original constraints\n\n-----Example Input-----\n2\n3\n0 0\n0 1\n0 -1\n3\n0 1\n1 0\n-1 0\n\n-----Example Output-----\n0.5\n0\n\n-----Explanation-----\nExample case 1: We should build roads described by equations $y-x+0.5 = 0$ and $y-x-0.5 = 0$.\nExample case 2: We should build roads described by equations $y-x-1 = 0$ and $y+x-1 = 0$.\n-/", "vc-preamble": "def manhattan_distance (p1 p2 : Point) : Nat :=\n  let dx := (p1.x - p2.x).toNat\n  let dy := (p1.y - p2.y).toNat\n  dx + dy\n\ndef euclidean_distance (p1 p2 : Point) : Float :=\n  let dx := (p1.x - p2.x).toNat.toFloat\n  let dy := (p1.y - p2.y).toNat.toFloat\n  Float.sqrt (dx * dx + dy * dy)", "vc-helpers": "", "vc-definitions": "def solve_min_distance (n : Nat) (points : List Point) : Float :=\n  sorry", "vc-theorems": "theorem min_distance_nonnegativity {n : Nat} {points : List Point}\n  (h1 : n ≥ 2)\n  (h2 : points.length = n)\n  (h3 : points.Nodup) :\n  solve_min_distance n points ≥ 0 :=\nsorry\n\ntheorem min_distance_euclidean_bound {n : Nat} {points : List Point} \n  (h1 : n ≥ 2)\n  (h2 : points.length = n)\n  (h3 : points.Nodup) :\n  ∀ (i j : Fin points.length), i ≠ j →\n  solve_min_distance n points ≤ euclidean_distance (points.get i) (points.get j) / Float.sqrt 2 + 0.000001 :=\nsorry\n\ntheorem two_points_special_case {points : List Point}\n  (h1 : points.length = 2)\n  (h2 : points.Nodup)\n  (h3 : points.get ⟨0, h1.symm ▸ Nat.zero_lt_succ 1⟩ = ⟨x₁, y₁⟩)\n  (h4 : points.get ⟨1, h1.symm ▸ Nat.succ_lt_succ (Nat.zero_lt_succ 0)⟩ = ⟨x₂, y₂⟩)\n  (h5 : x₁ = x₂ ∨ y₁ = y₂) :\n  (solve_min_distance 2 points - (manhattan_distance ⟨x₁, y₁⟩ ⟨x₂, y₂⟩).toFloat / 2) ≤ 0.000001 ∧\n  ((manhattan_distance ⟨x₁, y₁⟩ ⟨x₂, y₂⟩).toFloat / 2 - solve_min_distance 2 points) ≤ 0.000001 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1037", "language": "lean", "source": "fvapps", "source-id": "fvapps_001037", "source-notes": "", "vc-description": "/-\nand Bengali as well.\nThere are N$N$ cats (numbered 1$1$ through N$N$) and M$M$ rats (numbered 1$1$ through M$M$) on a line. Each cat and each rat wants to move from some point to some (possibly the same) point on this line. Naturally, the cats also want to eat the rats when they get a chance. Both the cats and the rats can only move with constant speed 1$1$.\nFor each valid i$i$, the i$i$-th cat is initially sleeping at a point a_i$a_i$. At a time s_i$s_i$, this cat wakes up and starts moving to a final point b_i$b_i$ with constant velocity and without any detours (so it arrives at this point at the time e_i = s_i + |a_i-b_i|$e_i = s_i + |a_i-b_i|$). After it arrives at the point b_i$b_i$, it falls asleep again.\nFor each valid i$i$, the i$i$-th rat is initially hiding at a point c_i$c_i$. At a time r_i$r_i$, this rat stops hiding and starts moving to a final point d_i$d_i$ in the same way as the cats ― with constant velocity and without any detours, arriving at the time q_i = r_i + |c_i-d_i|$q_i = r_i + |c_i-d_i|$ (if it does not get eaten). After it arrives at the point d_i$d_i$, it hides again.\nIf a cat and a rat meet each other (they are located at the same point at the same time), the cat eats the rat, the rat disappears and cannot be eaten by any other cat. A sleeping cat cannot eat a rat and a hidden rat cannot be eaten ― formally, cat i$i$ can eat rat j$j$ only if they meet at a time t$t$ satisfying s_i \\le t \\le e_i$s_i \\le t \\le e_i$ and r_j \\le t \\le q_j$r_j \\le t \\le q_j$.\nYour task is to find out which rats get eaten by which cats. It is guaranteed that no two cats will meet a rat at the same time.\n\n-----Input-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\n- The first line of each test case contains two space-separated integers N$N$ and M$M$.\n- N$N$ lines follow. For each i$i$ (1 \\le i \\le N$1 \\le i \\le N$), the i$i$-th of these lines contains three space-separated integers a_i$a_i$, b_i$b_i$ and s_i$s_i$.\n- M$M$ more lines follow. For each i$i$ (1 \\le i \\le M$1 \\le i \\le M$), the i$i$-th of these lines contains three space-separated integers c_i$c_i$, d_i$d_i$ and r_i$r_i$.\n\n-----Output-----\nFor each test case, print M$M$ lines. For each valid i$i$, the i$i$-th of these lines should contain a single integer ― the number of the cat that will eat the i$i$-th rat, or -1$-1$ if no cat will eat this rat.\n\n-----Constraints-----\n- 1 \\le T \\le 10$1 \\le T \\le 10$\n- 0 \\le N \\le 1,000$0 \\le N \\le 1,000$\n- 1 \\le M \\le 1,000$1 \\le M \\le 1,000$\n- 1 \\le a_i, b_i, s_i \\le 10^9$1 \\le a_i, b_i, s_i \\le 10^9$ for each valid i$i$\n- 1 \\le c_i, d_i, r_i \\le 10^9$1 \\le c_i, d_i, r_i \\le 10^9$ for each valid i$i$\n- all initial and final positions of all cats and rats are pairwise distinct\n\n-----Example Input-----\n2\n8 7\n2 5 1\n1 4 1\n9 14 10\n20 7 9\n102 99 1\n199 202 1\n302 299 3\n399 402 3\n6 3 1\n10 15 10\n100 101 1\n201 200 1\n300 301 5\n401 400 5\n1000 1010 1020\n8 8\n2 8 2\n12 18 2\n22 28 4\n32 38 4\n48 42 2\n58 52 3\n68 62 1\n78 72 3\n3 6 3\n13 19 3\n21 25 3\n31 39 3\n46 43 4\n59 53 2\n65 61 4\n79 71 2\n\n-----Example Output-----\n1\n4\n5\n6\n7\n8\n-1\n1\n2\n3\n4\n5\n6\n7\n8\n-/", "vc-preamble": "def absInt (n : Int) : Int :=\n  if n ≥ 0 then n else -n", "vc-helpers": "", "vc-definitions": "def Animal.will_collide : Animal → Animal → Option Float := sorry\n\ndef solve : Int → Int → List (Int × Int × Int) → List (Int × Int × Int) → List Int := sorry", "vc-theorems": "theorem animal_init_properties (start endpoint starting_time : Int) (a : Animal) \n    (h : a = Animal.mk start endpoint starting_time sorry sorry sorry) :\n  a.ending_time = starting_time + absInt (start - endpoint) ∧\n  (a.velocity = 1 ∨ a.velocity = -1) ∧\n  (endpoint ≥ start → a.velocity = 1) ∧\n  (endpoint < start → a.velocity = -1) ∧\n  a.eaten_by = (Int.neg 1, 10000000000) := sorry\n\ntheorem solve_output_properties (n m : Int) (cats rats : List (Int × Int × Int)) \n    (hn : n > 0) (hm : m > 0) :\n  let result := solve n m cats rats\n  List.length result = m ∧ \n  ∀ r ∈ result, -1 ≤ r ∧ r ≤ n := sorry\n\ntheorem collision_symmetry (s1 e1 t1 s2 e2 t2 : Int) :\n  let a1 := Animal.mk s1 e1 t1 sorry sorry sorry\n  let a2 := Animal.mk s2 e2 t2 sorry sorry sorry\n  match a1.will_collide a2, a2.will_collide a1 with\n  | some x, some y => Float.abs (x - y) < 0.0000000001\n  | none, none => True\n  | _, _ => False := sorry\n\ntheorem self_collision (start endpoint time : Int) :\n  let animal := Animal.mk start endpoint time sorry sorry sorry\n  match animal.will_collide animal with\n  | some t => Float.toUInt64 t ≥ Float.toUInt64 (Float.ofInt time) ∧ \n              Float.toUInt64 t ≤ Float.toUInt64 (Float.ofInt animal.ending_time)  \n  | none => True := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1043", "language": "lean", "source": "fvapps", "source-id": "fvapps_001043", "source-notes": "", "vc-description": "/-\nYou are given an unweighted tree with N$N$ nodes (numbered 1$1$ through N$N$). Let's denote the distance between any two nodes p$p$ and q$q$ by d(p,q)$d(p, q)$.\nYou should answer Q$Q$ queries. In each query, you are given parameters a$a$, da$d_a$, b$b$, db$d_b$, and you should find a node x$x$ such that d(x,a)=da$d(x, a) = d_a$ and d(x,b)=db$d(x, b) = d_b$, or determine that there is no such node.\n\n-----Input-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\n- The first line of each test case contains two space-separated integers N$N$ and Q$Q$.\n- Each of the next N−1$N-1$ lines contains two space-separated integers u$u$ and v$v$ denoting that nodes u$u$ and v$v$ are connected by an edge.\n- Each of the next Q$Q$ lines contains four space-separated integers a$a$, da$d_a$, b$b$ and db$d_b$ describing a query.\n\n-----Output-----\nFor each query, print a single line containing one integer ― the number of a node satisfying the given requirements, or −1$-1$ if no such node exists.\nIf there are multiple solutions, you may output any one.\n\n-----Constraints-----\n- 1≤T≤1,000$1 \\le T \\le 1,000$\n- 1≤N,Q≤106$1 \\le N, Q \\le 10^6$\n- 1≤u,v≤N$1 \\le u, v \\le N$\n- the graph on the input is a tree\n- 1≤a,b≤N$1 \\le a, b \\le N$\n- 1≤da,db<N$1 \\le d_a, d_b < N$\n- the sum of N$N$ over all test cases does not exceed 106$10^6$\n- the sum of Q$Q$ over all test cases does not exceed 106$10^6$\n\n-----Subtasks-----\nSubtask #1 (50 points):\n- 1≤N,Q≤1,000$1 \\le N, Q \\le 1,000$\n- the sum of N$N$ over all test cases does not exceed 1,000$1,000$\n- the sum of Q$Q$ over all test cases does not exceed 1,000$1,000$\nSubtask #2 (50 points): original constraints\n\n-----Example Input-----\n1\n5 3\n1 2\n2 3\n3 4\n3 5\n2 1 4 1\n2 2 4 2\n1 1 2 1\n\n-----Example Output-----\n3\n5\n-1\n-/", "vc-preamble": "def find_nodes_with_distance (t : Tree) (node : Nat) (dist : Nat) : List Nat :=\n  sorry\n\ndef resolve_query (t : Tree) (a b c d : Nat) : Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def resolve_queries (t : Tree) (qs : List (Nat × Nat × Nat × Nat)) : List Int :=\n  sorry", "vc-theorems": "theorem queries_results_length_matches {t : Tree} {qs : List (Nat × Nat × Nat × Nat)} :\n  let results := resolve_queries t qs\n  List.length results = List.length qs := sorry\n\ntheorem results_are_valid_nodes_or_neg_one {t : Tree} {qs : List (Nat × Nat × Nat × Nat)} :\n  let results := resolve_queries t qs\n  ∀ r ∈ results, r = -1 ∨ (1 ≤ Int.toNat r ∧ Int.toNat r ≤ t.n) := sorry\n\ntheorem zero_distance_to_self {t : Tree} {node : Nat} :\n  node ≤ t.n →\n  find_nodes_with_distance t node 0 = [node] := sorry\n\ntheorem zero_distance_query {t : Tree} {a b : Nat} :\n  a ≤ t.n →\n  b ≤ t.n →\n  resolve_query t a 0 b 0 = if a = b then Int.ofNat a else -1 := sorry\n\ntheorem nodes_at_distance_unique {t : Tree} {node dist : Nat} :\n  node ≤ t.n →\n  let nodes := find_nodes_with_distance t node dist\n  List.Nodup nodes := sorry\n\ntheorem nodes_at_distance_valid {t : Tree} {node dist : Nat} :\n  node ≤ t.n →\n  let nodes := find_nodes_with_distance t node dist\n  ∀ n ∈ nodes, 1 ≤ n ∧ n ≤ t.n := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1048", "language": "lean", "source": "fvapps", "source-id": "fvapps_001048", "source-notes": "", "vc-description": "/-\n$Jaggu$ monkey a friend of $Choota$ $Bheem$ a great warrior of $Dholakpur$. He gets everything he wants. Being a friend of $Choota$ $Bheem$ he never has to struggle for anything, because of this he is in a great debt of $Choota$ $Bheem$, he really wants to pay his debt off.\nFinally the time has come to pay his debt off, $Jaggu$ is on a magical tree. He wants to collect apples from different branches but he is in a hurry. $Botakpur$ has attacked on $Dholakpur$ and $Bheem$ is severely injured, as been instructed by the village witch, $Bheem$ can only be saved by the apples of the magical tree. Each apple is placed in Tree Node structure and each apple has some sweetness. Now there's a problem as $Jaggu$ is also injured so he can only slide downwards and alse is collecting apples in his hand so he can't climb. You would be given $Q$ queries. Queries are of 2 type :-\n- \nEnding Node Node of $Jaggu$ is given. $format$ - type of query node -(1 2)\n- \nSweetness of Apple on a given node is changed. $format$ - type of query node new sweetness(2 3 10)\n$Note$: $Jaggu$ is always on the top of tree initially in each query.The sweetness is always positive.\nHelp $Jaggu$ in saving $Bheem$\n\n-----Input:-----\n- First line contains $N$ - (number of nodes).  \n- Next line contains $N$ integers with space giving sweetness of apple on Nodes $(1 to N)$\n- Next $N-1$ lines contain  $N1$ $N2$ connected nodes.\n- Next line contains single integer $Q$ Number of queries\n\n-----Output:-----\n- For each query of type 1, print total sweetness of apples. \n\n-----Constraints-----\n- $1 \\leq N \\leq 10^4$\n- $2 \\leq Q \\leq 10^4$\n\n-----Sample Input:-----\n10\n10 12 6 8 1 19 0 5 13 17\n1 2\n1 3\n1 4\n3 10\n4 8\n8 9\n4 5\n5 7\n5 6\n3\n1 1\n2 3 20\n1 8\n\n-----Sample Output:-----\n10\n23\n\n-----EXPLANATION:-----\nThis sweetness array is :\n$[10,2,6,8,1,19,0,5,13,17]$\nThe tree is:\n1   \n\n/  |   \\      \n\n2    3     4     \n\n/    /    \\      \n\n10     8        5   \n\n/        /    \\     \n\n9         7        6\n-/", "vc-preamble": "def solve_tree_queries (n : Nat) (sweetness : List Int) (edges : List (Nat × Nat))\n  (queries : List QueryType) : List Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def is_tree (n : Nat) (edges : List (Nat × Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem solve_tree_queries_outputs_len {n : Nat} {sweetness : List Int} \n  {edges : List (Nat × Nat)} {queries : List QueryType}\n  (h1 : sweetness.length = n)\n  (h2 : is_tree n edges = true) :\n  (solve_tree_queries n sweetness edges queries).length = \n  (queries.filter (fun q => match q with \n                           | QueryType.get _ => true\n                           | _ => false)).length :=\nsorry \n\ntheorem solve_tree_queries_outputs_integers {n : Nat} {sweetness : List Int}\n  {edges : List (Nat × Nat)} {queries : List QueryType} \n  {result : List Int}\n  (h1 : sweetness.length = n)\n  (h2 : is_tree n edges = true)\n  (h3 : result = solve_tree_queries n sweetness edges queries) :\n  ∀ x, x ∈ result → x ∈ sweetness ∨ ∃ q, q ∈ queries ∧ (\n    match q with\n    | QueryType.update _ v => v = x\n    | _ => False\n  ) :=\nsorry\n\ntheorem solve_tree_queries_idempotent {n : Nat} {sweetness : List Int}\n  {edges : List (Nat × Nat)} {val : Int} {node : Nat}\n  (h1 : sweetness.length = n)\n  (h2 : is_tree n edges = true)\n  (h3 : node ≤ n) :\n  (solve_tree_queries n sweetness edges \n    [QueryType.update node val, QueryType.get node]).length = 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1052", "language": "lean", "source": "fvapps", "source-id": "fvapps_001052", "source-notes": "", "vc-description": "/-\nLet's define the niceness of a sequence of positive integers X1,X2,…,XN$X_1, X_2, \\dots, X_N$ as the sum of greatest common divisors of all pairs of its elements, i.e.\nN∑i=1N∑j=i+1gcd(Xi,Xj).∑i=1N∑j=i+1Ngcd(Xi,Xj).\\sum_{i=1}^N \\sum_{j=i+1}^N \\mathrm{gcd}(X_i, X_j)\\;.\nFor example, the niceness of the sequence [1,2,2]$[1, 2, 2]$ is gcd(1,2)+gcd(1,2)+gcd(2,2)=4$gcd(1, 2) + gcd(1, 2) + gcd(2, 2) = 4$.\nYou are given a sequence A1,A2,…,AN$A_1, A_2, \\dots, A_N$; each of its elements is either a positive integer or missing.\nConsider all possible ways to replace each missing element of A$A$ by a positive integer (not necessarily the same for each element) such that the sum of all elements is equal to S$S$. Your task is to find the total niceness of all resulting sequences, i.e. compute the niceness of each possible resulting sequence and sum up all these values. Since the answer may be very large, compute it modulo 109+7$10^9 + 7$.\n\n-----Input-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\n- The first line of each test case contains two space-separated integers N$N$ and S$S$. \n- The second line contains N$N$ space-separated integers A1,A2,…,AN$A_1, A_2, \\dots, A_N$. Missing elements in this sequence are denoted by −1$-1$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the total niceness modulo 109+7$10^9 + 7$.\n\n-----Constraints-----\n- 1≤T≤20$1 \\le T \\le 20$\n- 1≤N,S≤50$1 \\le N, S \\le 50$\n- 1≤Ai≤50$1 \\le A_i \\le 50$ or Ai=−1$A_i = -1$ for each valid i$i$\n\n-----Subtasks-----\nSubtask #1 (30 points):\n- 1≤N,S≤18$1 \\le N, S \\le 18$\n- 1≤Ai≤18$1 \\le A_i \\le 18$ or Ai=−1$A_i = -1$ for each valid i$i$\nSubtask #2 (70 points): original constraints\n\n-----Example Input-----\n3\n3 3\n1 1 -1\n4 8\n1 -1 -1 3\n3 10\n-1 -1 -1\n\n-----Example Output-----\n3\n23\n150\n\n-----Explanation-----\nExample case 1: There is only one possible way to fill in the missing element; the resulting sequence is [1,1,1]$[1, 1, 1]$. Its niceness is 3$3$.\nExample case 2: There is only three possible ways to fill in the missing elements; the resulting sequences are [1,1,3,3]$[1, 1, 3, 3]$, [1,3,1,3]$[1, 3, 1, 3]$, and [1,2,2,3]$[1, 2, 2, 3]$. The sum of their niceness is 8+8+7=23$8 + 8 + 7 = 23$.\n-/", "vc-preamble": "def calc_total_niceness (n : Nat) (target_sum : Nat) (nums : List Int) : Nat :=\nsorry\n\ndef gcd (a b : Nat) : Nat :=\nsorry\n\ndef list_sum (xs : List Int) : Int :=\nsorry", "vc-helpers": "", "vc-definitions": "def list_sum_nat (xs : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem result_within_mod (n : Nat) (target_sum : Nat) (nums : List Int)\n  (h1 : 1 ≤ n ∧ n ≤ 50)\n  (h2 : 1 ≤ target_sum ∧ target_sum ≤ 1000)\n  (h3 : ∀ x ∈ nums, -1 ≤ x ∧ x ≤ 1000)\n  (h4 : 1 ≤ nums.length ∧ nums.length ≤ 50) :\n  let result := calc_total_niceness n target_sum nums\n  0 ≤ result ∧ result < 10^9 + 7 :=\nsorry\n\ntheorem zero_sum_no_missing (n : Nat) (h : 1 ≤ n ∧ n ≤ 50) :\n  let ones := List.replicate n 1\n  let expected := list_sum_nat ((List.range n).bind (fun i =>\n    (List.range (n - i - 1)).map (fun j =>\n      gcd 1 1\n    )))\n  calc_total_niceness n n ones = expected % (10^9 + 7) :=\nsorry\n\ntheorem impossible_cases (n : Nat) (target_sum : Nat) (nums : List Int)\n  (h1 : 1 ≤ n ∧ n ≤ 50)\n  (h2 : 1 ≤ target_sum ∧ target_sum ≤ 1000)\n  (h3 : ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 1000) :\n  (list_sum nums ≠ target_sum → calc_total_niceness nums.length target_sum nums = 0) ∧\n  (let nums_with_missing := nums ++ [-1]\n   target_sum < list_sum (nums_with_missing.filter (· ≠ -1)) →\n   calc_total_niceness nums_with_missing.length target_sum nums_with_missing = 0) :=\nsorry\n\ntheorem order_invariance (n : Nat) (target_sum : Nat) (nums : List Int)\n  (h1 : 1 ≤ n ∧ n ≤ 10)\n  (h2 : 1 ≤ target_sum ∧ target_sum ≤ 20)\n  (h3 : ∀ x ∈ nums, -1 ≤ x ∧ x ≤ 10)\n  (h4 : 1 ≤ nums.length ∧ nums.length ≤ 10) :\n  ∀ perm : List Int,\n  List.Perm nums perm →\n  calc_total_niceness nums.length target_sum nums = \n  calc_total_niceness perm.length target_sum perm :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval calc_total_niceness 3 3 [1, 1, -1]\n\n/-\ninfo: 23\n-/\n-- #guard_msgs in\n-- #eval calc_total_niceness 4 8 [1, -1, -1, 3]\n\n/-\ninfo: 150\n-/\n-- #guard_msgs in\n-- #eval calc_total_niceness 3 10 [-1, -1, -1]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1058", "language": "lean", "source": "fvapps", "source-id": "fvapps_001058", "source-notes": "", "vc-description": "/-\nThe faculty of application management and consulting services (FAMCS) of the Berland State University (BSU) has always been popular among Berland's enrollees. This year, N students attended the entrance exams, but no more than K will enter the university. In order to decide who are these students, there are series of entrance exams. All the students with score strictly greater than at least (N-K) students' total score gets enrolled.\nIn total there are E entrance exams, in each of them one can score between 0 and M points, inclusively. The first E-1 exams had already been conducted, and now it's time for the last tribulation.\nSergey is the student who wants very hard to enter the university, so he had collected the information about the first E-1 from all N-1 enrollees (i.e., everyone except him). Of course, he knows his own scores as well.\nIn order to estimate his chances to enter the University after the last exam, Sergey went to a fortune teller. From the visit, he learnt about scores that everyone except him will get at the last exam. Now he wants to calculate the minimum score he needs to score in order to enter to the university. But now he's still very busy with minimizing the amount of change he gets in the shops, so he asks you to help him.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains four space separated integers N, K, E, M denoting the number of students, the maximal number of students who'll get enrolled, the total number of entrance exams and maximal number of points for a single exam, respectively.\nThe following N-1 lines will contain E integers each, where the first E-1 integers correspond to the scores of the exams conducted. The last integer corresponds to the score at the last exam, that was predicted by the fortune-teller.\nThe last line contains E-1 integers denoting Sergey's score for the first E-1 exams.\n\n-----Output-----\n\nFor each test case, output a single line containing the minimum score Sergey should get in the last exam in order to be enrolled. If Sergey doesn't have a chance to be enrolled, output \"Impossible\" (without quotes).\n\n-----Constraints-----\n\n- 1 ≤ T ≤ 5\n- 1 ≤ K < N ≤ 104\n- 1 ≤ M ≤ 109\n- 1 ≤ E ≤ 4\n\n-----Example-----\nInput:1\n4 2 3 10\n7 7 7\n4 6 10\n7 10 9\n9 9\n\nOutput:4\n\n-----Explanation-----\nExample case 1. If Sergey gets 4 points at the last exam, his score will be equal to 9+9+4=22. This will be the second score among all the enrollees - the first one will get 21, the second one will get 20 and the third will have the total of 26. Thus, Sergey will enter the university.\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat :=\nmatch xs with\n| [] => 0\n| x::xs => x + List.sum xs\n\ndef List.sortBy (lt : α → α → Bool) (xs : List α) : List α :=\nmatch xs with\n| [] => []\n| [x] => [x]\n| x::xs => x::xs -- stub implementation to avoid termination issues", "vc-helpers": "", "vc-definitions": "def calculate_min_score (n k e m : Nat) (other_scores : List (List Nat)) (sergey_scores : List Nat) : Nat ⊕ Unit :=\nsorry", "vc-theorems": "theorem min_score_bounded {n k e m : Nat} {other_scores : List (List Nat)} {sergey_scores : List Nat}\n  (h1 : n ≥ 2)\n  (h2 : k < n)\n  (h3 : k ≥ 1) \n  (h4 : e ≥ 2)\n  (h5 : m ≥ 1)\n  (h6 : calculate_min_score n k e m other_scores sergey_scores = .inl score)\n  : 0 ≤ score ∧ score ≤ m :=\nsorry\n\ntheorem min_score_achieves_position {n k e m : Nat} {other_scores : List (List Nat)} {sergey_scores : List Nat}\n  (h1 : n ≥ 2)\n  (h2 : k < n)\n  (h3 : k ≥ 1)\n  (h4 : e ≥ 2)\n  (h5 : m ≥ 1)\n  (h6 : calculate_min_score n k e m other_scores sergey_scores = .inl score)\n  : let sergey_total := score + List.sum sergey_scores\n    let other_totals := (other_scores.map List.sum).sortBy (fun x y => x > y)\n    List.length (other_totals.filter (fun x => x > sergey_total)) < k :=\nsorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval calculate_min_score 4 2 3 10 [[7, 7, 7], [4, 6, 10], [7, 10, 9]] [9, 9]\n\n/-\ninfo: 'Impossible'\n-/\n-- #guard_msgs in\n-- #eval calculate_min_score 3 1 2 5 [[5, 5], [5, 5]] [0]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval calculate_min_score 3 2 2 10 [[5, 1], [1, 1]] [10]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1060", "language": "lean", "source": "fvapps", "source-id": "fvapps_001060", "source-notes": "", "vc-description": "/-\nTwo words rhyme if their last 3 letters are a match. Given N words, print the test case number (of the format Case : num) followed by the rhyming words in separate line adjacent to each other.\n\nThe output can be in anyorder.\n\n-----Input-----\nFirst line contains the number of test case T\n\nThe next line contains the number of words N\n\nNext N words follow . They’ll contain only alphabets from ‘a’-‘z’.\n\n-----Output-----\nPrint case number (for each test case) of the format Case : num followed by the words that rhyme in a new line.\n\n-----Constraints-----\n1 <= T <= 5\n\n1 <= N <= 1000\n\n3 <= length of each word <= 1000\n\n-----Example-----\nInput:\n3\n3\nnope qwerty hope\n5 \nbrain drain request grain nest\n4\nthese words dont rhyme\n\nOutput:\nCase : 1\nhope nope\nqwerty\nCase : 2\nbrain drain grain\nnest request\nCase : 3\nthese\ndont\nwords\nrhyme\n\n-----Explanation-----\nCase : 2\n\nbrain drain grain\n\nnest request\n\nCase : 3\n\nthese\n\ndont\n\nwords\n\nrhyme\nExplanation for case 1: since hope and nope rhyme (suffix “ope” matches), we print them in the same line and qwerty In a new line.\n\nNote that\n\nqwerty\n\nnope hope\n\nis also correct (the output can be in any order )\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_rhyming_words (test_cases : List (List String)) : List String :=\n  sorry", "vc-theorems": "theorem result_format_prop {test_cases : List (List String)}\n  (h1 : ∀ case ∈ test_cases, case.length > 0)\n  (h2 : test_cases.length > 0) :\n  let result := find_rhyming_words test_cases\n  result.head? = some \"Case : 1\" ∧ \n  (result.filter (fun line => line.startsWith \"Case :\")).length = test_cases.length :=\nsorry\n\ntheorem words_preserved_prop {test_cases : List (List String)} \n  (h1 : ∀ case ∈ test_cases, case.length > 0)\n  (h2 : test_cases.length > 0) :\n  let result := find_rhyming_words test_cases\n  let input_words := test_cases.join\n  let output_words := (result.filter (fun line => ¬line.startsWith \"Case :\")).bind (fun s => (s.split (. = ' ')))\n  List.all input_words (fun w => w ∈ output_words) ∧\n  List.all output_words (fun w => w ∈ input_words) :=\nsorry\n\ntheorem rhyming_words_grouped_prop {test_cases : List (List String)}\n  (h1 : ∀ case ∈ test_cases, case.length ≥ 2)\n  (h2 : test_cases.length > 0) :\n  let result := find_rhyming_words test_cases\n  ∀ line ∈ result, ¬line.startsWith \"Case :\" →\n    let words := line.split (. = ' ')\n    words.length > 1 →\n    let suffix := (words.head?.getD \"\").takeRight 3\n    (∀ w ∈ words, w.takeRight 3 = suffix) ∧\n    ∀ x ∈ words, ∀ y ∈ words, x ≤ y ∨ y ≤ x :=\nsorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval find_rhyming_words [[\"nope\", \"qwerty\", \"hope\"]]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval find_rhyming_words [[\"brain\", \"drain\", \"request\", \"grain\", \"nest\"]]\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval find_rhyming_words [[\"these\", \"words\", \"dont\", \"rhyme\"]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1062", "language": "lean", "source": "fvapps", "source-id": "fvapps_001062", "source-notes": "", "vc-description": "/-\nZonal Computing Olympiad 2012, 26 Nov 2011\n\nThe year is 2102 and today is the day of ZCO. This year there are N contests and the starting and ending times of each contest is known to you. You have to participate in exactly one of these contests. Different contests may overlap. The duration of different contests might be different. \n\nThere is only one examination centre. There is a wormhole V that transports you from your house to the examination centre and another wormhole W that transports you from the examination centre back to your house. Obviously, transportation through a wormhole does not take any time; it is instantaneous. But the wormholes can be used at only certain fixed times, and these are known to you.\n\nSo, you use a V wormhole to reach the exam centre, possibly wait for some time before the next contest begins, take part in the contest, possibly wait for some more time and then use a W wormhole to return back home. If you leave through a V wormhole at time t1 and come back through a W wormhole at time t2, then the total time you have spent is (t2 - t1 + 1). Your aim is to spend as little time as possible overall while ensuring\nthat you take part in one of the contests.\n\nYou can reach the centre exactly at the starting time of the contest, if possible. And you can leave the examination centre the very second the contest ends, if possible. You can assume that you will always be able to attend at least one contest–that is, there will always be a contest such that there is a V wormhole before it and a W wormhole after it.\n\nFor instance, suppose there are 3 contests with (start,end) times (15,21), (5,10), and (7,25), respectively.  Suppose the V wormhole is available at times 4, 14, 25, 2 and the W wormhole is available at times 13 and 21.  In this case, you can leave by the V wormhole at time 14, take part in the contest from time 15 to 21, and then use the W wormhole at time 21 to get back home.  Therefore the time you have spent is (21 - 14 + 1) = 8. You can check that you cannot do better than this.\n\n-----Input format-----\nThe first line contains 3 space separated integers N, X, and Y, where N is the number of contests, X is the number of time instances when wormhole V can be used and Y is the number of time instances when wormhole W can be used.  The next N lines describe each contest.  Each of these N lines contains two space separated integers S and E, where S is the starting time of the particular contest and E is the ending time of that contest, with S < E.  The next line contains X space separated integers which are the time instances when the wormhole V can be used.  The next line contains Y space separated integers which are the time instances when the wormhole W can be used.\n\n-----Output format-----\nPrint a single line that contains a single integer, the minimum time needed to be spent to take part in a contest.\n\n-----Testdata-----\nAll the starting and ending times of contests are distinct and no contest starts at the same time as another contest ends. The time instances when wormholes are available are all distinct, but may coincide with starting and ending times of contests. All the time instances (the contest timings and the wormhole timings) will be integers between 1 and 1000000 (inclusive).\n\n- Subtask 1 (30 marks)\n- Subtask 2 (70 marks)\n\nYou may assume that \n1 ≤ N ≤ 105,\n1 ≤ X ≤ 105, and\n1 ≤ Y ≤ 105.\n\nIn 30% of the cases, \n1 ≤ N ≤ 103,\n1 ≤ X ≤ 103, and\n1 ≤ Y ≤ 103.\n\n-----Sample Input-----\n3 4 2\n15 21\n5 10\n7 25\n4 14 25 2\n13 21\n\n-----Sample Output-----\n8\n-/", "vc-preamble": "def find_min_contest_time (n x y : Nat) (contests : List (Nat × Nat)) \n    (v_times w_times : List Nat) : Nat := sorry", "vc-helpers": "", "vc-definitions": "def maxsize : Nat := 4294967295 -- Using max u32 as stand-in for sys.maxsize\n\ntheorem find_min_contest_time_positive\n    (n x y : Nat)\n    (contests : List (Nat × Nat))\n    (v_times w_times : List Nat)\n    (h1 : n > 0)\n    (h2 : x > 0)\n    (h3 : y > 0)\n    (h4 : contests.length > 0)\n    (h5 : v_times.length > 0)\n    (h6 : w_times.length > 0)\n    (h7 : ∀ c ∈ contests, c.1 ≥ 0 ∧ c.2 ≤ 100 ∧ c.1 < c.2)\n    (h8 : ∀ t ∈ v_times, t ≤ 100)\n    (h9 : ∀ t ∈ w_times, t ≤ 100) :\n    find_min_contest_time n x y contests v_times w_times > 0 := sorry", "vc-theorems": "theorem find_min_contest_time_exceeds_min_duration\n    (n x y : Nat)\n    (contests : List (Nat × Nat))\n    (v_times w_times : List Nat)\n    (h1 : n > 0)\n    (h2 : x > 0)\n    (h3 : y > 0)\n    (h4 : contests.length > 0)\n    (h5 : v_times.length > 0)\n    (h6 : w_times.length > 0)\n    (h7 : ∀ c ∈ contests, c.1 ≥ 0 ∧ c.2 ≤ 100 ∧ c.1 < c.2) \n    (h8 : ∀ t ∈ v_times, t ≤ 100)\n    (h9 : ∀ t ∈ w_times, t ≤ 100)\n    (result := find_min_contest_time n x y contests v_times w_times)\n    (min_duration := (contests.map (fun c => c.2 - c.1)).minimum?) :\n    result ≠ maxsize → result ≥ min_duration.getD 0 := sorry\n\ntheorem find_min_contest_time_order_invariant\n    (contests : List (Nat × Nat))\n    (v_times w_times : List Nat) \n    (h1 : contests.length > 0)\n    (h2 : v_times.length > 0)\n    (h3 : w_times.length > 0)\n    (h4 : ∀ c ∈ contests, c.1 ≥ 0 ∧ c.2 ≤ 100 ∧ c.1 < c.2)\n    (h5 : ∀ t ∈ v_times, t ≤ 100)\n    (h6 : ∀ t ∈ w_times, t ≤ 100)\n    (sorted_v := v_times)\n    (sorted_w := w_times) :\n    find_min_contest_time 1 1 1 contests v_times w_times = \n    find_min_contest_time 1 1 1 contests sorted_v sorted_w := sorry\n\n/-\ninfo: 8\n-/\n-- #guard_msgs in\n-- #eval find_min_contest_time 3 4 2 [(15, 21), (5, 10), (7, 25)] [4, 14, 25, 2] [13, 21]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1070", "language": "lean", "source": "fvapps", "source-id": "fvapps_001070", "source-notes": "", "vc-description": "/-\nA long way back I have taken $5000 from Golu when I used to live in Jodhpur. Now, time has passed and I am out of Jodhpur. While Golu still in Jodhpur, one day called me and asked about his money.\nI thought of giving Golu a chance. I told him that he can still take his money back if he reaches my home anyhow just in 2 days but not after that. \nIn excitement he made his way toward my hometown i.e. Gorakhpur. To cover up the petrol cost he started giving paid lift to whoever needs it throughout the way in order to earn some money. Help him to get the maximum profit.\n\nHis car has a capacity of k + 1 person, so in a certain moment he can transport k persons (and himself). \nFrom Jodhpur to Gorakhpur, there are l localities (cities, towns, villages), Jodhpur being the first and Gorakhpur being the lth.\nThere are n groups of lift takers along the road. The ith\ngroup consists of pi persons, wants to travel from locality si  to locality di and will pay an amount of mi money.\nA group must be taken into the car as a whole. Assume that lift takers are found only in localities.\n\nRestrictions\n• 1 ≤ k ≤ 7\n• 1 ≤ l ≤ 1000000\n• 1 ≤ n ≤ 50\n• 1 ≤ pi ≤ k\n• 1 ≤ si ≤ l – 1\n• 2 ≤ di ≤ l\n• si < di\n• 1 ≤ mi ≤ 1000000\n\n-----Input-----\nThe first line of the input contains the number of test cases.\nThe first line of each test case contains the numbers n, l and k separated by a single space.\nn lines follow, the ith line containing pi, si, di and mi separated by a single space.\n\n-----Output-----\nFor each test case output a single line containing the maximum amount of money Golu can earn.\n\n-----Example-----\nInput:\n2\n5 5 4\n2 1 5 50\n1 2 4 20\n2 3 4 40\n2 4 5 50\n3 4 5 80\n10 10 5\n2 5 10 17300\n2 1 8 31300\n5 4 10 27600\n4 8 10 7000\n5 9 10 95900\n2 7 10 14000\n3 6 10 63800\n1 7 10 19300\n3 8 10 21400\n2 2 10 7000\n\nOutput:\n140\n127200\n\nBy:\nChintan, Asad, Ashayam, Akanksha\n-/", "vc-preamble": "def get_max_earnings (n l k : Nat) (groups : List (Nat × Nat × Nat × Nat)) : Nat :=\n  sorry\n\ndef hash_state (groups : List Group) (i : Nat) : List Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def optimize (groups : List Group) : List Group :=\n  sorry", "vc-theorems": "theorem get_max_earnings_nonnegative (n l k : Nat) (groups : List (Nat × Nat × Nat × Nat)) :\n  get_max_earnings n l k groups ≥ 0 :=\nsorry\n\ntheorem get_max_earnings_bounded (n l k : Nat) (groups : List (Nat × Nat × Nat × Nat)) \n  (h : groups.length > 0) :\n  get_max_earnings n l k groups ≤ groups.foldr (fun g acc => g.2.2.2 + acc) 0 :=\nsorry \n\ntheorem hash_state_length (groups : List Group) (i : Nat) :\n  (hash_state groups i).length = groups.length + 1 :=\nsorry\n\ntheorem hash_state_last_elem (groups : List Group) (i : Nat) \n  (h : hash_state groups i ≠ []) :\n  (hash_state groups i).getLast h = i :=\nsorry\n\ntheorem hash_state_ordered (groups : List Group) (i : Nat) (j : Nat) \n  (h : j + 1 < (hash_state groups i).length) :\n  ((hash_state groups i)[j] ≤ (hash_state groups i)[j+1]) :=\nsorry\n\ntheorem optimize_ordered (groups : List Group) (j : Nat)\n  (h : j + 1 < (optimize groups).length) :\n  ((optimize groups)[j]).start ≤ ((optimize groups)[j+1]).start :=\nsorry\n\n/-\ninfo: 140\n-/\n-- #guard_msgs in\n-- #eval get_max_earnings 5 5 4 [(2, 1, 5, 50), (1, 2, 4, 20), (2, 3, 4, 40), (2, 4, 5, 50), (3, 4, 5, 80)]\n\n/-\ninfo: 127200\n-/\n-- #guard_msgs in\n-- #eval get_max_earnings 10 10 5 [(2, 5, 10, 17300), (2, 1, 8, 31300), (5, 4, 10, 27600), (4, 8, 10, 7000), (5, 9, 10, 95900), (2, 7, 10, 14000), (3, 6, 10, 63800), (1, 7, 10, 19300), (3, 8, 10, 21400), (2, 2, 10, 7000)]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1072", "language": "lean", "source": "fvapps", "source-id": "fvapps_001072", "source-notes": "", "vc-description": "/-\nThere were $N$ students (numbered $1$ through $N$) participating in the Indian Programming Camp (IPC) and they watched a total of $K$ lectures (numbered $1$ through $K$). For each student $i$ and each lecture $j$, the $i$-th student watched the $j$-th lecture for $T_{i, j}$ minutes.\nAdditionally, for each student $i$, we know that this student asked the question, \"What is the criteria for getting a certificate?\" $Q_i$ times.\nThe criteria for getting a certificate is that a student must have watched at least $M$ minutes of lectures in total and they must have asked the question no more than $10$ times.\nFind out how many participants are eligible for a certificate.\n\n-----Input-----\n- The first line of the input contains three space-separated integers $N$, $M$ and $K$.\n- $N$ lines follow. For each valid $i$, the $i$-th of these lines contains $K+1$ space-separated integers $T_{i, 1}, T_{i, 2}, \\ldots, T_{i, K}, Q_i$.\n\n-----Output-----\nPrint a single line containing one integer — the number of participants eligible for a certificate. \n\n-----Constraints-----\n- $1 \\le N, K \\le 1,000$\n- $1 \\le M \\le 10^6$\n- $1 \\le Q_i \\le 10^6$ for each valid $i$\n- $1 \\le T_{i, j} \\le 1,000$ for each valid $i$ and $j$\n\n-----Example Input-----\n4 8 4\n1 2 1 2 5\n3 5 1 3 4\n1 2 4 5 11\n1 1 1 3 12\n\n-----Example Output-----\n1\n\n-----Explanation-----\n- Participant $1$ watched $1 + 2 + 1 + 2 = 6$ minutes of lectures and asked the question $5$ times. Since $6 < M$, this participant does not receive a certificate.\n- Participant $2$ watched $3 + 5 + 1 + 3 = 12$ minutes of lectures and asked the question $4$ times. Since $12 \\ge M$ and $4 \\le 10$, this participant receives a certificate.\n- Participant $3$ watched $1 + 2 + 4 + 5 = 12$ minutes of lectures and asked the question $11$ times. Since $12 \\ge M$ but $11 > 10$, this participant does not receive a certificate.\n- Participant $4$ watched $1 + 1 + 1 + 3 = 6$ minutes of lectures and asked the question $12$ times. Since $6 < M$ and $12 > 10$, this participant does not receive a certificate.\nOnly participant $2$ receives a certificate.\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat :=\nmatch xs with\n| [] => 0\n| x::xs => x + xs.sum", "vc-helpers": "", "vc-definitions": "def count_eligible_students (N M K : Nat) (student_data : List (List Nat)) : Nat :=\nsorry", "vc-theorems": "theorem count_eligible_students_empty_data\n  {N M K : Nat} (h1 : N ≥ 1) (h2 : M ≥ 1) (h3 : K ≥ 1) :\n  count_eligible_students N M K [] = 0 :=\nsorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval count_eligible_students 4 8 4 [[1, 2, 1, 2, 5], [3, 5, 1, 3, 4], [1, 2, 4, 5, 11], [1, 1, 1, 3, 12]]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval count_eligible_students 2 10 2 [[1, 2, 11], [2, 3, 12]]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval count_eligible_students 2 5 2 [[2, 4, 5], [3, 3, 2]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1084", "language": "lean", "source": "fvapps", "source-id": "fvapps_001084", "source-notes": "", "vc-description": "/-\nChef is stuck on the minute hand of a giant clock. To escape from this clock he needs to get onto the hour hand which has an exit door. \nSince the minute hand and and hour hand are not connected at any point, chef will surely need to make a jump. Since he wants minimum risks, he chooses to jump on the hour hand so that the angle he has to cover is minimum possible.\nYou will be given a clock time in $UTC$ format denoting time of chef's jump and you have to compute the minimum angle that chef needs to cover while completing the jump.\nFor some reason chef times his jump only when the number of minutes is a multiple of 5.\n\n-----Input:-----\nThe first line of the input contains a single integer $T$ denoting the number of test cases. The description of  $T$ test cases follows.\nThe first line of each test case contains a string denoting time in UTC format (e.g. 10:20 i.e. 10 hours and 20 minutes)\n\n-----Output-----\nFor each test case, print a single line denoting the smallest angle of jump.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^3$\n- $0 \\leq hours \\leq 23$\n- $0 \\leq minutes \\leq 59$\n\n-----Example Input-----\n3\n14:20\n02:10\n09:30\n\n-----Example Output-----\n50 degree \n5 degree  \n105 degree\n\n-----Explanation-----\n- In the second case, once the hour hand reaches 2 it starts moving towards 3 with the passing of every minute, hence when the minute hand points 10 minutes, the hour hand has already covered some angle towards 3. \nIn this scenario the two angles made by hour and minute hand are 355 and 5 degrees. Since chef will jump on the side with minimum angle, he chooses the one with 5-degree angle.\n-/", "vc-preamble": "def find_min_angle (t : Time) : String := sorry\n\ndef string_to_float (s : String) : Float := sorry", "vc-helpers": "", "vc-definitions": "def round_float (f : Float) : Float := sorry\n\ntheorem find_min_angle_format (t : Time) : \n  ∃ n : Float, find_min_angle t = toString n ++ \" degree\" := sorry", "vc-theorems": "theorem find_min_angle_range (t : Time) :\n  let angle := string_to_float (find_min_angle t)\n  0 ≤ angle ∧ angle ≤ 180 := sorry \n\ntheorem find_min_angle_precision (t : Time) :\n  let angle := string_to_float (find_min_angle t)\n  ∃ n : Float, angle = n ∧ n * 2 = round_float (n * 2) := sorry\n\ntheorem find_min_angle_12hr_symmetry (t : Time) :\n  find_min_angle t = find_min_angle ⟨t.hours % 12, t.mins, sorry, t.m_valid⟩ := sorry\n\n/-\ninfo: '50 degree'\n-/\n-- #guard_msgs in\n-- #eval find_min_angle \"14:20\"\n\n/-\ninfo: '5 degree'\n-/\n-- #guard_msgs in\n-- #eval find_min_angle \"02:10\"\n\n/-\ninfo: '105 degree'\n-/\n-- #guard_msgs in\n-- #eval find_min_angle \"09:30\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1087", "language": "lean", "source": "fvapps", "source-id": "fvapps_001087", "source-notes": "", "vc-description": "/-\nLumpy is a bus driver. Today, the conductor is absent so Lumpy has to do the conductor's job as well. There are N creatures in the bus. Sometimes the creatures don't carry change and can't pay the exact amount of the fare. Each creature in the bus today has paid an amount\ngreater than his/her fare. You are given information about the extra amount paid by each creature, by an array A of size N, where Ai denotes the extra amount paid by the i-th creature, in rupees.\nAfter the end of the trip, Lumpy noticed that he had P one rupee coins and Q two rupee coins. He wants to pay back the creatures using this money. Being a kind hearted moose, Lumpy wants to pay back as many creatures as he can. Note that Lumpy will \nnot pay back the i-th creature if he can't pay the exact amount that the i-th creature requires with the coins that he possesses. \nLumpy is busy driving the bus and doesn't want to calculate the maximum number of creatures he can satisfy - He will surely cause an accident if he tries to do so. Can you help him out with this task? \n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n- For each test case, first line consists of three space separated integers N, P and Q.\n- Second line consists of N space separated integers A containing N space integers, where i-th integer denotes Ai.\n\n-----Output-----\n- For each test case, output a single line containing an integer corresponding to maximum number of creatures that Lumpy can pay back.\n\n-----Constraints-----\n- 1 ≤ T ≤ 106\n- 1 ≤ N ≤ 105\n- 1 ≤ Ai ≤ 109\n- 0 ≤ P, Q ≤ 1014\n- Sum of N over all the cases does not exceed 106\n\n-----Subtasks-----\n- Subtask #1 (15 points): P = 0\n- Subtask #2 (15 points): Q = 0\n- Subtask #3 (70 points): Original constraints\n\n-----Example-----\nInput:3\n3 3 0\n1 2 2\n3 2 1\n1 2 1\n4 5 4\n2 3 4 5\n\nOutput:2\n3\n3\n\n-----Explanation-----\nExample 1. Lumpy has just 3 one rupee coins. \n\nHe can pay creatures numbered {1, 2} or creatures numbered {1, 3} with these coins. Thus, answer is 2. \nExample 2. Lumpy has 2 one rupee coins and 1 two rupee coin. \n\nIn the optimal solution, Lumpy can give the two rupee coin to creature 2 and the one rupee coins to creatures 1 and 3. Thus, answer is 3.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def List.sort : List Nat → List Nat := sorry\n\ndef solve_bus_payback (n p q : Nat) (amounts : List Nat) : Nat := sorry", "vc-theorems": "theorem output_bounds (n p q : Nat) (amounts : List Nat) \n  (h : amounts.length = n) :\n  let result := solve_bus_payback n p q amounts\n  0 ≤ result ∧ result ≤ n := sorry\n\ntheorem zero_money_zero_creatures (n : Nat) (amounts : List Nat)\n  (h : amounts.length = n) :\n  solve_bus_payback n 0 0 amounts = 0 := sorry\n\ntheorem enough_money_even_amounts (n p q : Nat) (amounts : List Nat)\n  (h1 : amounts.length = n)\n  (h2 : ∀ i < n, amounts.get ⟨i, sorry⟩ = 2 * (i + 1))\n  (h3 : p + 2*q ≥ List.sum amounts) :\n  solve_bus_payback n p q amounts = n := sorry\n\ntheorem sorting_invariant (n p q : Nat) (amounts : List Nat)\n  (h : amounts.length = n) :\n  solve_bus_payback n p q amounts = \n  solve_bus_payback n p q (List.sort amounts) := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1096", "language": "lean", "source": "fvapps", "source-id": "fvapps_001096", "source-notes": "", "vc-description": "/-\nShivam is working on electric circuits. He requires some connecting wires. He needs to make a total of N connections and he has mentioned his wire length requirements for each connection in an integer sequence A. For buying wires, he need to decide the length of each wire piece, and he’ll get as many wire pieces of the chosen length each at unit cost (cost 1 per piece) but he can't get wires of different lengths. Also, he can't cut wire pieces to make new pieces of different (smaller) length(s).\nBut he can connect any number of wires together to form a new single wire piece whose length is the sum of lengths of the wires connected. So, Shivam needs to choose an integer length for buying wires. Shivam hates to waste anything, and he hates it even more if that thing is money.\nShivam is weak in mathematics and is asking you to help him in this situation. Help him decide the length of wires and total number of wires so as to minimize the total expenditure.\nNote: You cannot make a connection which requires a wire piece of length X with a wire piece of length Y if X≠Y.\nInput:\n·        The first line of the input contains T = Number of Test cases\n·        The first line of each test case contains an integer N\n·        The second line contains N space separated integers A1, A2, …., AN.\nOutput:\nFor each test case print a single line containing two space separated integers, length of each wire and the corresponding minimum cost.\nConstraints:\n·       1 <= T <= 10\n·       1 <= N <= 10^5\n·        1 <= Ai <= 10^5, for each valid i\nSample Input:\n1\n3\n2 4 8\nSample Output:\n2 7\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | x :: xs => x + xs.sum\n\ndef gcd (a b : Nat) : Nat :=\n  sorry\n\ndef gcd_list (nums : List Nat) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def min_wire_cost (n : Nat) (wire_lengths : List Nat) : Nat × Nat :=\n  sorry", "vc-theorems": "theorem min_wire_cost_divides_all (n : Nat) (wire_lengths : List Nat)\n  (h : wire_lengths.length > 0) (h2 : ∀ x ∈ wire_lengths, x > 0) :\n  let (result_len, _) := min_wire_cost n wire_lengths\n  ∀ w ∈ wire_lengths, w % result_len = 0 :=\nsorry \n\ntheorem min_wire_cost_gcd (n : Nat) (wire_lengths : List Nat)  \n  (h : wire_lengths.length > 0) (h2 : ∀ x ∈ wire_lengths, x > 0) :\n  let (result_len, _) := min_wire_cost n wire_lengths\n  result_len = gcd_list wire_lengths :=\nsorry\n\ntheorem min_wire_cost_preserves_sum (n : Nat) (wire_lengths : List Nat)\n  (h : wire_lengths.length > 0) (h2 : ∀ x ∈ wire_lengths, x > 0) :\n  let (result_len, result_pieces) := min_wire_cost n wire_lengths\n  result_len * result_pieces = wire_lengths.sum :=\nsorry\n\ntheorem min_wire_cost_even_output (n : Nat) (wire_lengths : List Nat)\n  (h : wire_lengths.length > 0) (h2 : ∀ x ∈ wire_lengths, x > 0)\n  (h3 : ∀ x ∈ wire_lengths, x % 2 = 0) :\n  let (result_len, _) := min_wire_cost n wire_lengths\n  result_len % 2 = 0 :=\nsorry\n\ntheorem min_wire_cost_positive (n : Nat) (wire_lengths : List Nat)\n  (h : wire_lengths.length > 0) (h2 : ∀ x ∈ wire_lengths, x > 0) :\n  let (result_len, result_pieces) := min_wire_cost n wire_lengths\n  result_len > 0 ∧ result_pieces > 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1097", "language": "lean", "source": "fvapps", "source-id": "fvapps_001097", "source-notes": "", "vc-description": "/-\nDaenerys Targaryen has been suggested by her counselors to leave the Meereen and start conquering other parts of the world. But she knows giving up on the people of Meereen means victory of slavery. Her plan is to start conquering rest of the world while she remains in Meereen. She can only trust her bravest and most beloved Daario Naharis to undertake this risk. She asks him to conquer a few nations and promises him a help from her dragons. She also promises to marry him if he successfully conquers all the nations and not if he is defeated.\nDaario has to conquer 'N' number of nations each nation with army size A[i]. He attacks the nations serially. As promised, he gets help from Daenerys's Dragons. His first 'M' attacks are made with the help of Dragons.\n\nFor first 'M' attacks, he gains A[i] soldiers.\n\nFor the rest, he looses ceiling of A[i]/2 soldiers.\n\nHe is defeated if he is left with no army before he conquers all the 'N' nations. He has no army initially and only has Dragons.\n\n-----Input-----\nFirst line has 'T' which is the number of test cases.\nFor each test cases there are two space separated integers 'N' and 'M' denoting the number of nations and the number of nations he has Dragon's help for respectively.\nFollows N space separated integers denoting the size of army of each nation.\n\n-----Output-----\nPrint 'VICTORY' if Daario conquers all nations and 'DEFEAT' if he doesn't.  \n\n-----Constraints-----\n- 1 ≤ T ≤ 500\n- 1 ≤ M ≤N ≤ 100000\n- 1 ≤ A[i] ≤ 100000\n\n-----Example-----\nInput:\n\n3\n5 3\n1 2 3 4 5\n6 2\n4 4 4 4 4 4\n7 4 \n10 10 10 10 50 60 70\nOutput:\n\nVICTORY\nVICTORY\nDEFEAT \n\n-----Explanation-----\nExample case 1.\n\nFirst 3 attacks add 1,2,3 to his army making it 6. (1+2+3 = 6)\n\nThen he looses 2 and 3 making it 1. (6-2-3 = 1)\n\nHe conquers all so VICTORY.\n\nExample case 2.\n\nFirst 2 attacks add 4,4 to his army making it 8. (4+4 = 8)\n\nThen he looses 2,2,2,2 making it 0. (8-2-2-2-2 = 0)\n\nHe conquers all so VICTORY.\n\nExample case 3.\n\nFirst 4 attacks add 10,10,10,10 to his army making it 40. (10+10+10+10 = 40)\n\nThen he looses 25 and then all 15 out of possible 30 making it 0. (40-25-15 = 0)\n\nHe is defeated on 6th attack so DEFEAT.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n| [] => 0\n| (x::xs) => x + sum xs", "vc-helpers": "", "vc-definitions": "def check_conquest (n m : Nat) (armies : List Nat) : BattleResult := sorry\n\ntheorem check_conquest_valid_result (n m : Nat) (armies : List Nat) :\n  check_conquest n m armies = BattleResult.VICTORY ∨ \n  check_conquest n m armies = BattleResult.DEFEAT := sorry", "vc-theorems": "theorem check_conquest_enough_armies (n m : Nat) (armies : List Nat) :\n  n ≤ m → check_conquest n m armies = BattleResult.VICTORY := sorry\n\ntheorem check_conquest_insufficient_armies (n m : Nat) (armies : List Nat) :\n  n > m → (List.take m armies).sum ≤ 0 → \n  check_conquest n m armies = BattleResult.DEFEAT := sorry\n\ntheorem check_conquest_monotone (n m : Nat) (armies : List Nat) :\n  n > m →\n  check_conquest n m armies = BattleResult.VICTORY →\n  check_conquest n m (armies.map (· + 1)) = BattleResult.VICTORY := sorry\n\n/-\ninfo: 'VICTORY'\n-/\n-- #guard_msgs in\n-- #eval check_conquest 5 3 [1, 2, 3, 4, 5]\n\n/-\ninfo: 'VICTORY'\n-/\n-- #guard_msgs in\n-- #eval check_conquest 6 2 [4, 4, 4, 4, 4, 4]\n\n/-\ninfo: 'DEFEAT'\n-/\n-- #guard_msgs in\n-- #eval check_conquest 7 4 [10, 10, 10, 10, 50, 60, 70]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1122", "language": "lean", "source": "fvapps", "source-id": "fvapps_001122", "source-notes": "", "vc-description": "/-\nChef is an advocate for Go Green Initiative. Today he had n trees planted in a row outside his his restaurant. Today, the height of i-th tree is hi feet. The trees grow at a rate of mi feet per day.\nChef knows that trees will look beautiful if they form a zig-zag sequence. The trees will be said to be in Zig-zag sequence if the heights of tree first increases or decreases, then alternates between decreasing/increasing respectively. Formally, the trees will be said to in Zig-zag sequence if one of the following two conditions holds.\n\n- h1 < h2 > h3 < h4 and so on..\n- h1 >  h2 < h3 > h4 and so on..\n\nChef wants to know intervals of time when the heights of the trees will form a zig-zag sequence.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains a single integer n, denoting the number of trees.\nThe ith of following N lines contains two space separated integers hi and mi, denoting the initial height and the growth speed for ith tree.\n\n-----Output-----\nFor each test case, output an integer Q - the amount of the periods of consecutive moments of time, when the trees for a zig-zag sequence.\nOn the following Q lines, output the intervals of time when the trees' heights form a zig-zag sequence. For each intervals, output its' smallest and the largest instants of time. If the range is infinite, output Inf as the right bound.\nThe test cases are designed in such a way that the total output won't exceed 2 MB.\n\n-----Constraints-----\n\n- 1 ≤ T ≤ 105\n- 1 ≤ n ≤ 10\n- Subtask 1 (23 points): 0 ≤ hi, mi ≤ 10\n- Subtask 2 (77 points): 0 ≤ hi, mi ≤ 109\n- 1 ≤ sum of n over a test cases in a single test file ≤ 5 × 105\n\n-----Example-----\nInput:3\n3\n0 1\n2 2\n0 3\n2\n2 1\n1 2\n3\n1 1\n2 2\n3 3\n\nOutput:1\n0 1\n2\n0 0\n2 Inf\n0\n\n-----Explanation-----\nExample case 1. In the first case 0 2 0 is already a zig-zag sequence, but on the 2nd second it will become 2 6 6 and will never turn back into zig-zag\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_zigzag_intervals (trees : List (Int × Int)) : List (Nat × (Nat ⊕ Unit)) :=\n  sorry", "vc-theorems": "theorem output_format (trees : List (Int × Int)) :\n  let result := find_zigzag_intervals trees\n  (∀ interval ∈ result,\n    ∃ (start : Nat) (endVal : Nat ⊕ Unit),\n      interval = (start, endVal) ∧\n      (match endVal with\n        | Sum.inl n => n ≥ start\n        | Sum.inr _ => True)) :=\n  sorry\n\ntheorem single_tree (tree : Int × Int) :\n  find_zigzag_intervals [tree] = [(0, Sum.inr ())] :=\n  sorry\n\ntheorem sorted_intervals (trees : List (Int × Int)) :\n  let result := find_zigzag_intervals trees\n  ∀ (i j : Nat),\n    i < j →\n    j < result.length →\n    i < result.length →\n    ∀ (n : Nat) (start : Nat),\n    (result.get! i).2 = Sum.inl n →\n    (result.get! j).1 = start →\n    n < start :=\n  sorry\n\ntheorem interval_bounds (trees : List (Int × Int)) :\n  let result := find_zigzag_intervals trees\n  ∀ interval ∈ result,\n    match interval with\n    | (start, Sum.inl endVal) => 0 ≤ start ∧ start ≤ endVal ∧ endVal < 10^20\n    | (start, Sum.inr _) => 0 ≤ start :=\n  sorry\n\n/-\ninfo: [(0, 1)]\n-/\n-- #guard_msgs in\n-- #eval find_zigzag_intervals [(0, 1), (2, 2), (0, 3)]\n\n/-\ninfo: [(0, 0), (2, 'Inf')]\n-/\n-- #guard_msgs in\n-- #eval find_zigzag_intervals [(2, 1), (1, 2)]\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval find_zigzag_intervals [(1, 1), (2, 2), (3, 3)]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1127", "language": "lean", "source": "fvapps", "source-id": "fvapps_001127", "source-notes": "", "vc-description": "/-\nChef will not be able to attend the birthday of his best friend Rock. He promised Rock that this will not be the case on his half birthday. To keep his promise Chef must know Rock’s next half birthday accurately. Being busy, he is assigning this work to you.\nHalf birthday is the day that occurs exactly between two subsequent birthdays. \nYou will be provided with Rock’s birthdate and birth month, you will have to figure out his half birthday.\n$Note$: Consider every year to be a leap year and all months are displayed in lowercase English characters.\n\n-----Input:-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. \n- The description of each of the $T$ test cases contains an integer $d$ followed by a string, denoting month $m$.\n- Here $d$ denotes day of a month and $m$ denotes the month of a year respectively.\n\n-----Output:-----\nFor each test case print an integer $d1$ followed by a string, denoting month $m1$, which overall denotes date and month of Rock’s half birthday.\n\n-----Constraints:-----\n- $1 \\leq T \\leq 10^5$\n- $1 \\leq d , d1 \\leq 31$\n- $january \\leq m , m1 \\leq december$\n\n-----Sample Input:-----\n3\n15 january\n31 august\n10 october\n\n-----Sample Output:-----\n16 july\n1 march\n10 april\n-/", "vc-preamble": "def daysInMonth (m : Month) : Nat :=\n  match m with\n  | Month.february => 29\n  | Month.april | Month.june | Month.september | Month.november => 30\n  | _ => 31\n\ndef find_half_birthday (day : Nat) (month : Month) : Nat × Month :=\n  sorry", "vc-helpers": "", "vc-definitions": "def month_difference (m1 m2 : Month) : Nat :=\n  sorry", "vc-theorems": "theorem half_birthday_returns_valid_date (day : Nat) (month : Month)\n  (h1 : 0 < day) (h2 : day ≤ daysInMonth month) :\n  let (resultDay, resultMonth) := find_half_birthday day month\n  0 < resultDay ∧ resultDay ≤ daysInMonth resultMonth :=\n  sorry\n\ntheorem half_birthday_approximately_six_months (day : Nat) (month : Month) \n  (h1 : 0 < day) (h2 : day ≤ daysInMonth month) :\n  let (_, resultMonth) := find_half_birthday day month\n  let diff := month_difference month resultMonth  \n  5 ≤ diff ∧ diff ≤ 7 :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1145", "language": "lean", "source": "fvapps", "source-id": "fvapps_001145", "source-notes": "", "vc-description": "/-\nChef's friend Alex runs a movie theatre. Due to the increasing number of platforms for watching movies online, his business is not running well. As a friend, Alex asked Chef to help him maximise his profits. Since Chef is a busy person, he needs your help to support his friend Alex.  \nAlex's theatre has four showtimes: 12 PM, 3 PM, 6 PM and 9 PM. He has four movies which he would like to play ― let's call them A, B, C and D. Each of these movies must be played exactly once and all four must be played at different showtimes. For each showtime, the price of a ticket must be one of the following: Rs 25, Rs 50, Rs 75 or Rs 100. The prices of tickets for different showtimes must also be different.\nThrough his app, Alex receives various requests from his customers. Each request has the form \"I want to watch this movie at this showtime\". Let's assume that the number of people who come to watch a movie at a given showtime is the same as the number of requests for that movie at that showtime.\nIt is not necessary to accommodate everyone's requests ― Alex just wants to earn the maximum amount of money. There is no restriction on the capacity of the theatre. However, for each movie that is not watched by anyone, Alex would suffer a loss of Rs 100 (deducted from the profit).\nYou are given $N$ requests Alex received during one day. Find the maximum amount of money he can earn on that day by choosing when to play which movies and with which prices. \n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- $N$ lines follow. Each of these lines contains a character $m$, followed by a space and an integer $t$, describing a request to see the movie $m$ at the showtime $t$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the maximum profit Alex can earn (possibly negative).\nFinally, print a line containing one integer ― the total profit over all test cases, i.e. over $T$ days.\n\n-----Constraints-----\n- $1 \\le T \\le 150$\n- $0 \\le N \\le 100$\n- $m$ is 'A', 'B', 'C' or 'D'\n- $t$ is $12$, $3$, $6$ or $9$\n\n-----Subtasks-----\nSubtask #1 (30 points): it is possible to fulfill all requests\nSubtask #2 (70 points): original constraints\n\n-----Example Input-----\n5\n12\nA 3\nB 12\nC 6\nA 9\nB 12\nC 12\nD 3\nB 9\nD 3\nB 12\nB 9\nC 6\n7\nA 9\nA 9\nB 6\nC 3\nD 12\nA 9\nB 6\n2\nA 9\nB 6\n1\nD 12\n0 \n\n-----Example Output-----\n575\n525\n-25 \n-200 \n-400\n475\n\n-----Explanation-----\nExample case 1: The following table shows the number of people that want to watch the movies at the given showtimes:  12  3  6  9   A   0  1  0 1  B   3  0  0  2   C   1  0  2  0   D   0  2  0  0 \nThe maximum number of requests was sent for movie B at 12 PM. Therefore, we play this movie at this time and the tickets cost Rs 100. Next, we play movie D at 3 PM with ticket price Rs 75 and movie C at 6 PM with ticket price Rs 50. Finally, we have a slot for 9 PM and the only movie we can play at that time now is movie A, with ticket price Rs 25. The total profit is $3 \\cdot 100 + 2 \\cdot 75 + 2 \\cdot 50 + 1 \\cdot 25 = 300 + 150 + 100 + 25 = 575$. Since each movie was watched by at least one person, there is no additional loss.\nExample case 2: Just like above, we show the requests in a table:  12  3  6  9   A   0  0  0 3  B   0  0  2  0   C   0  1  0  0   D   1  0  0  0 \nThe optimal solution is to play movie A at 9 PM, movie B at 6 PM, movie C at 3 PM and movie D at 12 PM, with decreasing ticket prices in this order. The profit is $3 \\cdot 100 + 2 \\cdot 75 + 1 \\cdot 50 + 1 \\cdot 25 = 300+150+50+25 = 525$.\nExample case 3: Again, we show the requests in a table:  12  3  6  9   A   0  0  0 1  B   0  0  1  0   C   0  0  0  0   D   0  0  0  0 \nThe optimal solution is to play movie A at 9 PM with ticket price Rs 100, movie B at 6 PM with ticket price Rs 75 and the remaining two movies in any order at 12 PM and 3 PM ― either way, there will be nobody watching them. We earn $1 \\cdot 100 + 1 \\cdot 75 = 175$, but we have to deduct Rs 200, so the resulting profit is $175 - 200 = -25$.\nExample case 4: The optimal solution is to play movie D at 12 PM; the other three movies go unattended. We have to deduct Rs 300, so the profit is $1 \\cdot 100 - 300 = -200$.\nExample case 5: Since there are no requests for any movie at any time, all movies go unattended and Alex just suffers a loss of Rs 400.\nThe total profit for all 5 days is $575+525-25-200-400 = 475$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maximize_profit (n : Nat) (requests : List Request) : Int := sorry\n\ntheorem profit_is_bounded_above (n : Nat) (requests : List Request) :\n  maximize_profit n requests ≤ n * 100 - 100 := sorry", "vc-theorems": "theorem profit_has_lower_bound (n : Nat) (requests : List Request) :\n  maximize_profit n requests ≥ -400 := sorry \n\ntheorem empty_requests_profit (requests : List Request) :\n  requests = [] → maximize_profit 0 requests = -400 := sorry\n\ntheorem single_request_above_min (r : Request) :\n  maximize_profit 1 [r] > -400 := sorry \n\ntheorem same_movie_diff_times_above_min (m : Char) :\n  let reqs := [⟨m, \"3\"⟩, ⟨m, \"6\"⟩, ⟨m, \"9\"⟩, ⟨m, \"12\"⟩]\n  maximize_profit 4 reqs > -400 := sorry\n\ntheorem diff_movies_same_time_above_min (t : String) :\n  let reqs := [⟨'A', t⟩, ⟨'B', t⟩, ⟨'C', t⟩, ⟨'D', t⟩] \n  maximize_profit 4 reqs > -400 := sorry\n\n/-\ninfo: 575\n-/\n-- #guard_msgs in\n-- #eval maximize_profit 12 [(\"A\", \"3\"), (\"B\", \"12\"), (\"C\", \"6\"), (\"A\", \"9\"), (\"B\", \"12\"), (\"C\", \"12\"), (\"D\", \"3\"), (\"B\", \"9\"), (\"D\", \"3\"), (\"B\", \"12\"), (\"B\", \"9\"), (\"C\", \"6\")]\n\n/-\ninfo: 525\n-/\n-- #guard_msgs in\n-- #eval maximize_profit 7 [(\"A\", \"9\"), (\"A\", \"9\"), (\"B\", \"6\"), (\"C\", \"3\"), (\"D\", \"12\"), (\"A\", \"9\"), (\"B\", \"6\")]\n\n/-\ninfo: -400\n-/\n-- #guard_msgs in\n-- #eval maximize_profit 0 []", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1165", "language": "lean", "source": "fvapps", "source-id": "fvapps_001165", "source-notes": "", "vc-description": "/-\nDo you know Professor Saeed? He is the algorithms professor at Damascus University. Yesterday, he gave his students hard homework (he is known for being so evil) - for a given binary string $S$, they should compute the sum of $F(S, L, R)$ over all pairs of integers $(L, R)$ ($1 \\le L \\le R \\le |S|$), where the function $F(S, L, R)$ is defined as follows:\n- Create a string $U$: first, set $U = S$, and for each $i$ ($L \\le i \\le R$), flip the $i$-th character of $U$ (change '1' to '0' or '0' to '1').\n- Then, $F(S, L, R)$ is the number of valid pairs $(i, i + 1)$ such that $U_i = U_{i+1}$.\nAs usual, Professor Saeed will give more points to efficient solutions. Please help the students solve this homework.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first and only line of each test case contains a single string $S$.\n\n-----Output-----\nFor each test case, print a single line containing one integer $\\sum_{1 \\le L \\le R \\le |S|} F(S, L, R)$.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le |S| \\le 3 \\cdot 10^6$\n- the sum of $|S|$ over all test cases does not exceed $6 \\cdot 10^6$\n\n-----Subtasks-----\nSubtask #1 (50 points):\n- $1 \\le |S| \\le 300$\n- the sum of $|S|$ over all test cases does not exceed $600$\nSubtask #2 (50 points): original constraints\n\n-----Example Input-----\n1\n001\n\n-----Example Output-----\n6\n\n-----Explanation-----\nExample case 1:\n- $L = 1, R = 1$: $U$ is \"101\", $F = 0$\n- $L = 2, R = 2$: $U$ is \"011\", $F = 1$\n- $L = 3, R = 3$: $U$ is \"000\", $F = 2$\n- $L = 1, R = 2$: $U$ is \"111\", $F = 2$\n- $L = 2, R = 3$: $U$ is \"010\", $F = 0$\n- $L = 1, R = 3$: $U$ is \"110\", $F = 1$\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_binary_string_flips : BinaryString → Nat\n  | _ => sorry", "vc-theorems": "theorem single_char_string_has_no_pairs (b : Bool) : \n  solve_binary_string_flips (BinaryString.cons b BinaryString.empty) = 0 := by\n  sorry\n\ntheorem output_is_nonnegative (s : BinaryString) : \n  solve_binary_string_flips s ≥ 0 := by\n  sorry\n\ntheorem empty_string_returns_zero :\n  solve_binary_string_flips BinaryString.empty = 0 := by\n  sorry\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval solve_binary_string_flips \"001\"\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval solve_binary_string_flips \"0\"\n\n/-\ninfo: 18\n-/\n-- #guard_msgs in\n-- #eval solve_binary_string_flips \"1111\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1169", "language": "lean", "source": "fvapps", "source-id": "fvapps_001169", "source-notes": "", "vc-description": "/-\n-----Problem Statement-----\nOne of the things JEC is known for is its GR (Group Recreation) where juniors and seniors do friendly interaction ;P\nAs for the new session of 2020 seniors decided to have their first GR and give them some treat. Juniors were excited about it they came to college canteen aligned in a line and counted themselves one by one from left to right so that every junior gets his/her treat. But seniors played a game and they will treat only the ones who passes in this game. Game is simple all they need to do is to alternate their language (between Hindi and English) while telling their positions that is if the junior just before you told 2 in English you need to say 3 in Hindi . You do not want to be the one left without a treat. \nYou are the junior standing at position $X$ from left and the counting could start from left or right you have to predict which number you have to speak and in which language when your turn comes.\n\n-----Input:-----\n- \nFirst line will contain $T$, number of testcases. Then the testcases follow. \n- \nEach testcase contains 2 lines first consist 2 space separated integers, $N$ (total count) , $X$ (your position from left), next line consist of 2 space separated characters  L or R (Direction from which counting starts L-left, R-Right) and H or E (the language to start counting).\n\n-----Output:-----\nFor each testcase, output a single line consisting space seperated Integer P and Character L\nwhere P is the number you will speak and L is the language (H or E).\n\n-----Constraints-----\n- $1 \\leq T \\leq 1000$\n- $1 \\leq N \\leq 120$\n- $1 \\leq X \\leq N$\n\n-----Sample Input:-----\n2\n15 5\nL H\n20 14\nR E\n\n*try to trim extra white spaces like new line during input in case of wrong answer\n\n-----Sample Output:-----\n5 H\n7 E\n\n-----EXPLANATION:-----\n- When counting starts from left with H it alternates like H E H E H….. on the fifth position H comes\n- When Count starts from right with E it alternates like E H E H E H E….. with E on the position of 14th student from right.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_gr_game (n x : Nat) (d : Direction) (l : Language) : Nat × Language :=\n  sorry", "vc-theorems": "theorem position_in_bounds {n x : Nat} {d : Direction} {l : Language} \n    (h1 : 0 < n) (h2 : 0 < x) :\n  let (pos, _) := solve_gr_game n x d l\n  0 < pos ∧ pos ≤ n :=\n  sorry\n\ntheorem position_matches_direction {n x : Nat} {d : Direction} {l : Language} \n    (h1 : 0 < n) (h2 : 0 < x) (h3 : x ≤ n) :\n  let (pos, _) := solve_gr_game n x d l\n  (d = Direction.L → pos = x) ∧ \n  (d = Direction.R → pos = n - x + 1) :=\n  sorry\n\ntheorem language_alternates {n x : Nat} {d : Direction} {l : Language}\n    (h1 : 0 < n) (h2 : 0 < x) :\n  let (pos, lang) := solve_gr_game n x d l\n  ((pos % 2 = 1) → lang = l) ∧\n  ((pos % 2 = 0) → lang = match l with\n                           | Language.E => Language.H\n                           | Language.H => Language.E) :=\n  sorry\n\nend Game", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1184", "language": "lean", "source": "fvapps", "source-id": "fvapps_001184", "source-notes": "", "vc-description": "/-\nIt is well-known that the elephants are afraid of mouses. The Little Elephant from the Zoo of Lviv is not an exception.\n\nThe Little Elephant is on a board A of n rows and m columns (0-based numeration). At the beginning he is in cell with coordinates (0; 0) and he wants to go to cell with coordinates (n-1; m-1). From cell (x; y) Little Elephant can go either to (x+1; y) or (x; y+1).\n\nEach cell of the board contains either 1 or 0. If A[i][j] = 1, then there is a single mouse in cell (i; j). Mouse at cell (i; j) scared Little Elephants if and only if during the path there was at least one such cell (x; y) (which belongs to that path) and |i-x| + |j-y| <= 1.\n\nLittle Elephant wants to find some correct path from (0; 0) to (n-1; m-1) such that the number of mouses that have scared the Little Elephant is minimal possible. Print that number.\n\n-----Input-----\nFirst line contains single integer T - the number of test cases. Then T test cases follow. First line of each test case contain pair of integers n and m - the size of the board. Next n lines contain n strings, each of size m and consisted of digits 0 and 1.\n\n-----Output-----\nIn T lines print T integer - the answers for the corresponding test.\n\n-----Constraints-----\n1 <= T <= 50\n2 <= n, m <= 100\n\n-----Example-----\nInput:\n2\n3 9\n001000001\n111111010\n100100100\n7 9\n010101110\n110110111\n010011111\n100100000\n000010100\n011011000\n000100101\n\nOutput:\n9\n10\n\n-----Explanation-----\nExample case 1: \nThe optimized path is: (0, 0) -> (0, 1) -> (0, 2) -> (0, 3) -> (0, 4) -> (0, 5) -> (0, 6) -> (0, 7) -> (0, 8) -> (1, 8) -> (2, 8). The mouses that scared the Little Elephant are at the following cells: (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 7), (0, 2), (0, 8).\n\nExample case 2: \nThe optimized path is: (0, 0) -> (1, 0) -> (1, 1) -> (2, 1) -> (2, 2) -> (3, 2) -> (3, 3) -> (4, 3) -> (4, 4) -> (5, 4) -> (5, 5) -> (6, 5) -> (6, 6) -> (6, 7) -> (6, 8). The 10 mouses that scared the Little Elephant are at the following cells: (0, 1), (1, 0), (1, 1), (2, 1), (3, 3), (4, 4), (5, 4), (5, 5), (6, 6), (6, 8).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_valid_grid (grid : List String) : Bool := sorry \n\ndef solve_elephant_path (grid : List String) : Result := sorry\n\n/- For any valid grid input, solve_elephant_path returns a natural number -/", "vc-theorems": "theorem valid_grid_returns_nat (grid : List String) \n  (h : is_valid_grid grid = true) : \n  ∃ (n : Nat), solve_elephant_path grid = Result.Value n := sorry\n\n/- For any invalid grid input, solve_elephant_path returns an error -/\n\ntheorem invalid_grid_errors (grid : List String) \n  (h : is_valid_grid grid = false) :\n  solve_elephant_path grid = Result.Error := sorry\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval solve_elephant_path [\"3 9\", \"001000001\", \"111111010\", \"100100100\"]\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval solve_elephant_path [\"7 9\", \"010101110\", \"110110111\", \"010011111\", \"100100000\", \"000010100\", \"011011000\", \"000100101\"]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1190", "language": "lean", "source": "fvapps", "source-id": "fvapps_001190", "source-notes": "", "vc-description": "/-\nAND gates and OR gates are basic components used in building digital circuits. Both gates have two input lines and one output line. The output of an AND gate is 1 if both inputs are 1, otherwise the output is 0. The output of an OR gate is 1 if at least one input is 1, otherwise the output is 0.\n\nYou are given a digital circuit composed of only AND and OR gates where one node (gate or input) is specially designated as the output. Furthermore, for any gate G and any input node I, at most one of the inputs to G depends on the value of node I.\n\nNow consider the following random experiment. Fix some probability p in [0,1] and set each input bit to 1 independently at random with probability p (and to 0 with probability 1-p). The output is then 1 with some probability that depends on p. You wonder what value of p causes the circuit to output a 1 with probability 1/2.\n\n-----Input-----\n\nThe first line indicates the number of test cases to follow (about 100).\n\nEach test case begins with a single line containing a single integer n with 1 ≤ n ≤ 100 indicating the number of nodes (inputs and gates) in the circuit. Following this, n lines follow where the i'th line describes the i'th node. If the node is an input, the line simply consists of the integer 0. Otherwise, if the node is an OR gate then the line begins with a 1 and if the node is an AND gate then the line begins with a 2. In either case, two more integers a,b follow, both less than i, which indicate that the outputs from both a and b are used as the two input to gate i.\n\nAs stated before, the circuit will be such that no gate has both of its inputs depending on the value of a common input node.\n\nTest cases are separated by a blank line including a blank line preceding the first test case.\n\n-----Output-----\n\nFor each test case you are to output a single line containing the value p for which the output of node n is 1 with probability exactly 1/2 if the inputs are independently and randomly set to value 1 with probability p. The value p should be printed with exactly 5 digits after the decimal.\n\n-----Example-----\nInput:\n\n4\n\n1\n0\n\n3\n0\n0\n1 1 2\n\n3\n0\n0\n2 1 2\n\n5\n0\n0\n0\n2 1 2\n1 3 4\n\nOutput:\n\n0.50000\n0.29289\n0.70711\n0.40303\n\n-----Temporary Stuff-----\n\nA horizontal rule follows.\n\n***\n\nHere's a definition list (with `definitionLists` option):\n\napples\n: Good for making applesauce.\noranges\n: Citrus!\ntomatoes\n: There's no \"e\" in tomatoe.\n\n#PRACTICE\n- This must be done\n[http:codechef.com/users/dpraveen](http:codechef.com/users/dpraveen)\n\n(0.8944272−0.44721360.4472136−0.8944272)(10005)(0.89442720.4472136−0.4472136−0.8944272)(10005)\n\\left(\\begin{array}{cc} \n0.8944272 & 0.4472136\\\\\n-0.4472136 & -0.8944272\n\\end{array}\\right)\n\\left(\\begin{array}{cc} \n10 & 0\\\\ \n0 & 5\n\\end{array}\\right)\n-/", "vc-preamble": "def parseNode (spec : Nat ⊕ (Nat × Nat × Nat)) : Node :=\n  match spec with\n  | Sum.inl n => { nodeType := n, inputA := 0, inputB := 0 }\n  | Sum.inr (t, a, b) => { nodeType := t, inputA := a, inputB := b }\n\ndef calcOutputProb (nodes : List Node) (p : Float) : Float :=\n  sorry", "vc-helpers": "", "vc-definitions": "def findPForHalf (nodes : List Node) : Float :=\n  sorry", "vc-theorems": "theorem input_only_nodes_half_prob (nodes : List Node)\n  (h : ∀ n ∈ nodes, n.nodeType = 0) :\n  Float.abs (findPForHalf nodes - 0.5) < 0.00001 := sorry\n\ntheorem output_prob_bounded (nodes : List Node) (p : Float)\n  (h1 : 0 ≤ p ∧ p ≤ 1) : \n  let out := calcOutputProb nodes p\n  0 ≤ out ∧ out ≤ 1 := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1203", "language": "lean", "source": "fvapps", "source-id": "fvapps_001203", "source-notes": "", "vc-description": "/-\nWalter White and Jesse Pinkman (a drug addict) both love to play with chemicals. One day they were playing with some chemicals to make an energy drink. Unknowingly they made a highly powerful drink. To test the drink on others also they called some of their friends and gave a drop of it to everyone. Now they all were feeling highly energetic and thought of an unique game to play with each other.\nAfter pondering for a while, Jesse came up with an extraordinary idea of competing in a race around a circular globe with N checkpoints each of one unit. Walter and all their other friends agreed with it.They divided themselves in $2$ teams with $N$ teammates in each team.This race has two commencing points $A$ and $B$ strictly facing each other. Walter and his team commences from $A$ point and other team starts from $B$. Both the teams start running at the same time clockwise around the globe. Speed of every player is constant throughout the race. If a player has a speed $X$ then it means that he covers a distance of $X$ units in one second.The race ends when some member of one team overtakes all members of opposite team at any point of time. Now you have to tell if any team will win the race or not.They all are stubborn and can run forever just to win the race. Help them to know if it is possible in anyway that the race will come to an end. \nFor Clarity, you can visualize the path as a circular paths where $A$ and $B$ are opposite ends of diameter. It can be proven that the actual circumference of circle do not affect the answer.\nIt is also possible that someone don't run at all.Keep in mind that the fastest one wins the race so does the code.\n\n-----Input:------\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows. \n- The first line of each test case contains a single integer $N$ number of teammates in both team.\n- The second line contains $N$ space-separated integers $A_1, A_2 \\ldots A_N$ denoting speed of A's Team\n- The third line contains $N$ space-separated integers  $B_1, B_2 \\ldots B_N$ denoting speed of B's Team\n\n-----Output:------\nFor each test case, print a single line denoting YES if the race ends at any point of time else NO\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $1 \\leq N \\leq 10^5$\n- $0 \\leq A_i \\leq 2^{15}$\n- $0 \\leq B_i \\leq 2^{15}$\n\n-----Subtasks-----\nSubtask #1 (30 points): \n- $1 \\le N \\le 20$\n- $0 \\le  A_i  \\le 11$\n- $0 \\le  B_i  \\le 11$\nSubtask #2 (70 points): \n- Original constraints\n\n-----Sample input:-----\n1\n5\n1 2 3 4 5\n2 7 8 9 9\n\n-----Sample output-----\nYES\n\n-----Sample Explanation:------\nTeam B can overtake all members of Team A.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_race_end (n : Nat) (team_a : List Int) (team_b : List Int) : String :=\n  sorry", "vc-theorems": "theorem can_race_end_returns_valid_answer\n  {n : Nat} {team_a team_b : List Int}\n  (h1 : team_a.length = n)\n  (h2 : team_b.length = n)\n  (h3 : n > 0) :\n  can_race_end n team_a team_b = \"YES\" ∨ can_race_end n team_a team_b = \"NO\" :=\n  sorry\n\ntheorem can_race_end_equal_max_implies_no\n  {n : Nat} {team_a team_b : List Int}\n  (h1 : team_a.length = n)\n  (h2 : team_b.length = n)\n  (h3 : n > 0)\n  (h4 : List.maximum? team_a = List.maximum? team_b) :\n  can_race_end n team_a team_b = \"NO\" :=\n  sorry\n\ntheorem can_race_end_unequal_max_implies_yes\n  {n : Nat} {team_a team_b : List Int}\n  (h1 : team_a.length = n)\n  (h2 : team_b.length = n)\n  (h3 : n > 0)\n  (h4 : List.maximum? team_a ≠ List.maximum? team_b) :\n  can_race_end n team_a team_b = \"YES\" :=\n  sorry\n\ntheorem can_race_end_single_element_equal\n  (speed : Int) :\n  can_race_end 1 [speed] [speed] = \"NO\" :=\n  sorry\n\ntheorem can_race_end_single_element_greater\n  (speed : Int) :\n  can_race_end 1 [speed + 1] [speed] = \"YES\" :=\n  sorry\n\ntheorem can_race_end_equal_max_extension\n  {team : List Int} {max_speed : Int}\n  (h1 : team.length > 0) :\n  can_race_end (team.length + 1) (team ++ [max_speed]) (team ++ [max_speed]) = \"NO\" :=\n  sorry\n\n/-\ninfo: 'YES'\n-/\n-- #guard_msgs in\n-- #eval can_race_end 5 [1, 2, 3, 4, 5] [2, 7, 8, 9, 9]\n\n/-\ninfo: 'NO'\n-/\n-- #guard_msgs in\n-- #eval can_race_end 3 [1, 2, 5] [3, 4, 5]\n\n/-\ninfo: 'YES'\n-/\n-- #guard_msgs in\n-- #eval can_race_end 1 [3] [5]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1208", "language": "lean", "source": "fvapps", "source-id": "fvapps_001208", "source-notes": "", "vc-description": "/-\nChef likes to travel very much. He plans some travel routes and wants to know their lengths. He hired you to make these calculations. But be careful, some of the routes are incorrect. There may be some misspelling in city names or there will be no road between some two consecutive cities in the route. Also note that Chef hates to visit the same city twice during his travel. Even the last city should differ from the first. Two consecutive cities in the route should also be different. So you need to check these conditions for the given routes too.\n\nYou will be given the list of all cities and all roads between them with their lengths. All roads are one-way. Also you will be given the list of all travel routes that Chef plans. For each route you should check whether it is correct and find its length in this case.\n\n-----Input-----\n\nThe first line contains positive integer N, the number of cities. The second line contains space separated list of N strings, city names. All city names are distinct.\n\nThe third line contains non-negative integer M, the number of available roads. Each of the next M lines describes one road and contains names C1 and C2 of two cities followed by the positive integer D, the length of the one-way road that connects C1 with C2. It is guaranteed that C1 and C2 will be correct names of two different cities from the list of N cities given in the second line of the input file. For each pair of different cities there is at most one road in each direction and each road will be described exactly once in the input file.\n\nNext line contains positive integer T, the number of travel routes planned by the Chef. Each of the next T lines contains positive integer K followed by K strings, names of cities of the current route. Cities are given in order in which Chef will visit them during his travel.\n\nAll strings in the input file composed only of lowercase, uppercase letters of the English alphabet and hyphens. Each string is non-empty and has length at most 20. If some line of the input file contains more then one element than consecutive elements of this line are separated by exactly one space. Each line of the input file has no leading or trailing spaces.\n\n-----Output-----\nFor each travel route from the input file output a single line containing word ERROR if the route is incorrect and its length otherwise.\n\n-----Constraints-----\n\n1 <= N <= 50\n\n0 <= M <= N * (N - 1)\n\n1 <= D <= 20000\n\n1 <= T <= 50\n\n1 <= K <= 50\n\n1 <= length of each string <= 20\n\n-----Example-----\nInput:\n5\nDonetsk Kiev New-York Miami Hollywood\n9\nDonetsk Kiev 560\nKiev New-York 7507\nNew-York Miami 1764\nMiami Hollywood 28\nHollywood Miami 30\nMiami New-York 1764\nKiev Donetsk 550\nHollywood New-York 1736\nNew-York Hollywood 1738\n13\n5 Donetsk Kiev New-York Miami Hollywood\n5 Hollywood Miami New-York Kiev Donetsk\n3 Donetsk Kiev Donetsk\n2 Kyiv New-York\n3 New-York Hollywood Miami\n2 New-York Miami\n3 Hollywood New-York Miami\n4 Donetsk Kiev Miami Hollywood\n2 Donetsk Hollywood\n1 Donetsk\n2 Mumbai Deli\n6 Donetsk Kiev New-York Miami Hollywood New-York\n2 Miami Miami\n\nOutput:\n9859\nERROR\nERROR\nERROR\n1768\n1764\n3500\nERROR\nERROR\n0\nERROR\nERROR\nERROR\n\n-----Explanation-----\nThe 2nd route is incorrect since there is no road from New-York to Kiev. Note however that inverse road from Kiev to New-York exists. \n\nThe 3rd route is incorrect since the first city coincides with the last one. \n\nThe 4th route is incorrect since there is no city with name Kyiv (Probably Chef means Kiev but he misspells this word). \n\nThe 8th route is incorrect since there is no road from Miami to Kiev. \n\nThe 9th route is incorrect since there is no road from Donetsk to  Hollywood. \n\nThe 10th route is correct. Note that a route composed of exactly one city is always correct provided that city name is written correctly. \n\nThe 11th route is incorrect since there is no cities with names Mumbai and Deli. (Probably Chef is not so good in geography :)) \n\nThe 12th route is incorrect since city New-York is visited twice. \n\nFinally the 13th route is incorrect since we have equal consecutive cities.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_travel_routes (cities : List String) (roads : List (String × String × Int)) \n  (routes : List (List String)) : List Answer := sorry", "vc-theorems": "theorem empty_roads_case {cities : List String} \n  (h1 : cities = [\"A\", \"B\"]) : \n  solve_travel_routes cities [] [[\"A\", \"B\"]] = [Answer.error] := sorry\n\ntheorem single_city_case {cities : List String}\n  (h1 : cities = [\"A\", \"B\"]) :\n  solve_travel_routes cities [] [[\"A\"]] = [Answer.value 0] := sorry\n\ntheorem non_existent_city {cities : List String}\n  (h1 : cities = [\"A\", \"B\"]) :\n  solve_travel_routes cities [] [[\"C\"]] = [Answer.error] := sorry\n\ntheorem valid_simple_route {cities : List String} {roads : List (String × String × Int)}\n  (h1 : cities = [\"A\", \"B\", \"C\"])\n  (h2 : roads = [(\"A\", \"B\", 5), (\"B\", \"C\", 3)]) :\n  solve_travel_routes cities roads [[\"A\", \"B\", \"C\"]] = [Answer.value 8] := sorry\n\ntheorem duplicate_cities_route {cities : List String} {roads : List (String × String × Int)}\n  (h1 : cities = [\"A\", \"B\", \"C\"]) \n  (h2 : roads = [(\"A\", \"B\", 5), (\"B\", \"C\", 3)]) :\n  solve_travel_routes cities roads [[\"A\", \"B\", \"B\"]] = [Answer.error] := sorry\n\ntheorem multiple_routes {cities : List String} {roads : List (String × String × Int)}\n  (h1 : cities = [\"A\", \"B\", \"C\"])\n  (h2 : roads = [(\"A\", \"B\", 1), (\"B\", \"C\", 2), (\"A\", \"C\", 5)]) :\n  solve_travel_routes cities roads [[\"A\", \"B\"], [\"B\", \"C\"], [\"A\", \"C\"]] = \n    [Answer.value 1, Answer.value 2, Answer.value 5] := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1226", "language": "lean", "source": "fvapps", "source-id": "fvapps_001226", "source-notes": "", "vc-description": "/-\nOnce again, we have a lot of requests from coders for a challenging problem on geometry. Geometry expert Nitin is thinking about a problem with parabolas, icosahedrons, crescents and trapezoids, but for now, to encourage beginners, he chooses to work with circles and rectangles.\nYou are given two sequences $A_1, A_2, \\ldots, A_N$ and $B_1, B_2, \\ldots, B_N$. You should choose a permutation $P_1, P_2, \\ldots, P_N$ of the integers $1$ through $N$ and construct $N$ rectangles with dimensions $A_1 \\times B_{P_1}, A_2 \\times B_{P_2}, \\ldots, A_N \\times B_{P_N}$. Then, for each of these rectangles, you should construct an inscribed circle, i.e. a circle with the maximum possible area that is completely contained in that rectangle.\nLet $S$ be the sum of diameters of these $N$ circles. Your task is to find the maximum value of $S$.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$. \n- The third line contains $N$ space-separated integers $B_1, B_2, \\ldots, B_N$. \n\n-----Output-----\nFor each test case, print a single line containing one integer ― the maximum value of $S$. It is guaranteed that this value is always an integer.\n\n-----Constraints-----\n- $1 \\le T \\le 50$\n- $1 \\le N \\le 10^4$\n- $1 \\le A_i, B_i \\le 10^9$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (20 points):\n- $A_1 = A_2 = \\ldots = A_N$\n- $B_1 = B_2 = \\ldots = B_N$\nSubtask #2 (80 points): original constraints\n\n-----Example Input-----\n2\n4\n8 8 10 12\n15 20 3 5\n3\n20 20 20\n10 10 10\n\n-----Example Output-----\n30\n30\n\n-----Explanation-----\nExample case 1: Four rectangles with dimensions $8 \\times 3$, $8 \\times 5$, $10 \\times 20$ and $12 \\times 15$ lead to an optimal answer.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def List.sort : List Nat → List Nat := sorry\n\ndef solve_circle_rectangles (n : Nat) (A B : List Nat) : Nat := sorry", "vc-theorems": "theorem result_less_than_inputs {n : Nat} {A B : List Nat} \n  (h1 : A.length = n) (h2 : B.length = n) :\n  solve_circle_rectangles n A B ≤ List.sum A ∧ \n  solve_circle_rectangles n A B ≤ List.sum B := sorry\n\ntheorem result_non_negative {n : Nat} {A B : List Nat}\n  (h1 : A.length = n) (h2 : B.length = n) :\n  solve_circle_rectangles n A B ≥ 0 := sorry\n\ntheorem result_order_independent {n : Nat} {A B : List Nat}\n  (h1 : A.length = n) (h2 : B.length = n) :\n  solve_circle_rectangles n A B = \n  solve_circle_rectangles n A.reverse B.reverse := sorry\n\ntheorem result_is_sum_of_mins {n : Nat} {A B : List Nat}\n  (h1 : A.length = n) (h2 : B.length = n) :\n  solve_circle_rectangles n A B = \n  List.sum (List.map (fun (p : Nat × Nat) => min p.fst p.snd) \n    (List.zip (List.sort A) (List.sort B))) := sorry\n\n/-\ninfo: 30\n-/\n-- #guard_msgs in\n-- #eval solve_circle_rectangles 4 [8, 8, 10, 12] [15, 20, 3, 5]\n\n/-\ninfo: 30\n-/\n-- #guard_msgs in\n-- #eval solve_circle_rectangles 3 [20, 20, 20] [10, 10, 10]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1227", "language": "lean", "source": "fvapps", "source-id": "fvapps_001227", "source-notes": "", "vc-description": "/-\nGet excited, folks, because it is time for the final match of Codechef Premier League (CPL)!\nMike and Tracy also want to watch the grand finale, but unfortunately, they could not get tickets to the match. However, Mike is not someone who gives up so easily — he has a plan to watch the match.\nThe field where the match is played is surrounded by a wall with height $K$. Outside, there are $N$ boxes (numbered $1$ through $N$). For each valid $i$, the $i$-th box has a height $H_i$.\nMike wants to take some boxes and stack them on top of each other to build two towers. The height of each tower is the sum of heights of all the boxes that form it. Of course, no box may be in both towers. The height of each tower should be at least $K$. Then Mike can climb on top of one tower and Tracy on top of the other, and they can watch the match uninterrupted!\nWhile Mike is busy stacking the boxes, Tracy would like to know the smallest number of boxes required to build two towers such that each of them has height at least $K$, or at least that it is impossible to build such towers. Can you help Tracy?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $K$.\n- The second line contains $N$ space-separated integers $H_1, H_2, \\ldots, H_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer — the smallest number of boxes required to build two towers, or $-1$ if it is impossible.\n\n-----Constraints-----\n- $1 \\leq T \\leq 5$\n- $1 \\leq N, K \\leq 4,000$\n- $1 \\leq H_i \\leq 10^5$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (30 points):\n- $1 \\leq N, K \\leq 100$\n- $1 \\leq H_i \\leq 100$ for each valid $i$\nSubtask #2 (70 points): original constraints\n\n-----Example Input-----\n2\n8 38\n7 8 19 7 8 7 10 20\n4 5\n2 10 4 9\n\n-----Example Output-----\n7\n2\n\n-----Explanation-----\nExample case 1: The first tower can be built with boxes $8 + 10 + 20 = 38$ and the second tower with boxes $7 + 7 + 8 + 19 = 41$. In this case, the box with height $7$ is left unused.\nExample case 2: We only need the box with height $10$ for one tower and the box with height $9$ for the other tower.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def build_two_towers (n : Nat) (k : Nat) (heights : List Nat) : Int := sorry\n\n/- Single box twice the height of k always returns -1 -/", "vc-theorems": "theorem single_tall_box_impossible (height : Nat) :\n  build_two_towers 1 height [2 * height] = -1 := sorry\n\n/- Given a list of heights, building towers of minimum height is always possible -/\n\ntheorem min_height_possible (heights : List Nat) (h : heights.length ≥ 2) :\n  let n := heights.length\n  let k := heights.minimum?\n  match k with\n  | none => True \n  | some k => build_two_towers n k heights ≠ -1\n  := sorry\n\n/- List elements in different order produce the same result -/\n\ntheorem permutation_preserves_result (heights1 heights2 : List Nat) \n    (h1 : heights1.length ≥ 2)\n    (h2 : heights1.isPerm heights2) :\n  let n := heights1.length\n  let k := heights1.minimum?\n  match k with\n  | none => True\n  | some k => build_two_towers n k heights1 = build_two_towers n k heights2\n  := sorry\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval build_two_towers 8 38 [7, 8, 19, 7, 8, 7, 10, 20]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval build_two_towers 4 5 [2, 10, 4, 9]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval build_two_towers 3 10 [2, 3, 4]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1231", "language": "lean", "source": "fvapps", "source-id": "fvapps_001231", "source-notes": "", "vc-description": "/-\nThe chef is trying to solve some pattern problems, Chef wants your help to code it. Chef has one number K to form a new pattern. Help the chef to code this pattern problem.\n\n-----Input:-----\n- First-line will contain $T$, the number of test cases. Then the test cases follow. \n- Each test case contains a single line of input, one integer $K$. \n\n-----Output:-----\nFor each test case, output as the pattern.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq K \\leq 100$\n\n-----Sample Input:-----\n3\n2\n3\n4\n\n-----Sample Output:-----\n1121\n1222\n112131\n122232\n132333\n11213141\n12223242\n13233343\n14243444\n\n-----EXPLANATION:-----\nNo need, else pattern can be decode easily.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def generate_pattern (k : Nat) : Array String := sorry\n\ntheorem generate_pattern_length (k : Nat) (h : k > 0) : \n  (generate_pattern k).size = k := sorry", "vc-theorems": "theorem generate_pattern_numeric (k : Nat) (h : k > 0) :\n  ∀ s ∈ (generate_pattern k).data, ∀ c ∈ s.data, c.isDigit := sorry\n\n/-\ninfo: ['1121', '1222']\n-/\n-- #guard_msgs in\n-- #eval generate_pattern 2\n\n/-\ninfo: ['112131', '122232', '132333']\n-/\n-- #guard_msgs in\n-- #eval generate_pattern 3\n\n/-\ninfo: ['11213141', '12223242', '13233343', '14243444']\n-/\n-- #guard_msgs in\n-- #eval generate_pattern 4", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1236", "language": "lean", "source": "fvapps", "source-id": "fvapps_001236", "source-notes": "", "vc-description": "/-\nChef hates unoptimized codes and people who write such codes. One fine day he decided to look through the kitchen's codebase and found a function whose pseudo-code is given here:\n\ninput: integer N, list X[1, 2, ..., N], list Y[1, 2, ..., N]\n\noutput: integer res\n\nfunction:\n\nset res = 0;\nfor i := 1 to N do\nfor j := 1 to N do\nfor k := 1 to N do\nif (X[i] = X[j]) OR (X[j] = X[k]) OR (X[k] = X[i])\ncontinue\nelse\nset res = max(res, Y[i] + Y[j] + Y[k])\nreturn res\n\nLuckily enough this code gets triggered only if the Head Chef makes a submission. But still there is a possibility that this can crash the judge. So help Chef by writing a new function which does the same thing but is faster.\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n- The first line of each test case contains an integer N denoting the number of elements in the two lists.\n- The i-th of the next N lines contains a pair of space-separated integers denoting the values of X[i] and Y[i] respectively.\n\n-----Output-----\nFor each test case, output an integer corresponding to the return value of the function.\n\n-----Constraints-----\n- 1 ≤ T ≤ 10\n- 1 ≤ N ≤ 105\n- 1 ≤ X[i], Y[i] ≤ 108\n\n-----Example-----\nInput\n2\n3\n1 3\n3 1\n1 2\n5\n1 3\n2 4\n1 2\n3 2\n3 4\n\nOutput\n0\n11\n\n-----Explanation-----\nTestcase 2: The maximum is attained when i = 1, j = 2 and k = 5. This leads to res being 3 + 4 + 4 = 11. This value is attained in other iterations as well, but it never exceeds this, and hence this is the answer.\n-/", "vc-preamble": "def Coord := Nat × Nat \n\ndef max_distinct_sum (n: Nat) (pairs: List Coord) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + List.sum xs", "vc-theorems": "theorem max_distinct_sum_single_coord (n: Nat) :\n  max_distinct_sum n [(1,n)] = 0 :=\nsorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval max_distinct_sum 3 [(1, 3), (3, 1), (1, 2)]\n\n/-\ninfo: 11\n-/\n-- #guard_msgs in\n-- #eval max_distinct_sum 5 [(1, 3), (2, 4), (1, 2), (3, 2), (3, 4)]\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval max_distinct_sum 4 [(1, 1), (2, 2), (3, 3), (4, 4)]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1244", "language": "lean", "source": "fvapps", "source-id": "fvapps_001244", "source-notes": "", "vc-description": "/-\nChef Shifu wanted to celebrate the success of his new restaurant with all his employees. He was willing to host a party and he had decided the location of the party as well. However, Chef Shifu was a shy person and wanted to communicate with the least possible employees to inform them about the party, and that these employees could inform their friends.\n\nNote that an employee could only inform his/her immediate friends about the party, not his/her friends’ friends.\n\nChef Shifu has a list of all the friendships among his employees. Help him find the minimum number of employees he should inform, so that every employee knows about the celebration party.\n\n-----Input-----\nFirst line contains a single integer T - the total number of testcases.\n\nT testcases follow. For each testcase:\n\nThe first line contains 2 space-separated integers N and M - the total number of employees working under Chef Shifu and the number of friendship relations.\n\nM lines follow - each line contains 2 space-separated integers u and v, indicating that employee u is a friend of employee v and vice-versa.\n\nThe employees are numbered from 1 to N, and each employee is assigned a distinct integer.\n\n-----Output-----\nFor each testcase, print the minimum number of employees to be informed on a new line.\n\n-----Constraints-----\nSubtask 1: 5 points\n\n1 ≤ T ≤ 5\n\n1 ≤ N ≤ 4\n\n0 ≤ M ≤ N*(N-1)/2\n\nSubtask 2: 35 points\n\n1 ≤ T ≤ 5\n\n1 ≤ N ≤ 15\n\n0 ≤ M ≤ N*(N-1)/2\n\nSubtask 3: 60 points\n\n1 ≤ T ≤ 5\n\n1 ≤ N ≤ 20\n\n0 ≤ M ≤ N*(N-1)/2\n\n-----Example-----\nInput\n2\n3 3\n1 2\n2 3\n1 3\n4 3\n1 2\n2 3\n3 4\n\nOutput\n1\n2\n\nExplanation\n\nIn testcase 1, since every employee is a friend of every other employee, we just need to select 1 employee.\nIn testcase 2, selecting employees 2 and 4 would ensure that all 4 employees are represented.\n\nSimilarly, selecting employees 1 and 3 would also ensure that all 4 employees are selected.\n\nIn both cases, we must select 2 employees in the best case.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_employees_to_inform (n : Nat) (pairs : List (Nat × Nat)) : Nat := sorry\n\ntheorem line_formation (n : Nat) (h : 2 ≤ n) \n  (pairs : List (Nat × Nat))\n  (h_pairs : pairs = List.map (fun i => (i, i+1)) (List.range (n-1))) :\n  min_employees_to_inform n pairs ≤ (n + 1) / 2 := sorry", "vc-theorems": "theorem star_formation (n : Nat) (h : 2 ≤ n)\n  (pairs : List (Nat × Nat))\n  (h_pairs : pairs = List.map (fun i => (1, i+2)) (List.range (n-1))) :\n  min_employees_to_inform n pairs = 1 := sorry\n\ntheorem fully_connected (n : Nat) (h : 3 ≤ n)\n  (pairs : List (Nat × Nat))\n  (h_pairs : pairs = List.join (List.map \n    (fun i => List.map (fun j => (i,j)) (List.range' (i+1) (n+1))) \n    (List.range' 1 n))) :\n  min_employees_to_inform n pairs = 1 := sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval min_employees_to_inform 3 [(1, 2), (2, 3), (1, 3)]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval min_employees_to_inform 4 [(1, 2), (2, 3), (3, 4)]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval min_employees_to_inform 4 [(1, 2), (1, 3), (1, 4)]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1247", "language": "lean", "source": "fvapps", "source-id": "fvapps_001247", "source-notes": "", "vc-description": "/-\nDid you hear about the Nibiru collision ? It is a supposed disastrous encounter between the earth and a large planetary object. Astronomers reject this idea. But why listen to other people's beliefs and opinions. We are coders above all, so what better way than to verify it by a small code. The earth and N asteroids are in the 2D plane. Each of them is initially located at some integer coordinates at time = 0 and is moving parallel to one of the X or Y axis with constant velocity of 1 unit per second. \n\nDirection of movement is given as 'U' ( Up = towards positive Y ), 'D' ( Down = towards negative Y ), 'R' ( Right = towards positive X ), 'L' ( Left = towards negative X ). Given the initial position and the direction of movement of the earth and each of the N asteroids, find the earliest time at which the earth collides with one of the asteroids. If there can not be any collisions with the earth, print \"SAFE\" ( without quotes ). You can ignore the collisions between asteroids ( i.e., they continue to move in same direction even after collisions between them ).\n\n-----Input-----\n\nFirst line contains T, number of test cases. T cases follow. In each test case, first line contains XE YE DIRE, where (XE,YE) is the initial position of the Earth, DIRE is the direction in which it moves. Second line contains N, the number of\nasteroids. N lines follow, each containing XA YA DIRA, the initial position and the direction of movement of each asteroid. No asteroid is initially located at (XE,YE)\n\n-----Output-----\n\nFor each test case, output the earliest time at which the earth can collide with an asteroid (rounded to 1 position after decimal). If there can not be any collisions with the earth, print \"SAFE\" (without quotes).\n\n-----Constraints-----\n\n1 ≤ T ≤ 10\n\n1 ≤ N ≤ 2012\n\n-100 ≤ XE, YE, XA, YA ≤ 100\n\n(XE,YE) != any of (XA,YA)\n\nDIRE, DIRA is one of 'U', 'R', 'D', 'L'\n\n-----Example-----\nInput:\n3\n0 0 R\n2\n1 -2 U\n2 2 D\n1 1 U\n1\n1 0 U\n0 0 R\n1\n3 0 L\n\nOutput:\n2.0\nSAFE\n1.5\n\nExplanation:\n\nCase 1 : \n\nTime 0 - Earth (0,0) Asteroids { (1,-2), (2,2) }\n\nTime 1 - Earth (1,0) Asteroids { (1,-1), (2,1) }\n\nTime 2 - Earth (2,0) Asteroids { (1,0 ), (2,0) }\n\nCase 2 : \n\nThe only asteroid is just one unit away below the earth and following us always, but it will never collide :)\n\nCase 3 : \n\nTime 0 - Earth (0,0) Asteroid (3,0)\n\nTime 1 - Earth (1,0) Asteroid (2,0)\n\nTime 1.5 - Earth (1.5,0) Asteroid (1.5,0)\n\nNote : There are multiple test sets, and the judge shows the sum of the time taken over all test sets of your submission, if Accepted.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_earliest_collision (earth_x earth_y: Int) (earth_dir: Dir) (asteroids: List Asteroid) : \n  String ⊕ Float := sorry", "vc-theorems": "theorem find_earliest_collision_safe_or_bounded\n  {earth_x earth_y: Int}\n  {earth_dir: Dir}\n  {asteroids: List Asteroid}\n  (h1: earth_x ≥ -100 ∧ earth_x ≤ 100)\n  (h2: earth_y ≥ -100 ∧ earth_y ≤ 100)\n  (h3: asteroids.length ≤ 5)\n  (h4: ∀ a ∈ asteroids, a.x ≥ -100 ∧ a.x ≤ 100 ∧ a.y ≥ -100 ∧ a.y ≤ 100) :\n  let result := find_earliest_collision earth_x earth_y earth_dir asteroids\n  match result with\n  | Sum.inl s => s = \"SAFE\" \n  | Sum.inr f => f ≥ 0 ∧ f ≤ 1000000\n  := sorry\n\ntheorem empty_asteroids_is_safe\n  {earth_x earth_y: Int}\n  {earth_dir: Dir}\n  (h1: earth_x ≥ -100 ∧ earth_x ≤ 100)\n  (h2: earth_y ≥ -100 ∧ earth_y ≤ 100) :\n  find_earliest_collision earth_x earth_y earth_dir [] = Sum.inl \"SAFE\" := sorry\n\ntheorem same_direction_is_safe\n  {asteroids: List Asteroid}\n  {dir: Dir}\n  (h: asteroids.length ≤ 5)\n  (h2: ∀ a ∈ asteroids, a.x ≥ -100 ∧ a.x ≤ 100 ∧ a.y ≥ -100 ∧ a.y ≤ 100) :\n  find_earliest_collision 0 0 dir (asteroids.map fun a => {x := a.x, y := a.y, dir := dir}) = \n    Sum.inl \"SAFE\" := sorry\n\n/-\ninfo: 2.0\n-/\n-- #guard_msgs in\n-- #eval find_earliest_collision *earth [(1, -2, \"U\"), (2, 2, \"D\")]\n\n/-\ninfo: 'SAFE'\n-/\n-- #guard_msgs in\n-- #eval find_earliest_collision *earth [(1, 0, \"U\")]\n\n/-\ninfo: 1.5\n-/\n-- #guard_msgs in\n-- #eval find_earliest_collision *earth [(3, 0, \"L\")]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1253", "language": "lean", "source": "fvapps", "source-id": "fvapps_001253", "source-notes": "", "vc-description": "/-\nChef has just started Programming, he is in first year of Engineering. Chef is reading about Relational Operators. \n\nRelational Operators are operators which check relatioship between two values. Given two numerical values A and B you need to help chef in finding the relationship between them that is, \n\n- First one is greater than second or,\n- First one is less than second or,\n- First and second one are equal.\n\n-----Input-----\nFirst line contains an integer T, which denotes the number of testcases. Each of the T lines contain two integers A and B. \n\n-----Output-----\nFor each line of input produce one line of output. This line contains any one of the relational operators\n\n'<' , '>' , '='.\n\n-----Constraints-----\n\n- 1 ≤ T ≤ 10000\n- 1 ≤ A, B ≤ 1000000001\n\n-----Example-----\nInput:\n3\n10 20\n20 10\n10 10\n\nOutput:\n<\n>\n=\n\n-----Explanation-----\nExample case 1. In this example 1 as 10 is lesser than 20.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def check_relation (a b : Int) : RelationType := sorry\n\ndef solve_multiple_testcases (cases : List (Int × Int)) : List RelationType := sorry", "vc-theorems": "theorem check_relation_valid (a b : Int) :\n  let r := check_relation a b\n  match r with\n  | RelationType.less => a < b\n  | RelationType.greater => a > b\n  | RelationType.equal => a = b\n  := sorry\n\ntheorem check_relation_total (a b : Int) :\n  let r := check_relation a b\n  (r = RelationType.less ∨ r = RelationType.greater ∨ r = RelationType.equal)\n  := sorry\n\ntheorem solve_multiple_testcases_valid (cases : List (Int × Int)) :\n  let results := solve_multiple_testcases cases\n  (results.length = cases.length) ∧\n  (∀ i : Nat, i < results.length → \n    results[i]! = check_relation cases[i]!.1 cases[i]!.2)\n  := sorry\n\ntheorem check_relation_transitive (a b c : Int) :\n  (check_relation a b = RelationType.less ∧ check_relation b c = RelationType.less \n    → check_relation a c = RelationType.less) ∧\n  (check_relation a b = RelationType.greater ∧ check_relation b c = RelationType.greater\n    → check_relation a c = RelationType.greater)\n  := sorry\n\n/-\ninfo: ['<', '>', '=']\n-/\n-- #guard_msgs in\n-- #eval solve_multiple_testcases [(10, 20), (20, 10), (10, 10)]\n\n/-\ninfo: ['<']\n-/\n-- #guard_msgs in\n-- #eval solve_multiple_testcases [(5, 7)]\n\n/-\ninfo: ['=']\n-/\n-- #guard_msgs in\n-- #eval solve_multiple_testcases [(1000000000, 1000000000)]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1256", "language": "lean", "source": "fvapps", "source-id": "fvapps_001256", "source-notes": "", "vc-description": "/-\nSunita has lots of tasks pending and she has no time to complete.  She needs your help and wants you complete the task.\nYou are given a list of integers and two values $N$ and $K$ $-$ the size of array of integers and the numbers of partitions to be made respectively.\nYou have to partition the list of integers without changing the order of elements ,into exactly $K$ parts. \nCalculate Greatest Common Divisor of all $K$ partition and sum up the gcd values for each partition.\nMaximize the sum obtained. \nCan you help Sunita ? \n\n-----Input:-----\n- First line will contain $T$, number of test cases. Then the test cases follow. \n- Each test case contains of a single line of input, two integers $N, K$. \n- Next line contains $N$ integers $-$ the list of integers.\n\n-----Output:-----\nFor each test case, output in a single line integer $-$ the maximal result.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq N, K \\leq 250$\n- $1 \\leq K \\leq N$\n- $1 \\leq A[i] \\leq 1e5$\n\n-----Sample Input:-----\n1\n4 2\n5 6 3 2\n\n-----Sample Output:-----\n6\n\n-----EXPLANATION:-----\n[5] [6 3 2] is the best partition [5 + GCD(6,3,2)] = 6\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x :: xs => x + xs.sum\n\ndef gcd_multiple (nums : List Nat) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def max_gcd_partition_sum (n k : Nat) (arr : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem gcd_multiple_divides (nums : List Nat) (h : nums ≠ []) :\n  let result := gcd_multiple nums\n  (∀ n ∈ nums, n % result = 0) ∧ result > 0 := by\n  sorry\n\ntheorem max_gcd_sum_basic_properties \n  (n k : Nat) (arr : List Nat)\n  (h1 : arr.length ≥ n)\n  (h2 : k ≤ n) :\n  let result := max_gcd_partition_sum n k arr \n  result ≥ 0 ∧ \n  result ≤ (arr.take n).sum := by\n  sorry\n\ntheorem max_gcd_sum_k_one\n  (n : Nat) (arr : List Nat)\n  (h : arr.length ≥ n) :\n  max_gcd_partition_sum n 1 arr = gcd_multiple (arr.take n) := by\n  sorry\n\ntheorem max_gcd_sum_k_eq_n\n  (n : Nat) (arr : List Nat)\n  (h : arr.length ≥ n) :\n  max_gcd_partition_sum n n arr = (arr.take n).sum := by\n  sorry\n\ntheorem max_gcd_sum_identical_elements\n  (n k : Nat) \n  (h1 : n ≥ 2)\n  (h2 : k = n/2) :\n  let arr := List.replicate n 10\n  max_gcd_partition_sum n k arr = 10 * k := by\n  sorry\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval max_gcd_partition_sum 4 2 [5, 6, 3, 2]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1264", "language": "lean", "source": "fvapps", "source-id": "fvapps_001264", "source-notes": "", "vc-description": "/-\nRaj is suffering from shot term memory loss so  he is unable to remember his laptop password  but he has a list of some string and the only thing that he remember about his password is alphanumeric and also that all the characters are unique.\nGiven a list of strings, your task is to find a valid password.\n\n-----Input-----\nEach String contains lower case alphabets and 0-9.\n\n-----Output-----\nprint \"Invalid\"(without quotes) if password is not valid else print \"Valid\"(without quotes) and stop processing input after it.\n\n-----Constraints-----\n1<=length of string <=100\n\n-----Example-----\nInput:\nabsdbads\nasdjenfef\ntyerbet\nabc564\n\nOutput:\nInvalid\nInvalid\nInvalid\nValid\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def check_valid_password (s : String) : PasswordResult :=\n  sorry", "vc-theorems": "theorem empty_string_invalid :\n  check_valid_password \"\" = PasswordResult.Invalid := by\n  sorry\n\ntheorem duplicate_chars_invalid (s : String) (h: s.length ≥ 2) \n  (h2: ∃ c, c ∈ s.data) : \n  let s' := s ++ (String.mk [s.data[0]!]) \n  check_valid_password s' = PasswordResult.Invalid := by\n  sorry\n\ntheorem unique_alphanumeric_valid (s : String) \n  (h1: s.length > 0)\n  (h2: ∀ c ∈ s.data, c.isAlphanum)\n  (h3: ∀ i j, i < s.length → j < s.length → i ≠ j → s.data[i]! ≠ s.data[j]!) :\n  check_valid_password s = PasswordResult.Valid := by\n  sorry\n\ntheorem non_alphanumeric_invalid (s : String)\n  (h1: s.length > 0) \n  (h2: ∃ c ∈ s.data, !c.isAlphanum) :\n  check_valid_password s = PasswordResult.Invalid := by\n  sorry\n\ntheorem result_is_valid_or_invalid (s : String) :\n  (check_valid_password s = PasswordResult.Valid) ∨ \n  (check_valid_password s = PasswordResult.Invalid) := by\n  sorry\n\n/-\ninfo: expected[i]\n-/\n-- #guard_msgs in\n-- #eval check_valid_password passwords[i]\n\n/-\ninfo: 'Valid'\n-/\n-- #guard_msgs in\n-- #eval check_valid_password \"abc123\"\n\n/-\ninfo: 'Invalid'\n-/\n-- #guard_msgs in\n-- #eval check_valid_password \"abcc123\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1270", "language": "lean", "source": "fvapps", "source-id": "fvapps_001270", "source-notes": "", "vc-description": "/-\n-----\nRANJANA QUIZ\n-----\n\nProf. Ranjana decided to conduct a quiz in her class. She divided all the students of her\nclass into groups of three. Consider that no student was left out after the division. She gave\ndifferent sets of questions to every group. A set is said to be unique if there is no other team that\nreceived the same number of maths, science and english questions. In every set, maximum\nquestions for each group were related to maths, then science, and the least number of\nquestions were related to English. Total number of questions given to each team can be\ndifferent. \n\nAfter the test, the CR of the class asked every team to report the number of questions\nthey got on each subject. The CR wants to know the number of unique sets of questions that\nwere given to the teams, the problem is that all the students have just submitted the number of\nquestions of each subject but in no particular order. Help the CR to find the number of unique\nsets\n\n-----Input Format-----\n\nLine 1 contains the number of teams ‘n’. In the next n lines, each line contains three space separated integers,i.e, the number of questions of each subject(in no particular order).\nemployee\n\n-----Output-----\n\nPrint the number of unique sets\n\n-----Example Text Case-----\nInput:\n\n5\n6 5 4\n2 3 7\n4 6 5\n7 2 3\n5 3 1\n\nOutput:\n1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_unique_sets (teams : List Team) : Nat :=\n  sorry", "vc-theorems": "theorem unique_sets_bounds {teams : List Team} :\n  let result := calculate_unique_sets teams\n  0 ≤ result ∧ result ≤ teams.length := by sorry\n\ntheorem shuffle_invariant {teams : List Team} :\n  let shuffled := teams.map (fun t => match t with\n    | Team.mk a b c => Team.mk b c a) \n  calculate_unique_sets shuffled = calculate_unique_sets teams := by sorry\n\ntheorem dedup_property {teams : List Team} :\n  let deduped := teams.eraseDups\n  calculate_unique_sets deduped ≤ calculate_unique_sets teams := by sorry\n\ntheorem repeat_invariant {teams : List Team} (h : teams ≠ []) :\n  calculate_unique_sets (teams ++ teams) = calculate_unique_sets teams := by sorry\n\ntheorem single_team_perms {a b c : Nat} :\n  let perms := [\n    Team.mk a b c,\n    Team.mk a c b,\n    Team.mk b a c,\n    Team.mk b c a, \n    Team.mk c a b,\n    Team.mk c b a\n  ]\n  calculate_unique_sets perms = 1 := by sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval calculate_unique_sets [(6, 5, 4), (2, 3, 7), (4, 6, 5), (7, 2, 3), (5, 3, 1)]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval calculate_unique_sets [(3, 2, 1), (3, 2, 1), (4, 3, 2)]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval calculate_unique_sets [(5, 4, 3), (5, 4, 3), (6, 5, 4)]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1271", "language": "lean", "source": "fvapps", "source-id": "fvapps_001271", "source-notes": "", "vc-description": "/-\nYou are given a weighted undirected graph consisting of n$n$ nodes and m$m$ edges. The nodes are numbered from 1$1$ to n$n$. The graph does not contain any multiple edges or self loops.\nA walk W$W$ on the graph is a sequence of vertices (with repetitions of vertices and edges allowed) such that every adjacent pair of vertices in the sequence is an edge of the graph. We define the cost of a walk W$W$, Cost(W)$Cost(W)$, as the maximum over the weights of the edges along the walk. \nYou will be given q$q$ queries. In each query, you will be given an integer X$X$.\n\nYou have to count the number of different walks W$W$ of length 4$4$ such that Cost(W)$Cost(W)$ = X$X$.\n\nTwo walks are considered different if they do not represent the same edge sequence.\n\n-----Input:-----\n- First line contains 2 integers : the number of nodes n$n$ and number of edges m$m$.\n- Next m$m$ lines each describe u$u$, v$v$ and w$w$, describing an edge between u$u$ and v$v$ with weight w$w$.\n- Next line contains q$q$, the number of queries.\n- Next q$q$ lines each describe an integer X$X$ - the cost of the walk in the query.\n\n-----Output:-----\nFor each query, output in a single line the number of different possible walks.\n\n-----Constraints-----\n- 1≤n≤100$1 \\leq n \\leq 100$\n- 1≤m≤n(n−1)2$1 \\leq m \\leq \\frac{n (n-1)}{2}$\n- 1≤u,v≤n$1 \\leq u, v \\leq n$\n- 1≤w≤100$1 \\leq w \\leq 100$\n- 1≤q≤100$1 \\leq q \\leq 100$\n- 1≤X≤100$1 \\leq X \\leq 100$\n\n-----Sample Input:-----\n3 3\n1 2 1\n2 3 2\n3 1 3\n3\n1\n2\n3\n\n-----Sample Output:-----\n2\n10\n36\n\n-----EXPLANATION:-----\nFor X=2$X = 2$, all possible 10$10$ walks are listed below :\n- 1 -> 2 -> 1 -> 2 -> 3\n- 1 -> 2 -> 3 -> 2 -> 1\n- 1 -> 2 -> 3 -> 2 -> 3\n- 2 -> 1 -> 2 -> 3 -> 2\n- 2 -> 3 -> 2 -> 1 -> 2\n- 2 -> 3 -> 2 -> 3 -> 2\n- 3 -> 2 -> 1 -> 2 -> 1\n- 3 -> 2 -> 1 -> 2 -> 3\n- 3 -> 2 -> 3 -> 2 -> 1\n- 3 -> 2 -> 3 -> 2 -> 3\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_walk_queries (n : Nat) (edges : List (List Nat)) (queries : List Nat) : List Nat := sorry\n\ndef count_walks (g : GraphWalks) (k : Nat) : Nat := sorry\n\n/- Main theorems corresponding to property tests -/\n\n-- Test that all query results are non-negative", "vc-theorems": "theorem query_results_non_negative \n  {n : Nat} {edges : List (List Nat)} {queries : List Nat}\n  (h_n : n ≥ 2)\n  (h_edges : edges.length > 0)\n  (h_queries : queries.length > 0) :\n  let results := solve_walk_queries n edges queries\n  (∀ r ∈ results, r ≥ 0) ∧ \n  (results.length = queries.length) :=\nsorry\n\n-- Test minimal graph case\n\ntheorem minimal_graph_walks :\n  let n := 2\n  let edges := [[1,2,1]]\n  let graph := { n := n, edges := edges : GraphWalks }\n  count_walks graph 1 = 2 :=\nsorry\n\n-- Test triangle graph case\n\ntheorem triangle_graph_walks :\n  let n := 3\n  let edges := [[1,2,1], [2,3,2], [3,1,3]]\n  let queries := [1, 2, 3]\n  solve_walk_queries n edges queries = [2, 10, 36] :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1274", "language": "lean", "source": "fvapps", "source-id": "fvapps_001274", "source-notes": "", "vc-description": "/-\nA despotic king decided that his kingdom needed to be rid of corruption and disparity. He called his prime minister and ordered that all corrupt citizens be put to death. Moreover, he wanted this done quickly.\nThe wily prime minister realised that investigating every citizen to decide who was corrupt and who was not was rather difficult. So he decided on the following plan: He ordered all the citizens to appear in the court one by one and declare their wealth.\nThe king does not sit in the court all the time (he has other important business to attend to - for instance, meet dignitaries from neighbouring kingdoms, spend time with his family …) Whenever the king walks into the court, the prime minister pulls out the richest man who has appeared before the court so far and is still alive and beheads him for being corrupt. Since the rich are more likely to be corrupt, he hopes to get rid of most of the corrupt and the king is happy as he sees his policy being implemented enthusiastically.\nSuppose the wealth of the citizens trooping into the court is\n1376518911241376518911241\\; 3\\; 7\\; 6\\; 5\\; 18\\;  9\\; 11\\;  2\\; 4\nand the king walked in three times: the first time after the first four persons have seen the minister, the second time after the first five persons have seen the minister and, finally after the first nine persons have seen the minister.\nAt the king's first visit the richest person to have met the minister has wealth $7$ and he would be beheaded. At the second visit, the wealth of the richest person who has met the minister and is still alive has wealth $6$ and so he would be beheaded. At the third visit the richest person to have met the minister who is still alive has wealth $18$ and so he would be beheaded.\nYou may assume that the input is such that whenever the king walks in, it is always possible to behead someone.\nYour aim is to write a program that will enable the prime minister to identify the richest man to have met the minister and who is still alive quickly. You may assume that no two citizens have the same wealth.\n\n-----Input:-----\nThe first line of the input consists of two numbers $N$ and $M$, where $N$ is the number of citizens in the kingdom and M is the number of visits to the court by the king.\nThe next $N+M$ lines describe the order in which the $N$ citizens' appearances are interleaved with the $M$ visits by the king. A citizen's visit is denoted by a positive integer, signifying his wealth. You may assume that no two citizens have the same wealth. A visit by the king is denoted by $-1$.\n\n-----Output:-----\nYour output should consist of $M$ lines, where the $i^{th}$ line contains the wealth of the citizen who is beheaded at the $i^{th}$ visit of the king.\n\n-----Constraints:-----\n- $1 \\leq M \\leq 10000$.\n- $1 \\leq N \\leq 100000$.\n- You may assume that in $50 \\%$ of the inputs $1 \\leq M \\leq 1000$ and $1 \\leq N \\leq 8000$.\n\n-----Sample Input-----\n10 3\n1 \n3 \n7 \n6 \n-1 \n5 \n-1 \n18 \n9 \n11\n2\n-1\n4\n\n-----Sample Output-----\n7\n6\n18\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solveExecutions (citizens : List Int) (visits : Nat) : List Int := sorry\n\ntheorem basic_execution_length\n  {wealth_values : List Int}\n  (h₁ : ∀ x ∈ wealth_values, 1 ≤ x ∧ x ≤ 10000)\n  (h₂ : 1 ≤ wealth_values.length ∧ wealth_values.length ≤ 20)\n  (h₃ : citizens = [wealth_values[0]!, -1])\n  : (solveExecutions citizens 1).length = 1 := sorry", "vc-theorems": "theorem basic_execution_value\n  {wealth_values : List Int}\n  (h₁ : ∀ x ∈ wealth_values, 1 ≤ x ∧ x ≤ 10000)\n  (h₂ : 1 ≤ wealth_values.length ∧ wealth_values.length ≤ 20)\n  (h₃ : citizens = [wealth_values[0]!, -1])\n  : (solveExecutions citizens 1)[0]! = wealth_values[0]! := sorry\n\ntheorem single_pair_length\n  {wealth : Int}\n  (h₁ : 1 ≤ wealth ∧ wealth ≤ 10000)\n  (h₂ : citizens = [wealth, -1])\n  : (solveExecutions citizens 1).length = 1 := sorry\n\ntheorem single_pair_value\n  {wealth : Int}\n  (h₁ : 1 ≤ wealth ∧ wealth ≤ 10000) \n  (h₂ : citizens = [wealth, -1])\n  : (solveExecutions citizens 1)[0]! = wealth := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1280", "language": "lean", "source": "fvapps", "source-id": "fvapps_001280", "source-notes": "", "vc-description": "/-\nThere are $N$ cars (numbered $1$ through $N$) on a circular track with length $N$. For each $i$ ($2 \\le i \\le N$), the $i$-th of them is at a distance $i-1$ clockwise from car $1$, i.e. car $1$ needs to travel a distance $i-1$ clockwise to reach car $i$. Also, for each valid $i$, the $i$-th car has $f_i$ litres of gasoline in it initially.\nYou are driving car $1$ in the clockwise direction. To move one unit of distance in this direction, you need to spend $1$ litre of gasoline. When you pass another car (even if you'd run out of gasoline exactly at that point), you steal all its gasoline. Once you do not have any gasoline left, you stop.\nWhat is the total clockwise distance travelled by your car? \n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $f_1, f_2, \\ldots, f_N$.\n\n-----Output-----\nFor each test case, print a single line containing one integer ― the total clockwise distance travelled.\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le N \\le 100$\n- $0 \\le f_i \\le 100$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (100 points): original constraints\n\n-----Example Input-----\n3\n5\n3 0 0 0 0\n5\n1 1 1 1 1\n5\n5 4 3 2 1\n\n-----Example Output-----\n3\n5\n15\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def find_distance (n : Nat) (fuel : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem first_zero_distance_zero (n : Nat) (fuel : List Nat) (h : fuel.length > 0) :\n  fuel.get ⟨0, h⟩ = 0 → find_distance n fuel = 0 :=\nsorry\n\ntheorem all_zeros_distance_zero (n : Nat) :\n  find_distance n (List.replicate n 0) = 0 :=\nsorry\n\ntheorem single_nonzero_distance (n : Nat) (val : Nat) (h : n > 0) :\n  find_distance n (val :: List.replicate (n-1) 0) = val :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval find_distance 5 [3, 0, 0, 0, 0]\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval find_distance 5 [1, 1, 1, 1, 1]\n\n/-\ninfo: 15\n-/\n-- #guard_msgs in\n-- #eval find_distance 5 [5, 4, 3, 2, 1]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1283", "language": "lean", "source": "fvapps", "source-id": "fvapps_001283", "source-notes": "", "vc-description": "/-\nSometimes Sergey visits fast food restaurants. Today he is going to visit the one called PizzaKing.\nSergey wants to buy N meals, which he had enumerated by integers from 1 to N. He knows that the meal i costs Ci rubles. He also knows that there are M meal sets in the restaurant.\nThe meal set is basically a set of meals, where you pay Pj burles and get Qj meals - Aj, 1, Aj, 2, ..., Aj, Qj.\nSergey has noticed that sometimes he can save money by buying the meals in the meal sets instead of buying each one separately. And now he is curious about what is the smallest amount of rubles he needs to spend to have at least one portion of each of the meals.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains a pair of integer numbers N and M denoting the number of meals and the number of the meal sets.\nThe second line contains N space-separated integers C1, C2, ..., CN denoting the costs of the meals, bought separately.\nEach of the following M lines starts with a pair of integer numbers Pi and Qi, denoting the cost of the meal set and the number of meals in it, followed with the integer numbers Ai, 1 Ai, 2, ..., Ai, Qi denoting the meal numbers.\n\n-----Output-----\nFor each test case, output a single line containing the minimal total amount of money Sergey needs to spend in order to have at least one portion of each meal.\n\n-----Constraints-----\n- 1 ≤ Pi, Ci ≤ 106\n- 1 ≤ M ≤ min{2N, 2 × 100000}\n- No meal appears in the set twice or more times.\n- Subtask 1 (16 points): 1 ≤ T ≤ 103, 1 ≤ N ≤ 8\n- Subtask 2 (23 points): For each test file, either 1 ≤ T ≤ 10, 1 ≤ N ≤ 12 or the constraints for Subtask 1 are held.\n- Subtask 3 (61 points): For each test file, either T = 1, 1 ≤ N ≤ 18 or the constraints for Subtask 1 or 2 are held.\n\n-----Example-----\nInput:1\n3 3\n3 5 6\n11 3 1 2 3\n5 2 1 2\n5 2 1 3\n\nOutput:10\n\n-----Explanation-----\nExample case 1. If Sergey buys all the meals separately, it would cost him 3 + 5 + 6 = 14 rubles. He can buy all of them at once by buying the first meal set, which costs for 11 rubles, but the optimal strategy would be either to buy the second and the third meal set, thus, paying 5 + 5 = 10 rubles, or to buy the third meal set and the second meal separately by paying the same amount of 10 rubles.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + List.sum xs\n\ndef min_in_list : List Nat → Nat → Nat\n  | [], default => default\n  | [x], _ => x\n  | x::xs, default => min x (min_in_list xs default)", "vc-helpers": "", "vc-definitions": "def solve_meal_sets (n m : Nat) (costs : List Nat) (meal_sets : List (List Nat)) : Nat :=\nsorry", "vc-theorems": "theorem solve_meal_sets_basic_properties \n  (n : Nat) (costs : List Nat) (meal_costs : List Nat) :\n  n > 0 → n ≤ 5 →\n  ∀ c ∈ costs, c > 0 ∧ c ≤ 100 →\n  ∀ mc ∈ meal_costs, mc > 0 ∧ mc ≤ 200 →\n  costs.length = n →\n  let m := meal_costs.length\n  let meal_sets := sorry -- construction of meal sets\n  let result := solve_meal_sets n m costs meal_sets \n  result > 0 ∧ result ≤ List.sum costs := by\n  sorry\n\ntheorem solve_meal_sets_bounded_by_min\n  (n : Nat) (costs : List Nat) (meal_costs : List Nat) :\n  n > 0 → n ≤ 5 →\n  ∀ c ∈ costs, c > 0 ∧ c ≤ 100 →\n  ∀ mc ∈ meal_costs, mc > 0 ∧ mc ≤ 200 →\n  costs.length = n →\n  let m := meal_costs.length\n  let meal_sets := sorry -- construction of meal sets  \n  let result := solve_meal_sets n m costs meal_sets\n  result ≤ min (List.sum costs) (min_in_list meal_costs (List.sum costs)) := by\n  sorry\n\ntheorem solve_meal_sets_empty_meals\n  (costs : List Nat) :\n  costs = [4, 5] →\n  solve_meal_sets 2 0 costs [] = 9 := by\n  sorry\n\ntheorem solve_meal_sets_single_optimal_meal\n  (costs : List Nat) (meal_sets : List (List Nat)) :\n  costs = [10] →\n  meal_sets = [[5, 1, 1]] →\n  solve_meal_sets 1 1 costs meal_sets = 5 := by\n  sorry\n\ntheorem solve_meal_sets_two_items_optimal_meal\n  (costs : List Nat) (meal_sets : List (List Nat)) :\n  costs = [10, 10] →\n  meal_sets = [[15, 2, 1, 2]] →\n  solve_meal_sets 2 1 costs meal_sets = 15 := by\n  sorry\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval solve_meal_sets 3 3 [3, 5, 6] [[11, 3, 1, 2, 3], [5, 2, 1, 2], [5, 2, 1, 3]]\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval solve_meal_sets 2 1 [4, 5] [[7, 2, 1, 2]]\n\n/-\ninfo: 8\n-/\n-- #guard_msgs in\n-- #eval solve_meal_sets 1 1 [10] [[8, 1, 1]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1301", "language": "lean", "source": "fvapps", "source-id": "fvapps_001301", "source-notes": "", "vc-description": "/-\nThere are a lot of problems related to the shortest paths. Nevertheless, there are not much problems, related to the shortest paths in average.\nConsider a directed graph G, consisting of N nodes and M edges. Consider a walk from the node A to the node B in this graph. The average length of this walk will be total sum of weight of its' edges divided by number of edges. Every edge counts as many times as it appears in this path.\nNow, your problem is quite simple. For the given graph and two given nodes, find out the shortest average length of the walk between these nodes. Please note, that the length of the walk need not to be finite, but average walk length will be.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains a pair of space-separated integers N and M denoting the number of nodes and the number of edges in the graph.\nEach of the following M lines contains a triple of space-separated integers Xi Yi Zi, denoting the arc, connecting the node Xi to the node Yi (but not vice-versa!) having the weight of Zi.\nThe next line contains a pair of space separated integers A and B, denoting the first and the last node of the path.\n\n-----Output-----\nFor each test case, output a single line containing the length of the shortest path in average.\nIf there is no path at all, output just -1 on the corresponding line of the output.\n\n-----Constraints-----\n- 1 ≤ N ≤ 500\n- 1 ≤ M ≤ 1000\n- A is not equal to B\n- 1 ≤ A, B, Xi, Yi ≤ N\n- 1 ≤ Zi ≤ 100\n- There are no self-loops and multiple edges in the graph.\n- 1 ≤ sum of N over all test cases ≤ 10000\n- 1 ≤ sum of M over all test cases ≤ 20000\n\n-----Subtasks-----\n- Subtask #1 (45 points): 1 ≤ N ≤ 10, 1 ≤ M ≤ 20; Your answer will be considered correct in case it has an absolute or relative error of no more than 10-2.\n- Subtask #2 (55 points): no additional constraints; Your answer will be considered correct in case it has an absolute or relative error of no more than 10-6.\n\n-----Example-----\nInput:2\n3 3\n1 2 1\n2 3 2\n3 2 3\n1 3\n3 3\n1 2 10\n2 3 1\n3 2 1\n1 3\n\nOutput:1.5\n1.0\n\n-----Explanation-----\nExample case 1. The walk 1 -> 2 and 2 -> 3 has average length of 3/2 = 1.5. Any other walks in the graph will have more or equal average length than this.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_shortest_avg_path (n : Nat) (edges : List (Nat × Nat × Nat)) (s e : Nat) : Float :=\nsorry", "vc-theorems": "theorem path_result_bounds (n : Nat) (edges : List (Nat × Nat × Nat)) (s e : Nat) :\n  let result := find_shortest_avg_path n edges s e\n  result ≠ -1 → (0 < result ∧ result ≤ 100) := by sorry\n\ntheorem path_weights_relation (n : Nat) (edges : List (Nat × Nat × Nat)) (s e : Nat) :\n  let direct_weights := edges.filter (fun edge : Nat × Nat × Nat => \n    match edge with | (s', e', _) => s' = s && e' = e)\n    |>.map (fun edge => let (_, _, w) := edge; w)\n  ¬direct_weights.isEmpty → \n  find_shortest_avg_path n edges s e ≤ Float.ofNat (direct_weights.maximum?.getD 0) := by sorry\n\ntheorem empty_path_property :\n  find_shortest_avg_path 2 [] 1 2 = -1 := by sorry\n\ntheorem basic_path_property (n weight : Nat) (hn : n ≥ 2) (hw : weight > 0) :\n  let edges := List.range (n-1) |>.map (fun i => (i+1, i+2, weight))\n  find_shortest_avg_path n edges 1 n = Float.ofNat weight := by sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1310", "language": "lean", "source": "fvapps", "source-id": "fvapps_001310", "source-notes": "", "vc-description": "/-\nChef owns an icecream shop in Chefland named scoORZ. There are only three types of coins in Chefland: Rs. 5, Rs. 10 and Rs. 15. An icecream costs Rs. 5.\nThere are $N$ people (numbered $1$ through $N$) standing in a queue to buy icecream from scoORZ. Each person wants to buy exactly one icecream. For each valid $i$, the $i$-th person has one coin with value $a_i$. It is only possible for someone to buy an icecream when Chef can give them back their change exactly ― for example, if someone pays with a Rs. 10 coin, Chef needs to have a Rs. 5 coin that he gives to this person as change.\nInitially, Chef has no money. He wants to know if he can sell icecream to everyone in the queue, in the given order. Since he is busy eating his own icecream, can you tell him if he can serve all these people?\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $a_1, a_2, \\ldots, a_N$.\n\n-----Output-----\nFor each test case, print a single line containing the string \"YES\" if all people can be served or \"NO\" otherwise (without quotes).\n\n-----Constraints-----\n- $1 \\le T \\le 100$\n- $1 \\le N \\le 10^3$\n- $a_i \\in \\{5, 10, 15\\}$ for each valid $i$\n\n-----Subtasks-----\nSubtask #1 (40 points): $a_i \\in \\{5, 10\\}$ for each valid $i$\nSubtask #2 (60 points): original constraints\n\n-----Example Input-----\n3\n2\n5 10\n2\n10 5\n2\n5 15\n\n-----Example Output-----\nYES\nNO\nNO\n\n-----Explanation-----\nExample case 1: The first person pays with a Rs. 5 coin. The second person pays with a Rs. 10 coin and Chef gives them back the Rs. 5 coin (which he got from the first person) as change.\nExample case 2: The first person already cannot buy an icecream because Chef cannot give them back Rs. 5.\nExample case 3: The first person pays with a Rs. 5 coin. The second person cannot buy the icecream because Chef has only one Rs. 5 coin, but he needs to give a total of Rs. 10 back as change.\n-/", "vc-preamble": "def canServeIcecream : List Coin → Bool\n  := sorry\n\ndef countFives (l : List Coin) : Nat :=\n  (l.filter (. == Coin.five)).length", "vc-helpers": "", "vc-definitions": "def countTens (l : List Coin) : Nat :=\n  (l.filter (. == Coin.ten)).length", "vc-theorems": "theorem all_fives_servable {coins : List Coin} (h : ∀ c ∈ coins, c = Coin.five) :\n  canServeIcecream coins = true := sorry\n\ntheorem start_with_ten_fails {coins : List Coin} (h1 : coins.length > 0) \n  (h2 : ∀ c ∈ coins, c = Coin.ten) :\n  canServeIcecream coins = false := sorry\n\ntheorem empty_and_base_cases :\n  canServeIcecream [] = true ∧\n  canServeIcecream [Coin.five] = true ∧\n  canServeIcecream [Coin.ten] = false ∧\n  canServeIcecream [Coin.fifteen] = false := sorry\n\ntheorem valid_service_has_change {coins : List Coin} \n  (h : ∀ c ∈ coins, c = Coin.five ∨ c = Coin.ten ∨ c = Coin.fifteen) :\n  canServeIcecream coins = true →\n  ∀ p : List Coin, p.isPrefixOf coins →\n  match p.getLast? with\n  | none => True \n  | some last =>\n    if decide (last = Coin.ten)\n    then countFives p > 0\n    else if decide (last = Coin.fifteen)\n    then countTens p > 0 ∨ countFives p ≥ 2\n    else True := sorry\n\ntheorem invalid_service_lacks_change {coins : List Coin}\n  (h : ∀ c ∈ coins, c = Coin.five ∨ c = Coin.ten ∨ c = Coin.fifteen) :\n  canServeIcecream coins = false →\n  ∃ p : List Coin, p.isPrefixOf coins ∧\n  match p.getLast? with\n  | none => False\n  | some last =>\n    (last = Coin.ten ∧ countFives p = 0) ∨ \n    (last = Coin.fifteen ∧ countTens p = 0 ∧ countFives p < 2) := sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval can_serve_icecream [5, 10]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval can_serve_icecream [10, 5]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval can_serve_icecream [5, 15]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1327", "language": "lean", "source": "fvapps", "source-id": "fvapps_001327", "source-notes": "", "vc-description": "/-\nSalmon loves to be a tidy person. One day, when he looked at the mess that he made after playing with his rubber ducks, he felt awful. Now he wants to clean up his mess, by placing his ducks into boxes.\nEach rubber duck has a color. There are a total of $N+1$ colors, numbered from $0$ to $N$. Salmon wants to place his $N*K$ ducks into $N$ boxes, each of which can fit $K$ ducks. Each duck should be placed inside a box.\nSalmon is very particular when it comes to how many colors he can place in each box. Since Salmon doesn't like lots of colors mixing together he only wants to have a maximum of $2$ distinct colors per box.\nPlease help Salmon achieve this goal!\n\nIt can be shown that there will always be at least one valid solution under given constraints.\n\nIf there are multiple correct solutions, you may output any one of them.   \n\n-----Input:-----\n- The first line contains an integer $T$, denoting the number of testcases. $T$ testcases will follow, each containing two lines.   \n- The first line of each testcase contains two space-separated integers $N$ and $K$.   \n- The second line of each testcase contains $N+1$  space-separated integers. The $i+1$-th integer denotes the number of ducks with color-$i$ where $0 \\leq i \\leq N$\n\n-----Output:-----\n- Output $N$ lines for each testcase. \n- The $i$-th line of a testcase should contain $4$ space-separated integers $c1, m1, c2, m2$ respectively which denotes that that are $m1$ ducks of color-$c1$ and $m2$ ducks of color-$c2$ inside the $i$-th box where $0 \\leq m1,m2 \\leq K$ and $0 \\leq c1,c2 \\leq N$. \n- Note that even if you have only one color to put inside the $i$-th box, you should still output $4$ space-separated integers and keep either $m1$ or $m2$ as $0$. And $0 \\leq c1,c2 \\leq N$.\n- The output should be valid and should satisfy Salmon's goal.\n\n-----Constraints-----\n- $T=10$\n- $2 \\leq N \\leq 10^5$ \n- $2 \\leq K \\leq 10^5$ \n- Total ducks for each test case is exactly $N*K$\n- There can be a color with $0$ ducks\n\n-----Subtasks-----\n- Subtask 1 [20 points]: $2 \\leq N \\leq 10$, $K=2$ \n- Subtask 2 [30 points]: $N=2$, $K=5$\n- Subtask 3 [50 points]: original constraints\n\n-----Sample Input:-----\n1\n2 4\n3 4 1\n\n-----Sample Output:-----\n2 1 1 3\n1 1 0 3\n\n-----Explanation:-----\n- In the given testcase, Salmon has $N=2$ boxes, each of size $K=4$ and there are total $N*K=8$ ducks.   \n- The first box is filled with $1$ duck of color-$2$ and $3$ ducks of color-$1$ and the second box is filled with $1$ duck of color-$1$ and $3$ ducks of color-$0$.   \n- Each duck is inside a box and each box has at most two distinct colors. Also each box contains exactly $K=4$ ducks.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_duck_boxes (N K : Nat) (colors : List Nat) : List Box := sorry\n\ndef validate_solution (N K : Nat) (colors : List Nat) (result : List Box) : Prop := sorry\n\n-- Main correctness theorems", "vc-theorems": "theorem box_count_correct (N K : Nat) (colors : List Nat) :\n  (List.length colors = N + 1) →\n  (List.foldr (· + ·) 0 colors ≥ N * K) →\n  List.length (solve_duck_boxes N K colors) = N := sorry\n\ntheorem box_content_valid (N K : Nat) (colors : List Nat) (box : Box) :\n  (List.length colors = N + 1) →\n  (List.foldr (· + ·) 0 colors ≥ N * K) →\n  box ∈ solve_duck_boxes N K colors →\n  box.count1 + box.count2 = K := sorry\n\ntheorem box_colors_distinct (N K : Nat) (colors : List Nat) (box : Box) :\n  (List.length colors = N + 1) →\n  (List.foldr (· + ·) 0 colors ≥ N * K) →\n  box ∈ solve_duck_boxes N K colors →\n  box.color1 ≠ box.color2 := sorry\n\ntheorem box_colors_valid_range (N K : Nat) (colors : List Nat) (box : Box) :\n  (List.length colors = N + 1) →\n  (List.foldr (· + ·) 0 colors ≥ N * K) →\n  box ∈ solve_duck_boxes N K colors →\n  box.color1 ≤ N ∧ box.color2 ≤ N := sorry\n\ntheorem color_usage_within_limits (N K : Nat) (colors : List Nat) (i : Nat) :\n  (List.length colors = N + 1) →\n  (List.foldr (· + ·) 0 colors ≥ N * K) →\n  i ≤ N →\n  (List.foldl (fun acc box => acc + \n    (if box.color1 = i then box.count1 else 0) +\n    (if box.color2 = i then box.count2 else 0)\n  ) 0 (solve_duck_boxes N K colors)) ≤ List.get! colors i := sorry\n\n-- Minimal input theorem\n\ntheorem minimal_input_valid (N K : Nat) :\n  N > 0 →\n  K > 0 →\n  let colors := N*K :: List.replicate N 0\n  validate_solution N K colors (solve_duck_boxes N K colors) := sorry\n\n/-\ninfo: N2\n-/\n-- #guard_msgs in\n-- #eval len solve_duck_boxes(N2, K2, colors2)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1340", "language": "lean", "source": "fvapps", "source-id": "fvapps_001340", "source-notes": "", "vc-description": "/-\nOur chef has recently opened a new restaurant with a unique style. The restaurant is divided into K compartments (numbered from 1 to K) and each compartment can be occupied by at most one customer. \nEach customer that visits the restaurant has a strongly preferred compartment p (1 ≤ p ≤ K), and if that compartment is already occupied, then the customer simply leaves. Now obviously, the chef wants to maximize the total number of customers that dine at his restaurant and so he allows (or disallows) certain customers so as to achieve this task. You are to help him with this. \nGiven a list of N customers with their arrival time, departure time and the preferred compartment, you need to calculate the maximum number of customers that can dine at the restaurant. \n\n-----Input-----\nThe first line contains an integer T denoting the number of test cases. Each of the next T lines contains two integers N and  K , the number of customers that plan to visit the chef's restaurant and the number of compartments the restaurant is divided into respectively. Each of the next N lines contains three integers si, fi and pi , the arrival time, departure time and the strongly preferred compartment of the ith customer respectively.  \n\nNote that the ith customer wants to occupy the pith compartment from [si, fi)  i.e the ith customer leaves just before   fi  so that another customer can occupy that compartment from   fi  onwards.\n\n-----Output-----\nFor every test case, print in a single line the maximum number of customers that dine at the restaurant.\n\n-----Constraints-----\n-  1 ≤  T ≤   30 \n-  0  ≤ N  ≤  105 \n-  1  ≤  K  ≤  109 \n-  0  ≤  si < fi ≤   109 \n-  1  ≤  pi  ≤  K  \n\n-----Example-----\nInput:\n2\n3 3\n1 3 1\n4 6 2\n7 10 3\n4 2\n10 100 1\n100 200 2\n150 500 2\n200 300 2\n\nOutput:\n3\n3\n\n-----Explanation-----\nExample case 1.\n\nAll three customers want different compartments and hence all 3 can be accommodated.\n\nExample case 2.\n\nIf we serve the 1st, 2nd and 4th customers, then we can get a maximum of 3.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxRestaurantCustomers (testCases : List (List Cell)) : List Nat :=\n  sorry", "vc-theorems": "theorem max_customers_single_case\n  (n k : Nat)\n  (cells : List Cell)\n  (h1 : n ≥ 1)\n  (h2 : k ≥ 1) \n  (h3 : cells.length ≥ 1)\n  (h4 : ∀ c ∈ cells, c.start < c.finish)\n  (h5 : ∀ c ∈ cells, c.capacity ≤ k) :\n  let result := maxRestaurantCustomers [cells]\n  result.head! ≤ cells.length ∧ \n  result.head! ≤ k * n :=\nsorry\n\ntheorem max_customers_multiple_cases\n  (testCases : List (List Cell))\n  (h1 : testCases.length ≥ 1)\n  (h2 : ∀ case ∈ testCases, case.length ≥ 1)\n  (h3 : ∀ case ∈ testCases, ∀ c ∈ case, c.start < c.finish)\n  (h4 : ∀ case ∈ testCases, ∀ c ∈ case, c.capacity ≤ k) :\n  let results := maxRestaurantCustomers testCases\n  results.length = testCases.length ∧\n  ∀ i < results.length, \n    results[i]! ≤ testCases[i]!.length ∧\n    results[i]! ≤ k * n :=\nsorry\n\n/-\ninfo: [3]\n-/\n-- #guard_msgs in\n-- #eval max_restaurant_customers [test1]\n\n/-\ninfo: [3]\n-/\n-- #guard_msgs in\n-- #eval max_restaurant_customers [test2]\n\n/-\ninfo: [3, 3]\n-/\n-- #guard_msgs in\n-- #eval max_restaurant_customers [test1, test2]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1346", "language": "lean", "source": "fvapps", "source-id": "fvapps_001346", "source-notes": "", "vc-description": "/-\nChef has a sequence $A_1, A_2, \\ldots, A_N$. For a positive integer $M$, sequence $B$ is defined as $B = A*M$ that is, appending $A$ exactly $M$ times. For example, If $A = [1, 2]$ and $M = 3$, then $B = A*M = [1, 2, 1, 2, 1, 2]$\nYou have to help him to find out the minimum value of $M$ such that the length of the longest strictly increasing subsequence is maximum possible.\n\n-----Input:-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains a single integer $N$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\ldots, A_N$.\n\n-----Output:-----\nFor each test case, print a single line containing one integer ― the minimum value of $M$.\n\n-----Constraints-----\n- $1 \\le T \\le 500$\n- $1 \\le N \\le 2*10^5$\n- $1 \\le A_i \\le 10^9$\n- It's guaranteed that the total length of the sequence $A$ in one test file doesn't exceed $2*10^6$\n\n-----Sample Input:-----\n3\n2\n2 1\n2\n1 2\n5\n1 3 2 1 2\n\n-----Sample Output:-----\n2\n1\n2\n\n-----Explanation:-----\nIn the first test case, Choosing $M = 2$ gives $B = [2, 1, 2, 1]$ which has a longest strictly increasing sequence of length $2$ which is the maximum possible.\nIn the second test case, Choosing $M = 1$ gives $B  = [1, 2]$ which has a longest strictly increasing sequence of length $2$ which is the maximum possible.\n-/", "vc-preamble": "def find_min_m (arr : List Int) (n : Nat) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def countUnique (arr : List Int) : Nat :=\n  (arr.eraseDups).length", "vc-theorems": "theorem find_min_m_bounds (arr : List Int) (n : Nat) (h : n = arr.length) :\n  1 ≤ find_min_m arr n ∧ find_min_m arr n ≤ countUnique arr := by\n  sorry\n\ntheorem find_min_m_single_element (arr : List Int) (h : arr.length = 1) :\n  find_min_m arr arr.length = 1 := by\n  sorry\n\ntheorem find_min_m_sorted (arr : List Int) (h : arr.length ≥ 2) :\n  find_min_m (List.mergeSort (·≤·) arr) arr.length = 1 := by\n  sorry\n\ntheorem find_min_m_reverse_sorted (arr : List Int) (h : arr.length ≥ 2) :\n  find_min_m (List.mergeSort (·≥·) arr) arr.length = countUnique arr := by\n  sorry\n\ntheorem find_min_m_small_range (arr : List Int) \n  (h₁ : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 3)\n  (h₂ : arr.length ≥ 1)\n  (h₃ : arr.length ≤ 10) :\n  1 ≤ find_min_m arr arr.length ∧ find_min_m arr arr.length ≤ countUnique arr := by\n  sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval find_min_m [2, 1] 2\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval find_min_m [1, 2] 2\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval find_min_m [1, 3, 2, 1, 2] 5", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1366", "language": "lean", "source": "fvapps", "source-id": "fvapps_001366", "source-notes": "", "vc-description": "/-\nRaj loves to listen to songs in his free time. It’s his birthday tomorrow and his friend Neelansh wants his gift to be the most unique. Being great at making music, he decides to produce a song for him. However, Raj likes songs according to their beauty. He determines the beauty of the song as the number of times all the octave musical tones are completed in ascending order.\n\nHe begins with a jumbled tone of length N and numbers each octave tone as 1,2,3….8.\n\nNeelansh wants to maximize the beauty of the song but since he uses the trial version of the software,\n- He cannot change the size of N.\n- He cannot introduce any new tone, but can choose any two tones and swap their positions\n\nHowever, Neelansh just received a mail that he needs to submit all his pending assignments by tomorrow. He has tons of assignments left to do, but he doesn’t want to spoil the idea of his gift. Can you help him? \n\n-----INPUT-----\n- The first line contains a single integer T- the number of test cases  \n- The first line of each test case contains a single integer N- the length of the song  \n- The second line contains N- space separated integers ai,  ai+1,.....aN \n\n-----OUTPUT-----\nFor each test case, print a single line containing one integer- the maximum possible beauty of the song  \n\n-----CONSTRAINTS-----\n1<=T<=102\n1<=N<=105\n1<=a<=8\n\n-----EXAMPLE INPUT-----\n2\n\n8\n\n1 2 3 4 5 6 7 8\n\n16\n\n1 2 1 2 3 3 4 4 5 5 6 6 7 8 7 8\n\n-----EXAMPLE OUTPUT-----\n1\n\n2\n-/", "vc-preamble": "def find_max_beauty (n: Nat) (tones: List Nat) : Nat := sorry\n\ndef countOccurrences (x : Nat) (xs : List Nat) : Nat :=\n  xs.foldl (fun count y => if x = y then count + 1 else count) 0", "vc-helpers": "", "vc-definitions": "def unique (xs : List Nat) : List Nat :=\n  xs.foldl (fun acc x => if x ∈ acc then acc else x::acc) []", "vc-theorems": "theorem find_max_beauty_is_min_frequency \n  (tones: List Nat) (h: ∀ x ∈ tones, 1 ≤ x ∧ x ≤ 8) :\n  let distinct := unique tones;\n  if distinct.length = 8 then\n    find_max_beauty tones.length tones = \n      (List.map (fun x => countOccurrences x tones) distinct).minimum?\n  else\n    find_max_beauty tones.length tones = 0 := sorry\n\ntheorem find_max_beauty_non_negative \n  (tones: List Nat) (h: ∀ x ∈ tones, 1 ≤ x ∧ x ≤ 8) :\n  find_max_beauty tones.length tones ≥ 0 := sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval find_max_beauty 8 [1, 2, 3, 4, 5, 6, 7, 8]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval find_max_beauty 16 [1, 2, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 8, 7, 8]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval find_max_beauty 4 [1, 2, 3, 4]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1375", "language": "lean", "source": "fvapps", "source-id": "fvapps_001375", "source-notes": "", "vc-description": "/-\nChef is operating a slush machine. The machine produces slush drinks with $M$ flavors (numbered $1$ through $M$); for each valid $i$, the maximum number of drinks with flavour $i$ the machine can produce is $C_i$.\nChef expects $N$ customers to come buy slush drinks today. The customers are numbered $1$ through $N$ in the order in which they buy the drinks. For each valid $i$, the favorite flavour of the $i$-th customer is $D_i$ and this customer is willing to pay $F_i$ units of money for a drink with this flavour, or $B_i$ units of money for a drink with any other flavuor. Whenever a customer wants to buy a drink:\n- if it is possible to sell this customer a drink with their favourite flavour, Chef must sell them a drink with this flavour\n- otherwise, Chef must sell this customer a drink, but he may choose its flavour\nChef wants to make the maximum possible profit. He is asking you to help him decide the flavours of the drinks he should sell to the customers in order to maximise the profit.\n\n-----Input-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.\n- The first line of each test case contains two space-separated integers $N$ and $M$.\n- The second line contains $M$ space-separated integers $C_1, C_2, \\ldots, C_M$.\n- $N$ lines follow. For each valid $i$, the $i$-th of these lines contains three space-separated integers $D_i$, $F_i$ and $B_i$.\n\n-----Output-----\nFor each test case, print two lines:\n- The first of these lines should contain a single integer — the maximum profit.\n- The second line should contain $N$ space-separated integers denoting the flavours of the drinks Chef should sell, in this order.\nIf there are multiple solutions, you may find any one.\n\n-----Constraints-----\n- $1 \\le T \\le 1,000$\n- $2 \\le N, M \\le 10^5$\n- $1 \\le D_i \\le M$ for each valid $i$\n- $1 \\le C_i \\le N$ for each valid $i$\n- $1 \\le B_i < F_i \\le 10^9$ for each valid $i$\n- $C_1+C_2+\\ldots+C_M \\ge N$\n- the sum of $N$ over all test cases does not exceed $10^6$\n- the sum of $M$ over all test cases does not exceed $10^6$\n\n-----Example Input-----\n1\n5 3\n1 2 3\n2 6 3\n2 10 7\n2 50 3\n1 10 5\n1 7 4\n\n-----Example Output-----\n33\n2 2 3 1 3\n-/", "vc-preamble": "def List.sum (l : List Nat) : Nat :=\n  sorry\n\ndef List.sumBy {α : Type} (l : List α) (f : α → Nat) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def solve_slush_machine (n m : Nat) (capacity : List Nat) (preferences : List (Nat × Nat × Nat)) : \n  Nat × List Nat :=\n  sorry", "vc-theorems": "theorem valid_list_lengths {n m : Nat} {capacity : List Nat} {preferences : List (Nat × Nat × Nat)}\n  (h : solve_slush_machine n m capacity preferences = (profit, assignments)) :\n  assignments.length = n := by\n  sorry\n\ntheorem valid_capacity_constraints {n m : Nat} {capacity : List Nat} {preferences : List (Nat × Nat × Nat)}\n  (h : solve_slush_machine n m capacity preferences = (profit, assignments))\n  (hcap : capacity.length = m) :\n  ∀ i : Nat, i > 0 ∧ i ≤ m → \n    (assignments.filter (λ x => x = i)).length ≤ capacity[i-1]'(by {\n      rw [hcap]\n      sorry\n    }) := by\n  sorry\n\ntheorem correct_profit_calculation {n m : Nat} {capacity : List Nat} {preferences : List (Nat × Nat × Nat)}\n  (h : solve_slush_machine n m capacity preferences = (profit, assignments))\n  (hp : preferences.length = n)\n  (ha : assignments.length = n) :\n  profit = List.sumBy (List.range n) (λ i => \n    let (d,f,b) := preferences[i]'(by {\n      sorry\n    })\n    if assignments[i]'(by {\n      sorry\n    }) = d then f else b) := by\n  sorry\n\ntheorem solution_bounds {n m : Nat} {capacity : List Nat} {preferences : List (Nat × Nat × Nat)}\n  (h : solve_slush_machine n m capacity preferences = (profit, assignments)) :\n  ∀ x ∈ assignments, x > 0 ∧ x ≤ m := by\n  sorry\n\ntheorem preferences_bounds {n m : Nat} {capacity : List Nat} {preferences : List (Nat × Nat × Nat)}\n  (h₁ : solve_slush_machine n m capacity preferences = (profit, assignments))\n  (h₂ : preferences.length = n) :\n  ∀ (d f b : Nat), (d,f,b) ∈ preferences → d > 0 ∧ d ≤ m ∧ f > 0 ∧ b > 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1392", "language": "lean", "source": "fvapps", "source-id": "fvapps_001392", "source-notes": "", "vc-description": "/-\nOnce N boys and M girls attended a party. You are given a matrix A of N rows and M columns where Aij is 1 if the i-th boy likes the j-th girl, otherwise it will be 0. Note that it is not necessary that if a boy x likes girl y, then girl y should like boy x.\nYou know that if there are two different boys x and y, who both like girl z, then there will be a collision.\nCan you calculate the number of different collisions at this party? Note that order of boys in the collision doesn't matter.\n\n-----Input-----\nThe first line contains a single integer T denoting the number of test cases. Then T test cases follow.\nThe first line of each test case contains two space separated integers N, M denoting the number of boys and girls, respectively.\nEach of the following N lines contain M characters, each of them is either '0' or '1'.\n\n-----Output-----\nFor each test case output a single line containing an integer corresponding to the number of collisions at the party.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N, M ≤ 10\n\n-----Example-----\nInput:\n2\n4 3\n111\n100\n110\n000\n2 2\n10\n01\n\nOutput:\n4\n0\n\n-----Explanation-----\nExample Case 1. All three boys like the first girl, so there are (1, 2, 1), (1, 3, 1), (2, 3, 1) collisions with her. Boys 1 and 3 both like the second girl so this is one more collision. Only one boy likes the third girl, so there are no collisions with her and thus we have 4 collisions total.\nExample Case 2. For each girl there is only one boy who likes her, so there are no collisions at all.\n-/", "vc-preamble": "def count_collisions (n m : Nat) (likes : List String) : Nat :=\n  sorry\n\ndef List.sum (xs : List Nat) : Nat :=\n  xs.foldl (· + ·) 0\n\n/- Helper function to get character from string at position -/", "vc-helpers": "", "vc-definitions": "def getChar? (s : String) (i : Nat) : Option Char :=\n  s.data.get? i", "vc-theorems": "theorem count_collisions_nonnegative {n m : Nat} {likes : List String} :\n  count_collisions n m likes ≥ 0 :=\n  sorry \n\n/- Helper function to sum a list of natural numbers -/\n\ntheorem count_collisions_formula {n m : Nat} {likes : List String} :\n  count_collisions n m likes = \n    let colSums := List.range m |>.map (fun col => \n      List.range n |>.filter (fun row => \n        match likes.get? row with\n        | none => false\n        | some s => match getChar? s col with\n          | some '1' => true\n          | _ => false\n      ) |>.length);\n    colSums.map (fun ones => ones * (ones - 1) / 2) |>.sum :=\n  sorry\n\ntheorem count_collisions_zeros {n m : Nat} {likes : List String}\n  (h : ∀ i j, i < n → j < m → \n    match likes.get? i with\n    | none => true\n    | some s => getChar? s j = some '0') :\n  count_collisions n m likes = 0 :=\n  sorry\n\ntheorem count_collisions_all_ones {n : Nat} {likes : List String}\n  (h : ∀ i, i < n → \n    match likes.get? i with\n    | none => true \n    | some s => getChar? s 0 = some '1') :\n  count_collisions n 1 likes = n * (n - 1) / 2 :=\n  sorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval count_collisions 4 3 [\"111\", \"100\", \"110\", \"000\"]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval count_collisions 2 2 [\"10\", \"01\"]\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval count_collisions 3 2 [\"11\", \"11\", \"11\"]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1394", "language": "lean", "source": "fvapps", "source-id": "fvapps_001394", "source-notes": "", "vc-description": "/-\nThere are N islands in the sea, enumerated from 1 to N. Each of them is so small that we can consider them as points on a plane. You are given the Cartesian coordinates of all islands. X-axis is directed towards East and Y-axis is directed towards North.\nYou need to illuminate all the islands. To do this, you can place lighthouses on some of the islands. You can't place more than one lighthouse on any single island. Each lighthouse can light only one of the 4 quadrants: North-Western, North-Eastern, South-Western or South-Eastern. If some island is located on the border of an illuminated quadrant, it is considered to be illuminated as well. Note that this means that a lighthouse always illuminates it's own island as well.\nFind the smallest possible number of lighthouses required to illuminate all the islands (say L). Describe their configurations — positions and quadrants illuminated — as well.\n\n-----Input-----\nThe first line of input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains a single integer N denoting the number of islands.\nThe ith of the following N lines contains two integers Xi and Yi denoting the coordinates of the ith island.\n\n-----Output-----\nFor each test case, first line of output must contain minimum number of lighthouses required to illuminate all islands, L.\nFollowing L lines must describe configuration of the lighthouses, one configuration per line. Description of a lighthouse configuration consists of the number of the island where the lighthouse is placed, and the direction of the quadrant (NW for North-Western, NE for North-Eastern, SW for South-Western, SE for South-Eastern) illuminated by it, separated by a single space.\nIf there are many possible placements, output any one of them.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ N ≤ 105\n- The sum of N over all test cases doesn't exceed 5*105\n- Absolute value of each coordinate doesn't exceed 109\n- No two given islands coincide.\n\n-----Subtasks-----\nSubtask 1: (15 points)\n- 1 ≤ N ≤ 8\n- Absolute value of each coordinate doesn't exceed 50\n\nSubtask 2: (85 points)\n- Original constraints\n\n-----Example-----\nInput:\n2\n5\n0 0\n1 0\n2 0\n0 -1\n0 -2\n4\n5 0\n-5 0\n0 5\n0 -5\n\nOutput:\n1\n3 SW\n2\n4 NE\n2 NE\n\n-----Explanation-----\nExample case 1. Also we can place lighthouse on 1st or 5th island.\nExample case 2. Notice that some islands can be illuminated by more than 1 lighthouse.\n-/", "vc-preamble": "def LighthouseConfig := Nat × Direction\n\ndef solve_lighthouse_placement (coords : List IslandCoord) : List LighthouseConfig :=\n  sorry\n\ndef format_output (configs : List LighthouseConfig) : List String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def direction_to_string : Direction → String\n  | Direction.NE => \"NE\"\n  | Direction.SE => \"SE\"\n  | Direction.SW => \"SW\"\n  | Direction.NW => \"NW\"", "vc-theorems": "theorem lighthouse_placement_valid {coords : List IslandCoord} :\n  let result := solve_lighthouse_placement coords\n  (∀ x ∈ result, x.1 ≤ coords.length) ∧ \n  (1 ≤ result.length ∧ result.length ≤ 2) := \nsorry\n\ntheorem format_output_valid {coords : List IslandCoord} :\n  let lighthouse_configs := solve_lighthouse_placement coords\n  let result := format_output lighthouse_configs\n  (result.head? = some (toString lighthouse_configs.length)) ∧\n  (result.length = lighthouse_configs.length + 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1407", "language": "lean", "source": "fvapps", "source-id": "fvapps_001407", "source-notes": "", "vc-description": "/-\nChef has recently been playing a lot of chess in preparation for the ICCT (International Chef Chess Tournament).\nSince putting in long hours is not an easy task, Chef's mind wanders elsewhere. He starts counting the number of squares with odd side length on his chessboard..\nHowever, Chef is not satisfied. He wants to know the number of squares of odd side length on a generic $N*N$ chessboard.\n\n-----Input:-----\n- The first line will contain a single integer $T$, the number of test cases.\n- The next $T$ lines will have a single integer $N$, the size of the chess board.\n\n-----Output:-----\nFor each test case, print a integer denoting the number of squares with odd length.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- $1 \\leq N \\leq 1000$\n\n-----Sample Input:-----\n2\n3\n8\n\n-----Sample Output:-----\n10\n120\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_odd_squares (n : Int) : Int := sorry\n\ntheorem count_odd_squares_positive (n : Int) : \n  n > 0 → count_odd_squares n > 0 := sorry", "vc-theorems": "theorem count_odd_squares_odd_numbers (n : Int) (hn : n > 0) :\n  n % 2 = 1 → count_odd_squares n = Nat.sum (List.filter (fun i => i % 2 = 1) (List.range (n.toNat))) := sorry\n\ntheorem count_odd_squares_monotonic (n : Int) :\n  n > 1 → count_odd_squares n > count_odd_squares (n-1) := sorry\n\ntheorem count_odd_squares_nonpositive (n : Int) :\n  n ≤ 0 → count_odd_squares n = 0 := sorry\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval count_odd_squares 3\n\n/-\ninfo: 120\n-/\n-- #guard_msgs in\n-- #eval count_odd_squares 8\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval count_odd_squares 1", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1416", "language": "lean", "source": "fvapps", "source-id": "fvapps_001416", "source-notes": "", "vc-description": "/-\nAlice and Johnny are playing a simple guessing game. Johnny picks an arbitrary positive integer n (1<=n<=109) and gives Alice exactly k hints about the value of n. It is Alice's task to guess n, based on the received hints. \n\nAlice often has a serious problem guessing the value of n, and she's beginning to suspect that Johnny occasionally cheats, that is, gives her incorrect hints. \nAfter the last game, they had the following little conversation:\n\n- [Alice] Johnny, you keep cheating!\n\n- [Johnny] Indeed? You cannot prove it.\n\n- [Alice] Oh yes I can. In fact, I can tell you with the utmost certainty that in the last game you lied to me at least *** times.\n\nSo, how many times at least did Johnny lie to Alice? Try to determine this, knowing only the hints Johnny gave to Alice.\n\n-----Input-----\nThe first line of input contains t, the number of test cases (about 20). Exactly t test cases follow. \n\nEach test case starts with a line containing a single integer k, denoting the number of hints given by Johnny (1<=k<=100000). Each of the next k lines contains exactly one hint. The i-th hint is of the form:\noperator li logical_value\nwhere operator denotes one of the symbols < , > , or =; li is an integer (1<=li<=109), while logical_value is one of the words: Yes or No. The hint is considered correct if logical_value is the correct reply to the question: \"Does the relation: n operator li hold?\", and is considered to be false (a lie) otherwise.\n\n-----Output-----\nFor each test case output a line containing a single integer, equal to the minimal possible number of Johnny's lies during the game.\n\n-----Example-----\nInput:\n3\n2\n< 100 No\n> 100 No\n3\n< 2 Yes\n> 4 Yes\n= 3 No\n6\n< 2 Yes\n> 1 Yes\n= 1 Yes\n= 1 Yes\n> 1 Yes\n= 1 Yes\n\nOutput:\n0\n1\n2\n\nExplanation: for the respective test cases, the number picked by Johnny could have been e.g. n=100, n=5, and n=1.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def guessing_game (hints : List Hint) : Nat :=\n  sorry", "vc-theorems": "theorem lies_bounds {hints : List Hint} : \n  let lies := guessing_game hints\n  0 ≤ lies ∧ lies ≤ hints.length := by\n  sorry\n\ntheorem single_hint_result {hint : Hint} :\n  let lies := guessing_game [hint]\n  lies = 0 ∨ lies = 1 := by\n  sorry\n\ntheorem contradictory_equal_hints {n m : Nat} (h : n ≠ m) :\n  let hints := [⟨'=', n, true⟩, ⟨'=', m, true⟩]\n  guessing_game hints = 1 := by\n  sorry\n\ntheorem opposite_operators_same_number {n : Nat} :\n  let hints := [⟨'>', n, true⟩, ⟨'<', n, true⟩]\n  guessing_game hints = 1 := by\n  sorry\n\ntheorem equal_consistency {n : Nat} :\n  let hints := [⟨'=', n, true⟩, ⟨'=', n, true⟩]\n  guessing_game hints = 0 := by\n  sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval guessing_game [[\"<\", \"100\", \"No\"], [\">\", \"100\", \"No\"]]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval guessing_game [[\"<\", \"2\", \"Yes\"], [\">\", \"4\", \"Yes\"], [\"=\", \"3\", \"No\"]]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval guessing_game [[\"<\", \"2\", \"Yes\"], [\">\", \"1\", \"Yes\"], [\"=\", \"1\", \"Yes\"], [\"=\", \"1\", \"Yes\"], [\">\", \"1\", \"Yes\"], [\"=\", \"1\", \"Yes\"]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1425", "language": "lean", "source": "fvapps", "source-id": "fvapps_001425", "source-notes": "", "vc-description": "/-\nYou have a string S consisting of N uppercase English letters. You are allowed to perform at most one operation of following kind: Choose any position in the string, remove the character at that position and insert it back to any other place in the string.\n\nFind the  lexicographically smallest  string you can achieve.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains the single integer N denoting length of string S.\nThe second line contains the string S.\n\n-----Output-----\nFor each test case, output a single line containing the answer to the corresponding test case.\n\n-----Constraints-----\n- 1 ≤ T ≤ 50\n- 1 ≤ N ≤ 50\n- S will consist of uppercase English letters.\n\n-----Example-----\nInput:\n2\n4\nDCBA\n7\nXYZZYZZ\n\nOutput:\nADCB\nXYYZZZZ\n\n-----Explanation-----\nExample case 1. The optimal solution here is to choose the last character and put it in the beginning of the string. So the answer will be ADCB\nExample case 2. The optimal solution here is to choose the 5-th character (1-based index) and put it between the 2-nd and the 3-rd characters. So the answer will be XYYZZZZ\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_smallest_string (s : String) : String :=\n  sorry", "vc-theorems": "theorem output_length_matches_input (s : String) (h : s.length > 0) :\n  (find_smallest_string s).length = s.length :=\nsorry\n\ntheorem output_has_same_characters (s : String) (h : s.length > 0) :\n  (find_smallest_string s).toList.sorted = s.toList.sorted :=\nsorry\n\ntheorem output_lexicographically_smaller_or_equal (s : String) (h : s.length > 0) :\n  find_smallest_string s ≤ s :=\nsorry\n\ntheorem result_is_minimal_rearrangement (s : String) (h : s.length > 0)\n    (i : Nat) (h1 : i < s.length)\n    (j : Nat) (h2 : j ≤ s.length - 1) :\n  let c := s.data.get ⟨i, h1⟩\n  let remaining := (s.take i) ++ (s.drop (i + 1))\n  let candidate := (remaining.take j) ++ String.mk [c] ++ (remaining.drop j)\n  find_smallest_string s ≤ candidate :=\nsorry\n\ntheorem sorted_string_is_minimal (s : String) (h : s.length > 0) :\n  let sorted_s := String.mk (s.toList.sorted)\n  find_smallest_string sorted_s = sorted_s :=\nsorry\n\n/-\ninfo: 'ADCB'\n-/\n-- #guard_msgs in\n-- #eval find_smallest_string \"DCBA\"\n\n/-\ninfo: 'XYYZZZZ'\n-/\n-- #guard_msgs in\n-- #eval find_smallest_string \"XYZZYZZ\"\n\n/-\ninfo: 'ABC'\n-/\n-- #guard_msgs in\n-- #eval find_smallest_string \"ABC\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1426", "language": "lean", "source": "fvapps", "source-id": "fvapps_001426", "source-notes": "", "vc-description": "/-\nLet's define a periodic infinite sequence S$S$ (0$0$-indexed) with period K$K$ using the formula Si=(i%K)+1$S_i = (i \\% K) + 1$.\nChef has found a sequence of positive integers A$A$ with length N$N$ buried underground. He suspects that it is a contiguous subsequence of some periodic sequence. Unfortunately, some elements of A$A$ are unreadable. Can you tell Chef the longest possible period K$K$ of an infinite periodic sequence which contains A$A$ (after suitably filling in the unreadable elements) as a contiguous subsequence?\n\n-----Input-----\n- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\n- The first line of each test case contains a single integer N$N$. \n- The second line contains N$N$ space-separated integers A1,A2,…,AN$A_1, A_2, \\dots, A_N$. Unreadable elements are denoted by −1$-1$.\n\n-----Output-----\nFor each test case, print a single line.\n- If the period can be arbitrarily large, this line should contain a single string \"inf\".\n- Otherwise, if A$A$ cannot be a contiguous subsequence of a periodic sequence, it should contain a single string \"impossible\".\n- Otherwise, it should contain a single integer — the maximum possible period.\n\n-----Constraints-----\n- 1≤T≤100$1 \\le T \\le 100$\n- 2≤N≤105$2 \\le N \\le 10^5$\n- the sum of N$N$ over all test cases does not exceed 106$10^6$\n- for each valid i$i$, 1≤Ai≤106$1 \\le A_i \\le 10^6$ or Ai=−1$A_i = -1$\n\n-----Subtasks-----\nSubtask #1 (50 points):\n- 2≤N≤1,000$2 \\le N \\le 1,000$\n- the sum of N$N$ over all test cases does not exceed 10,000$10,000$\nSubtask #2 (50 points): original constraints\n\n-----Example Input-----\n3\n3\n-1 -1 -1\n5\n1 -1 -1 4 1\n4\n4 6 7 -1\n\n-----Example Output-----\ninf\n4\nimpossible\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_periodic_sequence (n: Nat) (sequence: List Int) : String := sorry\n\ndef List.sum (l: List Int) : Int := sorry", "vc-theorems": "theorem sum_zero (sequence: List Int) :\n  solve_periodic_sequence 0 sequence = \"0\" := sorry\n\ntheorem cycle_repetition {n: Nat} {sequence: List Int} \n  (h: sequence.length > 0) :\n  let cycled := List.join (List.replicate (n / sequence.length + 1) sequence)\n  String.toInt! (solve_periodic_sequence n sequence) = \n    (List.take n cycled).sum := sorry\n\ntheorem cycle_consistency {n: Nat} {sequence: List Int}\n  (h1: sequence.length > 0)\n  (h2: n ≥ sequence.length) :\n  String.toInt! (solve_periodic_sequence (n + sequence.length) sequence) - \n  String.toInt! (solve_periodic_sequence n sequence) = \n  sequence.sum := sorry\n\n/-\ninfo: '0'\n-/\n-- #guard_msgs in\n-- #eval solve_periodic_sequence 0 [1, 2, 3]\n\n/-\ninfo: '1'\n-/\n-- #guard_msgs in\n-- #eval solve_periodic_sequence 1 [1, 2, 3]\n\n/-\ninfo: '3'\n-/\n-- #guard_msgs in\n-- #eval solve_periodic_sequence 2 [1, 2, 3]\n\n/-\ninfo: '7'\n-/\n-- #guard_msgs in\n-- #eval solve_periodic_sequence 4 [1, 2, 3]\n\n/-\ninfo: '-2'\n-/\n-- #guard_msgs in\n-- #eval solve_periodic_sequence 3 [-1, 2, -3]\n\n/-\ninfo: '-4'\n-/\n-- #guard_msgs in\n-- #eval solve_periodic_sequence 6 [-1, 2, -3]\n\n/-\ninfo: '4'\n-/\n-- #guard_msgs in\n-- #eval solve_periodic_sequence 5 [1, -1, -1, 4, 1]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1432", "language": "lean", "source": "fvapps", "source-id": "fvapps_001432", "source-notes": "", "vc-description": "/-\nYoung Sheldon is given the task to teach Chemistry to his brother Georgie. After teaching him how to find total atomic weight, Sheldon gives him some formulas which consist of $x$, $y$ and $z$ atoms as an assignment. \nYou already know that Georgie doesn't like Chemistry, so he want you to help him solve this assignment.\nLet the chemical formula be given by the string $S$. It consists of any combination of x, y and z with some value associated with it as well as parenthesis to encapsulate any combination. Moreover, the atomic weight of x, y and z are 2, 4 and 10 respectively.\nYou are supposed to find the total atomic weight of the element represented by the given formula.\nFor example, for the formula $(x_2y_2)_3z$, given string $S$ will be: $(x2y2)3z$. Hence, substituting values of x, y and z, total atomic weight will be \n$(2*2+4*2)*3 + 10 = 46$.\n\n-----Input:-----\n- First line will contain $T$, number of testcases. Then the testcases follow. \n- Each testcase contains of a single line of input $S$. \n\n-----Output:-----\nFor each testcase, output in a single line, the total atomic weight.\n\n-----Constraints-----\n- $1 \\leq T \\leq 100$\n- Length of string $S \\leq 100$\n- String contains $x, y, z, 1, 2,..., 9$ and parenthesis\n\n-----Sample Input:-----\n2\n(xy)2\nx(x2y)3(z)2\n\n-----Sample Output:-----\n12\n46\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_atomic_weight (f : ChemicalFormula) : Nat :=\n  sorry", "vc-theorems": "theorem atomic_weight_positive (f : ChemicalFormula) :\n  solve_atomic_weight f > 0 := by\n  sorry\n\ntheorem atomic_weight_consistent (f : ChemicalFormula) :\n  solve_atomic_weight f = solve_atomic_weight f := by\n  sorry\n\ntheorem atomic_weight_x :\n  solve_atomic_weight ⟨\"x\"⟩ = 2 := by\n  sorry\n\ntheorem atomic_weight_y :\n  solve_atomic_weight ⟨\"y\"⟩ = 4 := by\n  sorry\n\ntheorem atomic_weight_z :\n  solve_atomic_weight ⟨\"z\"⟩ = 10 := by\n  sorry\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval solve_atomic_weight \"(xy)2\"\n\n/-\ninfo: 46\n-/\n-- #guard_msgs in\n-- #eval solve_atomic_weight \"x(x2y)3(z)2\"\n\n/-\ninfo: 16\n-/\n-- #guard_msgs in\n-- #eval solve_atomic_weight \"xyz\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1434", "language": "lean", "source": "fvapps", "source-id": "fvapps_001434", "source-notes": "", "vc-description": "/-\nYou are provided with the marks of entire class in Data structures exam out of 100. You need to calculate the number of students having backlog (passing marks is >=31) and the average of the class. But this average is not a normal average, for this average marks of students having backlog are not considered but they will be considered in number of students. Also print the index of topper’s marks and print the difference of everyone’s marks with respect to the topper. \nIn first line print the number of students having backlog and average of the class. In second line print indices of all the toppers(in case of more than 1 topper print index of all toppers in reverse order). Next N lines print the difference of everyone’s marks with respect to topper(s).\nNote- if all students have backlog than average will be 0.\nINPUT\nThe first line of the input contains an integer T denoting the number of test cases.\nNext line contains N denoting the no of students in the class.\nThe line contains N space seprated integers A1,A2,A3….AN denoting the marks of each student in exam.\nOUTPUT\nFirst line contains the number of students having backlog and the special average of marks as described above. Average must have 2 decimal places.\nNext line contains the indices of all the toppers in given array in reverse order.\nNext N lines contain the difference of every student’s marks with respect to toppers.\nConstraints\n1<= T <= 100\n1<= N <= 30\n0<= Ai<= 100\nExample\nInput\n1\n9\n56 42 94 25 74 99 27 52 83\nOutput\n2 55.55\n5 \n43\n57\n5\n74\n25\n0\n72\n47\n16\n-/", "vc-preamble": "def sum (l: List Nat) : Nat :=\n  l.foldl (· + ·) 0\n\ndef natToFloat (n : Nat) : Float :=\n  Float.ofNat n", "vc-helpers": "", "vc-definitions": "def calculate_class_stats (marks: List Nat) : Nat × Float × List Nat × List Nat :=\n  sorry", "vc-theorems": "theorem calculate_class_stats_backlog_matches_failing_count \n  (marks: List Nat) (h: marks.length > 0) (h2: ∀ x ∈ marks, x ≤ 100) :\n  let (backlog, _, _, _) := calculate_class_stats marks\n  backlog = (marks.filter (· < 31)).length := sorry\n\ntheorem calculate_class_stats_average_matches_passing_average\n  (marks: List Nat) (h: marks.length > 0) (h2: ∀ x ∈ marks, x ≤ 100) :\n  let (_, avg, _, _) := calculate_class_stats marks\n  let passing := marks.filter (· ≥ 31)\n  passing.isEmpty → avg = 0 ∧\n  ¬passing.isEmpty → avg = natToFloat (sum passing) / natToFloat marks.length := sorry\n\ntheorem calculate_class_stats_toppers_correct\n  (marks: List Nat) (h: marks.length > 0) (h2: ∀ x ∈ marks, x ≤ 100) :\n  let (_, _, toppers, _) := calculate_class_stats marks\n  let maxMark := marks.maximum?.getD 0\n  toppers = (List.range marks.length).filter (fun i => \n    marks.get! i = maxMark) := sorry\n\ntheorem calculate_class_stats_diffs_correct\n  (marks: List Nat) (h: marks.length > 0) (h2: ∀ x ∈ marks, x ≤ 100) :\n  let (_, _, _, diffs) := calculate_class_stats marks\n  let maxMark := marks.maximum?.getD 0\n  diffs = marks.map (fun x => maxMark - x) := sorry\n\ntheorem calculate_class_stats_diffs_length\n  (marks: List Nat) (h: marks.length > 0) (h2: ∀ x ∈ marks, x ≤ 100) :\n  let (_, _, _, diffs) := calculate_class_stats marks\n  diffs.length = marks.length := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1441", "language": "lean", "source": "fvapps", "source-id": "fvapps_001441", "source-notes": "", "vc-description": "/-\nDevu is a class teacher of a class of n students. One day, in the morning prayer of the school, all the students of his class were standing in a line. You are given information of their arrangement by a string s. The string s consists of only letters 'B' and 'G', where 'B' represents a boy and 'G' represents a girl.\nDevu wants inter-gender interaction among his class should to be maximum. So he does not like seeing two or more boys/girls standing nearby (i.e. continuous) in the line. e.g. he does not like the arrangements BBG and GBB, but he likes BG, GBG etc.\nNow by seeing the initial arrangement s of students, Devu may get furious and now he wants to change this arrangement into a likable arrangement. For achieving that, he can swap positions of any two students (not necessary continuous). Let the cost of swapping people from position i with position j (i ≠ j) be c(i, j). You are provided an integer variable type, then the cost of the the swap will be defined by c(i, j) = |j − i|type.\n\nPlease help Devu in finding minimum cost of swaps needed to convert the current arrangement into a likable one.\n\n-----Input-----\nThe first line of input contains an integer T, denoting the number of test cases. Then T test cases are follow.\nThe first line of each test case contains an integer type, denoting the type of the cost function. Then the next line contains string s of length n, denoting the initial arrangement s of students.\nNote that the integer n is not given explicitly in input.\n\n-----Output-----\nFor each test case, print a single line containing the answer of the test case, that is, the minimum cost to convert the current arrangement into a likable one. If it is not possible to convert the current arrangement into a likable one, then print -1 instead of the minimum cost.\n\n-----Constraints and Subtasks-----Subtask 1: 25 points\n- 1 ≤ T ≤ 105\n- 1 ≤ n ≤ 105\n- type = 0\n- Sum of n over all the test cases in one test file does not exceed 106. \nSubtask 2: 25 points\n- 1 ≤ T ≤ 105\n- 1 ≤ n ≤ 105\n- type = 1\n- Sum of n over all the test cases in one test file does not exceed 106. \nSubtask 3: 25 points\n- 1 ≤ T ≤ 105\n- 1 ≤ n ≤ 105\n- type = 2\n- Sum of n over all the test cases in one test file does not exceed 106. \nSubtask 4: 25 points\n- 1 ≤ T ≤ 102\n- 1 ≤ n ≤ 103\n- type can be 0, 1 or 2, that is type ∈ {0, 1, 2}.\n\n-----Example-----\nInput:\n8\n0\nBB\n0\nBG\n0\nBBGG\n1\nBGG\n1\nBGGB\n1\nBBBGG\n2\nBBGG\n2\nBGB\n\nOutput:\n-1\n0\n1\n1\n1\n3\n1\n0\n\n-----Explanation-----\nNote type of the first 3 test cases is 0. So c(i, j) = 1. Hence we just have to count minimum number of swaps needed.\nExample case 1. There is no way to make sure that both the boys does not stand nearby. So answer is -1.\nExample case 2. Arrangement is already valid. No swap is needed. So answer is 0.\nExample case 3. Swap boy at position 1 with girl at position 2. After swap the arrangement will be BGBG which is a valid arrangement. So answer is 1.\nNow type of the next 3 test cases is 1. So c(i, j) = |j − i|, that is, the absolute value of the difference between i and j.\nExample case 4. Swap boy at position 0 with girl at position 1. After swap the arrangement will be GBG which is a valid arrangement. So answer is |1 - 0| = 1.\nExample case 5. Swap boy at position 0 with girl at position 1. After swap the arrangement will be GBGB which is a valid arrangement. So answer is |1 - 0| = 1.\nExample case 6. Swap boy at position 1 with girl at position 4. After swap the arrangement will be BGBGB which is a valid arrangement. So answer is |4 - 1| = 3.\nThen type of the last 2 test cases is 2. So c(i, j) = (j − i)2\nExample case 7. Swap boy at position 1 with girl at position 2. After swap the arrangement will be BGBG which is a valid arrangement. So answer is (2 - 1)2 = 1.\nExample case 8. Arrangement is already valid. No swap is needed. So answer is 0.\n-/", "vc-preamble": "def calculate_min_cost (cost_type : Nat) (arrangement : Arrangement) : Int :=\nsorry\n\ndef countBs (arr : Arrangement) : Nat :=\nmatch arr with\n| Arrangement.mk s => s.filter (· = 'B') |>.length\n\ndef countGs (arr : Arrangement) : Nat :=\nmatch arr with\n| Arrangement.mk s => s.filter (· = 'G') |>.length\n\ndef length (arr : Arrangement) : Nat :=\nmatch arr with\n| Arrangement.mk s => s.length", "vc-helpers": "", "vc-definitions": "def absDiff (a b : Nat) : Nat :=\nif a ≥ b then a - b else b - a", "vc-theorems": "theorem cost_type_and_arrangement_bounds \n  (cost_type : Nat) (arrangement : Arrangement)\n  (h1 : cost_type ≤ 2)\n  (h2 : length arrangement ≥ 1)\n  (h3 : ∀ (c : Char), c ∈ (match arrangement with | Arrangement.mk s => s) → c = 'B' ∨ c = 'G') :\n  let b_count := countBs arrangement\n  let g_count := countGs arrangement\n  let result := calculate_min_cost cost_type arrangement\n  (absDiff b_count g_count > 1 → result = -1) ∧\n  (absDiff b_count g_count ≤ 1 →\n    result ≥ 0 ∧\n    (cost_type = 0 → result ≤ length arrangement / 2) ∧\n    (cost_type = 1 → result ≤ (length arrangement) * (length arrangement)) ∧\n    (cost_type = 2 → result ≤ (length arrangement) * (length arrangement) * (length arrangement))) :=\nsorry\n\ntheorem balanced_arrangement_special_case\n  (arrangement : Arrangement)\n  (h1 : length arrangement ≥ 1)\n  (h2 : length arrangement ≤ 10)\n  (h3 : ∀ (c : Char), c ∈ (match arrangement with | Arrangement.mk s => s) → c = 'B' ∨ c = 'G') :\n  let b_count := countBs arrangement\n  let g_count := countGs arrangement\n  let result := calculate_min_cost 0 arrangement\n  (absDiff b_count g_count > 1 → result = -1) ∧\n  (b_count = g_count ∧ length arrangement = 2 → \n    result = 0 ∨ result = 1) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1457", "language": "lean", "source": "fvapps", "source-id": "fvapps_001457", "source-notes": "", "vc-description": "/-\nTuzik and Vanya are playing the following game.\nThey have an N × M board and a chip to indicate the current game position. The chip can be placed on any one cell of the game board, each of which is uniquely identified by an ordered pair of positive integers (r, c), where 1 ≤ r ≤ N is the row number and 1 ≤ c ≤ M is the column number.\nInitially, the chip is placed at the cell identified as (1, 1). For his move, a player can move it either 1, 2 or 3 cells up, or 1 or 2 cells to the right. The player who can not move the chip loses. In other words, a player suffers defeat if the chip is placed in the cell (N, M) at the start of his turn.\nTuzik starts the game. You have to determine who will win the game if both players play optimally.\n\n-----Input-----\nThe first line contains an integer T denoting the number of tests. Each of the following T lines contain two integers N and M.\n\n-----Output-----\nFor each test output \"Tuzik\" or \"Vanya\" on a separate line, indicating who will win the game.\n\n-----Constraints-----\n- 1 ≤ T ≤ 100\n- 1 ≤ N, M ≤ 106\n\n-----Example-----\nInput:\n2\n4 4\n2 2\n\nOutput:\nTuzik\nVanya\n\n-----Explanation-----Test case 1: On his first turn Tuzik moves chip 3 cells up to the cell (4, 1). On his turn Vanya can move chip only right to the cell (4, 2) or to the cell (4, 3) and after that Tuzik moves it to (4, 4) and finishes the game.\n\nTest case 2: On his first Turn Tuzik can move chip to the cell (2, 1) or (1, 2), but on his next turn Vanya moves it to (2, 2) and wins the game.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def determine_winner (rows cols : Nat) : Player := sorry\n\ntheorem determine_winner_returns_valid_player (rows cols : Nat) \n  (h1 : 1 ≤ rows) (h2 : rows ≤ 1000) (h3 : 1 ≤ cols) (h4 : cols ≤ 1000) :\n  (determine_winner rows cols = Player.Vanya) ∨ \n  (determine_winner rows cols = Player.Tuzik) := sorry", "vc-theorems": "theorem winner_pattern_properties (rows cols : Nat)\n  (h1 : 1 ≤ rows) (h2 : rows ≤ 1000) (h3 : 1 ≤ cols) (h4 : cols ≤ 1000) :\n  let row_mod := (rows - 1) % 4\n  let col_mod := (cols - 1) % 3\n  ((col_mod = 0 ∧ row_mod = 0) ∨ \n   (col_mod = 1 ∧ row_mod = 1) ∨ \n   (col_mod = 2 ∧ row_mod = 2)) → determine_winner rows cols = Player.Vanya \n  ∧\n  ¬((col_mod = 0 ∧ row_mod = 0) ∨ \n    (col_mod = 1 ∧ row_mod = 1) ∨ \n    (col_mod = 2 ∧ row_mod = 2)) → determine_winner rows cols = Player.Tuzik := sorry\n\ntheorem column_periodicity (rows : Nat) (h1 : 1 ≤ rows) (h2 : rows ≤ 1000) :\n  ∀ col : Nat, 1 ≤ col → col ≤ 3 →\n    determine_winner rows col = determine_winner rows (col + 3) := sorry\n\ntheorem row_periodicity (cols : Nat) (h1 : 1 ≤ cols) (h2 : cols ≤ 1000) :\n  ∀ row : Nat, 1 ≤ row → row ≤ 4 →\n    determine_winner row cols = determine_winner (row + 4) cols := sorry\n\n/-\ninfo: 'Tuzik'\n-/\n-- #guard_msgs in\n-- #eval determine_winner 4 4\n\n/-\ninfo: 'Vanya'\n-/\n-- #guard_msgs in\n-- #eval determine_winner 2 2\n\n/-\ninfo: 'Vanya'\n-/\n-- #guard_msgs in\n-- #eval determine_winner 5 4", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1468", "language": "lean", "source": "fvapps", "source-id": "fvapps_001468", "source-notes": "", "vc-description": "/-\nZonal Computing Olympiad 2014, 30 Nov 2013\n\nIn IPL 2025, the amount that each player is paid varies from match to match.  The match fee depends on the quality of opposition, the venue etc.\n\nThe match fees for each match in the new season have been announced in advance.  Each team has to enforce a mandatory rotation policy so that no player ever plays three matches in a row during the season.\n\nNikhil is the captain and chooses the team for each match. He wants to allocate a playing schedule for himself to maximize his earnings through match fees during the season.  \n\n-----Input format-----\nLine 1: A single integer N, the number of games in the IPL season.\nLine 2: N non-negative integers, where the integer in\nposition i represents the fee for match i.\n\n-----Output format-----\nThe output consists of a single non-negative integer, the\nmaximum amount of money that Nikhil can earn during this IPL\nseason. \n\n-----Sample Input 1-----\n5 \n10 3 5 7 3 \n\n-----Sample Output 1-----\n23\n\n(Explanation: 10+3+7+3)\n\n-----Sample Input 2-----\n8\n3 2 3 2 3 5 1 3\n\n-----Sample Output 2-----\n17\n\n(Explanation: 3+3+3+5+3)\n\n-----Test data-----\nThere is only one subtask worth 100 marks.  In all inputs:\n\n• 1 ≤ N ≤ 2×105\n• The fee for each match is between 0 and 104, inclusive.\n\n-----Live evaluation data-----\nThere are 12 test inputs on the server during the exam.\n-/", "vc-preamble": "def List.sum : List Nat → Nat\n  | [] => 0\n  | x :: xs => x + List.sum xs\n\ndef List.maximum' : List Nat → Nat\n  | [] => 0\n  | [x] => x\n  | x :: xs => max x (List.maximum' xs)\n\n/- Main function -/", "vc-helpers": "", "vc-definitions": "def calculate_max_earnings (n : Nat) (fees : List Nat) : Nat :=\n  sorry\n\n/- Theorems -/", "vc-theorems": "theorem calculate_max_earnings_bounded (n : Nat) (fees : List Nat) :\n  n > 0 → fees.length = n → calculate_max_earnings n fees ≤ fees.sum :=\n  sorry\n\ntheorem calculate_max_earnings_nonnegative (n : Nat) (fees : List Nat) :\n  n > 0 → fees.length = n → calculate_max_earnings n fees ≥ 0 :=\n  sorry\n\ntheorem calculate_max_earnings_returns_number (n : Nat) (fees : List Nat) :\n  n > 0 → fees.length = n → calculate_max_earnings n fees = calculate_max_earnings n fees :=\n  sorry\n\n/-\ninfo: 23\n-/\n-- #guard_msgs in\n-- #eval calculate_max_earnings 5 [10, 3, 5, 7, 3]\n\n/-\ninfo: 17\n-/\n-- #guard_msgs in\n-- #eval calculate_max_earnings 8 [3, 2, 3, 2, 3, 5, 1, 3]\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval calculate_max_earnings 3 [1, 2, 3]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1515", "language": "lean", "source": "fvapps", "source-id": "fvapps_001515", "source-notes": "", "vc-description": "/-\nChef is making polygon cakes in his kitchen today! \nSince the judge panel is very strict, Chef's cakes must be beautiful and have sharp and precise $internal$ angles in arithmetic progression. \nGiven the number of sides, $N$, of the cake Chef is baking today and also the measure of its first angle(smallest angle), $A$, find the measure of the $K^{th}$ angle.\n\n-----Input:-----\n- The first line contains a single integer $T$, the number of test cases. \n- The next $T$ lines contain three space separated integers $N$, $A$ and $K$, the number of sides of polygon, the first angle and the $K^{th}$ angle respectively. \n\n-----Output:-----\nFor each test case, print two space separated integers $X$ and $Y$, such that the $K^{th}$ angle can be written in the form of $X/Y$ and $gcd(X, Y) = 1$\n\n-----Constraints-----\n- $1 \\leq T \\leq 50$\n- $3 \\leq N \\leq 1000$\n- $1 \\leq A \\leq 1000000000$\n- $1 \\leq K \\leq N$\n- It is guaranteed the answer is always valid.\n\n-----Sample Input:-----\n1\n3 30 2\n\n-----Sample Output:-----\n60 1\n-/", "vc-preamble": "def Int.abs (n : Int) : Int := \n  if n ≥ 0 then n else -n", "vc-helpers": "", "vc-definitions": "def find_kth_angle (N : Nat) (A : Int) (K : Nat) : Int × Nat := sorry\n\ntheorem first_angle_matches {N : Nat} {A : Int} \n  (hN : N ≥ 3) (hN2 : N ≤ 100) (hA : 0 ≤ A) (hA2 : A ≤ 360) :\n  let (num, den) := find_kth_angle N A 1\n  Int.div num den = A := sorry", "vc-theorems": "/-\ninfo: (60, 1)\n-/\n-- #guard_msgs in\n-- #eval find_kth_angle 3 30 2\n\n/-\ninfo: (90, 1)\n-/\n-- #guard_msgs in\n-- #eval find_kth_angle 4 90 2\n\n/-\ninfo: (108, 1)\n-/\n-- #guard_msgs in\n-- #eval find_kth_angle 5 72 3", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1520", "language": "lean", "source": "fvapps", "source-id": "fvapps_001520", "source-notes": "", "vc-description": "/-\nYou are given $N$ gears numbered $1$ through $N$. For each valid $i$, gear $i$ has $A_i$ teeth. In the beginning, no gear is connected to any other. Your task is to process $M$ queries and simulate the gears' mechanism. There are three types of queries:\n- Type 1: Change the number of teeth of gear $X$ to $C$.\n- Type 2: Connect two gears $X$ and $Y$.\n- Type 3: Find the speed of rotation of gear $Y$ if gear $X$ rotates with speed $V$.\nIt is known that if gear $i$ is directly connected to gear $j$ and gear $i$ rotates with speed $V$, then gear $j$ will rotate with speed $-V A_i / A_j$, where the sign of rotation speed denotes the direction of rotation (so minus here denotes rotation in the opposite direction). You may also notice that gears can be blocked in some cases. This happens when some gear would have to rotate in different directions. If a gear is connected to any blocked gear, it is also blocked. For example, if three gears are connected to each other, this configuration can not rotate at all, and if we connect a fourth gear to these three, it will also be blocked and not rotate.\n\n-----Input-----\n- The first line of the input contains two space-separated integers $N$ and $M$.\n- The second line contains $N$ space-separated integers $A_1, A_2, \\dots, A_N$.\n- The following $M$ lines describe queries. Each of these lines begins with an integer $T$ denoting the type of the current query.\n- If $T = 1$, it is followed by a space and two space-separated integers $X$ and $C$.\n- If $T = 2$, it is followed by a space and two space-separated integers $X$ and $Y$.\n- If $T = 3$, it is followed by a space and three space-separated integers $X$, $Y$ and $V$.\n\n-----Output-----\nFor each query of type 3, print a single line containing two integers separated by a slash '/' — the numerator and denominator of the rotation speed of the given gear expressed as an irreducible fraction (even if this speed is an integer), or $0$ if the gear does not rotate at all.\n\n-----Constraints-----\n- $1 \\le N \\le 10^5$\n- $1 \\le M \\le 2\\cdot 10^5$\n- $6 \\le A_i \\le 10^6$ for each valid $i$\n- $1 \\le X, Y \\le N$\n- $1 \\le C, V \\le 10^6$\n\n-----Subtasks-----\nSubtask #1 (30 points):\n- $N \\le 2,000$\n- $M \\le 5,000$\nSubtask #2 (70 points): original constraints\n\n-----Example Input-----\n4 10\n6 8 10 13\n3 1 2 2\n2 1 2\n3 1 2 3\n2 2 3\n1 1 7\n3 1 3 10\n2 3 1\n3 1 3 2\n2 1 4\n3 1 4 6\n\n-----Example Output-----\n0\n-9/4\n7/1\n0\n0\n\n-----Explanation-----\nFor the first query of type 3, there are no connections between gears, so the answer is $0$.\nFor the second query of type 3, we can calculate the rotation speed using the formula $-3\\cdot\\frac{6}{8} = \\frac{-9}{4}$.\nFor the third query of type 3, we can use the formula twice, so the speed of the second gear is $-10\\cdot\\frac{7}{8} = -\\frac{35}{4}$, and the speed of the third gear is $-(-\\frac{35}{4})\\frac{8}{10} = \\frac{7}{1}$.\nFor the last query of type 3, all gears are blocked.\n-/", "vc-preamble": "def find (d : Dsu) (x : Nat) : Nat := sorry\ndef union (d : Dsu) (x y : Nat) : Dsu := sorry\n\ndef stringContainsSlash (s : String) : Bool := \n  s.any (fun c => c = '/')", "vc-helpers": "", "vc-definitions": "def solve_gears (speeds : List Nat) (queries : List (List Nat)) : List String := sorry\n\nvariable (n : Nat) (speeds : List Nat) (queries : List (List Nat)) (d : Dsu)", "vc-theorems": "theorem basic_gear_properties \n  (h1 : n ≥ 2) \n  (h2 : speeds.length ≥ 2)\n  (h3 : queries.length ≥ 1) :\n  let result := solve_gears speeds queries\n  (∀ r ∈ result, r = \"0\" ∨ stringContainsSlash r) := sorry\n\ntheorem dsu_reflexivity\n  (h1 : n ≥ 2)\n  (h2 : speeds.length ≥ 2) :\n  ∀ i < n, find d i = find d i := sorry\n\ntheorem dsu_initial_state\n  (h1 : n ≥ 2)\n  (h2 : speeds.length ≥ 2) :\n  (∀ x ∈ d.zero, ¬x) ∧ \n  (∀ x ∈ d.dr, x = 1) := sorry\n\ntheorem dsu_union_symmetry\n  (h1 : n ≥ 2)\n  (h2 : speeds.length ≥ 2) :\n  find (union d 0 1) 0 = find (union d 0 1) 1 := sorry\n\ntheorem three_gear_ratio\n  (h1 : n ≥ 3)\n  (h2 : speeds.length ≥ 3) :\n  let queries := [[2, 1, 2], [2, 2, 3], [3, 1, 3, 1]]\n  let result := solve_gears speeds queries\n  match result.getLast? with\n  | some s => s = \"0\" ∨ stringContainsSlash s\n  | none => False := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1521", "language": "lean", "source": "fvapps", "source-id": "fvapps_001521", "source-notes": "", "vc-description": "/-\nGiven an alphanumeric string made up of digits and lower case Latin characters only, find the sum of all the digit characters in the string.\n\n-----Input-----\n- The first line of the input contains an integer T denoting the number of test cases. Then T test cases follow.\n- Each test case is described with a single line containing a string S, the alphanumeric string.\n\n-----Output-----\n- For each test case, output a single line containing the sum of all the digit characters in that string.\n\n-----Constraints-----\n- 1 ≤ T ≤ 1000\n- 1 ≤ |S| ≤ 1000, where |S| is the length of the string S.\n\n-----Example-----\nInput:\n1\nab1231da\n\nOutput:\n7\n\n-----Explanation-----\nThe digits in this string are 1, 2, 3 and 1. Hence, the sum of all of them is 7.\n-/", "vc-preamble": "def sum_of_digits (s : String) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + sum xs", "vc-theorems": "theorem sum_of_digits_no_digits (s : String) \n  (h : ∀ c ∈ s.data, !c.isDigit) : \n  sum_of_digits s = 0 := \n  sorry\n\ntheorem sum_of_digits_all_digits (digits : List Nat)\n  (h : ∀ d ∈ digits, d ≤ 9) :\n  sum_of_digits (String.join (digits.map toString)) = List.sum digits := \n  sorry\n\ntheorem sum_of_digits_mixed (letters digits : String)\n  (h1 : ∀ c ∈ letters.data, !c.isDigit)\n  (h2 : ∀ c ∈ digits.data, c.isDigit) :\n  sum_of_digits (letters ++ digits) = sum_of_digits digits :=\n  sorry\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval sum_of_digits \"ab1231da\"\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval sum_of_digits \"a1b2c3\"\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval sum_of_digits \"nodigits\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1523", "language": "lean", "source": "fvapps", "source-id": "fvapps_001523", "source-notes": "", "vc-description": "/-\nIn this problem the input will consist of a number of lines of English text consisting of the letters of the English alphabet, the punctuation marks ' (apostrophe), . (full stop), , (comma), ; (semicolon), :(colon) and white space characters (blank, newline).\nYour task is print the words in the text in lexicographic order (that is, dictionary order). Each word should appear exactly once in your list. You can ignore the case (for instance, \"The\" and \"the\" are to be treated as the same word). There should be no uppercase letters in the output.\nFor example, consider the following candidate for the input text: \nThis is a sample piece of text to illustrate this \nproblem.\n\nThe corresponding output would read as:\na\nillustrate\nis\nof\npiece\nproblem\nsample\ntext\nthis\nto\n\n-----Input format-----\n- The first line of input contains a single integer $N$, indicating the number of lines in the input.\n- This is followed by $N$ lines of input text.\n\n-----Output format-----\n- The first line of output contains a single integer $M$ indicating the number of distinct words in the given text. \n- The next $M$ lines list out these words in lexicographic order.\n\n-----Constraints-----\n- $1 \\leq N \\leq 10000$\n- There are at most 80 characters in each line.\n- There are at the most 1000 distinct words in the given text.\n\n-----Sample Input-----\n2\nThis is a sample piece of text to illustrate this \nproblem. \n\n-----Sample Output-----\n10\na\nillustrate\nis\nof\npiece\nproblem\nsample\ntext\nthis\nto\n-/", "vc-preamble": "def process_text (lines : List String) : List String :=\n  sorry\n\ninductive List.LocalSorted : List String → Prop where\n  | nil : List.LocalSorted []\n  | single (x : String) : List.LocalSorted [x]\n  | cons (x y : String) (rest : List String) \n    (h₁ : x ≤ y) (h₂ : List.LocalSorted (y::rest)) : \n    List.LocalSorted (x::y::rest)\n\ninductive List.LocalNodup : List α → Prop where\n  | nil : List.LocalNodup []\n  | cons (x : α) (xs : List α) \n    (h₁ : x ∉ xs) (h₂ : List.LocalNodup xs) : \n    List.LocalNodup (x::xs)", "vc-helpers": "", "vc-definitions": "def words (s : String) : List String :=\n  sorry", "vc-theorems": "theorem process_text_output_properties {lines : List String} :\n  let result := process_text lines\n  -- First element is length of remaining list\n  (result.head! = toString (result.tail.length)) ∧ \n  -- Result is sorted\n  result.tail.LocalSorted ∧\n  -- All elements are lowercase\n  (∀ x ∈ result.tail, x = x.toLower) ∧\n  -- No duplicates\n  result.tail.LocalNodup :=\n  sorry\n\ntheorem process_text_empty_strings {lines : List String} :\n  (∀ x ∈ lines, x = \"\") → \n  process_text lines = [\"0\"] :=\n  sorry\n\ntheorem process_text_case_insensitive_count {lines : List String} \n  (h₁ : ∀ x ∈ lines, x.length > 0)\n  (h₂ : ∀ x ∈ lines, ∀ c ∈ x.toList, c.isAlpha ∨ c = ' ') :\n  let lines_with_upper := lines ++ (lines.map String.toUpper)\n  let result := process_text lines_with_upper\n  let original_words := (lines.bind (λ s => words s)).map String.toLower |>.eraseDups\n  result.tail.length = original_words.length :=\n  sorry\n\n/-\ninfo: ['0']\n-/\n-- #guard_msgs in\n-- #eval process_text [\"\"]\n\n/-\ninfo: ['1', 'the']\n-/\n-- #guard_msgs in\n-- #eval process_text [\"The THE the\", \"THE\"]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1525", "language": "lean", "source": "fvapps", "source-id": "fvapps_001525", "source-notes": "", "vc-description": "/-\nThere are n cards of different colours placed in a line, each of them can be either red, green or blue cards. Count the minimum number of cards to withdraw from the line so that no two adjacent cards have the same colour.\n\n-----Input-----\n- The first line of each input contains an integer n— the total number of cards.\n- The next line of the input contains a string s, which represents the colours of the cards. We'll consider the cards in a line numbered from 1 to n from left to right. Then the $i^t$$^h$ alphabet equals \"G\", if the $i^t$$^h$ card is green, \"R\" if the card is red,  and \"B\", if it's blue.\n\n-----Output-----\n- Print a single integer — the answer to the problem.\n\n-----Constraints-----\n- $1 \\leq n \\leq 50$\n\n-----Sample Input 1:-----\n5\nRGGBG\n\n-----Sample Input 2:-----\n5\nRRRRR\n\n-----Sample Input 3:-----\n2\nBB\n\n-----Sample Output 1:-----\n1\n\n-----Sample Output 2:-----\n4\n\n-----Sample Output 3:-----\n1\n-/", "vc-preamble": "def count_min_cards_to_remove (n : Nat) (colors : List Color) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def countAdjacentSame (colors : List Color) : Nat :=\n  (List.zip colors colors.tail).filter (fun (x, y) => decide (x = y)) |>.length", "vc-theorems": "theorem min_cards_upper_bound {n : Nat} {colors : List Color} \n  (h : colors.length = n) (h1 : n > 0) :\n  count_min_cards_to_remove n colors ≤ n - 1 :=\nsorry\n\ntheorem min_cards_non_negative {n : Nat} {colors : List Color} \n  (h : colors.length = n) (h1 : n > 0) :\n  count_min_cards_to_remove n colors ≥ 0 :=\nsorry\n\ntheorem min_cards_equals_adjacent_same {n : Nat} {colors : List Color}\n  (h : colors.length = n) (h1 : n > 0) :\n  count_min_cards_to_remove n colors = countAdjacentSame colors :=\nsorry\n\ntheorem min_cards_all_same_color {n : Nat} {colors : List Color}\n  (h : colors.length = n) (h1 : n > 0)\n  (h2 : ∀ i j, i < colors.length → j < colors.length → colors[i]! = colors[j]!) :\n  count_min_cards_to_remove n colors = n - 1 :=\nsorry\n\ntheorem min_cards_alternating {n : Nat} {colors : List Color}\n  (h : colors.length = n) (h1 : n ≥ 2)\n  (h2 : ∀ i, i < colors.length - 1 → colors[i]! ≠ colors[i+1]!) :\n  count_min_cards_to_remove n colors = 0 :=\nsorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval count_min_cards_to_remove 5 \"RGGBG\"\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval count_min_cards_to_remove 5 \"RRRRR\"\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval count_min_cards_to_remove 2 \"BB\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1545", "language": "lean", "source": "fvapps", "source-id": "fvapps_001545", "source-notes": "", "vc-description": "/-\nThere are some websites that are accessible through several different addresses. For example, for a long time Codeforces was accessible with two hostnames codeforces.com and codeforces.ru.\n\nYou are given a list of page addresses being queried. For simplicity we consider all addresses to have the form http://<hostname>[/<path>], where:\n\n  <hostname> — server name (consists of words and maybe some dots separating them),  /<path> — optional part, where <path> consists of words separated by slashes. \n\nWe consider two <hostname> to correspond to one website if for each query to the first <hostname> there will be exactly the same query to the second one and vice versa — for each query to the second <hostname> there will be the same query to the first one. Take a look at the samples for further clarifications.\n\nYour goal is to determine the groups of server names that correspond to one website. Ignore groups consisting of the only server name.\n\nPlease note, that according to the above definition queries http://<hostname> and http://<hostname>/ are different.\n\n-----Input-----\n\nThe first line of the input contains a single integer n (1 ≤ n ≤ 100 000) — the number of page queries. Then follow n lines each containing exactly one address. Each address is of the form http://<hostname>[/<path>], where:\n\n  <hostname> consists of lowercase English letters and dots, there are no two consecutive dots, <hostname> doesn't start or finish with a dot. The length of <hostname> is positive and doesn't exceed 20.  <path> consists of lowercase English letters, dots and slashes. There are no two consecutive slashes, <path> doesn't start with a slash and its length doesn't exceed 20. \n\nAddresses are not guaranteed to be distinct.\n\n-----Output-----\n\nFirst print k — the number of groups of server names that correspond to one website. You should count only groups of size greater than one.\n\nNext k lines should contain the description of groups, one group per line. For each group print all server names separated by a single space. You are allowed to print both groups and names inside any group in arbitrary order.\n\n-----Examples-----\nInput\n10\nhttp://abacaba.ru/test\nhttp://abacaba.ru/\nhttp://abacaba.com\nhttp://abacaba.com/test\nhttp://abacaba.de/\nhttp://abacaba.ru/test\nhttp://abacaba.de/test\nhttp://abacaba.com/\nhttp://abacaba.com/t\nhttp://abacaba.com/test\n\nOutput\n1\nhttp://abacaba.de http://abacaba.ru \n\nInput\n14\nhttp://c\nhttp://ccc.bbbb/aba..b\nhttp://cba.com\nhttp://a.c/aba..b/a\nhttp://abc/\nhttp://a.c/\nhttp://ccc.bbbb\nhttp://ab.ac.bc.aa/\nhttp://a.a.a/\nhttp://ccc.bbbb/\nhttp://cba.com/\nhttp://cba.com/aba..b\nhttp://a.a.a/aba..b/a\nhttp://abc/aba..b/a\n\nOutput\n2\nhttp://cba.com http://ccc.bbbb \nhttp://a.a.a http://a.c http://abc\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_website_groups (urls : List String) : List (List String) := sorry\n\ntheorem groups_return_type (urls : List String) : \n  let result := find_website_groups urls\n  result.all (fun group => group.all (fun _ => true)) := sorry", "vc-theorems": "theorem groups_min_size (urls : List String) :\n  let result := find_website_groups urls\n  result.all (fun group => group.length > 1) := sorry\n\ntheorem hostnames_appear_once (urls : List String) :\n  let result := find_website_groups urls\n  let all_hostnames := result.bind id\n  all_hostnames.length = (all_hostnames.eraseDups).length := sorry\n\ntheorem empty_paths_normalized (urls : List String) (h : String) :\n  let test_urls := urls ++ [s!\"http://{h}\", s!\"http://{h}/\"]\n  let result := find_website_groups test_urls\n  result.all (fun group => \n    if group.contains h then group.count h = 1 \n    else true) := sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval len find_website_groups(test1)\n\n/-\ninfo: {'abacaba.ru', 'abacaba.de'}\n-/\n-- #guard_msgs in\n-- #eval set result1[0]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval len find_website_groups(test2)\n\n/-\ninfo: {'cba.com', 'ccc.bbbb'}\n-/\n-- #guard_msgs in\n-- #eval set result2[0]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval len find_website_groups(test3)\n\n/-\ninfo: {'abacaba.com', 'abacaba.de'}\n-/\n-- #guard_msgs in\n-- #eval set result3[0]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1546", "language": "lean", "source": "fvapps", "source-id": "fvapps_001546", "source-notes": "", "vc-description": "/-\nYou are at the top left cell $(1, 1)$ of an $n \\times m$ labyrinth. Your goal is to get to the bottom right cell $(n, m)$. You can only move right or down, one cell per step. Moving right from a cell $(x, y)$ takes you to the cell $(x, y + 1)$, while moving down takes you to the cell $(x + 1, y)$.\n\nSome cells of the labyrinth contain rocks. When you move to a cell with rock, the rock is pushed to the next cell in the direction you're moving. If the next cell contains a rock, it gets pushed further, and so on.\n\nThe labyrinth is surrounded by impenetrable walls, thus any move that would put you or any rock outside of the labyrinth is illegal.\n\nCount the number of different legal paths you can take from the start to the goal modulo $10^9 + 7$. Two paths are considered different if there is at least one cell that is visited in one path, but not visited in the other.\n\n-----Input-----\n\nThe first line contains two integers $n, m$ — dimensions of the labyrinth ($1 \\leq n, m \\leq 2000$).\n\nNext $n$ lines describe the labyrinth. Each of these lines contains $m$ characters. The $j$-th character of the $i$-th of these lines is equal to \"R\" if the cell $(i, j)$ contains a rock, or \".\" if the cell $(i, j)$ is empty.\n\nIt is guaranteed that the starting cell $(1, 1)$ is empty.\n\n-----Output-----\n\nPrint a single integer — the number of different legal paths from $(1, 1)$ to $(n, m)$ modulo $10^9 + 7$.\n\n-----Examples-----\nInput\n1 1\n.\n\nOutput\n1\n\nInput\n2 3\n...\n..R\n\nOutput\n0\n\nInput\n4 4\n...R\n.RR.\n.RR.\nR...\n\nOutput\n4\n\n-----Note-----\n\nIn the first sample case we can't (and don't have to) move, hence the only path consists of a single cell $(1, 1)$.\n\nIn the second sample case the goal is blocked and is unreachable.\n\nIllustrations for the third sample case can be found here: https://assets.codeforces.com/rounds/1225/index.html\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_paths (n m : Nat) (grid : Grid) : Nat :=\n  sorry", "vc-theorems": "theorem count_paths_dimensions {n m : Nat} {grid : Grid} \n  (h1 : grid.length = n)\n  (h2 : ∀ (row : List Char), row ∈ grid → row.length = m) :\n  let result := count_paths n m grid\n  0 ≤ result ∧ result ≤ 10^9+7 :=\nsorry\n\ntheorem count_paths_blocked_start_end {n m : Nat} {grid : Grid}\n  (h1 : grid.length = n) \n  (h2 : ∀ (row : List Char), row ∈ grid → row.length = m)\n  (h3 : (grid.get! 0).get! 0 = 'R' ∨ (grid.get! (n-1)).get! (m-1) = 'R') :\n  count_paths n m grid = 0 :=\nsorry\n\ntheorem count_paths_single_row {n : Nat} \n  (grid : Grid)\n  (h1 : grid.length = 1)\n  (h2 : (grid.get! 0).length = n)\n  (h3 : ∀ i < n, (grid.get! 0).get! i = '.') :\n  count_paths 1 n grid = 1 :=\nsorry\n\ntheorem count_paths_single_col {n : Nat}\n  (grid : Grid) \n  (h1 : grid.length = n)\n  (h2 : ∀ (row : List Char), row ∈ grid → row.length = 1)\n  (h3 : ∀ i < n, (grid.get! i).get! 0 = '.') :\n  count_paths n 1 grid = 1 :=\nsorry\n\ntheorem count_paths_modulo {n m : Nat} {grid : Grid}\n  (h1 : grid.length = n)\n  (h2 : ∀ (row : List Char), row ∈ grid → row.length = m) :\n  let result := count_paths n m grid\n  0 ≤ result ∧ result < 10^9+7 :=\nsorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval count_paths 1 1 [\".\"]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval count_paths 2 3 [\"...\", \"..R\"]\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval count_paths 4 4 [\"...R\", \".RR.\", \".RR.\", \"R...\"]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1551", "language": "lean", "source": "fvapps", "source-id": "fvapps_001551", "source-notes": "", "vc-description": "/-\nWrite a function called `sumIntervals`/`sum_intervals()` that accepts an array of intervals, and returns the sum of all the interval lengths. Overlapping intervals should only be counted once.\n\n### Intervals\n\nIntervals are represented by a pair of integers in the form of an array. The first value of the interval will always be less than the second value. Interval example: `[1, 5]` is an interval from 1 to 5. The length of this interval is 4.\n\n### Overlapping Intervals\n\nList containing overlapping intervals:\n\n```\n[\n   [1,4],\n   [7, 10],\n   [3, 5]\n]\n```\n\nThe sum of the lengths of these intervals is 7. Since [1, 4] and [3, 5] overlap, we can treat the interval as [1, 5], which has a length of 4.\n\n### Examples:\n\n```C#\n// empty intervals\nIntervals.SumIntervals(new (int, int)[]{ });  // => 0\nIntervals.SumIntervals(new (int, int)[]{ (2, 2), (5, 5)});  // => 0\n\n// disjoined intervals\nIntervals.SumIntervals(new (int, int)[]{\n  (1, 2), (3, 5)\n});  // => (2-1) + (5-3) = 3\n\n// overlapping intervals\nIntervals.SumIntervals(new (int, int)[]{\n  (1, 4), (3, 6), (2, 8)\n});  // (1,8) => 7\n```\n-/", "vc-preamble": "def sumOfIntervals (intervals: List (Int × Int)) : Int :=\n  sorry\n\ndef normalizeInterval (interval: Int × Int) : Int × Int :=\n  let (a, b) := interval\n  (min a b, max a b)\n\ndef normalizeIntervals (intervals: List (Int × Int)) : List (Int × Int) :=\n  intervals.map normalizeInterval", "vc-helpers": "", "vc-definitions": "def sumLengths (intervals: List (Int × Int)) : Int :=\n  let lengths := intervals.map (fun i => i.2 - i.1)\n  lengths.foldl (· + ·) 0", "vc-theorems": "theorem sum_of_intervals_non_negative\n    (intervals: List (Int × Int)) (h: intervals.length ≥ 1):\n    sumOfIntervals (normalizeIntervals intervals) ≥ 0 := sorry\n\ntheorem sum_of_intervals_bounded_by_range\n    (intervals: List (Int × Int)) (h: intervals.length ≥ 1):\n    let normalized := normalizeIntervals intervals\n    let minStart := normalized.map Prod.fst |>.minimum?.get!\n    let maxEnd := normalized.map Prod.snd |>.maximum?.get!\n    sumOfIntervals normalized ≤ maxEnd - minStart := sorry\n\ntheorem sum_of_intervals_single_case\n    (intervals: List (Int × Int)) \n    (h: intervals.length = 1):\n    let normalized := normalizeIntervals intervals\n    let (a,b) := normalized.head!\n    sumOfIntervals normalized = b - a := sorry\n\ntheorem sum_of_intervals_reordering_invariant\n    (intervals: List (Int × Int))\n    (sorted: List (Int × Int))\n    (h: sorted.isPerm (normalizeIntervals intervals)):\n    sumOfIntervals (normalizeIntervals intervals) = \n    sumOfIntervals sorted := sorry\n\ntheorem sum_of_overlapping_intervals_bounded\n    (intervals: List (Int × Int))\n    (h: intervals.length ≥ 2):\n    let normalized := normalizeIntervals intervals\n    sumOfIntervals normalized ≤ sumLengths normalized := sorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval sum_of_intervals [[1, 5]]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval sum_of_intervals [[1, 2], [3, 5]]\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval sum_of_intervals [[1, 4], [3, 6], [2, 8]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1553", "language": "lean", "source": "fvapps", "source-id": "fvapps_001553", "source-notes": "", "vc-description": "/-\n# 'Magic' recursion call depth number\n\nThis Kata was designed as a Fork to the one from donaldsebleung Roboscript series with a reference to:\n\nhttps://www.codewars.com/collections/roboscript\n\nIt is not more than an extension of Roboscript infinite \"single-\" mutual recursion handling to a \"multiple-\" case.\n\nOne can suppose that you have a machine that works through a specific language. It uses the script, which consists of 3 major commands:\n\n - `F` - Move forward by 1 step in the direction that it is currently pointing.\n\n - `L` - Turn \"left\" (i.e. rotate 90 degrees anticlockwise).\n\n - `R` - Turn \"right\" (i.e. rotate 90 degrees clockwise).\n\nThe number n afterwards enforces the command to execute n times.\n\nTo improve its efficiency machine language is enriched by patterns that are containers to pack and unpack the script.\n\nThe basic syntax for defining a pattern is as follows:\n\n`pnq`\n\nWhere:\n\n - `p` is a \"keyword\" that declares the beginning of a pattern definition \n\n - `n` is a non-negative integer, which acts as a unique identifier for the pattern (pay attention, it may contain several digits).\n\n - `` is a valid RoboScript code (without the angled brackets)\n\n - `q` is a \"keyword\" that marks the end of a pattern definition \n\nFor example, if you want to define `F2LF2` as a pattern and reuse it later:\n\n```\np333F2LF2q\n```\n\nTo invoke a pattern, a capital `P` followed by the pattern identifier `(n)` is used:\n\n```\nP333\n```\n\nIt doesn't matter whether the invocation of the pattern or the pattern definition comes first. Pattern definitions should always be parsed first.\n\n```\nP333p333P11F2LF2qP333p11FR5Lq\n```\n\n# ___Infinite recursion___\n\nAs we don't want a robot to be damaged or damaging someone else by becoming uncontrolable when stuck in an infinite loop, it's good to considere this possibility in the programs and to build a compiler that can detect such potential troubles before they actually happen.\n\n* ### Single pattern recursion infinite loop\n\nThis is the simplest case, that occurs when the pattern is invoked inside its definition:\n\n    p333P333qP333 => depth = 1: P333 -> (P333)\n\n* ### Single mutual recursion infinite loop\n\nOccurs when a pattern calls to unpack the mutual one, which contains a callback to the first:\n\n    p1P2qp2P1qP2  => depth = 2: P2 -> P1 -> (P2)\n\n* ### Multiple mutual recursion infinite loop\n\nOccurs within the combo set of mutual callbacks without termination: \n\n    p1P2qp2P3qp3P1qP3 => depth = 3: P3 -> P1 -> P2 -> (P3)\n\n* ### No infinite recursion: terminating branch\n\nThis happens when the program can finish without encountering an infinite loop. Meaning the depth will be considered 0. Some examples below:\n\n    P4p4FLRq      => depth = 0\n    p1P2qp2R5qP1  => depth = 0\n    p1P2qp2P1q    => depth = 0 (no call)\n\n# Task\n\nYour interpreter should be able to analyse infinite recursion profiles in the input program, including multi-mutual cases.\n\nThough, rather than to analyse only the first encountered infinite loop and get stuck in it like the robot would be, your code will have continue deeper in the calls to find the depth of any infinite recursion or terminating call. Then it should return the minimal and the maximal depths encountered, as an array `[min, max]`.\n\n### About the exploration of the different possible branches of the program:\n\n* Consider only patterns that are to be executed:\n\n```\np1P1q                 => should return [0, 0], there is no execution\np1P2P3qp2P1qp3P1q     => similarly [0, 0]\np1P1qP1               => returns [1, 1]\n```\n\n* All patterns need to be executed, strictly left to right. Meaning that you may encounter several branches:\n\n```\np1P2P3qp2P1qp3P1qP3   => should return [2, 3]\n\nP3 -> P1 -> P2 -> (P1)    depth = 3 (max)\n        \\-> (P3)          depth = 2 (min)\n```\n\n# Input\n\n* A valid RoboScript program, as string.\n* Nested definitions of patterns, such as `p1...p2***q...q` will not be tested, even if that could be of interest as a Roboscript improvement.\n* All patterns will have a unique identifier.\n* Since the program is valid, you won't encounter calls to undefined pattern either.\n\n# Output\n\n* An array `[min, max]`, giving what are the minimal and the maximal recursion depths encountered.\n\n### Examples\n```\np1F2RF2LqP1         =>  should return [0, 0], no infinite recursion detected\n\np1F2RP1F2LqP1       =>  should return [1, 1], infinite recursion detection case\n\nP2p1P2qp2P1q        =>  should return [2, 2], single mutual infinite recursion case\n\np1P2qP3p2P3qp3P1q   =>  should return [3, 3], twice mutual infinite recursion case\n\np1P2P1qp2P3qp3P1qP1 =>  should return [1, 3], mixed infinite recursion case\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def magic_call_depth_number (p : Program) : List Nat := sorry\n\ntheorem magic_returns_valid_range (p : Program) :\n  let result := magic_call_depth_number p\n  result.length = 2 ∧ \n  result.head! ≤ result.get! 1 ∧\n  ∀ x ∈ result, x ≥ 0\n  := sorry", "vc-theorems": "theorem single_proc_depth_zero (c : Char) : \n  magic_call_depth_number (Program.proc c Program.end) = [0, 0] := sorry\n\ntheorem depth_bounded_by_unique_procs (p : Program) :\n  let result := magic_call_depth_number p\n  let proc_count := sorry -- Helper function to count unique procedures\n  result.get! 1 ≤ proc_count := sorry\n\ntheorem empty_program : \n  magic_call_depth_number Program.empty = [0, 0] := sorry\n\n/-\ninfo: [0, 0]\n-/\n-- #guard_msgs in\n-- #eval magic_call_depth_number \"p0F2LF2RqP0\"\n\n/-\ninfo: [2, 3]\n-/\n-- #guard_msgs in\n-- #eval magic_call_depth_number \"p1P2P3qp2P1qp3P1qP3\"\n\n/-\ninfo: [4, 4]\n-/\n-- #guard_msgs in\n-- #eval magic_call_depth_number \"p1P2qp2P3qp3P4qP4p4P1q\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1560", "language": "lean", "source": "fvapps", "source-id": "fvapps_001560", "source-notes": "", "vc-description": "/-\nCreate a function that differentiates a polynomial for a given value of `x`.\n\nYour function will receive 2 arguments: a polynomial as a string, and a point to evaluate the equation as an integer.\n\n## Assumptions:\n\n* There will be a coefficient near each `x`, unless the coefficient equals `1` or `-1`.\n* There will be an exponent near each `x`, unless the exponent equals `0` or `1`.\n* All exponents will be greater or equal to zero\n\n## Examples:\n\n```python\ndifferenatiate(\"12x+2\", 3)      ==>   returns 12\ndifferenatiate(\"x^2+3x+2\", 3)   ==>   returns 9\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def differentiate (p : Polynomial) (x : Int) : Int :=\n  sorry", "vc-theorems": "theorem differentiate_return_number \n  (p : Polynomial) (x : Int) : \n  ∃ n : Int, differentiate p x = n :=\n  sorry\n\ntheorem differentiate_constant\n  (n : Int) (x : Int) :\n  differentiate (Polynomial.const n) x = 0 :=\n  sorry\n\ntheorem differentiate_linear_constant_derivative \n  (p : Polynomial) (x₁ x₂ : Int)\n  (h : ∀ term : Polynomial, term ≠ Polynomial.var → false) :\n  differentiate p x₁ = differentiate p x₂ := \n  sorry\n\ntheorem differentiate_var\n  (x : Int) :\n  differentiate Polynomial.var x = 1 :=\n  sorry\n\ntheorem differentiate_square\n  (x : Int) :\n  differentiate (Polynomial.power 1 2) x = 2 * x :=\n  sorry\n\ntheorem differentiate_constant_zero\n  (n : Int) (x : Int) :\n  differentiate (Polynomial.const n) x = 0 :=\n  sorry\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval differentiate \"12x+2\" 3\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval differentiate \"x^2+3x+2\" 3\n\n/-\ninfo: -20\n-/\n-- #guard_msgs in\n-- #eval differentiate \"-5x^2+10x+4\" 3", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1565", "language": "lean", "source": "fvapps", "source-id": "fvapps_001565", "source-notes": "", "vc-description": "/-\n## Story\n\nBefore we dive into the exercise, I would like to show you why these numbers are so important in computer programming today.\n\nIt all goes back to the time of 19th century. Where computers we know today were non-existing. The first ever **computer program** was for the Analytical Engine to compute **Bernoulli numbers**. A woman named Ada Lovelace wrote the very first program. The sad part is the engine was never fully build so her code was never tested. She also predicted the start of **AI** (artificial intelligence).\n\nComputers will be able to compose music by themselves, solve problems (not only numbers) ... So in her honor reproduce what was done back in 1842. The Bernoulli numbers are a sequence of rational numbers with deep connections to number theory. The Swiss mathematician Jakob Bernoulli and the Japanese mathematician Seki Kowa discovered the numbers around the same time at the start of the 18th Century. If you want to read more about her or Bernoulli numbers follow these links:\n\nhttps://en.wikipedia.org/wiki/Ada_Lovelace\n\nhttps://en.wikipedia.org/wiki/Bernoulli_number\n\nhttp://mathworld.wolfram.com/BernoulliNumber.html\n\n## Exercise\n\nYour job is to write a function `bernoulli_number(n)` which outputs the n-th Bernoulli number. The input will always be a non-negative integer so you do not need to worry about exceptions. How you will solve the problem is none of my business but here are some guidelines.  \nYou can make pascal triangle and then with the basic formula generate all Bernoulli numbers. Look example below.\n\nFor the sake of floating numbers, just use `Fractions` so there will be no problems with rounding.\n\n0 = 1 + 2b1 ............................................................... \n  b1 = - 1/2\n\n0 = 1 + 3b1 + 3b2 ...................................................    b2        = 1/6\n\n0 = 1 + 4b1 + 6b2 + 4b3 .......................................  b3 = 0\n\n0 = 1 + 5b1 + 10b2 + 10b3 + 5b4 ...................... b4 = - 1/30\n\n... and so on.\n\n```\nbernoulli_number(0) # return 1\nbernoulli_number(1) # return Fraction(-1,2) or Rational(-1,2) or \"1/2\"\nbernoulli_number(6) # return Fraction(1,42) or ...\nbernoulli_number(42) # return Fraction(1520097643918070802691,1806) or ...\nbernoulli_number(22) # return Fraction(854513,138) or ... \"854513/138\"\n```\n\n## Note\n\nSee \"Sample Tests\" to see the return type for each language.\n\nGood luck and happy coding! \n\nPS: be careful some numbers might exceed `1000`.\nIf this kata is too hard for you try to solve pascal triangle and something similar to this and then come back :).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bernoulli_number (n : Nat) : Rat :=\n  sorry", "vc-theorems": "theorem odd_bernoulli_numbers_are_zero (n : Nat)\n  (h : n ≥ 3)\n  (h₂ : n % 2 = 1) :\n  bernoulli_number n = 0 :=\nsorry\n\ntheorem bernoulli_numbers_are_rational (n : Nat) :\n  ∃ r : Rat, bernoulli_number n = r ∨ bernoulli_number n = 0 :=\nsorry\n\ntheorem first_bernoulli_number :\n  bernoulli_number 0 = 1 :=\nsorry\n\ntheorem second_bernoulli_number :\n  bernoulli_number 1 = -1/2 :=\nsorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval bernoulli_number 0\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval bernoulli_number 3\n\n/-\ninfo: Fraction(1, 42)\n-/\n-- #guard_msgs in\n-- #eval bernoulli_number 6", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1571", "language": "lean", "source": "fvapps", "source-id": "fvapps_001571", "source-notes": "", "vc-description": "/-\n# Task\n Sorting is one of the most basic computational devices used in Computer Science. \n\n Given a sequence (length ≤ 1000) of 3 different key values (7, 8, 9), your task is to find the minimum number of exchange operations necessary to make the sequence sorted. \n\n One operation is the switching of 2 key values in the sequence.\n\n# Example\n\n For `sequence = [7, 7, 8, 8, 9, 9]`, the result should be `0`.\n\n It's already a sorted sequence.\n\n For `sequence = [9, 7, 8, 8, 9, 7]`, the result should be `1`.\n\n We can switching `sequence[0]` and `sequence[5]`.\n\n For `sequence = [8, 8, 7, 9, 9, 9, 8, 9, 7]`, the result should be `4`.\n\n We can:\n```\n [8, 8, 7, 9, 9, 9, 8, 9, 7] \n switching sequence[0] and sequence[3]\n --> [9, 8, 7, 8, 9, 9, 8, 9, 7]\n switching sequence[0] and sequence[8]\n --> [7, 8, 7, 8, 9, 9, 8, 9, 9]\n switching sequence[1] and sequence[2]\n --> [7, 7, 8, 8, 9, 9, 8, 9, 9]\n switching sequence[5] and sequence[7]\n --> [7, 7, 8, 8, 8, 9, 9, 9, 9] \n```\nSo `4` is the minimum number of operations for the sequence to become sorted.\n\n# Input/Output\n\n - `[input]` integer array `sequence`\n\n  The Sequence.\n\n - `[output]` an integer\n\n  the minimum number of operations.\n-/", "vc-preamble": "def exchange_sort (sequence : List Int) : Nat :=\n  sorry\n\ndef isSorted (l : List Int) : Bool :=\n  match l with\n  | [] => true\n  | [_] => true\n  | x :: y :: rest => x ≤ y && isSorted (y :: rest)", "vc-helpers": "", "vc-definitions": "def count (x : Int) (l : List Int) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => (if h = x then 1 else 0) + count x t", "vc-theorems": "theorem exchange_sort_nonnegative {sequence : List Int}\n  (h : ∀ x ∈ sequence, x ≥ 7 ∧ x ≤ 9) :\n  exchange_sort sequence ≥ 0 := sorry\n\ntheorem exchange_sort_zero_when_sorted {sequence : List Int}\n  (h₁ : ∀ x ∈ sequence, x ≥ 7 ∧ x ≤ 9)\n  (h₂ : isSorted sequence = true) :\n  exchange_sort sequence = 0 := sorry\n\ntheorem exchange_sort_bounded_by_length {sequence : List Int}\n  (h : ∀ x ∈ sequence, x ≥ 7 ∧ x ≤ 9) :\n  exchange_sort sequence ≤ sequence.length := sorry\n\ntheorem exchange_sort_preserves_frequency {sequence : List Int}\n  (h : ∀ x ∈ sequence, x ≥ 7 ∧ x ≤ 9) :\n  ∀ x, count x sequence = count x (List.mergeSort (· ≤ ·) sequence) := sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval exchange_sort [7, 7, 8, 8, 9, 9]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval exchange_sort [9, 7, 8, 8, 9, 7]\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval exchange_sort [8, 8, 7, 9, 9, 9, 8, 9, 7]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1591", "language": "lean", "source": "fvapps", "source-id": "fvapps_001591", "source-notes": "", "vc-description": "/-\nAutomatons, or Finite State Machines (FSM), are extremely useful to programmers when it comes to software design. You will be given a simplistic version of an FSM to code for a basic TCP session.\n\nThe outcome of this exercise will be to return the correct state of the TCP FSM based on the array of events given.\n\n---------------------------------\n\nThe input array of events will consist of one or more of the following strings:\n\n```\nAPP_PASSIVE_OPEN, APP_ACTIVE_OPEN, APP_SEND, APP_CLOSE, APP_TIMEOUT, RCV_SYN, RCV_ACK, RCV_SYN_ACK, RCV_FIN, RCV_FIN_ACK\n```\n\n---------------------------------\n\nThe states are as follows and should be returned in all capital letters as shown:\n\n```\nCLOSED, LISTEN, SYN_SENT, SYN_RCVD, ESTABLISHED, CLOSE_WAIT, LAST_ACK, FIN_WAIT_1, FIN_WAIT_2, CLOSING, TIME_WAIT\n```\n\n---------------------------------\n\nThe input will be an array of events. Your job is to traverse the FSM as determined by the events, and return the proper state as a string, all caps, as shown above.\n\nIf an event is not applicable to the current state, your code will return `\"ERROR\"`.\n\n### Action of each event upon each state:\n(the format is `INITIAL_STATE: EVENT -> NEW_STATE`)\n\n```\nCLOSED: APP_PASSIVE_OPEN -> LISTEN\nCLOSED: APP_ACTIVE_OPEN  -> SYN_SENT\nLISTEN: RCV_SYN          -> SYN_RCVD\nLISTEN: APP_SEND         -> SYN_SENT\nLISTEN: APP_CLOSE        -> CLOSED\nSYN_RCVD: APP_CLOSE      -> FIN_WAIT_1\nSYN_RCVD: RCV_ACK        -> ESTABLISHED\nSYN_SENT: RCV_SYN        -> SYN_RCVD\nSYN_SENT: RCV_SYN_ACK    -> ESTABLISHED\nSYN_SENT: APP_CLOSE      -> CLOSED\nESTABLISHED: APP_CLOSE   -> FIN_WAIT_1\nESTABLISHED: RCV_FIN     -> CLOSE_WAIT\nFIN_WAIT_1: RCV_FIN      -> CLOSING\nFIN_WAIT_1: RCV_FIN_ACK  -> TIME_WAIT\nFIN_WAIT_1: RCV_ACK      -> FIN_WAIT_2\nCLOSING: RCV_ACK         -> TIME_WAIT\nFIN_WAIT_2: RCV_FIN      -> TIME_WAIT\nTIME_WAIT: APP_TIMEOUT   -> CLOSED\nCLOSE_WAIT: APP_CLOSE    -> LAST_ACK\nLAST_ACK: RCV_ACK        -> CLOSED\n```\n\n![\"EFSM TCP\" ](http://theangelfallseries.com/img/EFSM_TCP.png)\n\n## Examples\n\n```\n[\"APP_PASSIVE_OPEN\", \"APP_SEND\", \"RCV_SYN_ACK\"] =>  \"ESTABLISHED\"\n\n[\"APP_ACTIVE_OPEN\"] =>  \"SYN_SENT\"\n\n[\"APP_ACTIVE_OPEN\", \"RCV_SYN_ACK\", \"APP_CLOSE\", \"RCV_FIN_ACK\", \"RCV_ACK\"] =>  \"ERROR\"\n```\n\nThis kata is similar to [Design a Simple Automaton (Finite State Machine)](https://www.codewars.com/kata/design-a-simple-automaton-finite-state-machine), and you may wish to try that kata before tackling this one.\n\nSee wikipedia page [Transmission Control Protocol]( http://en.wikipedia.org/wiki/Transmission_Control_Protocol)\nfor further details.\n\nSee http://www.medianet.kent.edu/techreports/TR2005-07-22-tcp-EFSM.pdf page 4, for the FSM diagram used for this kata.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def traverse_TCP_states : List TCPEvent → TCPState \n  | _ => sorry", "vc-theorems": "theorem traverse_TCP_states_valid (events : List TCPEvent) :\n  traverse_TCP_states events ≠ TCPState.ERROR → \n  ∃ s, traverse_TCP_states events = s :=\nsorry\n\ntheorem traverse_TCP_states_empty : \n  traverse_TCP_states [] = TCPState.CLOSED :=\nsorry\n\ntheorem traverse_TCP_states_deterministic (events : List TCPEvent) :\n  traverse_TCP_states events = traverse_TCP_states events :=\nsorry\n\ntheorem traverse_TCP_states_invalid_error (events : List TCPEvent) (invalid : TCPEvent) :\n  ¬(invalid ∈ events) →\n  traverse_TCP_states (invalid::events) = TCPState.ERROR :=\nsorry\n\n/-\ninfo: 'ESTABLISHED'\n-/\n-- #guard_msgs in\n-- #eval traverse_TCP_states [\"APP_PASSIVE_OPEN\", \"APP_SEND\", \"RCV_SYN_ACK\"]\n\n/-\ninfo: 'SYN_SENT'\n-/\n-- #guard_msgs in\n-- #eval traverse_TCP_states [\"APP_ACTIVE_OPEN\"]\n\n/-\ninfo: 'ERROR'\n-/\n-- #guard_msgs in\n-- #eval traverse_TCP_states [\"APP_ACTIVE_OPEN\", \"RCV_SYN_ACK\", \"APP_CLOSE\", \"RCV_FIN_ACK\", \"RCV_ACK\"]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1596", "language": "lean", "source": "fvapps", "source-id": "fvapps_001596", "source-notes": "", "vc-description": "/-\n```if:java\n___Note for Java users:___ Due to type checking in Java, inputs and outputs are formated quite differently in this language. See the footnotes of the description.\n\n```\n\nYou have the following lattice points with their corresponding coordinates and each one with an specific colour.\n\n ```\nPoint   [x ,  y]     Colour\n----------------------------\n  A     [ 3,  4]     Blue\n  B     [-7, -1]     Red\n  C     [ 7, -6]     Yellow\n  D     [ 2,  5]     Yellow\n  E     [ 1, -5]     Red\n  F     [-1,  4]     Red\n  G     [ 1,  7]     Red\n  H     [-3,  5]     Red\n  I     [-3, -5]     Blue\n  J     [ 4,  1]     Blue\n```\nWe want to count the triangles that have the three vertices with the same colour. The following picture shows the distribution of the points in the plane with the required triangles.\n\n![source: imgur.com](http://i.imgur.com/sP0l1i1.png)\n\nThe input that we will have for the field of lattice points described above is:\n\n```\n[[[3, -4], \"blue\"],  [[-7, -1], \"red\"], [[7, -6], \"yellow\"], [[2, 5], \"yellow\"],\n [[1, -5], \"red\"],   [[-1, 4], \"red\"],  [[1, 7], \"red\"],     [[-3, 5], \"red\"], \n [[-3, -5], \"blue\"], [[4, 1], \"blue\"] ]\n```\nWe see the following result from it:\n\n```\nColour   Amount of Triangles       Triangles\nYellow         0                    -------\nBlue           1                      AIJ\nRed            10                   BEF,BEG,BEH,BFG,BFH,BGH,EFG,EFH,EHG,FGH\n```\nAs we have 5 different points in red and each combination of 3 points that are not aligned.\n\nWe need a code that may give us the following information in order:\n\n```\n1) Total given points\n2) Total number of colours\n3) Total number of possible triangles\n4) and 5) The colour (or colours, sorted alphabetically) with the highest amount of triangles\n```\n\nIn Python our function will work like:\n\n```\n[10, 3, 11, [\"red\",10]]) == count_col_triang([[[3, -4], \"blue\"],  [[-7, -1], \"red\"], [[7, -6], \"yellow\"], [[2, 5], \"yellow\"], \n                                              [[1, -5], \"red\"],   [[-1, 4], \"red\"],  [[1, 7], \"red\"],     [[-3, 5], \"red\"],\n                                              [[-3, -5], \"blue\"], [[4, 1], \"blue\"] ])\n```\nIn the following case we have some points that are aligned and we have less triangles that can be formed:\n\n```\n[10, 3, 7, [\"red\", 6]] == count_col_triang([[[3, -4], \"blue\"],  [[-7, -1], \"red\"], [[7, -6], \"yellow\"], [[2, 5], \"yellow\"],\n                                            [[1, -5], \"red\"],   [[1, 1], \"red\"],   [[1, 7], \"red\"],     [[1, 4], \"red\"], \n                                            [[-3, -5], \"blue\"], [[4, 1], \"blue\"] ])\n```\nJust to see the change with the previous case we have this:\n\n![source: imgur.com](http://i.imgur.com/cCgO7ql.png)\n\nIn the special case that the list of points does not generate an even single triangle, the output will be like this case:\n\n```\n[9, 3, 0, []] == count_col_triang([[[1, -2], \"red\"], [[7, -6], \"yellow\"], [[2, 5], \"yellow\"], [[1, -5], \"red\"],\n                                  [[1, 1], \"red\"],   [[1, 7], \"red\"],     [[1, 4], \"red\"],    [[-3, -5], \"blue\"], \n                                  [[4, 1], \"blue\"] ])\n```\nIt will be this case:\n\n![source: imgur.com](http://i.imgur.com/VB7t7Ij.png)\n\nIf in the result we have two or more colours with the same maximum amount of triangles, the last list should be like (e.g)\n\n```\n[35, 6, 35, [\"blue\", \"red\", \"yellow\", 23]]     # having the names of the colours sorted alphabetically\n```\nFor the condition of three algined points A, B, C, you should know that the the following determinant should be 0.\n\n```\n | xA    yA    1|\n | xB    yB    1|    = 0\n | xC    yC    1|\n\n```\nAssumptions:\n\n- In the list you have unique points, so a point can have only one colour.\n\n- All the inputs are valid\n\nEnjoy it!\n\n````if:java\n---\n\n___For java users:___\n\nTwo immutable objects, `ColouredPoint` and `TriangleResult`, have been designed for you in the preloaded part. You will receive inputs as lists of ColouredPoint objects and will return a TriangleResult object. For the last one, you may note the organization of the arguments of the constructor which differs a bit from the description above.\n\nYou may find below the signatures of the available methods of these objects:\n\n````\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_col_triang (points : List Point) : TriangleCount :=\nsorry", "vc-theorems": "theorem count_col_triang_basic_properties {points : List Point} :\n  let result := count_col_triang points;\n  result.totalPoints = points.length ∧ \n  result.uniqueColors ≤ result.totalPoints ∧\n  result.triangleCount ≥ 0 := by sorry\n\ntheorem count_col_triang_max_info {points : List Point} :\n  let result := count_col_triang points;\n  (result.maxColorInfo = none → result.triangleCount = 0) ∧\n  (result.maxColorInfo.isSome → \n    match result.maxColorInfo with\n    | some (colors, count) => count > 0 ∧ colors.eraseDups = colors\n    | none => True) := by sorry \n\ntheorem count_col_triang_vertical_collinear {points : List Point} \n    (h : ∀ p ∈ points, p.coord.1 = 1) :\n  let result := count_col_triang points;\n  result.triangleCount = 0 ∧ result.maxColorInfo = none := by sorry\n\ntheorem count_col_triang_horizontal_collinear {points : List Point}\n    (h : ∀ p ∈ points, p.coord.2 = 1) :\n  let result := count_col_triang points;\n  result.triangleCount = 0 ∧ result.maxColorInfo = none := by sorry\n\n/-\ninfo: [10, 3, 11, ['red', 10]]\n-/\n-- #guard_msgs in\n-- #eval count_col_triang [[[3, -4], \"blue\"], [[-7, -1], \"red\"], [[7, -6], \"yellow\"], [[2, 5], \"yellow\"], [[1, -5], \"red\"], [[-1, 4], \"red\"], [[1, 7], \"red\"], [[-3, 5], \"red\"], [[-3, -5], \"blue\"], [[4, 1], \"blue\"]]\n\n/-\ninfo: [10, 3, 7, ['red', 6]]\n-/\n-- #guard_msgs in\n-- #eval count_col_triang [[[3, -4], \"blue\"], [[-7, -1], \"red\"], [[7, -6], \"yellow\"], [[2, 5], \"yellow\"], [[1, -5], \"red\"], [[1, 1], \"red\"], [[1, 7], \"red\"], [[1, 4], \"red\"], [[-3, -5], \"blue\"], [[4, 1], \"blue\"]]\n\n/-\ninfo: [9, 3, 0, []]\n-/\n-- #guard_msgs in\n-- #eval count_col_triang [[[1, -2], \"red\"], [[7, -6], \"yellow\"], [[2, 5], \"yellow\"], [[1, -5], \"red\"], [[1, 1], \"red\"], [[1, 7], \"red\"], [[1, 4], \"red\"], [[-3, -5], \"blue\"], [[4, 1], \"blue\"]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1601", "language": "lean", "source": "fvapps", "source-id": "fvapps_001601", "source-notes": "", "vc-description": "/-\nYou are given a binary tree:\n\n```python\nclass Node:\n    def __init__(self, L, R, n):\n        self.left = L\n        self.right = R\n        self.value = n\n```\n\nYour task is to return the list with elements from tree sorted by levels, which means the root element goes first, then root children (from left to right) are second and third, and so on.\n```if:ruby\nReturn empty array if root is `nil`.\n```\n```if:haskell\nReturn empty list if root is `Nothing`.\n```\n```if:python\nReturn empty list if root is `None`.\n```\n```if:csharp\nReturn empty list if root is 'null'.\n```\n```if:java\nReturn empty list is root is 'null'.\n```\n\nExample 1 - following tree:\n\n                     2\n                8        9\n              1  3     4   5\n\nShould return following list:\n\n    [2,8,9,1,3,4,5]\n\nExample 2 - following tree:\n\n                     1\n                8        4\n                  3        5\n                             7\nShould return following list:\n\n    [1,8,4,3,5,7]\n-/", "vc-preamble": "def treeByLevels {α : Type} (t : BTree α) : List α :=\n  sorry", "vc-helpers": "", "vc-definitions": "def buildTree {α : Type} (values : List α) : BTree α :=\n  sorry", "vc-theorems": "theorem empty_tree_gives_empty_list {α : Type} :\n  treeByLevels (BTree.leaf : BTree α) = [] :=\nsorry\n\ntheorem tree_length {α : Type} (values : List α) (h : values ≠ []) :\n  let tree := buildTree values\n  List.length (treeByLevels tree) = List.length values :=\nsorry\n\ntheorem root_is_first {α : Type} [Inhabited α] (values : List α) (h : values ≠ []) (v : α) (vs : List α) \n  (h2 : values = v :: vs) :\n  let tree := buildTree values\n  List.head? (treeByLevels tree) = some v :=\nsorry\n\ntheorem values_preserved_length {α : Type} (values : List α) (h : values ≠ []) :\n  let tree := buildTree values\n  List.length (treeByLevels tree) = List.length values :=\nsorry\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval tree_by_levels None\n\n/-\ninfo: [2, 8, 9, 1, 3, 4, 5]\n-/\n-- #guard_msgs in\n-- #eval tree_by_levels Node(Node(Node(None, None, 1), Node(None, None, 3), 8), Node(Node(None, None, 4), Node(None, None, 5), 9), 2)\n\n/-\ninfo: [1, 8, 4, 3, 5, 7]\n-/\n-- #guard_msgs in\n-- #eval tree_by_levels Node(Node(None, Node(None, None, 3), 8), Node(None, Node(None, Node(None, None, 7), 5), 4), 1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1604", "language": "lean", "source": "fvapps", "source-id": "fvapps_001604", "source-notes": "", "vc-description": "/-\nComplete the function/method (depending on the language) to return `true`/`True` when its argument is an array that has the same nesting structures and same corresponding length of nested arrays as the first array.\n\nFor example:\n\n```python\n# should return True\nsame_structure_as([ 1, 1, 1 ], [ 2, 2, 2 ] )\nsame_structure_as([ 1, [ 1, 1 ] ], [ 2, [ 2, 2 ] ] )\n\n# should return False \nsame_structure_as([ 1, [ 1, 1 ] ], [ [ 2, 2 ], 2 ] )\nsame_structure_as([ 1, [ 1, 1 ] ], [ [ 2 ], 2 ] )\n\n# should return True\nsame_structure_as([ [ [ ], [ ] ] ], [ [ [ ], [ ] ] ] )\n\n# should return False\nsame_structure_as([ [ [ ], [ ] ] ], [ [ 1, 1 ] ] )\n```\n\n~~~if:javascript\nFor your convenience, there is already a function 'isArray(o)' declared and defined that returns true if its argument is an array, false otherwise.\n~~~\n\n~~~if:php\nYou may assume that all arrays passed in will be non-associative.\n~~~\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def same_structure_as {α β : Type} (x : NestedList α) (y : NestedList β) : Bool :=\n  sorry", "vc-theorems": "theorem same_structure_reflexive {α : Type} (x : NestedList α) :\n  same_structure_as x x = true :=\n  sorry\n\ntheorem same_structure_value_independent {α β : Type} (x : NestedList α) (y : NestedList β) :\n  same_structure_as x y = true ∨ same_structure_as x y = false :=\n  sorry\n\ntheorem same_structure_symmetric {α β : Type} (x : NestedList α) (y : NestedList β) :\n  same_structure_as x y = same_structure_as y x :=\n  sorry\n\ntheorem flat_vs_nested_mismatch {α β : Type} (l : List (NestedList α)) (b : β) :\n  l ≠ [] →\n  same_structure_as (NestedList.node l) (NestedList.leaf b) = false :=\n  sorry\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval same_structure_as [1, [1, 1]] [[2, 2], 2]\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval same_structure_as [1, [1, 1]] [2, [2, 2]]\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval same_structure_as [[[], []]] [[[], []]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1605", "language": "lean", "source": "fvapps", "source-id": "fvapps_001605", "source-notes": "", "vc-description": "/-\n## Description\n\nGiven an array X of positive integers, its elements are to be transformed by running the following operation on them as many times as required:\n\n```if X[i] > X[j] then X[i] = X[i] - X[j]```\n\nWhen no more transformations are possible, return its sum (\"smallest possible sum\").\n\nFor instance, the successive transformation of the elements of input X = [6, 9, 21] is detailed below:\n```\nX_1 = [6, 9, 12] # -> X_1[2] = X[2] - X[1] = 21 - 9\nX_2 = [6, 9, 6]  # -> X_2[2] = X_1[2] - X_1[0] = 12 - 6\nX_3 = [6, 3, 6]  # -> X_3[1] = X_2[1] - X_2[0] = 9 - 6\nX_4 = [6, 3, 3]  # -> X_4[2] = X_3[2] - X_3[1] = 6 - 3\nX_5 = [3, 3, 3]  # -> X_5[1] = X_4[0] - X_4[1] = 6 - 3\n```\nThe returning output is the sum of the final transformation (here 9).\n\n## Example\n\n## Solution steps:\n\n## Additional notes:\n\nThere are performance tests consisted of very big numbers and arrays of size at least 30000. Please write an efficient algorithm to prevent timeout.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | h::t => h + sum t", "vc-helpers": "", "vc-definitions": "def solution (nums: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solution_divisible_by_length (nums: List Nat) (h: nums.length > 0) :\n  solution nums % nums.length = 0 :=\nsorry\n\ntheorem solution_gcd_divides_all (nums: List Nat) (h: nums.length > 0) :\n  ∀ n ∈ nums, n % (solution nums / nums.length) = 0 :=\nsorry\n\ntheorem solution_identical_elements (n: Nat) (len: Nat) (h: len > 0) :\n  solution (List.replicate len n) = n * len :=\nsorry\n\ntheorem solution_single_element (n: Nat) :\n  solution [n] = n :=\nsorry\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval solution [6, 9, 21]\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval solution [30, 12]\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval solution [4, 16, 24]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1613", "language": "lean", "source": "fvapps", "source-id": "fvapps_001613", "source-notes": "", "vc-description": "/-\nAlex and Lee continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones. \nAlex and Lee take turns, with Alex starting first.  Initially, M = 1.\nOn each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X).\nThe game continues until all the stones have been taken.\nAssuming Alex and Lee play optimally, return the maximum number of stones Alex can get.\n\nExample 1:\nInput: piles = [2,7,9,4,4]\nOutput: 10\nExplanation:  If Alex takes one pile at the beginning, Lee takes two piles, then Alex takes 2 piles again. Alex can get 2 + 4 + 4 = 10 piles in total. If Alex takes two piles at the beginning, then Lee can take all three piles left. In this case, Alex get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n\nConstraints:\n\n1 <= piles.length <= 100\n1 <= piles[i] <= 10 ^ 4\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + sum xs", "vc-helpers": "", "vc-definitions": "def stone_game_ii (piles : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem stone_game_ii_positive (piles : List Nat) \n  (h : piles.all (λ x => x > 0)) :\n  stone_game_ii piles > 0 :=\nsorry\n\ntheorem stone_game_ii_bounded (piles : List Nat) :\n  stone_game_ii piles ≤ List.sum piles :=\nsorry  \n\ntheorem stone_game_ii_singleton (pile : Nat) \n  (h : pile > 0) : \n  stone_game_ii [pile] = pile :=\nsorry\n\ntheorem stone_game_ii_same_values (x : Nat)\n  (h : x > 0) :\n  stone_game_ii [x, x, x] ≤ 3 * x :=\nsorry\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval stone_game_ii [2, 7, 9, 4, 4]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval stone_game_ii [1]\n\n/-\ninfo: 15\n-/\n-- #guard_msgs in\n-- #eval stone_game_ii [8, 7, 1, 2]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1614", "language": "lean", "source": "fvapps", "source-id": "fvapps_001614", "source-notes": "", "vc-description": "/-\nYou are given a set of points in the 2D plane. You start at the point with the least X and greatest Y value, and end at the point with the greatest X and least Y value. The rule for movement is that you can not move to a point with a lesser X value as compared to the X value of the point you are on. Also for points having the same X value, you need to visit the point with the greatest Y value before visiting the next point with the same X value. So, if there are 2 points: (0,4 and 4,0) we would start with (0,4) - i.e. least X takes precedence over greatest Y. You need to visit every point in the plane.\n\n-----Input-----\nYou will be given an integer t(1<=t<=20) representing the number of test cases. A new line follows; after which the t test cases are given. Each test case starts with a blank line followed by an integer n(2<=n<=100000), which represents the number of points to follow. This is followed by a new line. Then follow the n points, each being a pair of integers separated by a single space; followed by a new line. The X and Y coordinates of each point will be between 0 and 10000 both inclusive.\n\n-----Output-----\nFor each test case, print the total distance traveled by you from start to finish; keeping in mind the rules mentioned above, correct to 2 decimal places. The result for each test case must be on a new line.\n\n-----Example-----\nInput:\n3\n\n2\n0 0\n0 1\n\n3\n0 0\n1 1\n2 2\n\n4\n0 0\n1 10\n1 5\n2 2\n\nOutput:\n1.00\n2.83\n18.21\n\nFor the third test case above, the following is the path you must take:\n0,0 -> 1,10  \n1,10 -> 1,5\n1,5 -> 2,2\n= 18.21\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculatePathDistance (p : Path) : Nat := sorry\n\ntheorem pathDistance_nonnegative (p : Path) :\n  calculatePathDistance p ≥ 0 := sorry", "vc-theorems": "theorem pathDistance_exceeds_y_diff (p : Path) (x : Nat) (yVals : List Nat) :\n  yVals = (p.filter (fun pt => pt.1 == x)).map Prod.snd →\n  yVals ≠ [] →\n  calculatePathDistance p ≥ 0 := sorry\n\ntheorem pathDistance_exceeds_x_span (p : Path) :\n  p.length > 1 →\n  let xVals := p.map Prod.fst\n  calculatePathDistance p ≥ 0 := sorry\n\ntheorem pathDistance_monotonic_right (p : Path) (newX newY : Nat) :\n  p ≠ [] →\n  newX > 0 →\n  calculatePathDistance (p ++ [(newX, newY)]) ≥ calculatePathDistance p := sorry\n\ntheorem pathDistance_triangle_inequality (paths : List Path) :\n  paths ≠ [] →\n  let combinedPath := List.join paths\n  ∀ path ∈ paths, calculatePathDistance combinedPath ≥ calculatePathDistance path := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1620", "language": "lean", "source": "fvapps", "source-id": "fvapps_001620", "source-notes": "", "vc-description": "/-\nUttu got to know about an interesting two-player mobile game recently and invites his friend Gangwar to try it out with him. Gangwar, however, has been playing this game since it was out 5 years ago and is a Legendary Grandmaster at it. Uttu immediately thought of somehow cheating in this game to beat Gangwar.\nBut the most he could do was choose if he wanted to go \"First\" or if he wanted to go \"Second\" in this alternative turn based game. Help Uttu choose so that he will always win regardless of Gangwar's moves.Description of the game\nYou are playing on a continent name Tamriel. This continent have $N$ towns numbered from $1$ to $N$ where town $1$ is the capital. These towns are connected to each other by $N-1$ roads. Any two towns are connected by some series of roads, i.e., You can go from any town to any other town using these roads.\nEach town $i$ some initial amout of soldiers $S_i$ in it. At every move, a player can choose a town other than the capital $i$ and move some non-zero amount of its current soldiers to a town which is one step closer towards the capital. After the first move, the moves are alternated between the players. The player who cannot make a move loses.Input\n- The first line contains a single integer $N$\n- The second line contains a $N$ space seperated integers denoting $S_1,S_2,\\dots,S_n$\n- The $N-1$ subsequent lines contain two space seperated integers $u$ and $v$, denoting that the town $u$ and town $v$ are connected by a road.Output\n- Print \"First\" or \"Second\" based on what Uttu should choose to win.Constraints\n- $ 2 \\leq N \\leq {2}\\times{10}^{5}$\n- $ 1 \\leq S_i \\leq {10}^{9}$ for each valid $i$\n- $ 1 \\leq u,v \\leq N$Sample Input 1\n2\n10 10\n1 2\nSample Output 1\nFirst\nExplanation 1\nUttu will move the $10$ soldiers at town $2$ to the capital (town $1$). After this Gangwar cannot make a move, so he loses.Sample Input 2\n3\n1 1 1\n1 2\n1 3\nSample Output 2\nSecond\nExplanation 2\nGangwar has options: either move the soldier at town $2$, or move the soldier at town $3$.\nWhatever he choses, Uttu will chose the other town's soldier to move. And then Gangwar loses.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_game (input : GameInput) : String := sorry\n\ntheorem game_result_valid (input : GameInput) : \n  solve_game input = \"First\" ∨ solve_game input = \"Second\" := sorry", "vc-theorems": "theorem symmetric_soldiers_same_result (input : GameInput) \n    (h_all_same : ∀ x : Nat, x < input.soldiers.length → input.soldiers[x]! = input.soldiers[0]!)\n    (soldiers' : List Nat) \n    (h_len : soldiers'.length = input.n)\n    (h_all_same' : ∀ i, i < soldiers'.length → soldiers'[i]! = input.soldiers[0]!) :\n    solve_game ⟨input.n, soldiers', input.connections, input.h_n, h_len, input.h_valid_conn⟩ = \n    solve_game input := sorry\n\ntheorem zero_soldiers_second (n : Nat) (h : n ≥ 2) :\n  let soldiers := List.replicate n 0\n  let connections := List.map (fun i => (1, i + 2)) (List.range (n-1))\n  solve_game ⟨n, soldiers, connections, h, List.length_replicate n 0, sorry⟩ = \"Second\" := sorry\n\n/-\ninfo: 'First'\n-/\n-- #guard_msgs in\n-- #eval solve_game 2 [10, 10] [[1, 2]]\n\n/-\ninfo: 'Second'\n-/\n-- #guard_msgs in\n-- #eval solve_game 3 [1, 1, 1] [[1, 2], [1, 3]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1630", "language": "lean", "source": "fvapps", "source-id": "fvapps_001630", "source-notes": "", "vc-description": "/-\nHeidi is a statistician to the core, and she likes to study the evolution of marmot populations in each of V (1 ≤ V ≤ 100) villages! So it comes that every spring, when Heidi sees the first snowdrops sprout in the meadows around her barn, she impatiently dons her snowshoes and sets out to the Alps, to welcome her friends the marmots to a new season of thrilling adventures.\n\nArriving in a village, Heidi asks each and every marmot she comes across for the number of inhabitants of that village. This year, the marmots decide to play an April Fools' joke on Heidi. Instead of consistently providing the exact number of inhabitants P (10 ≤ P ≤ 1000) of the village, they respond with a random non-negative integer k, drawn from one of two types of probability distributions:\n\n  Poisson (d'avril) distribution: the probability of getting an answer k is $\\frac{p^{k} e^{-P}}{k !}$ for k = 0, 1, 2, 3, ...,  Uniform distribution: the probability of getting an answer k is $\\frac{1}{2 P + 1}$ for k = 0, 1, 2, ..., 2P. \n\nHeidi collects exactly 250 answers per village. Every village follows either the Poisson or the uniform distribution. Heidi cannot tell marmots apart, so she may query some marmots several times, and each time the marmot will answer with a new number drawn from the village's distribution.\n\nCan you help Heidi to find out whether a village follows a Poisson or a uniform distribution?\n\n-----Input-----\n\nThe first line of input will contain the number of villages V (1 ≤ V ≤ 100). The following V lines each describe one village. The description of each village consists of 250 space-separated integers k, drawn from one of the above distributions.\n\n-----Output-----\n\nOutput one line per village, in the same order as provided in the input. The village's line shall state poisson if the village's distribution is of the Poisson type, and uniform if the answer came from a uniform distribution.\n\n-----Example-----\nInput\n2\n92 100 99 109 93 105 103 106 101 99 ... (input is truncated)\n28 180 147 53 84 80 180 85 8 16 ... (input is truncated)\nOutput\npoisson\nuniform\n\n-----Note-----\n\nThe full example input is visually represented below, along with the probability distribution function it was drawn from (the y-axis is labeled by its values multiplied by 250).\n\n[Image]\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def classify_distributions (villages : List (List Nat)) : List ClassificationType :=\n  sorry", "vc-theorems": "theorem classify_distributions_output_length {villages : List (List Nat)} :\n  (villages.all (fun v => v.length > 0)) →\n  (villages.all (fun v => v.all (fun x => x > 0))) →\n  (classify_distributions villages).length = villages.length :=\nsorry\n\ntheorem classify_distributions_valid_values {villages : List (List Nat)} :\n  (villages.all (fun v => v.length > 0)) →\n  (villages.all (fun v => v.all (fun x => x > 0))) →\n  (classify_distributions villages).all (fun r => r == ClassificationType.uniform || r == ClassificationType.poisson) :=\nsorry\n\ntheorem classify_distributions_input_constraints {villages : List (List Nat)} :\n  villages.all (fun v => v.length > 0) →\n  villages.all (fun v => v.all (fun x => x > 0)) →\n  villages.all (fun v => v.length ≥ 5 ∧ v.length ≤ 50) →\n  classify_distributions villages ≠ [] :=\nsorry\n\n/-\ninfo: ['poisson']\n-/\n-- #guard_msgs in\n-- #eval classify_distributions [[92, 100, 99, 109, 93, 105, 103, 106, 101, 99] * 25]\n\n/-\ninfo: ['uniform']\n-/\n-- #guard_msgs in\n-- #eval classify_distributions [[28, 180, 147, 53, 84, 80, 180, 85, 8, 16] * 25]\n\n/-\ninfo: ['poisson', 'uniform']\n-/\n-- #guard_msgs in\n-- #eval classify_distributions [[92, 100, 99, 109, 93, 105, 103, 106, 101, 99] * 25, [28, 180, 147, 53, 84, 80, 180, 85, 8, 16] * 25]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1637", "language": "lean", "source": "fvapps", "source-id": "fvapps_001637", "source-notes": "", "vc-description": "/-\nThe Dynamic Connectivity Problem\n\nGiven a set of of N objects, is there a path connecting the two objects?\n\nImplement an class that implements the following API:\n\n  *  Takes n as input, initializing a data-structure with N objects (0...N-1)\n  *  Implements a Union command that adds a connection between point p and point q\n  *  Implements a Connected command that returns a boolean and asks is there a connection between point p and point q\n\nAs a simple example: \nImagine you initialize an data structure filled with integers from 0 to 9 (N = 10)\n```python\n  results1 = DynamicConnectivity(10)\n```\nYou will receive a series of union commands linking various points\n```python\n  results1.union(4,3)\n  results1.union(3,8)\n  results1.union(6,5)\n  results1.union(9,4)\n  results1.union(2,1)\n```\nThis should result in 5 groups of connections:\n\n  * 3,4,8,9\n  * 5,6\n  * 2,1\n  * 0\n  * 7\n\nAll members of a groups (set) are conected to every other member\nIf you asked is 0 connected to 7, it should return False\nIf you asked is 8 connected to 9 you should return True even if 8,9 wern't directly joined.\n(8 is connected to 3 which is connected to 4 which is connected to 9)\n```python\n  results1.connected(0,7) == False\n  results1.connected(8,9) == True\n```\n\nFor the purposes of this problem, you do not have to mainatin the order of the connections, you just have to know that the connection is there.\n\nHint:\n  There is a naive implenetation that takes time proportional to O(n^2) (Quadratic Funtion)\n  **This will time out the problem**\n  (Because every time you double the input like from 50 nodes to 100 nodes, the function takes **4** times as long)\n  Test will check that you are able to outrun this naive implementation. If you can't that means that your code is too slow\n\n  There is a solution that takes linearitmic time or faster O(n * lg n)\n\nHint Two: (Take it or leave it)\n  If you find yourself nesting a loop inside a loop, you are creating a quadratic function\n\nImplementation must be able to handle initializing 1 million nodes, and creating connections between those nodes.\n\nFull Tests before submission generate random connections to make sure you can't hard code the connections into your class.\n-/", "vc-preamble": "def DynamicConnectivity.connected (dc : DynamicConnectivity) (p q : Nat) : Bool := sorry\ndef DynamicConnectivity.root (dc : DynamicConnectivity) (p : Nat) : Nat := sorry", "vc-helpers": "", "vc-definitions": "def DynamicConnectivity.union (dc : DynamicConnectivity) (p q : Nat) : DynamicConnectivity := sorry\n\ntheorem init_creates_valid_parent_array {n : Nat} (h : 0 < n) (dc : DynamicConnectivity) :\n  ∀ i, i < n → dc.par[i]! = i := sorry", "vc-theorems": "theorem unions_create_valid_connections {n : Nat} (h : 1 < n) (dc : DynamicConnectivity) \n  (p q : Nat) (hp : p < n) (hq : q < n) : \n  let dc' := dc.union p q\n  dc'.connected p q := sorry\n\ntheorem connectivity_is_transitive {n : Nat} (h : 1 < n) (dc : DynamicConnectivity)\n  (i j k : Nat) (hi : i < n) (hj : j < n) (hk : k < n) :\n  dc.connected i j → dc.connected j k → dc.connected i k := sorry\n\ntheorem root_returns_valid_parent {n : Nat} (h : 1 < n) (dc : DynamicConnectivity)\n  (i : Nat) (hi : i < n) :\n  let r := dc.root i\n  0 ≤ r ∧ r < n ∧ dc.root r = r := sorry\n\ntheorem connectivity_is_reflexive {n : Nat} (h : 1 < n) (dc : DynamicConnectivity)\n  (i : Nat) (hi : i < n) :\n  dc.connected i i := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1638", "language": "lean", "source": "fvapps", "source-id": "fvapps_001638", "source-notes": "", "vc-description": "/-\nThe Stack Arithmetic Machine\n---------------------------\n\nThis time we're going to be writing a stack arithmetic machine, and we're going to call it Sam. Essentially, Sam is a very small virtual machine, with a simple intruction set, four general registers, and a stack. We've already given a CPU class, which gives you read and write access to registers and the stack, through `readReg()` and `writeReg()`, and `popStack()` and `writeStack()` respectively. All instructions on Sam are 32-bit (Java int), and either interact with the stack, or one of the 4 registers; `a`, `b`, `c`, or `d`.\n\nThe CPU API\n-----------\n\nThe CPU instructions available through the CPU class, with a bit more detail:\n\n```python\nread_reg(self, name): Returns the value of the named register.\nwrite_reg(self, name, value): Stores the value into the given register.\n\npop_stack(self): Pops the top element of the stack, returning the value.\nwrite_stack(self, value): Pushes an element onto the stack.\n```\n\nNote that the registers have a default value of `0` and  that the sStack is printable (if needed).\n\nThe Instruction Set\n-------------------\n\nInstructions for same are done in assembly style, and are passed one by one into the `Exec|exec|execute` function (depending on your language). Each instruction begins with the name of the operation, and is optionally followed by either one or two operands. The operands are marked in the table below by either `[reg]`, which accepts a register name, or `[reg|int]` which accepts either a register, or an immediate integer value.\n\n### Stack Operations\n\n```\npush [reg|int]: Pushes a register [reg] or an immediate value [int] to the stack.\n\npop: Pops a value of the stack, discarding the value.\n\npop [reg]: Pops a value of the stack, into the given register [reg].\n\npushr: Pushes the general registers onto the stack, in order. (a, b, c, d)\n\npushrr: Pushes the general registers onto the stack, in reverse order. (d, c, b, a)\n\npopr: Pops values off the stack, and loads them into the general registers, in order so that the two executions `pushr()`  and `popr()` would leave the registers unchanged.\n\npoprr: Pops values off the stack, and loads them into the general registers, in order so that the two executions `pushr()`  and `poprr()` would invert the values of the registers from left to right.\n```\n\n### Misc Operations\n\n```\nmov [reg|int], [reg2]: Stores the value from [reg|int] into the register [reg2].\n```\n\n### Arithmetic Operations\n\n```\nadd [reg|int]: Pops [reg|int] arguments off the stack, storing the sum in register a.\n\nsub [reg|int]: Pops [reg|int] arguments off the stack, storing the difference in register a.\n\nmul [reg|int]: Pops [reg|int] arguments off the stack, storing the product in register a.\n\ndiv [reg|int]: Pops [reg|int] arguments off the stack, storing the quotient in register a.\n\nand [reg|int]: Pops [reg|int] arguments off the stack, performing a bit-and operation, and storing the result in register a.\n\nor [reg|int] : Pops [reg|int] arguments off the stack, performing a bit-or operation, and storing the result in register a.\n\nxor [reg|int]: Pops [reg|int] arguments off the stack, performing a bit-xor operation, and storing the result in register a.\n```\n\nAll arithmetic operations have 4 variants; they may be suffixed with the character `'a'` (`adda`, `xora`), and they may take an additional register parameter, which is the destination register. Thus, using add as an example:\n```\nadd 5: Adds the top 5 values of the stack, storing the result in register a.\n\nadd 5, b: Adds the top 5 values of the stack, storing the result in register b instead.\n\nadda 5: Pushes the value of register A onto the stack, then adds the top 5 values of the stack, and stores the result in register a.\n\nadda 5, b: Pushes the value of register A onto the stack, adds the top 5 values of the stack, and stores the result in register b.\n```\n\nAll arithmetic instructions may also take a register as their first argument, to perform a variable number of operation, as follows:\n```\nmov 3, a: Stores the number 3 in register a.\nadd a: Adds the top a values of the stack (in this case 3), storing the result in register a.\n```\n-/", "vc-preamble": "def sum (l: List Int) : Int :=\n  match l with\n  | [] => 0\n  | h::t => h + sum t\n\ndef prod (l: List Int) : Int :=\n  match l with\n  | [] => 1\n  | h::t => h * prod t\n\ndef bitAnd (l: List Int) : Int :=\n  match l with\n  | [] => 0\n  | [x] => x\n  | h::t => h\n\nstructure CPU where\n  regs : String → Int\n  stack : List Int\n\nstructure Machine where\n  cpu : CPU", "vc-helpers": "", "vc-definitions": "def Machine.execute : Machine → String → Machine :=\n  sorry", "vc-theorems": "theorem arithmetic_operations_stack_add \n  (values : List Int) \n  (h : values.length ≥ 2 ∧ values.length ≤ 10) :\n  let m : Machine := ⟨⟨λ_ => 0, []⟩⟩\n  let m' := (values.foldl (λ acc v => Machine.execute acc s!\"push {v}\") m)\n  let m'' := Machine.execute m' s!\"add {values.length}\"\n  m''.cpu.regs \"a\" = values.sum := \n  sorry\n\ntheorem arithmetic_operations_stack_mul \n  (values : List Int)\n  (h : values.length ≥ 2 ∧ values.length ≤ 10) :\n  let m : Machine := ⟨⟨λ_ => 0, []⟩⟩\n  let m' := (values.foldl (λ acc v => Machine.execute acc s!\"push {v}\") m)\n  let m'' := Machine.execute m' s!\"mul {values.length}\"\n  m''.cpu.regs \"a\" = values.prod :=\n  sorry\n\ntheorem arithmetic_operations_stack_and\n  (values : List Int)\n  (h : values.length ≥ 2 ∧ values.length ≤ 10) :\n  let m : Machine := ⟨⟨λ_ => 0, []⟩⟩\n  let m' := (values.foldl (λ acc v => Machine.execute acc s!\"push {v}\") m)\n  let m'' := Machine.execute m' s!\"and {values.length}\"\n  m''.cpu.regs \"a\" = values.bitAnd :=\n  sorry\n\ntheorem register_operations_mov\n  (reg : String)\n  (value : Int)\n  (h : reg ∈ [\"a\", \"b\", \"c\", \"d\"]) :\n  let m : Machine := ⟨⟨λ_ => 0, []⟩⟩\n  let m' := Machine.execute m s!\"mov {value}, {reg}\"\n  m'.cpu.regs reg = value :=\n  sorry\n\ntheorem register_operations_push_pop\n  (reg : String)\n  (value : Int)\n  (h : reg ∈ [\"a\", \"b\", \"c\", \"d\"]) :\n  let m : Machine := ⟨⟨λ_ => 0, []⟩⟩\n  let m' := Machine.execute m s!\"mov {value}, {reg}\"\n  let m'' := Machine.execute m' s!\"push {m'.cpu.regs reg}\"\n  let m''' := Machine.execute m'' \"pop a\"\n  m'''.cpu.regs \"a\" = value :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1641", "language": "lean", "source": "fvapps", "source-id": "fvapps_001641", "source-notes": "", "vc-description": "/-\nA famous casino is suddenly faced with a sharp decline of their revenues. They decide to offer Texas hold'em also online. Can you help them by writing an algorithm that can rank poker hands? \n\n## Task\n\nCreate a poker hand that has a method to compare itself to another poker hand:\n\n```python\ncompare_with(self, other_hand)\n```\n\nA poker hand has a constructor that accepts a string containing 5 cards:\n```python\nPokerHand(\"KS 2H 5C JD TD\")\n```\n\nThe characteristics of the string of cards are:\n* Each card consists of two characters, where\n * The first character is the value of the card: `2, 3, 4, 5, 6, 7, 8, 9, T(en), J(ack), Q(ueen), K(ing), A(ce)`\n * The second character represents the suit: `S(pades), H(earts), D(iamonds), C(lubs)`\n* A space is used as card separator between cards\n\nThe result of your poker hand compare can be one of these 3 options:\n\n```python\n[ \"Win\", \"Tie\", \"Loss\" ]\n```\n\n## Notes\n* Apply the [Texas Hold'em](https://en.wikipedia.org/wiki/Texas_hold_%27em) rules for ranking the cards.\n* Low aces are **NOT** valid in this kata.\n* There is no ranking for the suits.\n\nIf you finished this kata, you might want to continue with [Sortable Poker Hands](https://www.codewars.com/kata/sortable-poker-hands)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def PokerHand.compare_with (h1 h2 : PokerHand) : String :=\n  sorry\n\n/- Comparing hands is symmetric: if h1 beats h2, then h2 loses to h1 -/", "vc-theorems": "theorem compare_symmetry (h1 h2 : PokerHand) : \n  (h1.compare_with h2 = \"Win\" → h2.compare_with h1 = \"Loss\") ∧\n  (h1.compare_with h2 = \"Loss\" → h2.compare_with h1 = \"Win\") ∧\n  (h1.compare_with h2 = \"Tie\" → h2.compare_with h1 = \"Tie\") :=\n  sorry\n\n/- A hand compared to itself always ties -/\n\ntheorem self_comparison_tie (h : PokerHand) :\n  h.compare_with h = \"Tie\" :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1642", "language": "lean", "source": "fvapps", "source-id": "fvapps_001642", "source-notes": "", "vc-description": "/-\nSpider-Man (\"Spidey\") needs to get across town for a date with Mary Jane and his web-shooter is low on web fluid. He travels by slinging his web rope to latch onto a building rooftop, allowing him to swing to the opposite end of the latch point.\nWrite a function that, when given a list of buildings, returns a list of optimal rooftop latch points for minimal web expenditure.\nInput\nYour function will receive an array whose elements are subarrays in the form [h,w] where h and w represent the height and width, respectively, of each building in sequence\nOutput\nAn array of latch points (integers) to get from 0 to the end of the last building in the input list\nTechnical Details\n\nAn optimal latch point is one that yields the greatest horizontal distance gain relative to length of web rope used. Specifically, the highest horizontal distance yield per length unit of web rope used. Give this value rounded down to the nearest integer as a distance from Spidey's origin point (0)\nAt the start of each swing, Spidey selects a latch point based on his current position.\nAt the end of each swing, Spidey ends up on the opposite side of the latch point equal to his distance from the latch point before swing.\nSpidey's initial altitude is 50, and will always be the same at the start and end of each swing. His initial horizontal position is 0.\nTo avoid collision with people/traffic below, Spidey must maintain a minimum altitude of 20 at all times.\nBuilding height (h) range limits: 125 <= h < 250\nBuilding width (w) range limits: 50 <= w <= 100\nInputs will always be valid.\n\nTest Example\n\n- Spidey's initial position is at `0`. His first latch point is marked at `76` (horizontal position) on `buildings[0]`.\n- At the end of the swing, Spidey's position is at the point marked `B` with a horizontal position of `152`. The green arc represents Spidey's path during swing.\n- The marker on the 3rd building and the arc going from point `B` to point `C` represent the latch point (`258`) and arc path for the next swing.\n\n```python\nbuildings = [[162,76], [205,96], [244,86], [212,68], [174,57], [180,89], [208,70], [214,82], [181,69], [203,67]]\n\nspidey_swings(buildings)# [76,258,457,643,748]\n-/", "vc-preamble": "def spidey_swings (buildings : BuildingParams) : List Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def sum_widths (buildings : BuildingParams) : Int :=\n  List.foldl (fun acc b => acc + b.width) 0 buildings\n\n@[simp] theorem spidey_swings_nonempty {buildings : BuildingParams} \n  (h : buildings ≠ []) : \n  (spidey_swings buildings).length > 0 :=\nsorry", "vc-theorems": "theorem spidey_swings_result_elements_increasing {buildings : BuildingParams}\n  (h : buildings ≠ []) :\n  ∀ i, i < (spidey_swings buildings).length - 1 → \n    (spidey_swings buildings)[i]! < (spidey_swings buildings)[i+1]! :=\nsorry\n\ntheorem spidey_swings_within_bounds {buildings : BuildingParams}\n  (h : buildings ≠ []) :\n  let total_width := sum_widths buildings\n  ∀ pos ∈ spidey_swings buildings, 0 ≤ pos ∧ pos ≤ total_width :=\nsorry\n\ntheorem spidey_swings_min_height {buildings : BuildingParams}\n  (h : buildings ≠ []) \n  (b : Building) (hb : b ∈ buildings) :\n  b.height ≥ 50 :=\nsorry\n\ntheorem spidey_swings_uniform_height_bound \n  {buildings : BuildingParams}\n  (h₁ : buildings ≠ [])\n  (h₂ : ∀ (b : Building), b ∈ buildings → b.height = 100)\n  (h₃ : ∀ (b : Building), b ∈ buildings → 10 ≤ b.width ∧ b.width ≤ 20)\n  (h₄ : buildings.length ≤ 5) :\n  (spidey_swings buildings).getLast! < sum_widths buildings :=\nsorry\n\n/-\ninfo: [76, 258, 457, 643, 748]\n-/\n-- #guard_msgs in\n-- #eval spidey_swings [[162, 76], [205, 96], [244, 86], [212, 68], [174, 57], [180, 89], [208, 70], [214, 82], [181, 69], [203, 67]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1645", "language": "lean", "source": "fvapps", "source-id": "fvapps_001645", "source-notes": "", "vc-description": "/-\nOne of the services provided by an operating system is memory management. The OS typically provides an API for allocating and releasing memory in a process's address space. A process should only read and write memory at addresses which have been allocated by the operating system. In this kata you will implement a simulation of a simple memory manager.\n\nThe language you will be using has no low level memory API, so for our simulation we will simply use an array as the process address space. The memory manager constructor will accept an array (further referred to as `memory`) where blocks of indices will be allocated later.\n\n___\n\n# Memory Manager Contract\n\n## allocate(size)\n\n`allocate` reserves a sequential block (sub-array) of `size` received as an argument in `memory`. It should return the index of the first element in the allocated block, or throw an exception if there is no block big enough to satisfy the requirements.\n\n## release(pointer)\n\n`release` accepts an integer representing the start of the block allocated ealier, and frees that block. If the released block is adjacent to a free block, they should be merged into a larger free block. Releasing an unallocated block should cause an exception.\n\n## write(pointer, value)\n\nTo support testing this simulation our memory manager needs to support read/write functionality. Only elements within allocated blocks may be written to. The `write` method accepts an index in `memory` and a `value`. The `value` should be stored in `memory` at that index if it lies within an allocated block, or throw an exception otherwise.\n\n## read(pointer)\n\nThis method is the counterpart to `write`. Only indices within allocated blocks may be read. The `read` method accepts an index. If the `index` is within an allocated block, the value stored in `memory` at that index should be returned, or an exception should be thrown otherwise.\n-/", "vc-preamble": "def MemoryManager.init {α : Type} (memory : List α) : MemoryManager α := sorry\ndef MemoryManager.allocate {α : Type} (mm : MemoryManager α) (size : Nat) : Option Nat := sorry\n\ndef MemoryManager.write {α : Type} (mm : MemoryManager α) (pointer : Nat) (value : α) : MemoryManager α := sorry\ndef MemoryManager.read {α : Type} (mm : MemoryManager α) (pointer : Nat) : Option α := sorry", "vc-helpers": "", "vc-definitions": "def MemoryManager.release {α : Type} (mm : MemoryManager α) (pointer : Nat) : MemoryManager α := sorry\ndef MemoryManager.allocate_multiple {α : Type} (mm : MemoryManager α) (sizes : List Nat) : List (Nat × Nat) := sorry\n\n/- Memory manager initialization preserves sizes and sets initial state -/", "vc-theorems": "theorem memory_manager_init {α : Type} {memory : List α} (h : memory.length > 0) :\n  let mm := MemoryManager.init memory\n  (mm.storage.length = memory.length) ∧\n  (mm.previous_allocated_index = 0) ∧ \n  (mm.allocated = []) ∧\n  (mm.data = memory) := sorry\n\n/- Allocation respects size bounds -/\n\ntheorem allocation_size_bounds {α : Type} {memory : List α} {size : Nat} \n  (h : memory.length > 0) :\n  let mm := MemoryManager.init memory \n  if size > memory.length then\n    (MemoryManager.allocate mm size).isNone\n  else match MemoryManager.allocate mm size with\n    | some pointer => \n      (0 ≤ pointer) ∧ \n      (pointer ≤ memory.length - size) ∧\n      ((pointer, pointer + size) ∈ mm.allocated)\n    | none => False := sorry\n\n/- Multiple allocations and releases maintain memory consistency -/\n\ntheorem multiple_allocations {α : Type} {memory : List α} {sizes : List Nat}\n  (h : memory.length > 0) :\n  let mm := MemoryManager.init memory\n  ∀ (alloc : Nat × Nat),\n    alloc ∈ MemoryManager.allocate_multiple mm sizes →\n    let (pointer, size) := alloc\n    (0 ≤ pointer ∧ pointer + size ≤ memory.length) ∧\n    (alloc ∈ mm.allocated) ∧\n    (alloc ∉ (MemoryManager.release mm pointer).allocated) := sorry\n\n/- Memory read/write operations maintain expected behavior -/\n\ntheorem memory_operations {α : Type} {memory : List α} {size : Nat} {value : α}\n  (h : memory.length > 0) (h₂ : size ≤ memory.length) :\n  let mm := MemoryManager.init memory\n  match MemoryManager.allocate mm size with\n  | some pointer => \n    (MemoryManager.read (MemoryManager.write mm pointer value) pointer = some value) ∧\n    (MemoryManager.read (MemoryManager.release mm pointer) pointer = none)\n  | none => False := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1647", "language": "lean", "source": "fvapps", "source-id": "fvapps_001647", "source-notes": "", "vc-description": "/-\n![alt text](https://2.bp.blogspot.com/-DNNiOXduuvQ/Vh-FR-qbKXI/AAAAAAAAEOA/HT0IzJ36zW4/s1600/voz.jpg)\n\nCreate a class called `Warrior` which calculates and keeps track of their level and skills, and ranks them as the warrior they've proven to be.\n\nBusiness Rules:\n\n- A warrior starts at level 1 and can progress all the way to 100.\n- A warrior starts at rank `\"Pushover\"` and can progress all the way to `\"Greatest\"`.\n- The only acceptable range of rank values is `\"Pushover\", \"Novice\", \"Fighter\", \"Warrior\", \"Veteran\", \"Sage\", \"Elite\", \"Conqueror\", \"Champion\", \"Master\", \"Greatest\"`.\n- Warriors will compete in battles. Battles will always accept an enemy level to match against your own.\n- With each battle successfully finished, your warrior's experience is updated based on the enemy's level.\n- The experience earned from the battle is relative to what the warrior's current level is compared to the level of the enemy.\n- A warrior's experience starts from 100. Each time the warrior's experience increases by another 100, the warrior's level rises to the next level.\n- A warrior's experience is cumulative, and does not reset with each rise of level. The only exception is when the warrior reaches level 100, with which the experience stops at 10000\n- At every 10 levels, your warrior will reach a new rank tier. (ex. levels 1-9 falls within `\"Pushover\"` tier, levels 80-89 fall within `\"Champion\"` tier, etc.)\n- A warrior cannot progress beyond level 100 and rank `\"Greatest\"`.\n\nBattle Progress Rules & Calculations:\n\n- If an enemy level does not fall in the range of 1 to 100, the battle cannot happen and should return `\"Invalid level\"`.\n- Completing a battle against an enemy with the same level as your warrior will be worth 10 experience points.\n- Completing a battle against an enemy who is one level lower than your warrior will be worth 5 experience points.\n- Completing a battle against an enemy who is two levels lower or more than your warrior will give 0 experience points.\n- Completing a battle against an enemy who is one level higher or more than your warrior will accelarate your experience gaining. The greater the difference between levels, the more experinece your warrior will gain. The formula is `20 * diff * diff` where `diff` equals the difference in levels between the enemy and your warrior.\n- However, if your warrior is at least one rank lower than your enemy, and at least 5 levels lower, your warrior cannot fight against an enemy that strong and must instead return `\"You've been defeated\"`.\n- Every successful battle will also return one of three responses: `\"Easy fight\", \"A good fight\", \"An intense fight\"`. Return `\"Easy fight\"` if your warrior is 2 or more levels higher than your enemy's level. Return `\"A good fight\"` if your warrior is either 1 level higher or equal to your enemy's level. Return `\"An intense fight\"` if your warrior's level is lower than the enemy's level.\n\nLogic Examples:\n\n- If a warrior level 1 fights an enemy level 1, they will receive 10 experience points.\n- If a warrior level 1 fights an enemy level 3, they will receive 80 experience points.\n- If a warrior level 5 fights an enemy level 4, they will receive 5 experience points.\n- If a warrior level 3 fights an enemy level 9, they will receive 720 experience points, resulting in the warrior rising up by at least 7 levels.\n- If a warrior level 8 fights an enemy level 13, they will receive 0 experience points and return `\"You've been defeated\"`. (Remember, difference in rank & enemy level being 5 levels higher or more must be established for this.)\n- If a warrior level 6 fights an enemy level 2, they will receive 0 experience points.\n\n Training Rules & Calculations:\n- In addition to earning experience point from battles, warriors can also gain experience points from training.\n- Training will accept an array of three elements (except in java where you'll get 3 separated arguments): the description, the experience points your warrior earns, and the minimum level requirement.\n- If the warrior's level meets the minimum level requirement, the warrior will receive the experience points from it and store the description of the training. It should end up returning that description as well.\n- If the warrior's level does not meet the minimum level requirement, the warrior doesn not receive the experience points and description and instead returns `\"Not strong enough\"`, without any archiving of the result.\n\n Code Examples:\n```python\nbruce_lee = Warrior()\nbruce_lee.level         # => 1\nbruce_lee.experience    # => 100\nbruce_lee.rank          # => \"Pushover\"\nbruce_lee.achievements  # => []\nbruce_lee.training([\"Defeated Chuck Norris\", 9000, 1]) # => \"Defeated Chuck Norris\"\nbruce_lee.experience    # => 9100\nbruce_lee.level         # => 91\nbruce_lee.rank          # => \"Master\"\nbruce_lee.battle(90)    # => \"A good fight\"\nbruce_lee.experience    # => 9105\nbruce_lee.achievements  # => [\"Defeated Chuck Norris\"]\n```\n-/", "vc-preamble": "def Warrior.level (self : Warrior) : Nat := sorry\ndef Warrior.rank (self : Warrior) : String := sorry", "vc-helpers": "", "vc-definitions": "def Warrior.training (self : Warrior) (t : String × Nat × Nat) : String := sorry\ndef Warrior.battle (self : Warrior) (level : Nat) : String := sorry", "vc-theorems": "theorem experience_level_relationship (exp : Nat) (h : exp > 0 ∧ exp ≤ 10000) :\n  let w : Warrior := ⟨exp, []⟩\n  w.level = min 100 (exp / 100) := sorry\n\ntheorem training_sequence (trainings : List (String × Nat × Nat)) :\n  let w : Warrior := ⟨0, []⟩\n  ∀ t ∈ trainings,\n    (t.2.2 ≤ w.level → \n      w.training t = t.1 ∧ \n      t.1 ∈ w.achievements) ∧\n    (t.2.2 > w.level → \n      w.training t = \"Not strong enough\") := sorry\n\ntheorem battle_level_bounds (level : Nat) :\n  let w : Warrior := ⟨0, []⟩\n  (level = 0 ∨ level > 100) →\n    w.battle level = \"Invalid level\" := sorry\n\ntheorem experience_cap (exp_gain : Nat) (h : exp_gain > 0 ∧ exp_gain ≤ 100) :\n  let w : Warrior := ⟨10000, []⟩\n  w.experience = 10000 := sorry\n\ntheorem rank_progression (exp : Nat) (h : exp < 10000) :\n  let w : Warrior := ⟨exp, []⟩\n  let ranks := [\"Pushover\", \"Novice\", \"Fighter\", \"Warrior\", \"Veteran\", \n                \"Sage\", \"Elite\", \"Conqueror\", \"Champion\", \"Master\", \"Greatest\"]\n  have h' : min 10 (exp / 1000) < 11 := by\n    exact Nat.lt_succ_of_le (Nat.min_le_left 10 (exp / 1000))\n  w.rank = ranks[min 10 (exp / 1000)]'h' := sorry\n\ntheorem battle_outcomes (level : Nat) (h : level > 0 ∧ level ≤ 100) :\n  let w : Warrior := ⟨0, []⟩\n  w.battle level ∈ [\"A good fight\", \"An intense fight\", \n                    \"Easy fight\", \"You've been defeated\"] := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1648", "language": "lean", "source": "fvapps", "source-id": "fvapps_001648", "source-notes": "", "vc-description": "/-\n### Context and Definitions\n\nYou are in charge of developing a new cool JavaScript library that provides functionality similar to that of [Underscore.js](http://underscorejs.org/).\n\nYou have started by adding a new  **list data type** to your library. You came up with a design of a data structure that represents an [algebraic data type](http://en.wikipedia.org/wiki/Algebraic_data_type) as a pair of elements:\n\n```python\nclass Cons:\n  def __init__(self, head, tail):\n    self.head = head\n    self.tail = tail\n```\n\nYou are pretty smart, because using this new data type, we can easily build a list of elements. For instance, a list of numbers:\n\n```python\nnumbers = Cons(1, Cons(2, Cons(3, Cons(4, Cons(5, None)))))\n```\n\nIn a code review with your boss, you explained him how every *cons cell* contains a \"value\" in its head, and in its tail it contains either another cons cell or null. We know we have reached the end of the data structure when the tail is null.\n\nSo, your boss is pretty excited about this new data structure and wants to know if you will be able to build some more  functionality around it. In a demo you did this week for the rest of your team, in order to illustrate how this works, you showed them a method to transform a list of items of your list data type into a JavaScript array:\n\n```python\n  # added to the class implementation:\n  def to_array(self):\n    tail = self.tail\n    new_tail = (tail.to_array() if tail is not None else [])\n    return [self.head] + new_tail\n```\n\nAnd they were amazed when you simply did this:\n\n```python\nprint(numbers.to_array())  # yields [1,2,3,4,5]\n```\n\n### The New Requirements\n\nNow, the team is convinced that this is the way to go and they would like to build the library around this cool new data type, but they want you to provide a few more features for them so that they can start using this type in solving some real world problems.\n\nYou have been reading about a technique called  [applicative programming](http://quod.lib.umich.edu/s/spobooks/bbv9810.0001.001/1:15?rgn=div1;view=fulltext) which basically consists in applying a function to every element in a list.  So, you gave it some thought and you have decided to start adding features  like **filter**, **map** and **reduce**. Basically you want to provide equivalent functionality to that of JavaScript arrays and in the future even more.\n\nSo, you will now add:\n\n - [filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2Ffilter): create a new algebraic list containing only the elements that satisfy a predicate function. \n - [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2Ffilter) : create a new list in which every element is the result of applying a function provided as argument.\n - fromArray:  a convenient complementary method  that creates a list out of a JavaScript array.\n\nFor this Kata, the definition of `Cons` and the prototypal/class method `toArray`/`to_array`/`into_vec` are already loaded in your environment.\n\n### Examples of Usage\n\n```python\nnumbers = Cons.from_array([1,2,3,4,5])\nnumbers.filter(lambda x: x % 2 == 0).to_array()  # yields [2,4]\nnumbers.map(lambda x: x * x).to_array()  # yields [1,4,9,16,25]\n\ndigits = Cons.from_array([\"1\",\"2\",\"3\",\"4\",\"5\"])\nintegers = digits.map(int) \\\n                 .filter(lambda n: n > 3) \\\n                 .to_array()  # yields [4,5]\n```\n\nIn other words:\n\n - The static method `Cons.fromArray` (or `from_array`, `from_iter`) produces `Cons(1, Cons(2, Cons(3, Cons 4, Cons 5, null)))))`.\n  - Above filter creates a new list: `Cons(2, Cons(4, null))`.\n -  So does above map:  `Cons(1, Cos(4, Cons(9, Cons(16, Cons(25, null)))))`.\n-/", "vc-preamble": "def ConsList.fromArray {α : Type} (arr : Array α) : ConsList α :=\n  sorry\n\ndef ConsList.toArray {α : Type} (l : ConsList α) : Array α :=\n  sorry\n\ndef ConsList.filter {α : Type} (l : ConsList α) (p : α → Bool) : ConsList α :=\n  sorry", "vc-helpers": "", "vc-definitions": "def ConsList.map {α β : Type} (l : ConsList α) (f : α → β) : ConsList β :=\n  sorry", "vc-theorems": "theorem fromArray_toArray_roundtrip {α : Type} (arr : Array α) :\n  let cons := ConsList.fromArray arr\n  match cons with\n  | ConsList.nil => arr.isEmpty\n  | _ => cons.toArray = arr\n  := sorry\n\ntheorem filter_preserves_valid {α : Type} [BEq α] (arr : Array α) (p : α → Bool) :\n  let cons := ConsList.fromArray arr\n  match cons with\n  | ConsList.nil => True\n  | cons =>\n    let filtered := cons.filter p\n    match filtered with\n    | ConsList.nil => ∀ x, x ∈ arr → ¬(p x)\n    | filtered =>\n      (∀ x, x ∈ filtered.toArray → p x) ∧\n      (∀ x, x ∈ filtered.toArray → x ∈ arr) ∧\n      (∀ x, x ∈ arr → p x → x ∈ filtered.toArray)\n  := sorry\n\ntheorem map_applies_function {α β : Type} (arr : Array α) (f : α → β) :\n  let cons := ConsList.fromArray arr\n  (cons.map f |>.toArray) = arr.map f\n  := sorry\n\ntheorem map_preserves_length {α β : Type} (arr : Array α) (f : α → β) :\n  let cons := ConsList.fromArray arr\n  (cons.map f |>.toArray).size = arr.size\n  := sorry\n\ntheorem operations_independent {α : Type} (arr1 arr2 : Array α) (f : α → α) :\n  let cons1 := ConsList.fromArray arr1\n  let cons2 := ConsList.fromArray arr2\n  match cons1, cons2 with\n  | ConsList.nil, _ => True\n  | _, ConsList.nil => True\n  | cons1, cons2 =>\n    let _ := cons1.map f\n    cons2.toArray = arr2\n  := sorry\n\ntheorem successive_operations {α : Type} [BEq α] [OfNat α 1] [OfNat α 2] [Mul α] (arr : Array α) :\n  let cons := ConsList.fromArray arr\n  match cons with\n  | ConsList.nil => True\n  | cons =>\n    let doubled := cons.map (· * 2)\n    match doubled with\n    | ConsList.nil => True\n    | doubled =>\n      let filtered := doubled.filter (fun _ => true)\n      match filtered with\n      | ConsList.nil => True\n      | filtered =>\n        let final := filtered.map (· * 1)\n        ∀ x, x ∈ final.toArray → x ∈ arr\n  := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1649", "language": "lean", "source": "fvapps", "source-id": "fvapps_001649", "source-notes": "", "vc-description": "/-\n# Overview\n\nThe goal here is to solve a puzzle (the \"pieces of paper\" kind of puzzle). You will receive different pieces of that puzzle as input, and you will have to find in what order you have to rearrange them so that the \"picture\" of the puzzle is complete.\n\n## Puzzle pieces\n\nAll the pieces of the puzzle will be represented in the following way:\n\n* 4 numbers, grouped in 2 tuples, which are representing the \"picture\" on the piece. Every piece has a 2x2 size.\n* 1 id number. All id numbers are unique in a puzzle, but their value may be random.\n* Note that all numbers will be non-negative integers (except for outer border \"picture\" numbers in C#)\n\nFor example, \n\n    ((1, 2), (3, 4), 1) \n     Puzzle piece id ^  \n\nis equivalent the the following square piece of puzzle, having the id number `1`:\n\n    +---+\n    |1 2|\n    |3 4|\n    +---+\n\nIf the piece is on a border or is a corner, some numbers will be replaced with `None` (`-1` in C#):\n```python\n((None, None), (1, 2), 10)       -->   upper border\n((9, None), (None, None), 11)   -->   bottom right corner\n```\n\nNote that you cannot flip or rotate the pieces (_would you like to change the picture!?_)\n\n## Solving the puzzle\n\n* You'll get an array of pieces as well as the size of the puzzle (width and height).  \n* Two pieces can be assembled if they share the same pattern on the border where they are in contact (see example below).\n* Puzzle pieces being unique, you'll never encounter two different pieces that could be assembled with the same third one. So to say: borders are unique.\n* Once you found the proper arrangment for all the pieces, return the solved puzzle as a list of tuples (height * width) of the id number of the piece at its correct position. (For C#, return the solved puzzle as a 2-dimensional array of integers.)\n\n## Example:\n\nInputs:\n\n```python\nwidth, height = 3,3\npieces = [ ((None, 5), (None, None), 3), \n           ((17, None), (None, None), 9),\n           ((None, 4), (None, 5), 8),\n           ((4, 11), (5, 17), 5),\n           ((11, None), (17, None), 2),   \n           ((None, None), (None, 4), 7),\n           ((5, 17), (None, None), 1), \n           ((None, None), (11, None), 4),\n           ((None, None), (4, 11), 6) ]`\n```\n\nIn this case, the expected output would be:\n\n```python\nexpected = [(7, 6, 4), (8, 5, 2), (3, 1, 9)]\n```\n\n... the solved puzzle looking like this:\n\n```python\n         Puzzle Solved:                     Related id numbers:\n -----------------------------                  7    6    4\n|None None|None None|None None|                 \n|None   4 | 4    11 | 11  None|                 8    5    2\n|-----------------------------|\n|None   4 | 4    11 | 11  None|                 3    1    9\n|None   5 | 5    17 | 17  None|\n|-----------------------------| \n|None   5 | 5    17 | 17  None| \n|None None|None None|None None|\n -----------------------------\n```\n\n### Notes:\n\n* Be careful about performances, you'll have to handle rather big puzzles.\n* Width and height will be between 2 and 100 (inclusive)\n* The puzzle may be rectangular too\n-/", "vc-preamble": "def getMatchingPieces (pieces: List Piece) : Piece → Bool := sorry\ndef checkFit (p1 p2: Piece) (dir: String) : Bool := sorry", "vc-helpers": "", "vc-definitions": "def puzzleSolver (pieces: List Piece) (width height: Nat) : Option (List (List Nat)) := sorry\n\ntheorem getMatchingPieces_preserves_length (pieces: List Piece):\n  pieces.length = (pieces.filter (getMatchingPieces pieces)).length := sorry", "vc-theorems": "theorem getMatchingPieces_contains_all_ids (pieces: List Piece) (p: Piece):\n  p ∈ pieces → p ∈ (pieces.filter (getMatchingPieces pieces)) := sorry\n\ntheorem checkFit_returns_bool (p1 p2: Piece) (dir: String):\n  checkFit p1 p2 dir = true ∨ checkFit p1 p2 dir = false := sorry\n\ntheorem checkFit_right (p1 p2: Piece):\n  checkFit p1 p2 \"right\" = (p1.right + p2.left = 0) := sorry\n\ntheorem checkFit_down (p1 p2: Piece): \n  checkFit p1 p2 \"down\" = (p1.down + p2.up = 0) := sorry\n\ntheorem checkFit_invalid (p1 p2: Piece) (dir: String):\n  dir ≠ \"right\" → dir ≠ \"down\" → checkFit p1 p2 dir = false := sorry\n\ntheorem puzzleSolver_result_dimensions {pieces: List Piece} {width height: Nat}\n  (result: Option (List (List Nat))):\n  result = puzzleSolver pieces width height →\n  result.isSome → \n  match result with\n  | none => True\n  | some grid => grid.length = height ∧ grid.all (fun row => row.length = width)\n  := sorry\n\ntheorem puzzleSolver_uses_valid_pieces {pieces: List Piece} {width height: Nat}\n  (result: Option (List (List Nat))):\n  result = puzzleSolver pieces width height →\n  result.isSome →\n  match result with\n  | none => True  \n  | some grid => ∀ id ∈ grid.join, ∃ p ∈ pieces, p.id = id\n  := sorry\n\ntheorem puzzleSolver_pieces_fit {pieces: List Piece} {width height: Nat}\n  (result: Option (List (List Nat))):\n  result = puzzleSolver pieces width height →\n  result.isSome →\n  match result with\n  | none => True\n  | some grid =>\n    ∀ y x: Nat, y < height → x < width →\n    if x > 0 ∧ grid[y]?.isSome ∧ Option.isSome (grid[y]? >>= (·[x]?)) ∧ Option.isSome (grid[y]? >>= (·[x-1]?))\n    then match grid[y]?, grid[y]? >>= (·[x]?), grid[y]? >>= (·[x-1]?) with\n      | some row, some curr, some prev =>\n        match pieces.find? (·.id = curr), pieces.find? (·.id = prev) with\n        | some currPiece, some prevPiece => checkFit prevPiece currPiece \"right\"\n        | _, _ => false\n      | _, _, _ => false\n    else if y > 0 ∧ grid[y]?.isSome ∧ Option.isSome (grid[y]? >>= (·[x]?)) ∧ Option.isSome (grid[y-1]? >>= (·[x]?))\n    then match grid[y]?, grid[y]? >>= (·[x]?), grid[y-1]? >>= (·[x]?) with\n      | some row, some curr, some above =>\n        match pieces.find? (·.id = curr), pieces.find? (·.id = above) with\n        | some currPiece, some abovePiece => checkFit abovePiece currPiece \"down\"\n        | _, _ => false\n      | _, _, _ => false\n    else true\n  := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1655", "language": "lean", "source": "fvapps", "source-id": "fvapps_001655", "source-notes": "", "vc-description": "/-\nYour task in this kata is to implement the function `create_number_class` which will take a string parameter `alphabet` and return a class representing a number composed of this alphabet.\n\nThe class number will implement the four classical arithmetic operations (`+`, `-`, `*`, `//`), a method to convert itself to string, and a `convert_to` method which will take another class number as parameter and will return the value of the actual class number converted to the equivalent value with tha alphabet of the parameter class (return a new instance of this one).\n\nExample:\n\n```python\nBinClass = create_number_class('01')\nHexClass = create_number_class('0123456789ABCDEF')\n\nx = BinClass('1010')\ny = BinClass('10')\n\nprint(x+y)                   => '1100'\nisinstance(x+y, BinClass)    => True\nprint(x.convert_to(HexClass) => 'A'\n```\n\n___Notes:___\n\n* Only positives integers will be used (either as parameters or results of calculations).\n* You'll never encounter invalid calculations (divisions by zero or things like that).\n* Alphabets will contain at least 2 characters.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def BinClass : NumberClass := sorry\ndef HexClass : NumberClass := sorry", "vc-theorems": "theorem bin_str_roundtrip (s : String) : \n  s.any (fun c => c = '0' ∨ c = '1') → \n  BinClass.value (BinClass.toString (BinClass.value s)) = BinClass.value s := sorry\n\ntheorem bin_int_str_roundtrip (n : Nat) :\n  BinClass.value (BinClass.toString n) = n := sorry \n\ntheorem bin_arithmetic_add (s1 s2 : String) :\n  BinClass.value s1 + BinClass.value s2 = BinClass.value (BinClass.toString (BinClass.value s1 + BinClass.value s2)) := sorry\n\ntheorem bin_arithmetic_mul (s1 s2 : String) :\n  BinClass.value s1 * BinClass.value s2 = BinClass.value (BinClass.toString (BinClass.value s1 * BinClass.value s2)) := sorry\n\ntheorem bin_arithmetic_div (s1 s2 : String) :\n  BinClass.value s2 ≠ 0 →\n  BinClass.value s1 / BinClass.value s2 = BinClass.value (BinClass.toString (BinClass.value s1 / BinClass.value s2)) := sorry\n\ntheorem bin_arithmetic_sub (s1 s2 : String) :\n  BinClass.value s1 ≥ BinClass.value s2 →\n  BinClass.value s1 - BinClass.value s2 = BinClass.value (BinClass.toString (BinClass.value s1 - BinClass.value s2)) := sorry\n\ntheorem base_conversion (n : Nat) :\n  BinClass.value (BinClass.toString n) = HexClass.value (HexClass.toString n) := sorry\n\ntheorem arbitrary_base_conversion {α : Type} (s : List α) (n : Nat) [DecidableEq α] :\n  s.length > 1 →\n  ∃ (NumClass : NumberClass),\n  NumClass.value (NumClass.toString n) = n := sorry\n\n/-\ninfo: '1100'\n-/\n-- #guard_msgs in\n-- #eval str x + y\n\n/-\ninfo: '1000'\n-/\n-- #guard_msgs in\n-- #eval str x - y\n\n/-\ninfo: '10100'\n-/\n-- #guard_msgs in\n-- #eval str x * y\n\n/-\ninfo: '101'\n-/\n-- #guard_msgs in\n-- #eval str x // y\n\n/-\ninfo: 'A'\n-/\n-- #guard_msgs in\n-- #eval str x.convert_to(HexClass)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1656", "language": "lean", "source": "fvapps", "source-id": "fvapps_001656", "source-notes": "", "vc-description": "/-\n# The learning game - Machine Learning #1\nGrowing up you would have learnt a lot of things like not to stand in fire, to drink food and eat water and not to jump off very tall things But Machines have it difficult they cannot learn for themselves we have to tell them what to do, why don't we give them a chance to learn it for themselves?\n\n### Task\nYour task is to finish the Machine object. What the machine object must do is learn from its mistakes! The Machine will be given a command and a number you will return a random action. After the command has returned you will be given a response (true/false) if the response is true then you have done good, if the response is false then the action was a bad one. You must program the machine to learn to apply an action to a given command using the reponse given. Note: It must take no more than 20 times to teach an action to a command also different commands can have the same action.\n\n### Info\n- In the preloaded section there is a constant called ```ACTIONS``` it is a function that returns the 5 possible actions.\n- In Java, this a constant ```Actions.FUNCTIONS``` of type ```List>```. \n- In C++, the actions can be accessed by ```get_action(i)(unsigned int num)``` where i chooses the function (and therefore can range from 0 to 4) and num is its argument.\n- In python ```ACTIONS()``` returns a list of lambdas.\n- In Golang ```Actions()``` retruns a function slice ```[]func(int) int```\n-/", "vc-preamble": "def Machine.command (m : Machine) (cmd : String) (n : Int) : Int := sorry\ndef Machine.response (m : Machine) (b : Bool) : Machine := sorry", "vc-helpers": "", "vc-definitions": "def Machine.actions : List (Int → Int) := sorry\n\n-- First command matches first action", "vc-theorems": "theorem initial_command_matches_first_action (cmd : String) (n : Int) :\n  let m : Machine := default\n  let firstAction := (Machine.actions.head! : Int → Int)\n  Machine.command m cmd n = firstAction n := sorry\n\n-- False response changes behavior eventually\n\ntheorem false_response_changes_behavior (cmd : String) (n : Int) \n  (h : 1 ≤ n ∧ n ≤ 100) :\n  let m : Machine := default\n  let first := Machine.command m cmd n\n  ∃ i : Nat, i ≤ 3 ∧\n    let m' := Machine.response m false\n    let second := Machine.command m' cmd n\n    second ≠ first := sorry\n\n-- Cycles through multiple actions\n\ntheorem cycling_through_actions (cmd : String) (n : Int)\n  (h : 1 ≤ n ∧ n ≤ 100) :\n  let m : Machine := default\n  let r1 := Machine.command m cmd n\n  let m1 := Machine.response m false\n  let r2 := Machine.command m1 cmd n\n  let m2 := Machine.response m1 false\n  let r3 := Machine.command m2 cmd n\n  let results := [r1, r2, r3]\n  (results.eraseDups).length ≥ 2 := sorry\n\n-- Different commands are independent\n\ntheorem commands_independent (cmd1 cmd2 : String) (h : cmd1 ≠ cmd2) :\n  let m : Machine := default\n  let r1 := Machine.command m cmd1 1\n  let m' := Machine.response m false\n  let r2 := Machine.command m' cmd2 1\n  let firstAction := (Machine.actions.head! : Int → Int)\n  r2 = firstAction 1 := sorry\n\n-- True response maintains same action\n\ntheorem true_response_maintains_action (cmd : String) (n : Int) :\n  let m : Machine := default\n  let first := Machine.command m cmd n\n  let m' := Machine.response m true\n  let second := Machine.command m' cmd n\n  first = second := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1661", "language": "lean", "source": "fvapps", "source-id": "fvapps_001661", "source-notes": "", "vc-description": "/-\nTask\n\nCreate a top-down movement system that would feel highly responsive to the player. In your Update method you have to check for the keys that are currently being pressed, the keys correspond to the enum Direction shown below, based on which key is pressed or released your method should behave this way:\n\n1) When a key is first pressed, the player has to change his direction to that of the current key, without moving\n\n2) If the key is still being pressed during the next Update, the player will move towards his current direction using these vectors: (Up = { 0, +1 } , Down = { 0, -1 }, Left = { -1, 0 }, Right = { +1, 0 })\n\n3) If a new key is pressed, it will gain precedence over the previous key and the player will act as per 1)\n\n4-A) If the current key (A) is released, then the precedence will go back to the previous key (B) (or the one before it, if (B) is not pressed anymore, and so on), then the player will behave as per 1).\n\n4-B) If the current key is released, and no other keys are being pressed, the player will stand still\n\n5) If all keys are released at once, the player will not move nor change direction\n\n6) If multiple keys are pressed at once, the order of precedence will be the following { Up, Down, Left, Right } \n\nExamples\n\n    (n = pressed key, [n] = current key, p() = press, r() = release, (8,2,4,6 = up, down, left, right)):\n\n    [] , p(8) -> [8] , p(4,6) -> 86[4] , r(6) -> 8[4] , r(4) -> [8] , r(8) -> []\n\n    [] , p(2486) -> 642[8] , r(2,8) -> 6[4] , r(4,6) -> []\n\nThis is what you'll need to use in your code (NB: the tile coordinates cannot be changed, you'll need to assign a new Tile each time the player moves):\n\n```python\nclass Tile:\n\n    @property\n    def x(self):\n        return self._x\n\n    @property\n    def y(self):\n        return self._y\n\n    def __str__(self):\n        return \"({},{})\".format(self._x, self._y)\n\nclass Input:\n\n    @staticmethod\n    def get_state(direction): # 2, 4, 6, 8\n        return Input.STATES[direction] # pressed = true, released = false\n```\n-/", "vc-preamble": "def PlayerMovement.PREC : List Nat := [2, 4, 6, 8]\n\ndef PlayerMovement.new (x y : Int) : PlayerMovement := sorry", "vc-helpers": "", "vc-definitions": "def PlayerMovement.update (pm : PlayerMovement) : PlayerMovement := sorry\n\ndef Input.set_states (states : List (Nat × Bool)) : Unit := sorry", "vc-theorems": "theorem player_movement_initialization (x y : Int) :\n  let pm := PlayerMovement.new x y\n  pm.position.x = x ∧\n  pm.position.y = y ∧\n  pm.direction = 8 ∧\n  pm.pressed = [false, false, false, false] ∧\n  pm.stack = [] := sorry\n\ntheorem movement_preserves_invariants (states : List (Nat × Bool)) :\n  let pm := PlayerMovement.new 0 0\n  let _ := Input.set_states states\n  let pm' := pm.update\n  List.length pm'.pressed = 4 ∧\n  (∀ x ∈ pm'.pressed, x = true ∨ x = false) ∧\n  (pm'.direction = 2 ∨ pm'.direction = 4 ∨ pm'.direction = 6 ∨ pm'.direction = 8) ∧\n  (∀ x ∈ pm'.stack, x = 2 ∨ x = 4 ∨ x = 6 ∨ x = 8) ∧\n  List.Nodup pm'.stack := sorry\n\ntheorem precedence (pressed_keys : List (Nat × Bool)) \n  (h1 : ∀ k ∈ pressed_keys, k.1 ∈ PlayerMovement.PREC)\n  (h2 : ∀ k ∈ pressed_keys, k.2 = true)\n  (h3 : pressed_keys.length > 0) :\n  let pm := PlayerMovement.new 0 0\n  let _ := Input.set_states pressed_keys\n  let pm' := pm.update\n  pm'.direction ∈ PlayerMovement.PREC ∧\n  ∀ k ∈ pressed_keys, \n    ∃ i j : Nat, \n      PlayerMovement.PREC.get? i = some pm'.direction ∧\n      PlayerMovement.PREC.get? j = some k.1 ∧\n      i ≤ j := sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval len player.stack\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval len player.stack\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval len player.stack", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1665", "language": "lean", "source": "fvapps", "source-id": "fvapps_001665", "source-notes": "", "vc-description": "/-\nWrite a class called User that is used to calculate the amount that a user will progress through a ranking system similar to the one Codewars uses.  \n\n##### Business Rules:\n\n* A user starts at rank -8 and can progress all the way to 8.\n* There is no 0 (zero) rank. The next rank after -1 is 1.\n* Users will complete activities. These activities also have ranks.\n* Each time the user completes a ranked activity the users rank progress is updated based off of the activity's rank\n* The progress earned from the completed activity is relative to what the user's current rank is compared to the rank of the activity\n* A user's rank progress starts off at zero, each time the progress reaches 100 the user's rank is upgraded to the next level\n* Any remaining progress earned while in the previous rank will be applied towards the next rank's progress (we don't throw any progress away). The exception is if there is no other rank left to progress towards (Once you reach rank 8 there is no more progression). \n* A user cannot progress beyond rank 8. \n* The only acceptable range of rank values is -8,-7,-6,-5,-4,-3,-2,-1,1,2,3,4,5,6,7,8. Any other value should raise an error. \n\nThe progress is scored like so:\n\n* Completing an activity that is ranked the same as that of the user's will be worth 3 points\n* Completing an activity that is ranked one ranking lower than the user's will be worth 1 point\n* Any activities completed that are ranking 2 levels or more lower than the user's ranking will be ignored\n* Completing an activity ranked higher than the current user's rank will accelerate the rank progression. The greater the difference between rankings the more the progression will be increased. The formula is `10 * d * d` where `d` equals the difference in ranking between the activity and the user.  \n\n##### Logic Examples:\n* If a user ranked -8 completes an activity ranked -7 they will receive 10 progress\n* If a user ranked -8 completes an activity ranked -6 they will receive 40 progress\n* If a user ranked -8 completes an activity ranked -5 they will receive 90 progress\n* If a user ranked -8 completes an activity ranked -4 they will receive 160 progress, resulting in the user being upgraded to rank -7 and having earned 60 progress towards their next rank\n* If a user ranked -1 completes an activity ranked 1 they will receive 10 progress (remember, zero rank is ignored)\n\n##### Code Usage Examples:\n```python\nuser = User()\nuser.rank # => -8\nuser.progress # => 0\nuser.inc_progress(-7)\nuser.progress # => 10\nuser.inc_progress(-5) # will add 90 progress\nuser.progress # => 0 # progress is now zero\nuser.rank # => -7 # rank was upgraded to -7\n```\n\n~~~if:java\n**Note:** In **Java** some methods may throw an `IllegalArgumentException`.\n~~~\n~~~if:csharp\n**Note:** In **C#** some methods may throw an `ArgumentException`.\n~~~\n\n**Note**: Codewars no longer uses this algorithm for its own ranking system. It uses a pure Math based solution that gives consistent results no matter what order a set of ranked activities are completed at.\n-/", "vc-preamble": "def User.incProgress (self : User) (rank : Rank) : User :=\n  sorry\n\ndef isValidRank (r : Rank) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def getRankProgress (self : User) (rank : Rank) : Nat :=\n  sorry", "vc-theorems": "theorem valid_rank_input (r : Rank) (u : User) :\n  let u' := u.incProgress r\n  u'.progress ≥ 0 ∧ isValidRank u'.rank := by\n  sorry\n\ntheorem invalid_rank_progress (n : Int) (u : User) :\n  n ≠ -8 ∧ n ≠ -7 ∧ n ≠ -6 ∧ n ≠ -5 ∧ n ≠ -4 ∧ n ≠ -3 ∧ n ≠ -2 ∧ n ≠ -1 ∧ \n  n ≠ 1 ∧ n ≠ 2 ∧ n ≠ 3 ∧ n ≠ 4 ∧ n ≠ 5 ∧ n ≠ 6 ∧ n ≠ 7 ∧ n ≠ 8 →\n  False := by\n  sorry\n\ntheorem same_rank_progress (r : Rank) (u : User) : \n  u.rank = r →\n  let u' := u.incProgress r\n  (u'.progress - u.progress) % 100 = 3 ∨ u.rank = Rank.Eight := by\n  sorry\n\ntheorem one_rank_below_progress (r : Rank) (u : User) :\n  r ≠ Rank.Eight →\n  let nextRank := Rank.Eight -- simplified for demonstration\n  u.rank = nextRank →\n  let u' := u.incProgress r\n  (u'.progress - u.progress) % 100 = 1 ∨ u'.rank = Rank.Eight := by \n  sorry\n\ntheorem max_rank_progress (r : Rank) (u : User) :\n  u.rank = Rank.Eight →\n  let u' := u.incProgress r\n  u'.progress = 0 ∧ u'.rank = Rank.Eight := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1669", "language": "lean", "source": "fvapps", "source-id": "fvapps_001669", "source-notes": "", "vc-description": "/-\nFor a new 3D game that will be released, a team of programmers needs an easy function. (Then it will be processed as a method in a Class, forget this concept for Ruby)\n\nWe have an sphere with center O, having in the space the coordinates `[α, β, γ]` and radius `r`  and a list of points, `points_list`, each one with coordinates `[x, y, z]`. Select the biggest triangle (or triangles) that has (have) all its (their) 3 vertice(s) as interior points of the sphere (not even in the sphere contour). You should consider that a point P is interior if its distance to center O, d, is such that:\n\nd < r\n\nand \n\n(d - r) / r| > 10^(-10)\n\nLet's see the situation with the following points in the image posted below:\n```python\nA = [1,2,-4]; B = [-3, 2, 4]; C = [7, 8, -4]; D = [2, 3, 5]; E = [-2, -1, 1]\n```\n\nThe sphere has the following features:\n```\nO = [1, 2, -2] (Center of the sphere)\nradius = 8\n```\n\nAs C is the only exterior point of the sphere, the possible triangles that have their vertices interior to the sphere are: \n\n```\nABD, ABE, ADE, BDE\n```\n\nLet's see which is the biggest one:\n\n```python\nTriangle    Triangle with its points         Area\nABD        [[1,2,-4],[-3,2,4],[2,3,5]]    22.44994432064\nABE        [[1,2,-4],[-3,2,4],[-2,-1,1]]  13.56465996625\nADE        [[1,2,-4],[2,3,5],[-2,-1,1]]   22.62741699796 <---- biggest triangle\nBDE        [[-3,2,4],[2,3,5],[-2,-1,1]]   11.31370849898\n```\n\nOur function ```biggest_triang_int()``` (javascript: ```biggestTriangInt()```should output for this case:\n\n```python\npoints_list = [[1,2,-4], [-3, 2, 4], [7, 8, -4], [2, 3, 5], [-2, -1, 1]]\nsphere_center = [1, 2, -2]\nradius = 8\nbiggest_triang_int(points_list, sphere_center, radius) == [4, 22.62741699796,  [[1,2,-4],[2,3,5],[-2,-1,1]]]\n```\n\nThat means that with the given points list we may generate 4 triangles with all their vertices as interior points of the sphere, the biggest triangle has an area of 22.62741699796 (the units does not matter and the values for the area should not be rounded) and finally, there is only one triangle with this maximum value.\nEvery triangle should be output having the same order of its vertices than in the given list of points. B = [-3,2,4], comes before than D =[2,3,5] and the last one E = [-2,-1,1]\nIf in the result we have only one triangle, the function should output a list of three points.\n\nLet'see the next case:\n\n```python\npoints_list = [[1,2,-4], [-3, 2, 4], [7, 8, -4], [2, 3, 5], [-2, -1, 1],\n              [3, 2, 6], [1, 4, 0], [-4, -5, -6], [4, 5, 6], [-2, -3, -5],\n              [-1, -2, 4], [-3, -2, -6], [-1, -4, 0], [2, 1, -1]]\nsphere_center = [0, 0, 0]\nradius = 8\nbiggest_triang_int(points_list, sphere_center, radius) == [165, 33.645207682521445, [[[1, 2, -4], [3, 2, 6], [-1, -4, 0]], [[1, 4, 0], [-1, -2, 4], [-3, -2, -6]]]]\n```\n\nNow there are a total of 165 triangles with their vertices in the sphere, the biggest triangle has an area of 33.645207682521445 but we have two triangles with this area value. The vertices of each triangle respect the order of the points list as we expressed before but the additional detail is that the triangles are sorted by the values of the coordinates of their points. Let's compare the coordinates of the first point\n\n```\nFirst point   x  y  z\nTriangle1     1  2 -4  <--- this triangle is first in the result\nTriangle2     1  4  0\n              |  |\n              |  y1 < y2 (2, 4)\n              |\n              x1 = x2     (1 = 1)\n```\n\nIn the case that all the given points are exterior to the sphere the function should output the empty list.\n\nThe points in the list are all valid and each one occurs once.\n\nRemember that if three points are collinear do not form a triangle. For practical purposes you may consider that if the area of a triangle is lower than 10^(-8), the points are aligned.\n\nEnjoy it!\n-/", "vc-preamble": "def Points := List Point\n\nstructure Triangle where\n  points : List Point\n  valid : points.length = 3\n\nstructure Result where\n  numTriangles : Option Int\n  area : Option Float  \n  triangles : Option (List Triangle)\n\ndef biggest_triang_int (points : Points) (center : Point) (radius : Int) : Result :=\n  sorry\n\ndef norme (p : Point) : Float :=\n  sorry\n\ndef vectorize (p1 p2 : Point) : Point := \n  sorry\n\ndef isInCircle (p : Point) (center : Point) (radius : Int) : Bool :=\n  sorry\n\ndef crossProd (v1 v2 : Point) : Point :=\n  sorry", "vc-helpers": "", "vc-definitions": "def origin : Point := {\n  coords := [0,0,0]\n  valid := by simp\n}", "vc-theorems": "theorem output_structure \n  (points : Points) \n  (center : Point) \n  (radius : Int)\n  (h1 : points.length ≥ 3)\n  (h4 : radius > 0) :\n  let result := biggest_triang_int points center radius\n  (result.numTriangles.isSome → \n   result.area.isSome ∧\n   result.triangles.isSome) :=\nsorry\n\ntheorem empty_small_inputs\n  (points : Points)\n  (h1 : points.length < 3) :\n  let result := biggest_triang_int points origin 10\n  result.numTriangles = none ∧\n  result.area = none ∧\n  result.triangles = none :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1671", "language": "lean", "source": "fvapps", "source-id": "fvapps_001671", "source-notes": "", "vc-description": "/-\nWe need a system that can learn facts about family relationships, check their consistency and answer queries about them.\n\n# The task\n\n~~~if:javascript\nCreate a class `Family` with the following methods. All arguments are strings: names of persons. Upon the first use of a name, that name is added to the family.\n\n* `male(name)` and `female(name)` returning `boolean`\n\n Define the gender (corresponding to the method name) of the given person. Return `false` when these assignments cannot be made because of conflicts with earlier registered information.\n\n* `isMale(name)` and `isFemale(name)` returning `boolean`\n\n Return `true` when the person has the said gender. When no gender was assigned, both methods should return `false`\n\n* `setParent(childName, parentName)` returning `boolean`\n\n Defines the child-parent relationship between two persons. Returns `false` when the relationship cannot be made because of conflicts with earlier registered information.\n\n* `getParents(name)` and `getChildren(name)` returning `array` of `string`\n\n Return the names of the person's parents/children in alphabetical order\n~~~\n~~~if:python\nCreate a class `Family` with the following methods. All arguments are strings: names of persons. Upon the first use of a name, that name is added to the family.\n\n* `male(name)` and `female(name)` returning `boolean`\n\n Define the gender (corresponding to the method name) of the given person. Return `False` when these assignments cannot be made because of conflicts with earlier registered information.\n\n* `is_male(name)` and `is_female(name)` returning `boolean`\n\n Return `True` when the person has the said gender. When no gender was assigned, both methods should return `False`\n\n* `set_parent_of(child_name, parent_name)` returning `boolean`\n\n Defines the child-parent relationship between two persons. Returns `False` when the relationship cannot be made because of conflicts with earlier registered information.\n\n* `get_parents_of(name)` and `get_children_of(name)` returning `list` of `string`\n\n Return the names of the person's parents/children in alphabetical order\n~~~\n~~~if:java\nCreate a class `Family` with the following methods. All arguments are names of persons. Upon the first use of a name, that name is added to the family.\n\n* `boolean male(String name)` and `boolean female(String name)`\n\n Define the gender (corresponding to the method name) of the given person. Return `false` when these assignments cannot be made because of conflicts with earlier registered information.\n\n* `boolean isMale(String name)` and `boolean isFemale(String name)`\n\n Return `true` when the person has the said gender. When no gender was assigned, both methods should return `false`\n\n* `boolean setParent(String childName, String parentName)`\n\n Defines the child-parent relationship between two persons. Returns `false` when the relationship cannot be made because of conflicts with earlier registered information.\n\n* `List getParents(String name)` and `List getChildren(String name)`\n\n Return the names of the person's parents/children in alphabetical order\n~~~\n~~~if:php\nCreate a class `Family` with the following methods. All arguments are names of persons. Upon the first use of a name, that name is added to the family.\n\n* `male(string $name): bool` and `female(string $name): bool`\n\n Define the gender (corresponding to the method name) of the given person. Return `false` when these assignments cannot be made because of conflicts with earlier registered information.\n\n* `isMale(string $name): bool` and `isFemale(string $name): bool`\n\n Return `true` when the person has the said gender. When no gender was assigned, both methods should return `false`\n\n* `setParent(string $child_name, string $parent_name): bool`\n\n Defines the child-parent relationship between two persons. Returns `false` when the relationship cannot be made because of conflicts with earlier registered information.\n\n* `getParents(string $name): array` and `getChildren(string $name): array`\n\n Return the names of the person's parents/children in alphabetical order\n~~~\n\n# Deducing information\n\nWhen things can be implied from given information, it should be done.\n\nFor instance, a parent's gender can be determined as soon as the other parent's gender becomes known:\n\n```python\nfam = Family()\nfam.set_parent_of(\"Vera\", \"George\")\nfam.set_parent_of(\"Vera\", \"Vanessa\")\nfam.female(\"Vanessa\")\nfam.female(\"George\");  # False, because:\nfam.is_male(\"George\"); # ...this is True.\n```\n\n~~~if:javascript,java,php\nAlso `setParentOf` can return `false`. For example, if the relationship would infer that one becomes their own ancestor:\n~~~\n~~~if:python\nAlso `set_parent_of` can return `False`. For example, if the relationship would infer that one becomes their own ancestor:\n~~~\n\n```python\nfam = Family()\nfam.set_parent_of(\"Vera\", \"George\")\nfam.set_parent_of(\"George\", \"Vera\") # False\n```\n\n# Details, rules, assumptions\n\nAlthough the task relates to genealogy, the rules of this kata are not claimed to be realistic. Several simplifications and rules apply, which may not hold in real life: \n\n- Strings are case sensitive, but there are no tests playing around with \"Peter\", \"PETER\" and \"PeTeR\".\n- People are uniquely identified by their name. For instance, there are no two different people called \"Jim\" in the same family.\n- Once a person has an assigned gender, it cannot be changed.\n- No gender conclusions should be made from personal names: \"Bob\" could well be a woman and \"Susan\" a man.\n- People cannot have more than one mother and one father.\n- The terms \"parents\" and \"children\" refer to the relatives in the immediate previous/next generations only, not to more remote ancestors or descendants.\n- Incest may occur, so, for example, one's parent may at the same time be their grandparent.\n- One cannot be their own ancestor.\n- Age is not accounted for. Even if some incestuous relationships would infer that one's parent is more than 5 generations older, it should be allowed.\n- In case a name's first occurrence is in a call of one of the two gender querying methods, the return value will always be false, as that new person does not have a known gender.\n- In case a name's first occurrence is in a call of one of the two relation querying methods, the return value will always be an empty array/list, as there are no relationships known yet in which that new person participates.\n- For the reasons in the preceding two bullet points it should not matter whether you actually store that name in these cases in your data structure, or not. In the latter case you would only store it at the next occasion when that name is mentioned in a call of one of the three other methods, that actually *add* information. The described interface has no way to query the difference between these two possible implementations, so you can choose freely.\n\n# Example\n\nConsider the following family graph:\n\n  .dot { height: 49px; width: 100px; background-color: #666; border-radius: 50%;\n      border: #aaa 1px solid ; display: flex; align-items: center; justify-content: center; }\n  table.tight { border-spacing: 0px; border-collapse: separate; width: 250px}\n  table.tight td { padding: 0px; min-width: 25px; height: 25px; }\n  .up { border-top: #aaa 1px solid; }\n  .right { border-right: #aaa 1px solid; }\n  .red { color: #ea6 }\n\nDylan (m)\n\nMorgan (f)\n\nFrank (m)\n\nJuly\n\nJennifer\n\nJoy\n\nIt could be created step by step with the following code — the expected return value for each method call is indicated in comments:\n\n```python\nfam = Family()\nfam.set_parent_of(\"Frank\", \"Morgan\")       # True\nfam.set_parent_of(\"Frank\", \"Dylan\")        # True\nfam.male(\"Dylan\")                          # True\nfam.male(\"Dylan\")                          # True, no conflict\nfam.set_parent_of(\"Joy\", \"Frank\")          # True\nfam.male(\"Frank\")                          # True\nfam.male(\"Morgan\")                         # False\n# (Morgan is a woman because she both is Frank's parent, but not his father) \nfam.set_parent_of(\"July\", \"Morgan\")        # True\n# (The preceding assertion was rejected, so there is no conflict)\nfam.is_male(\"Joy\") or fam.is_female(\"Joy\") # False\n# (We know Joy is Frank's child, but we can't derive Joy's gender)\nfam.get_children_of(\"Morgan\")              # [\"Frank\", \"July\"]\nfam.set_parent_of(\"Jennifer\", \"Morgan\")    # True\nfam.get_children_of(\"Morgan\")              # [\"Frank\", \"Jennifer\", \"July\"]\nfam.get_children_of(\"Dylan\")               # [\"Frank\"]\n# (That is all we know for sure)\nfam.get_parents_of(\"Frank\")                # [\"Dylan\", \"Morgan\"]\nfam.set_parent_of(\"Morgan\", \"Frank\")       # False\n# (It is impossible to be the parent of your parent)\n```\n\nHave fun!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def mkFamily : Family := {\n  male := fun _ => false,\n  female := fun _ => false,\n  get_parents_of := fun _ => [],\n  get_children_of := fun _ => [],\n  set_parent_of := fun _ _ => false,\n  is_male := fun _ => false,\n  is_female := fun _ => false\n}\n\nvariable (f : Family)", "vc-theorems": "theorem male_female_exclusive (name : String) :\n  ¬(f.male name = true ∧ f.female name = true) :=\nsorry\n\ntheorem male_idempotent (name : String) :\n  f.male name = true → f.male name = true ∧ f.female name = false :=\nsorry\n\ntheorem female_idempotent (name : String) :\n  f.female name = true → f.female name = true ∧ f.male name = false :=\nsorry\n\ntheorem empty_relationships (name : String) :\n  f.get_parents_of name = [] ∧ \n  f.get_children_of name = [] ∧\n  f.is_male name = false ∧\n  f.is_female name = false :=\nsorry\n\ntheorem parent_child_relationship (parent child : String) :\n  parent ≠ child →\n  (f.set_parent_of child parent = true → \n    (parent ∈ f.get_parents_of child ∧\n     child ∈ f.get_children_of parent ∧\n     (f.get_parents_of child).length ≤ 2)) ∧\n  (f.set_parent_of child parent = false →\n    parent ∉ f.get_parents_of child ∧\n    child ∉ f.get_children_of parent) :=\nsorry\n\ntheorem gender_deduction (parent1 parent2 child : String) :\n  parent1 ≠ parent2 ∧ parent1 ≠ child ∧ parent2 ≠ child →\n  f.set_parent_of child parent1 = true ∧ f.set_parent_of child parent2 = true →\n  f.male parent1 = true →\n  f.is_female parent2 = true ∧\n  f.is_male parent1 ≠ f.is_male parent2 ∧ \n  f.is_female parent1 ≠ f.is_female parent2 :=\nsorry\n\ntheorem no_cyclic_relationships (names : List String) :\n  names.length ≥ 3 →\n  names.Nodup →\n  (∀ (i : Nat), i < names.length - 1 → \n    f.set_parent_of (names[i]!) (names[i+1]!) = true) →\n  f.set_parent_of (names[names.length - 1]!) (names[0]!) = false :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1677", "language": "lean", "source": "fvapps", "source-id": "fvapps_001677", "source-notes": "", "vc-description": "/-\n# Let's play some games!\n\nA new RPG called **_Demon Wars_** just came out! Imagine the surprise when you buy it after work, go home, start you _GameStation X_ and it happens to be too difficult for you. Fortunately, you consider yourself a computer connoisseur, so you want to build an AI that tells you every step you have to make to **defeat the evil Demon Lord** and win the game. For now, let's program a simulator.\n\nThis game features procedurally generated stages like this one:\n\n  Health: ♥️ ♥️ ♥️   Atk: 1   Def: 1   Bag: []  \nK   E     |    X#        C      E   S#  D  \n    E     #######               ###### E E \n##### #####                          ###-##\n     M                                 EEE \n                     ###   ###             \n                     #       ##E##E##      \n     ^               #          C  K#      \n               C      #   H   ##E##E##       \n\nAs you can see in the upper status bar, your player starts with **three Health Points**, **1 Attack**, **1 Defense** and an empty **Bag**. These are the only stats that you have to care about for the game. As for the map, we can see many different things, so let's explain every tile one by one:\n* `^` or `v` or `<` or `>` => **Player** (you). It can face any of four directions.\n* `#` => **Wall**. You cannot pass through here.\n* `C` => **Coin _[object]_**.\n* `M` => **Merchant**. They will go away if you give them **three coins**.\n* `K` => **Key _[object]_**. They can open a door, after which they break _(yes, like in horror games)_.\n* `-` and `|` => **Doors** _(there are two doors in the map above)_.\n* `H` => **Health Potion _[object]_**. It refuels your life to three hearts.\n* `S` => **Shield**. It gives **+1 defense** permanently.\n* `X` => **Dual Swords**. It gives **+1 attack** permanently.\n* `E` => **Enemy**. Has **1 Health Point** and **2 Attack**.\n* `D` => **Demon Lord**. Has **10 Health Points** and **3 Attack**. You win the game if you kill him.\n\nNow, _Demon Wars_ is a turn based game with tank controls. Each turn you can either:\n* Move forward.\n* Change direction.\n* Use an item.\n* Attack the enemy you have in front of you.\n\nWill you be able to defeat your foe and save us all?\n\n---------------------\n\n# Attack mechanics and enemies\n\nWhen you use the attack command, you will attack the enemy right in front of you and deal **the same amount of damage as your attack stat**:\n\n E                         E\n>E    === [Attack] ==>    > \n E                         E\n\n**However**, an enemy can attack you (whatever your orientation is), as long as you are on an adjacent cell to the enemy (vertically or horizontally, not diagonally) and if one of those conditions is fullfilled:\n\n* If you turn your character during the turn.\n* If you move away from them (_D&D's opportunity attack_ :D).\n* If you use a potion. You will still recover your life points, but then you will be attacked.\n\nThe damage formula is `max(0, (Enemy's attack stat) - (Your defense stat))`. Just remember that you attack and use objects **before** the enemies besides you attack. Here is an example where two enemies would attack you:\n\nEEE                        EEE\n >E    === [Attack] ==>     > \nEEE                        EEE\n\nBut enemies are more than obstacles, each time you defeat three of them (demon lord not included), you level up! This level increase will give you **+1 attack** permanently.\n\n# Object usage mechanics\n\nThere are only three cases where it is acceptable to use objects:\n* When you use a key in front of a closed door.\n\n #                          #\n>|    === [Use Key] ==>    > \n #                          #\n\n* When you use a coin in front of a merchant (repeat three times for them to go away).\n\n>M  === [Use Coin] ==>  >M  === [Use Coin] ==>  >M  === [Use Coin] ==> > \n\n* When you refuel your life using a potion (you must have suffered some damage).\n\nAny other object usage is considered **invalid**. Also, this is more or less standard, but you have to walk over an object to pick it up automatically.\n\n---------------------\n\n# Your task\n\nWrite a function `rpg(field: List[List[str]], actions: List[str]) -> Tuple[List[List[str]], int, int, int, List[str]]` that takes the initial state of the game map and a list of actions and returns the new state of the map and the player after executing them in order. All these actions must be valid (no using objects in invalid spots, attacking thin air, going out of bounds, etc), so if any of them turns out not to be valid, return `None`. **Dying counts as an invalid state**.\n\nThe order of the elements of the output tuple is: (`new map state`, `health`, `attack`, `defense`, `sorted bag`)\n\nThe syntax of the actions is as follows:\n* `F` to move forward.\n* `^`, `>`, `v` and `<`to rotate the player.\n* `A` to attack the enemy you have in front of you.\n* `C`, `K` and `H` to use a coin, a key and a health potion, respectively.\n\n**Technical notes:** \n* You **can** mutate the input (and probably should), but it is not necessary.\n* There will only be one Demon Lord per map, but every other tile may be repeated two or even more times.\n* Only the tiles marked as **[object]** will be stored in your bag (i.e. keys, coins and potions).\n* Only valid inputs will be given.\n\n----------------\n\nAs always, I hope you have fun with this kata :)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def rpg : List (List Char) → List Action → Option GameState := sorry\n\ntheorem valid_field_movements {field : List (List Char)} {actions : List Action} \n    (h : rpg field actions ≠ none) :\n  let result := (rpg field actions).get!\n  ∃ dir, dir ∈ ['<', '>', '^', 'v'] ∧ \n  dir ∈ result.field.join := sorry", "vc-theorems": "theorem item_collection {field : List (List Char)} {actions : List Action}\n    (h : rpg field actions ≠ none) :\n  let result := (rpg field actions).get!\n  result.attack ≥ 1 ∧ result.defense ≥ 1 := sorry\n\ntheorem health_bounds {field : List (List Char)} {actions : List Action}\n    (h : rpg field actions ≠ none) :\n  let result := (rpg field actions).get!\n  1 ≤ result.health ∧ result.health ≤ 3 := sorry\n\ntheorem merchant_interaction {field : List (List Char)} {actions : List Action}\n    (h : rpg field actions ≠ none) :\n  let result := (rpg field actions).get!\n  'C' ∉ result.bag := sorry\n\ntheorem combat_outcome {field : List (List Char)} {actions : List Action}\n    (h : rpg field actions ≠ none)\n    (h2 : field.length > 0)\n    (h3 : field[0]!.length > 0) :\n  let result := (rpg field actions).get!\n  result.field[0]![0]! = ' ' ∨ field[0]![0]! = 'E' := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1679", "language": "lean", "source": "fvapps", "source-id": "fvapps_001679", "source-notes": "", "vc-description": "/-\nThis kata is inspired by Tower Defense (TD), a subgenre of strategy video games where the goal is to defend a player's territories or possessions by obstructing enemy attackers, usually by placing defensive structures on or along their path of attack.\n\nObjective\nIt's the future, and hostile aliens are attacking our planet. We've set up a defense system in the planet's outer perimeter. You're tasked with calculating the severity of a breach.\nInput\nYour function will receive three arguments:\n\nBattle Area Map: An array/list of strings representing an n x n battle area.\n        Each string will consist of any of the following characters:\n\n0: entrance point (starting position on alien path)\n1: alien path\n\" \"(space character): not alien path\nA - Z: turret positions\n\nTurret Stats: An object/dict where keys are upper-case characters from the English alphabet (A - Z) and the values are subarrays in the following format:\n[n,m] - where n is the attack range of a turret, and m is its shot frequency per move\nAlien Wave Stats: An array of integers representing each individual alien in sequence. Each value is an integer representing the health points of each alien; health points are the number of turret shots required to take down a given alien. Integer zero (0) counts as a gap in sequence.\n\nOutput\nReturn the integer sum of total health points of all aliens that successfully penetrate our defense.\n\nThe image above shows the game state for the test example (below) at the 11th move.\nThe green square in the north-west quadrant represents the starting position of the alien wave, and the red square in the south-east quadrant represents the last position before breaching the defensive perimeter.\nThe blue circles represent the turret positions and are labeled A,B,C, and D.\nThe red alien is the first alien in the sequence.\nTechnical Details\n\nThere is only one path and it maintains a width of 1.\nAliens move one square per turn\nTurrets only fire toward enemies in range.\n        In the image above, the turret labeled A has the value [3,2], meaning it can fire at aliens that occupy any position within 3 squares' length in Euclidean distance (the pink squares). Turret A will fire 2 times per move.\n        The turret labeled D with the value [1,3] can fire at targets that enter the square above it and the square to the right of it (the blue shaded squares) at a rate of 3 times per move.\nTurret target priority is toward the enemy within shooting range that is furthest along on the path.\n        In the image above, turret A will target the red alien because it is the alien furthest along the path that is also within shooting range. This reduces the alien's health from 8 to 6.\n        The next alien will die from damage taken from turret B, which reduced its health from 4 to 0.\n\nTurret shooting timing: All turrets with a target will fire their first shot in alphabetical order. The remaining turrets that still have more shots available will fire their next shot in alphabetical order once again. This repeats until there are no more shots to fire. This marks the end of the move.\nMatrix size: n x n where 20 >= n >= 7\nAlien list max length: 80\nFull Test Suite: 10 Fixed Tests, 100 Random Tests\nInput will always be valid.\n\nTest Example\n\n```python\nbattlefield = [\n        '0111111',\n        '  A  B1',\n        ' 111111',\n        ' 1     ',\n        ' 1C1111',\n        ' 111 D1',\n        '      1'\n]\nturrets = {'A':[3,2],'B':[1,4],'C':[2,2],'D':[1,3]}\nwave = [30,14,27,21,13,0,15,17,0,18,26]\ntower_defense(battlefield,turrets,wave); #10\n'''\nThe aliens that survive are the alien at wave[7] with an ending health of 2\nand the alien at wave[8] with an ending health of 8.'''\n```\nFor another Tower Defense-style challenge, check out Plants and Zombies\n\nIf you enjoyed this kata, be sure to check out [my other katas](https://www.codewars.com/users/docgunthrop/authored).\n-/", "vc-preamble": "def tower_defense (grid : Array String) (turrets : List (Char × TurretInfo)) \n                  (wave : List Int) : Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def list_sum : List Int → Int \n  | [] => 0\n  | x::xs => x + list_sum xs\n\n/- The tower_defense function returns a non-negative integer result -/", "vc-theorems": "theorem tower_defense_returns_nonneg (grid : Array String) \n        (turrets : List (Char × TurretInfo)) (wave : List Int)\n        (h : turrets.length > 0) :\n  0 ≤ tower_defense grid turrets wave := sorry\n\n/- The tower_defense result is at most the sum of the wave numbers -/\n\ntheorem tower_defense_leq_wave_sum (grid : Array String)\n        (turrets : List (Char × TurretInfo)) (wave : List Int)  \n        (h : turrets.length > 0) :\n  tower_defense grid turrets wave ≤ list_sum wave := sorry\n\n/- The tower_defense function returns 0 for an empty wave -/ \n\ntheorem tower_defense_empty_wave (grid : Array String)\n        (turrets : List (Char × TurretInfo))\n        (h : turrets.length > 0) :\n  tower_defense grid turrets [] = 0 := sorry\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval tower_defense #[\"0111111\", \"  A  B1\", \" 111111\", \" 1     \", \" 1C1111\", \" 111 D1\", \"      1\"] {\"A\": [3, 2], \"B\": [1, 4], \"C\": [2, 2], \"D\": [1, 3]} #[30, 14, 27, 21, 13, 0, 15, 17, 0, 18, 26]\n\n/-\ninfo: 16\n-/\n-- #guard_msgs in\n-- #eval tower_defense #[\"011111\", \"1A   1\", \"111111\"] {\"A\": [1, 2]} #[10, 10]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1684", "language": "lean", "source": "fvapps", "source-id": "fvapps_001684", "source-notes": "", "vc-description": "/-\nYou are in the capital of Far, Far Away Land, and you have heard about this museum where the royal family's crown jewels are on display. Before you visit the museum, a friend tells you to bring some extra money that you'll need to bribe the guards. You see, he says, the crown jewels are in one of 10 rooms numbered from 1 to 10. The doors to these room are kept closed, and each is guarded by a very intimidating guard.\n\nFor security purposes, the jewels are moved every night to a different room. To find out which room they are in, you'll have to ask one of the guards. But first you have to pay him a bribe. After paying him:\n\n  1. If the jewels are behind the door he's guarding, he'll let you in.\n  2. Otherwise, he'll point you in the direction of the correct room by telling you if the room has a higher or lower room number than the room he's guarding.\n\nThe guards have a special rank system, and, depending on rank, the size of the bribe that you'll need to pay to each guard may vary. For example, you may have to pay $1 to the guard at room 1, $2 to the guard at room 2, and so on, up to $10 to the guard at room 10. The bribe amounts are specified by an array/list sorted by room number in ascending order. Hence, in this example, the bribes are given by `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`.\n\nThe problem you need to solve is to determine the minimum amount you may need _in the worst case_ to get into the room with the crown jewels. As a seasoned programmer, you might try doing a binary search. Let's assume that the bribes are as specified in the example above. You first go to the guard standing in front of room 5, and pay him $5. In the worst case the crown jewels are in room 10 and you'll end up paying: $5 + $8 + $9 + $10 = $32. It turns out that a regular binary search is not optimal in this case. You are better off if you first go to room 7. In the worst case the guard will direct you to the right(i.e., higher numbered rooms) and then you go to room 9. Again, in the worst case the guard will direct you to the right, and you go to room 10. In all, you'll have to pay $7 + $9 + $10 = $26. You can easily verify that if the first guard (at room 7) had directed you to the left, you would have ended up paying less than $26. So for this problem, the maximum you will need to pay is $26. There are no other solutions where you would need less in the worst case, so 26 is the solution to this problem instance. \n\nYou are asked to define function `least_bribes(bribes)` that takes as argument an array that contains the bribes that each guard will accept in ascending room number and returns the minumum amount you'll need to spend on bribes _in the worst case_. The problem is not limited to 10 rooms only, so the array `bribes` can be of any length greater or equal to 1. Your code will have to handle arrays up to 100 in length and bribes between $1 and $1000.\n-/", "vc-preamble": "def List.sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum xs\n\ndef List.minimum : (l : List Nat) → l ≠ [] → Nat\n  | [], h => by contradiction\n  | [x], _ => x\n  | (x::y::xs), _ => Nat.min x (minimum (y::xs) (by simp))", "vc-helpers": "", "vc-definitions": "def List.sublist (l : List Nat) (i j : Nat) : List Nat := sorry\n\ndef least_bribes (bribes : List Nat) : Nat := sorry", "vc-theorems": "theorem least_bribes_bounded\n  (bribes : List Nat)\n  (h : bribes ≠ []) :\n  let result := least_bribes bribes\n  result ≤ List.sum bribes ∧ result ≥ List.minimum bribes h := sorry\n\ntheorem least_bribes_increasing\n  (bribes : List Nat)\n  (h : bribes ≠ []) :\n  let increased := bribes.map (· + 1)\n  least_bribes increased > least_bribes bribes := sorry\n\ntheorem least_bribes_subarray\n  (bribes : List Nat)\n  (i j : Nat)\n  (h1 : i < bribes.length)\n  (h2 : j < bribes.length)\n  (h3 : i < j) :\n  let subarray := List.sublist bribes i j\n  least_bribes subarray ≤ least_bribes bribes := sorry\n\n/-\ninfo: 26\n-/\n-- #guard_msgs in\n-- #eval least_bribes [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval least_bribes [5]\n\n/-\ninfo: 20\n-/\n-- #guard_msgs in\n-- #eval least_bribes [10, 10, 10]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1685", "language": "lean", "source": "fvapps", "source-id": "fvapps_001685", "source-notes": "", "vc-description": "/-\nA group of N golfers wants to play in groups of G players for D days in such a way that no golfer plays more than once with any other golfer. For example, for N=20, G=4, D=5, the solution at Wolfram MathWorld is\n\n```\n Mon:   ABCD    EFGH    IJKL    MNOP    QRST\n Tue:   AEIM    BJOQ    CHNT    DGLS    FKPR\n Wed:   AGKO    BIPT    CFMS    DHJR    ELNQ\n Thu:   AHLP    BKNS    CEOR    DFIQ    GJMT\n Fri:   AFJN    BLMR    CGPQ    DEKT    HIOS\n```\n\nWrite a function that validates a proposed solution, a list of list of strings, as being a solution to the social golfer problem. Each character represents a golfer, and each string is a group of players. Rows represent days. The solution above would be encoded as:\n\n```\n [\n  ['ABCD', 'EFGH', 'IJKL', 'MNOP', 'QRST'],\n  ['AEIM', 'BJOQ', 'CHNT', 'DGLS', 'FKPR'],\n  ['AGKO', 'BIPT', 'CFMS', 'DHJR', 'ELNQ'],\n  ['AHLP', 'BKNS', 'CEOR', 'DFIQ', 'GJMT'],\n  ['AFJN', 'BLMR', 'CGPQ', 'DEKT', 'HIOS']\n ]\n```\n\nYou need to make sure (1) that each golfer plays exactly once every day, (2) that the number and size of the groups is the same every day, and (3) that each player plays with every other player *at most* once.\n\nSo although each player must play every day, there can be particular pairs of players that never play together.\n\nIt is not necessary to consider the case where the number of golfers is zero; no tests will check for that. If you do wish to consider that case, note that you should accept as valid all possible solutions for zero golfers, who (vacuously) can indeed play in an unlimited number of groups of zero.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def valid (schedule : List (List (List Char))) : Bool :=\n  sorry", "vc-theorems": "theorem empty_or_valid_structure\n  (schedule : List (List (List Char))) :\n  (schedule = [] ∨ (∃ day ∈ schedule, day = [])) → valid schedule ∧\n  valid schedule →\n    (∀ day ∈ schedule,\n      (∀ day' ∈ schedule, day.length = day'.length) ∧\n      (∀ group ∈ day, ∀ group' ∈ day, group.length = group'.length)) :=\n  sorry\n\ntheorem single_day_valid\n  (schedule : List (List (List Char))) :\n  schedule.length = 1 →\n  valid schedule →\n  ∀ day ∈ schedule,\n    let golfers := List.join day\n    ∀ golfer ∈ golfers,\n      List.length (List.filter (List.elem golfer) day) = 1 :=\n  sorry\n\ntheorem multi_day_valid\n  (schedule : List (List (List Char))) :\n  schedule.length > 1 →\n  valid schedule →\n  let golfers := List.join (List.head! schedule)\n  (∀ day ∈ schedule, List.join day = golfers) ∧\n  (∀ g1 ∈ golfers,\n   ∀ g2 ∈ golfers,\n   g1 ≠ g2 →\n   ∀ day1 ∈ schedule,\n   ∀ group1 ∈ day1,\n   group1.contains g1 ∧ group1.contains g2 →\n   ∀ day2 ∈ schedule,\n   ∀ group2 ∈ day2,\n   day1 ≠ day2 →\n   ¬(group2.contains g1 ∧ group2.contains g2)) :=\n  sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval valid [[\"ABCD\", \"EFGH\", \"IJKL\", \"MNOP\", \"QRST\"], [\"AEIM\", \"BJOQ\", \"CHNT\", \"DGLS\", \"FKPR\"], [\"AGKO\", \"BIPT\", \"CFMS\", \"DHJR\", \"ELNQ\"], [\"AHLP\", \"BKNS\", \"CEOR\", \"DFIQ\", \"GJMT\"], [\"AFJN\", \"BLMR\", \"CGPQ\", \"DEKT\", \"HIOS\"]]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval valid [[\"AB\", \"AC\"]]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval valid [[\"AB\", \"CD\"], [\"AB\", \"CD\"]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1687", "language": "lean", "source": "fvapps", "source-id": "fvapps_001687", "source-notes": "", "vc-description": "/-\nWe all know how to handle exceptions in Python. Just use:\n\n    try:\n        num = float(input())\n    except ValueError:\n        print(\"That's not a number!\")\n    else:\n        print(num)\n\nCode such as this\n\n    def factorial(x, n = 1):\n        if x == 0:\n          raise ValueError(n)\n        factorial(x - 1, n * x)\n\nrelies on ridiculous exception misuse, but you can't change it because that would require a complete refactor. Code such as this\n\n    try:\n        return int(input(\"Input a number: \")\n    except ValueError:\n        return 4 # random number\n\nrelies on reasonable exception use - almost all of the Python documentation examples are written in this way.\n\nWhat if you are using a faulty implementation of Embedded Python that doesn't implement the `try` statement? Where `sys.excepthook` is a hard-coded, unoverrideable value? Where even `__file__` is not defined? How do you use basic functions like `list.index`?\n\nYour task is to write a function that can handle exceptions raised in a program or function _without_ using `try` or `except`. Somehow.\n\nThe first argument of your function `handle` will be a `lambda` requiring no parameters. You will call this function and handle any exceptions raised. The second argument will be a callable `success`:\n\n    def success(func, val):\n        pass\n\nThe third argument will be a callable `failure`:\n\n    def failure(func, exc):\n        pass\n\nSubsequent arguments will be exceptions. If instances of these exceptions are raised, you must call the handler and no error message must be printed to `stderr`. If the exception raised is not provided as an argument, it should appear as though the exception was never caught.\n\nPass the return value of `func` to `success` unless it raises an exception. If it raises an exception that `isinstance` of an exception class passed to `handle`, call `failure` with an instance of the raised exception.\n\nDon't worry about the little things like dealing with the extra arguments to exceptions or maintaining the call stack. Whoever writes code like _that_ deserves the extra work.\n\n## What does \"catching an exception\" mean?\nIt means:\n\n  * The exception will not be printed to `stderr`.\n  * Code can continue to be executed.\n  * The `failure` callable knows what the exception was.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def handle (f : Unit → α) (onSuccess : (Unit → α) → α → β) \n    (onFailure : (Unit → α) → Exception → β) (excType : Type) : β := sorry", "vc-theorems": "theorem handle_no_exception {α β : Type} [Inhabited α] [Inhabited β] {x : α} \n    (f : Unit → α) (s : (Unit → α) → α → β) (fail : (Unit → α) → Exception → β) \n    (exc : Type) (h : f = fun _ => x) :\n  handle f s fail exc = s f x := sorry\n\ntheorem handle_with_failure {α β : Type} [Inhabited α] [Inhabited β] {msg : String} \n    (f : Unit → α) (s : (Unit → α) → α → β) (fail : (Unit → α) → Exception → β) :\n  handle f s fail ValueError = fail f (ValueError.mk msg) := sorry\n\ntheorem handle_wrong_exception {α β : Type} [Inhabited α] [Inhabited β]\n    (f : Unit → α) (s : (Unit → α) → α → β) (fail : (Unit → α) → Exception → β)\n    (h : f = fun _ => default) :\n  handle f s fail Exception = default := sorry\n\ntheorem handle_custom_callbacks {x : Nat}\n    (f : Unit → Nat)\n    (s : (Unit → Nat) → Nat → Nat) \n    (fail : (Unit → Nat) → Exception → Nat)\n    (h : f = fun _ => x)\n    (h₂ : s = fun _ v => 2 * v) :\n  handle f s fail Exception = 2 * x := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1688", "language": "lean", "source": "fvapps", "source-id": "fvapps_001688", "source-notes": "", "vc-description": "/-\n## A Knight's Tour\n\nA knight's tour is a sequence of moves of a knight on a chessboard such that the knight visits every square only once.\n\nhttps://en.wikipedia.org/wiki/Knight%27s_tour\n\nTraditional chess boards are 8x8 grids, but for this kata we are interested in generating tours for any square board sizes.\n\nYou will be asked to find a knight's path for any NxN board from any start position.\n\nI have provided a tool to visualize the output of your code at the following link: http://jsfiddle.net/7sbyya59/2/\n\nEDIT: The expected output is a 2D array `(n x 2)` comprised of the `[x,y]` coordinates of the Knight's path taken in sequential order. (e.g. `[[2,3],[4,4],...,[x,y]]`)\n\nAll test cases will have a passing solution.\n\n-dg\n-/", "vc-preamble": "def knights_tour (start : Pos) (size : Nat) : List Pos :=\n  sorry", "vc-helpers": "", "vc-definitions": "def is_valid_knight_move (p1 p2 : Pos) : Bool :=\n  let dx := if p1.x ≥ p2.x then p1.x - p2.x else p2.x - p1.x\n  let dy := if p1.y ≥ p2.y then p1.y - p2.y else p2.y - p1.y\n  (dx == 2 && dy == 1) || (dx == 1 && dy == 2)", "vc-theorems": "theorem knights_tour_returns_valid_path (start : Pos) (size : Nat) \n    (h1 : size ≥ 5) (h2 : start.x < size) (h2' : start.y < size) :\n    let path := knights_tour start size\n    -- Path has correct length\n    (path.length = size * size) ∧ \n    -- Starts at given position\n    (path.head? = some start) ∧\n    -- All positions are within bounds\n    (∀ p ∈ path, p.x < size ∧ p.y < size) ∧\n    -- All positions are unique\n    (∀ i j, i < path.length → j < path.length → i ≠ j → path.get! i ≠ path.get! j) ∧\n    -- All moves are valid knight moves\n    (∀ i, i < path.length - 1 → is_valid_knight_move (path.get! i) (path.get! (i+1))) := by\n  sorry\n\ntheorem small_boards_sequential (size : Nat) (h : size ≤ 4) :\n    let start := ⟨0,0⟩\n    let path := knights_tour start size\n    let expected := (List.range size).bind (fun x => \n      (List.range size).map (fun y => ⟨x,y⟩))\n    path = expected := by\n  sorry\n\n/-\ninfo: 25\n-/\n-- #guard_msgs in\n-- #eval len knights_tour((0, 0), 5)\n\n/-\ninfo: 36\n-/\n-- #guard_msgs in\n-- #eval len knights_tour((2, 2), 6)\n\n/-\ninfo: 64\n-/\n-- #guard_msgs in\n-- #eval len knights_tour((0, 0), 8)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1690", "language": "lean", "source": "fvapps", "source-id": "fvapps_001690", "source-notes": "", "vc-description": "/-\n_yet another easy kata!_\n\n_Bored of usual python katas? me too;_\n\n## Overview\n\n     As you have guessed from the title of the kata you are going to implement a class that supports ***function overloading***. You might be thinking python doesn't support that thing... Of course python doesn't support that! So you have to implement that missing functionality.\n\n     To achieve that You have to implement the `Meta` class which will be the metaclass of `Overload` class (see sample tests) and class that use `Meta` should work as usual at other things.\n\n## The Goal\n\n```python\n\nclass Overload(metaclass=Meta):\n\n    CLS_VAR = 42\n\n    def __init__(self):\n        self.a = 1\n        self.no = 'This is \"No parameter\" function.'\n        self.single = 'This is \"Single parameter\" function'\n        self.two = 'This is \"Two parameter\" function'\n        self.three = 'This is \"Three parameter\" function'\n\n    def foo(self):\n        return self.no\n\n    def foo(self, x):\n        return self.single + ':' + str(x)\n\n    def foo(self, x, y):\n        return self.two + ':' + str(x) + ',' + str(y)\n\n    def foo(self, x, y, z):\n        return self.three + ':' + str(x) + ',' + str(y) + ',' + str(z)\n\n    def extra(self):\n        return 'This is extra method.'\n\n  obj = Overload()\n\n  Overload.foo=lambda self,a,b,c,d: 'from outside!'\n\n  obj.foo()            # 'This is \"No parameter\" function.'\n  obj.foo(1, 2)        # 'This is \"Two parameter\" function:1,2'\n  obj.foo(1, 2, 3)     # 'This is \"Three parameter\" function:1,2,3'\n  obj.foo(1, 2, 3, 4)  # 'from outside!'\n```\n\n## Specifications\n\n   * The Overload base class will always be the same as above. It will be regenerated different times in the tests, for testing purpose.\n   * All the other methods will be added and tested **after instanciation** the class like shown in the example above (***Focus on this point; you will need this***).\n   * Only instance methods will be tested, no static or class level methods.\n   * There is no testing for either `*varargs` or `**kwargs`.\n   * Aside from overloading, the class should behave just like usual. Talking here about variable assginment or reassignment, at class or instance level, reassigning a method to a var or the opposite, ...\n   * If there is neither a method (overloaded or not) which satisfies the expected number of arguments nor a property or class level property that cn be found when calling for an attribute, raise an exception of type `AttributeError` (\"just like usual\", as said above...)\n   * Last but not least, different classes must not share overloaded method. Hence:\n\n```python\nCls1 = generate_Overload()\nobj = Cls1()\nCls1.foo=lambda self,a,b,c,d: 'from Cls1'\n\nCls2 = generate_Overload()\nobj2 = Cls2()\nCls2.foo=lambda self,a,b,c,d: 'from Cls2'\n\nobj.foo(1,2,3,4)    # -> 'from Cls1'\nobj2.foo(1,2,3,4)   # -> 'from Cls2'\n\nCls2.foo=lambda self: 'updated'\n\nobj.foo()           # -> 'This is \"No parameter\" function.'\nobj2.foo()          # -> 'updated'\n```\n\n## Notes\n\n   * If there are any flaw in testing then report me.\n   * If you need some hints then ping me in discourse.\n\n_Enjoy!_\n\n_Thanks to B4B for his contribution._\n\n_I can assure you that this can be done without using any library/modules._\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem method_isolation_diff \n  (a : α) (b : β) (h : (Meta.foo a) ≠ (Meta.foo b)) :\n  ∃ (f : α → String), \n    Meta.foo a = f a ∧ \n    Meta.foo b = Meta.foo b := by\n  sorry\n\ntheorem method_isolation_update\n  (a : α) (b : β) (f : α → String) :\n  ∃ (g : α → String), g a = f a ∧ Meta.foo b = Meta.foo b := by\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1691", "language": "lean", "source": "fvapps", "source-id": "fvapps_001691", "source-notes": "", "vc-description": "/-\n# Task\n\nYou are given a `chessBoard`, a 2d integer array that contains only `0` or `1`. `0` represents a chess piece and `1` represents a empty grid. It's always square shape.\n\nYour task is to count the number of squares made of empty grids.\n\nThe smallest size of the square is `2 x 2`. The biggest size of the square is `n x n`, where `n` is the size of chess board. \n\nA square can overlap the part of other squares. For example:\n\nIf\n\n```\nchessBoard=[\n  [1,1,1],\n  [1,1,1],\n  [1,1,1]\n]\n```\n\n...there are four 2 x 2 squares in the chess board:\n\n```\n[1,1, ]  [ ,1,1]  [ , , ]  [ , , ]\n[1,1, ]  [ ,1,1]  [1,1, ]  [ ,1,1]\n[ , , ]  [ , , ]  [1,1, ]  [ ,1,1]\n```\n\nAnd one 3 x 3 square:\n```\n[1,1,1]\n[1,1,1]\n[1,1,1]\n```\n\nYour output should be an object/dict. Each item in it should be: `size:number`, where size is the square's size, and number is the number of squares. \n\nFor example, if there are four `2 x 2` squares and one `3 x 3` square in the chess board, the output should be: `{2:4,3:1}` (or any equivalent hash structure in your language). The order of items is not important, `{3:1,2:4}` is also a valid output.\n\nIf there is no square in the chess board, just return `{}`.\n\n# Note\n\n```if:javascript\n- `2 <= chessBoard.length <= 400`\n```\n```if:python\n- `2 <= chessBoard.length <= 120`\n```\n```if:ruby\n- `2 <= chessBoard.length <= 130`\n```\n```if:java\n- `2 <= chessBoard.length <= 250`\n```\n```if:haskell\n- `2 <= chessBoard.length <= 120`\n```\n```if:csharp\n- `2 <= chessBoard.Length <= 220`\n```\n\n- `5` fixed testcases\n\n- `100` random testcases, testing for correctness of solution\n\n- `100` random testcases, testing for performance of code\n\n- All inputs are valid.\n\n- Pay attention to code performance.\n\n- If my reference solution gives the wrong result in the random tests, please let me know(post an issue). \n\n# Example\n\nFor \n```\nchessBoard = [\n  [1,1],\n  [1,1]\n]\n```\n\nthe output should be `{2:1}`.\n\nFor \n```\nchessBoard = [\n  [0,1],\n  [1,1]\n]\n```\n\nthe output should be `{}`.\n\nFor \n```\nchessBoard = [\n  [1,1,1],\n  [1,1,1],\n  [1,1,1]\n]\n```\n\nthe output should be `{2:4,3:1}`.\n\nFor \n```\nchessBoard = [\n  [1,1,1],\n  [1,0,1],\n  [1,1,1]\n]\n```\n\nthe output should be `{}`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count (board : List (List Int)) : List SquareCount := sorry\n\ntheorem count_square_ones_board \n  {n : Nat} (h : n ≥ 2)\n  (board : List (List Int))\n  (h_board : board.length = n ∧ ∀ row ∈ board, row.length = n)\n  (h_ones : ∀ i j, i < n → j < n → board[i]![j]! = 1) :\n  ∀ size, 2 ≤ size → size ≤ n → \n    let result := count board\n    ∃ sc ∈ result, sc.size = size ∧ sc.count = (n - size + 1) ^ 2 := sorry", "vc-theorems": "theorem count_preserves_input\n  {rows cols : Nat} (h : rows ≥ 1 ∧ cols ≥ 1)\n  (board : List (List Int)) \n  (h_board : board.length = rows ∧ ∀ row ∈ board, row.length = cols) :\n  let board' := board\n  count board = count board' ∧ board = board' := sorry\n\n/-\ninfo: {2: 1}\n-/\n-- #guard_msgs in\n-- #eval count [[1, 1], [1, 1]]\n\n/-\ninfo: {2: 4, 3: 1}\n-/\n-- #guard_msgs in\n-- #eval count [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n\n/-\ninfo: {}\n-/\n-- #guard_msgs in\n-- #eval count [[1, 1, 1], [1, 0, 1], [1, 1, 1]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1698", "language": "lean", "source": "fvapps", "source-id": "fvapps_001698", "source-notes": "", "vc-description": "/-\npre.handle{\n      height: 2em;\n      width: 4em;\n      margin: auto;\n      margin-bottom: 0 !important;\n      background: none !important;\n\n      border-radius: 0.5em 0.5em 0 0; \n      border-top: 5px solid saddlebrown;\n      border-left: 5px solid saddlebrown;\n      border-right: 5px solid saddlebrown;\n  }\n\n  table.example-piece{\n      width: fit-content;\n      height: fit-content;\n\n      margin: auto;\n  }\n\n  pre.piece{\n      font-size: 1.75em;\n      line-height: 1.4;\n      letter-spacing: 0.1em;\n\n      background: none !important;\n  }\n\n  pre.bag{\n      border-radius: 0.5em; \n      border:5px solid saddlebrown; \n      width: fit-content; \n      background: burlywood;\n\n      font-size: 1.75em;\n      line-height: 1.4;\n      letter-spacing: 0.1em;\n      color: white;\n      text-align: center;\n\n      margin: auto;\n      padding: 0.2em;\n\n  }\n\n  pre b{\n      padding: 0.1em;  \n  }\n\n  .a{ background: darkolivegreen; }\n  .b{ background: seagreen;}\n  .c{ background: limegreen; }\n  .d{ background: darkgreen; }\n\n# On a business trip, again...\n\nI love traveling, just like everyone else. If only they were not business trips... They force me to go to places I don't want to go and listen to people that I don't care about. But, by far, the thing I hate the most is **packing my bag**.\n\nThe thing is, I can only carry one bag in the plane and I **NEED** to bring some important items. Every item is numbered and has a specific shape. Here is an example of a well-sorted bag:\n\n11112233\n14444233\n14442223\n\nWill I be able to fit all the items I need in the bag?\n\n# Your task\n\nWrite a funtion `fit_bag(height: int, width: int, items: List[List[List[int]]]) -> List[List[int]]` that takes a bag height and width and a list of items and returns a bag with all the items in a correct place.\n\nThe pieces will be given as a square bidimensional array that represents items as follows:\n\n1111\n1\n1\n\n → \n\n[\n  [1, 1, 1, 1],\n  [1, 0, 0, 0],\n  [1, 0, 0, 0]\n]\n\n4444\n444\n\n → \n\n[\n  [4, 4, 4, 4],\n  [4, 4, 4, 0],\n]\n\nAnd, as you may have guessed, the output is represented the same way as the pieces, but it will contain the numbers of all the pieces and zeroes in the case of empty spaces. The thing is, **you cannot rotate the pieces nor flip them**.\n\n4444\n444\n\n → \n\n4\n44\n44\n44\n\n ✖ \n\n**Technical notes:**\n* Items will only contain zeroes (for empty spaces) and another number that identifies the item.\n* Items will not have rows or columns of zeros at the borders. If an item's matrix is of size *n*x*m*, this means the object has a bounding box of *n*x*m*.\n* There will be no two items with the same number.\n* There will never be more than 9 items.\n* Items do not necessarily have to be one connected component.\n* The only condition for your solution to be valid is that there has to be at least one instance of each requested item. There can be empty spaces (represented by zeroes) or repeated items.\n* Every test case **is solvable**.\n\n# Preloaded code\n\nYou are given two functions for debugging purposes:\n\n* `only_show_wrong()`: disable the bag print of the test cases that you solved successfully. Use this only once at the beginning or your code.\n* `print_bag(bag)`: this function prints a bag in a human-readable format for debugging purposes. It is done by default in every test case unless it is disabled.\n\n# Tests\n\nHere are the tests that will be done:\n* **Fixed tests (respectively):** bags of sizes 3x8, 3x6, 3x5, 3x7, 3x8 and 5x9. Six tests of each with 4 to 8 items.\n* **Random tests:** 300 5x9 bags tests with 7 to 9 items.\n-/", "vc-preamble": "def fit_bag (height width : Nat) (items : List (List (List Nat))) : List (List Nat) := sorry\n\n/- Each row in the result bag has the same width -/", "vc-helpers": "", "vc-definitions": "def IsConnected (grid : List (List Nat)) (i j i' j' : Nat) : Prop := sorry\n\n/- The items form connected shapes (no diagonals) -/", "vc-theorems": "theorem fit_bag_uniform_width (height width : Nat) (items : List (List (List Nat))) \n  (result := fit_bag height width items) :\n  ∀ row ∈ result, List.length row = width := sorry\n\n/- Each number in the items appears exactly once in the result -/\n\ntheorem fit_bag_items_appear_once (height width : Nat) (items : List (List (List Nat))) \n  (result := fit_bag height width items) :\n  ∀ item ∈ items, ∀ val : Nat,\n    (val ∈ (List.join item) ∧ val ≠ 0) →\n    (List.countP (λ x => x = val) (List.join result) = \n     List.countP (λ x => x = val) (List.join item)) := sorry\n\ntheorem fit_bag_items_connected (height width : Nat) (items : List (List (List Nat))) \n  (result := fit_bag height width items) :\n  ∀ item ∈ items, ∀ val : Nat,\n    val ∈ (List.join item) →\n    val ≠ 0 → \n    ∀ i j i' j', \n      i < List.length item ∧ j < List.length (List.get! item i) ∧\n      i' < List.length item ∧ j' < List.length (List.get! item i') ∧\n      List.get! (List.get! item i) j = val ∧\n      List.get! (List.get! item i') j' = val →\n      IsConnected item i j i' j' := sorry\n\n/- The result has the specified dimensions -/\n\ntheorem fit_bag_dimensions (height width : Nat) (items : List (List (List Nat))) \n  (result := fit_bag height width items) :\n  List.length result = height ∧\n  ∀ row ∈ result, List.length row = width := sorry\n\n/- All numbers in result appear in original items -/\n\ntheorem fit_bag_valid_numbers (height width : Nat) (items : List (List (List Nat))) \n  (result := fit_bag height width items) :\n  ∀ x ∈ List.join result,\n    x = 0 ∨ ∃ item ∈ items, x ∈ List.join item := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1702", "language": "lean", "source": "fvapps", "source-id": "fvapps_001702", "source-notes": "", "vc-description": "/-\nThe Vigenère cipher is a classic cipher originally developed by Italian cryptographer Giovan Battista Bellaso and published in 1553. It is named after a later French cryptographer Blaise de Vigenère, who had developed a stronger autokey cipher (a cipher that incorporates the message of the text into the key). \n\nThe cipher is easy to understand and implement, but survived three centuries of attempts to break it, earning it the nickname \"le chiffre indéchiffrable\" or \"the indecipherable cipher.\"\n\n[From Wikipedia](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher):\n\n> The Vigenère cipher is a method of encrypting alphabetic text by using a series of different Caesar ciphers based on the letters of a keyword. It is a simple form of polyalphabetic substitution.\n>\n> . . .\n>\n> In a Caesar cipher, each letter of the alphabet is shifted along some number of places; for example, in a Caesar cipher of shift `3`, `A` would become `D`, `B` would become `E`, `Y` would become `B` and so on. The Vigenère cipher consists of several Caesar ciphers in sequence with different shift values.\n\nAssume the key is repeated for the length of the text, character by character. Note that some implementations repeat the key over characters only if they are part of the alphabet -- **this is not the case here.**\n\nThe shift is derived by applying a Caesar shift to a character with the corresponding index of the key in the alphabet.\n\nVisual representation:\nWrite a class that, when given a key and an alphabet, can be used to encode and decode from the cipher.\n\n## Example\nAny character not in the alphabet must be left as is. For example (following from above):\n-/", "vc-preamble": "def isLower (c : Char) : Bool := sorry\ndef isUpper (c : Char) : Bool := sorry", "vc-helpers": "", "vc-definitions": "def toLower (c : Char) : Char := sorry\ndef charInString (c : Char) (s : String) : Bool := sorry", "vc-theorems": "theorem encode_decode_roundtrip (cipher : VigenereCipher) (text : String) :\n  cipher.decode (cipher.encode text) = text := sorry\n\ntheorem case_preservation (cipher : VigenereCipher) (text encoded : String)\n  (h1 : encoded = cipher.encode text) \n  (h2 : ∃ i c1 c2, text.get? i = some c1 ∧ encoded.get? i = some c2 ∧ charInString (toLower c1) cipher.alphabet) :\n  ∀ i c1 c2, text.get? i = some c1 → encoded.get? i = some c2 → charInString (toLower c1) cipher.alphabet →\n  isUpper c1 = isUpper c2 := sorry \n\ntheorem special_char_preservation (cipher : VigenereCipher) (text encoded : String)\n  (h1 : encoded = cipher.encode text)\n  (h2 : ∃ i c1 c2, text.get? i = some c1 ∧ encoded.get? i = some c2 ∧ ¬charInString (toLower c1) cipher.alphabet) :\n  ∀ i c1 c2, text.get? i = some c1 → encoded.get? i = some c2 → ¬charInString (toLower c1) cipher.alphabet →\n  c1 = c2 := sorry\n\ntheorem empty_string (cipher : VigenereCipher) :\n  cipher.encode \"\" = \"\" ∧ cipher.decode \"\" = \"\" := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1705", "language": "lean", "source": "fvapps", "source-id": "fvapps_001705", "source-notes": "", "vc-description": "/-\ntable {\n        width: 236px;\n    }\n\n    table, tr, td {\n        border: 0px;\n    }\n\nIn a grid of 4 by 4 squares you want to place a skyscraper in each square with only some clues:\n\nThe height of the skyscrapers is between 1 and 4\nNo two skyscrapers in a row or column may have the same number of floors\nA clue is the number of skyscrapers that you can see in a row or column from the outside\nHigher skyscrapers block the view of lower skyscrapers located behind them\n\nCan you write a program that can solve this puzzle?\n\nExample:\n\nTo understand how the puzzle works, this is an example of a row with 2 clues. Seen from the left side there are 4 buildings visible while seen from the right side only 1:\n\n 4\n\n 1\n\nThere is only one way in which the skyscrapers can be placed. From left-to-right all four buildings must be visible and no building may hide behind another building:\n\n 4\n 1\n 2\n 3\n 4\n 1\n\nExample of a 4 by 4 puzzle with the solution:\n\n 1\n 2\n\n 2\n\n 1\n\n 3\n\n 1\n 2\n\n 2\n 1\n 4\n 3\n\n 3\n 4\n 1\n 2\n 2\n\n 1\n 4\n 2\n 3\n 1\n\n 1\n 3\n 2\n 4\n\n 3\n\nTask:\n\nFinish:\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_puzzle (clues : List Nat) : Option Board :=\nsorry", "vc-theorems": "theorem solution_dimensions {clues : List Nat} {sol : Board} \n  (h : solve_puzzle clues = some sol) : \n  sol.rows.length = 4 ∧ ∀ row, row ∈ sol.rows → row.length = 4 :=\nsorry\n\ntheorem solution_value_range {clues : List Nat} {sol : Board}\n  (h : solve_puzzle clues = some sol) :\n  ∀ row, row ∈ sol.rows → ∀ x, x ∈ row → 1 ≤ x ∧ x ≤ 4 :=\nsorry \n\ntheorem solution_row_uniqueness {clues : List Nat} {sol : Board}\n  (h : solve_puzzle clues = some sol) :\n  ∀ row, row ∈ sol.rows → \n  ∀ x y, x ∈ row → y ∈ row → x ≠ y → \n  List.indexOf x row ≠ List.indexOf y row :=\nsorry\n\ntheorem solution_col_uniqueness {clues : List Nat} {sol : Board}\n  (h : solve_puzzle clues = some sol) :\n  ∀ i j : Nat, i < 4 → j < 4 → i ≠ j →\n  ∀ col : List Nat, \n  (col = sol.rows.map (λ row => row[i]!)) →\n  col[i]! ≠ col[j]! :=\nsorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval solve_puzzle (2, 2, 1, 3, 2, 2, 3, 1, 1, 2, 2, 3, 3, 2, 1, 3)\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval solve_puzzle (0, 0, 1, 2, 0, 2, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1712", "language": "lean", "source": "fvapps", "source-id": "fvapps_001712", "source-notes": "", "vc-description": "/-\nThe Challenge\n-------------\nYou'll need to implement a simple lexer type. It should take in an input string through the constructor (or the parameter, for Javascript), and break it up into typed-tokens (in python, C# and Java, you'll have to manage `null/None` input too, resulting in the same behavior than an empty string). You'll need to implement the necessary methods (aaccording to your language) to make the Simplexer object behave like an iterator, Meaning that it returns a token (assuming one is available) object each time it a `next` (`Current` field in C#) method would be called. If no tokens are available, an exception should be thrown (idealy: `StopIteration` in python, `InvalidOperationException` in C# and `NoSuchElementException` in Java).\n\nTokens are represented by Token objects, which define two properties as strings: `text`, and `type`. Constructor is `Token(text, type)`.\n\n**C# Notes**:\n`Iterator` is an extension of `IEnumerator` with default implementations for `Reset()`, `Dispose()` and `IEnumerator.Current` as these are not need to pass the challenge. You only need to override `MoveNext()` and `Current { get; }`.\n\nToken Types\n-----------\nThere are 7 tokens types that your lexer will need to produce: `identifier`, `string`, `integer`, `boolean`, `keyword`, `operator`, and `whitespace`. To create the token, you'd need to pass in the token value (the text) and the token type as strings, so for example, a simple integer token could be created with `new Token(\"1\", \"integer\")` (Note: no default values or default constructor are provided, so use `new Token(\"\",\"\")` if you want a default Token object).\n\nToken Grammar\n--------------\nHere's a table of the grammars for the various token types:\n```\ninteger : Any sequence of one or more digits.\n\nboolean : true or false.\n\nstring : Any sequence of characters surrounded by \"double quotes\".\n\noperator : The characters +, -, *, /, %, (, ), and =.\n\nkeyword : The following are keywords: if, else, for, while, return, func, and break.\n\nwhitespace : Matches standard whitespace characters (space, newline, tab, etc.)\nConsecutive whitespace characters should be matched together.\n\nidentifier : Any sequence of alphanumber characters, as well as underscore and dollar sign,\nand which doesn't start with a digit. Make sure that keywords aren't matched as identifiers!\n```\n-/", "vc-preamble": "def Simplexer : Type := String → List Token\ndef empty : Simplexer := sorry", "vc-helpers": "", "vc-definitions": "def scan : String → Token := sorry\n\ntheorem empty_simplexer : \n  empty \"\" = [] := sorry", "vc-theorems": "theorem integer_token :\n  scan \"123\" = ⟨\"123\", \"integer\"⟩ := sorry\n\ntheorem identifier_token :\n  scan \"abc\" = ⟨\"abc\", \"identifier\"⟩ := sorry\n\ntheorem keyword_token :\n  scan \"if\" = ⟨\"if\", \"keyword\"⟩ := sorry\n\ntheorem whitespace_token :\n  scan \" \" = ⟨\" \", \"whitespace\"⟩ := sorry\n\ntheorem operator_token :\n  scan \"+\" = ⟨\"+\", \"operator\"⟩ := sorry\n\ntheorem boolean_token :\n  scan \"true\" = ⟨\"true\", \"boolean\"⟩ := sorry\n\n/-\ninfo: len(expected_tokens)\n-/\n-- #guard_msgs in\n-- #eval len list(lexer)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1714", "language": "lean", "source": "fvapps", "source-id": "fvapps_001714", "source-notes": "", "vc-description": "/-\n[Currying and partial application](http://www.2ality.com/2011/09/currying-vs-part-eval.html) are two ways of transforming a function into another function with a generally smaller arity. While they are often confused with each other, they work differently. The goal is to learn to differentiate them.\n\n## Currying\n\n> Is the technique of transforming a function that takes multiple arguments in such a way that it can be called as a chain of functions each with a single argument.\n\nCurrying takes a function:\n\n```\nf: X × Y → R\n```\n\nand turns it into a function:\n\n```\nf': X → (Y → R)\n```\n\nInstead of calling `f` with two arguments, we invoke `f'` with the first argument. The result is a function that we then call with the second argument to produce the result. Thus, if the uncurried `f` is invoked as:\n\n```\nf(3, 5)\n```\n\nthen the curried `f'` is invoked as:\n\n`f'(3)(5)`\n\n### Example\n\nGiven this function:\n\n```python\ndef add(x, y, z):\n  return x + y + z\n```\n\nWe can call in a normal way:\n\n```python\nadd(1, 2, 3) # => 6\n```\n\nBut we can create a curried version of `add(a, b, c)`function:\n\n```python\ncurriedAdd = lambda a: (lambda b: (lambda c: add(a,b,c)))\ncurriedAdd(1)(2)(3) # => 6\n```\n\n## Partial application\n\n> Is the process of fixing a number of arguments to a function, producing another function of smaller arity.\n\nPartial application takes a function:\n\n```\nf: X × Y → R\n```\n\nand a fixed value `x` for the first argument to produce a new function\n\n```\nf': Y → R\n```\n\n`f'` does the same as `f`, but only has to fill in the second parameter which is why its arity is one less than the arity of `f`. One says that the first argument is bound to `x`.\n\n### Example\n\n```python\npartialAdd = lambda a: (lambda *args: add(a,*args))\npartialAdd(1)(2, 3) # => 6\n```\n\n-------------\n\nYour work is to implement a generic `curryPartial()` function allows either currying or partial application.\n\nFor example:\n\n```python\ncurriedAdd = curryPartial(add)\ncurriedAdd(1)(2)(3) # => 6\n\npartialAdd = curryPartial(add, 1)\npartialAdd(2, 3) # => 6\n```\n\nWe want the function be very flexible.\n\nAll these examples should produce the same result:\n\n```python\ncurryPartial(add)(1)(2)(3) # =>6 \ncurryPartial(add, 1)(2)(3) # =>6 \ncurryPartial(add, 1)(2, 3) # =>6 \ncurryPartial(add, 1, 2)(3) # =>6 \ncurryPartial(add, 1, 2, 3) # =>6 \ncurryPartial(add)(1, 2, 3) # =>6 \ncurryPartial(add)(1, 2)(3) # =>6 \ncurryPartial(add)()(1, 2, 3) # =>6 \ncurryPartial(add)()(1)()()(2)(3) # =>6 \n\ncurryPartial(add)()(1)()()(2)(3, 4, 5, 6) # =>6 \ncurryPartial(add, 1)(2, 3, 4, 5) # =>6 \n```\n\nAnd also all of these:\n\n```python\ncurryPartial(curryPartial(curryPartial(add, 1), 2), 3) # =>6\ncurryPartial(curryPartial(add, 1, 2), 3) # =>6\ncurryPartial(curryPartial(add, 1), 2, 3) # =>6\ncurryPartial(curryPartial(add, 1), 2)(3) # =>6\ncurryPartial(curryPartial(add, 1)(2), 3) # =>6\ncurryPartial(curryPartial(curryPartial(add, 1)), 2, 3) # =>6\n```\n-/", "vc-preamble": "def add2 (x y : Int) : Int :=\n  sorry\n\ndef add3 (x y z : Int) : Int :=\n  sorry\n\ndef concat3 (x y z : α) : String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def curry_partial : ((α → β) → (α → β)) :=\n  sorry", "vc-theorems": "theorem curry_preserves_binary_function (x y : Int) :\n  curry_partial add2 x y = add2 x y :=\n  sorry\n\ntheorem curry_preserves_ternary_function (x y z : Int) :\n  curry_partial add3 x y z = add3 x y z :=\n  sorry\n\ntheorem partial_application_preserves_result_1 (x y z : Int) :\n  curry_partial add3 x y z = add3 x y z :=\n  sorry\n\ntheorem partial_application_preserves_result_2 (x y z : Int) :\n  curry_partial (curry_partial add3 x) y z = add3 x y z :=\n  sorry\n\ntheorem nested_curry_calls (x y z : Int) :\n  curry_partial (curry_partial (curry_partial add3 x) y) z = add3 x y z :=\n  sorry\n\ntheorem curry_works_with_different_types {α : Type} (x y z : α) :\n  curry_partial concat3 x y z = concat3 x y z :=\n  sorry\n\nend CurryPartial", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1720", "language": "lean", "source": "fvapps", "source-id": "fvapps_001720", "source-notes": "", "vc-description": "/-\nA \"graph\" consists of \"nodes\", also known as \"vertices\". Nodes may or may not be connected with one another. \nIn our definition below the node \"A0\" is connected with the node \"A3\", but \"A0\" is not connected with \"A1\".\n\nThe connecting line between two nodes is called an edge. If the edges between the nodes are undirected, \nthe graph is called an undirected graph. A weighted graph is a graph in which a number (the weight) is assigned to each edge.\nA graph is acyclic if it has no loop.\n\nA graph can be represented as a dictionary:\n\n`graph = {'A0': [('A3', 1), ('A5', 4)], \n 'A1': [('A2', 2)], \n 'A2': [('A1', 1), ('A2', 2), ('A3', 1), ('A4', 1)],\n 'A3': [('A0', 1), ('A2', 1)], \n 'A4': [('A2', 1), ('A4', 1)], \n 'A5': [('A3', 3)]\n}`\n\nHere the nodes are A0...A5; following each nodes is the edges list of linked nodes with their weight.\nA0 is linked to A3 with a weight of 1 and to A5 with weight 4. A dictionary is not ordered but the list\nof linked nodes is sorted. So: \n\n`'A0': [('A3', 1), ('A5', 4)]`is correct but `'A0': [('A5', 4), ('A3', 1)]`is not.\n\nThe edges E of a graph G induce a binary relation that is called the adjacency relation of G.\nOne can associate an adjacency matrix:\n\n`M = \n[[0, 0, 0, 1, 0, 4], \n [0, 0, 2, 0, 0, 0], \n [0, 1, 2, 1, 1, 0], \n [1, 0, 1, 0, 0, 0], \n [0, 0, 1, 0, 1, 0], \n [0, 0, 0, 3, 0, 0]]`\n\nLet us imagine that lines are numbered from A0 to A5 and the same for columns.\nThe first line correspond to A0 and we can see that A0 is connected to A3 with weight 1, A0 is also connected to A5 with weight 4.\n\nAnother way is to use an adjacency list: An adjacency list representation for a graph \nassociates each vertex in the graph with the collection of its neighboring edges:\n\n`L = [['A0', [('A3', 1), ('A5', 4)]], \n     ['A1', [('A2', 2)]], \n     ['A2', [('A1', 1), ('A2', 2), ('A3', 1), ('A4', 1)]], \n     ['A3', [('A0', 1), ('A2', 1)]], \n     ['A4', [('A2', 1), ('A4', 1)]], \n     ['A5', [('A3', 3)]]] `\n\nL is sorted in order A0 to A5 and each sublist is sorted as in a graph dictionary.\n\nIn the kata nodes will be numbered from A0 to A(n-1) for a graph with n nodes. \nThe task is to go from each represention to each other one\nand at last to find *all* paths from a node to another node.\n\nBelow is a skeleton for our class `Graph`.\n\nclass Graph():\n\n    def __init__(self, vertices_num):\n        # number of nodes (an integer)\n        self.v = vertices_num\n        # (maybe not useful here) : list of nodes from \"A0\", \"A1\" ... to \"A index (vertices_num - 1)\"\n        self.nodes = None\n\n    # from adjacency matrix to dictionary\n    def adjmat_2_graph(self, adjm):\n\n    # from dictionary to adjacency matrix\n    def graph_2_mat(self, graph):\n\n    # from dictionary to adjacency list    \n    def graph_2_list(self, graph):\n\n    # from adjacency list to dictionary\n    def list_2_graph(self, lst):\n\n    # from adjacency matrix to adjacency list    \n    def mat_2_list(self, mat):\n\n    # from adjacency list to adjacency matrix\n    def list_2_mat(self, lst):\n\n    # find all paths from node start_vertex to node end_vertex\n    def find_all_paths(self, graph, start_vertex, end_vertex):\n\n# Examples: \n- see: graph, M, L above.\n- finding all paths:\n\n`dct = {'A3': [('A0', 1), ('A2', 1)], 'A0': [('A3', 1), ('A2', 1)], 'A4': [('A2', 1)], 'A1': [('A2', 1)], 'A2': [('A1', 1), ('A2', 1), ('A3', 1), ('A4', 1)]}`\n\n`g = Graph(5)`\n\n`g.find_all_paths(dct, \"A0\", \"A4\") return l = ['A0-A2-A4', 'A0-A3-A2-A4']`\n\nNote that ['A0-A2-A4', 'A0-A3-A2-A4'] is sorted (hint: sorted(sorted(l, key=str), key=len))\n\nTranslators and critics are welcome.\n-/", "vc-preamble": "def Graph.adjmat_2_graph {n : Nat} (g : Graph n) (mat : List (List Nat)) : List (String × List (String × Nat)) := sorry \ndef Graph.graph_2_list {n : Nat} (g : Graph n) (graph : List (String × List (String × Nat))) : List (Nat × Nat × Nat) := sorry", "vc-helpers": "", "vc-definitions": "def Graph.list_2_graph {n : Nat} (g : Graph n) (lst : List (Nat × Nat × Nat)) : List (String × List (String × Nat)) := sorry\n\ntheorem graph_initialization (size : Nat) (h : size > 0) : \n  ∃ g : Graph size, true \n  := sorry", "vc-theorems": "theorem adjmat_graph_properties {size : Nat} (h : size > 0) (mat : List (List Nat)) :\n  ∀ g : Graph size,\n  let graph := Graph.adjmat_2_graph g mat\n  (∀ k ∈ graph, String.startsWith (k.fst) \"A\") ∧ \n  graph.length = size\n  := sorry\n\ntheorem list_conversion_properties {size : Nat} (h : size > 0) (graph : List (String × List (String × Nat))) :\n  ∀ g : Graph size,\n  let lst := Graph.graph_2_list g graph\n  let result := Graph.list_2_graph g lst\n  (∀ k ∈ result, String.startsWith (k.fst) \"A\") ∧ \n  (∀ v ∈ result, v.snd.all (λ x => true))\n  := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1733", "language": "lean", "source": "fvapps", "source-id": "fvapps_001733", "source-notes": "", "vc-description": "/-\nThere are n people, each person has a unique id between 0 and n-1. Given the arrays watchedVideos and friends, where watchedVideos[i] and friends[i] contain the list of watched videos and the list of friends respectively for the person with id = i.\nLevel 1 of videos are all watched videos by your friends, level 2 of videos are all watched videos by the friends of your friends and so on. In general, the level k of videos are all watched videos by people with the shortest path exactly equal to k with you. Given your id and the level of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest. \n\nExample 1:\n\nInput: watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1\nOutput: [\"B\",\"C\"] \nExplanation: \nYou have id = 0 (green color in the figure) and your friends are (yellow color in the figure):\nPerson with id = 1 -> watchedVideos = [\"C\"] \nPerson with id = 2 -> watchedVideos = [\"B\",\"C\"] \nThe frequencies of watchedVideos by your friends are: \nB -> 1 \nC -> 2\n\nExample 2:\n\nInput: watchedVideos = [[\"A\",\"B\"],[\"C\"],[\"B\",\"C\"],[\"D\"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2\nOutput: [\"D\"]\nExplanation: \nYou have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure).\n\nConstraints:\n\nn == watchedVideos.length == friends.length\n2 <= n <= 100\n1 <= watchedVideos[i].length <= 100\n1 <= watchedVideos[i][j].length <= 8\n0 <= friends[i].length < n\n0 <= friends[i][j] < n\n0 <= id < n\n1 <= level < n\nif friends[i] contains j, then friends[j] contains i\n-/", "vc-preamble": "def PersonId := Nat\ndef Video := String\n\ndef WatchedVideos := List (List Video)\ndef Friends := List (List PersonId)\n\ninstance : Inhabited PersonId where\n  default := Nat.zero", "vc-helpers": "", "vc-definitions": "def watched_videos_by_friends (watchedVideos : WatchedVideos) \n  (friends : Friends) (id : PersonId) (level : Nat) : List Video := sorry", "vc-theorems": "theorem watched_videos_by_friends_result_subset_all_videos \n  (watchedVideos : WatchedVideos) (friends : Friends) \n  (id : PersonId) (level : Nat) :\n  let result := watched_videos_by_friends watchedVideos friends id level\n  let allVideos := List.join watchedVideos\n  ∀ v, v ∈ result → v ∈ allVideos := sorry\n\ntheorem friends_lists_symmetric\n  (friends : Friends) (i j : Nat) (h1 : i < friends.length) (h2 : j < friends.length)\n  (h3 : j ∈ List.get! friends i) :\n  i ∈ List.get! friends j := sorry\n\ntheorem friends_lists_ascending\n  (friends : Friends) (i : Nat) (h : i < friends.length) (x y : Nat) :\n  x ∈ List.get! friends i → y ∈ List.get! friends i → x ≤ y ∨ y ≤ x := sorry\n\ntheorem friends_lists_unique\n  (friends : Friends) (i : Nat) (h : i < friends.length) :\n  List.Nodup (List.get! friends i) := sorry\n\ntheorem friends_not_self_referential\n  (friends : Friends) (i : Nat) (h : i < friends.length) :\n  i ∉ List.get! friends i := sorry\n\n/-\ninfo: ['B', 'C']\n-/\n-- #guard_msgs in\n-- #eval watched_videos_by_friends [[\"A\", \"B\"], [\"C\"], [\"B\", \"C\"], [\"D\"]] [[1, 2], [0, 3], [0, 3], [1, 2]] 0 1\n\n/-\ninfo: ['D']\n-/\n-- #guard_msgs in\n-- #eval watched_videos_by_friends videos1 friends1 0 2\n\n/-\ninfo: ['B', 'C']\n-/\n-- #guard_msgs in\n-- #eval watched_videos_by_friends [[\"A\"], [\"B\"], [\"C\"], [\"A\", \"B\"]] [[1, 2], [0, 3], [0, 3], [1, 2]] 0 1", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1734", "language": "lean", "source": "fvapps", "source-id": "fvapps_001734", "source-notes": "", "vc-description": "/-\nIn a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array.\n\nReturn the minimum number of rabbits that could be in the forest.\n\nExamples:\nInput: answers = [1, 1, 2]\nOutput: 5\nExplanation:\nThe two rabbits that answered \"1\" could both be the same color, say red.\nThe rabbit than answered \"2\" can't be red or the answers would be inconsistent.\nSay the rabbit that answered \"2\" was blue.\nThen there should be 2 other blue rabbits in the forest that didn't answer into the array.\nThe smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.\n\nInput: answers = [10, 10, 10]\nOutput: 11\n\nInput: answers = []\nOutput: 0\n\nNote:\n\n       answers will have length at most 1000.\n       Each answers[i] will be an integer in the range [0, 999].\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem numRabbits_nonnegative (answers : List Nat) :\n  numRabbits answers ≥ 0 := sorry\n\ntheorem numRabbits_at_least_length (answers : List Nat) :\n  numRabbits answers ≥ answers.length := sorry \n\ntheorem numRabbits_accommodates_groups (answers : List Nat) (ans : Nat) :\n  ans ∈ answers → numRabbits answers ≥ ans + 1 := sorry\n\n-- Results are the same regardless of permutations\n\ntheorem numRabbits_consistent_order (answers₁ answers₂ : List Nat) :\n  answers₁.Perm answers₂ → numRabbits answers₁ = numRabbits answers₂ := sorry\n\n-- Empty list gives 0\n\ntheorem numRabbits_empty : \n  numRabbits [] = 0 := sorry\n\n-- Minimum bound based on max answer\n\ntheorem numRabbits_min_bound {answers : List Nat} (h : answers ≠ []) :\n  numRabbits answers ≥ (List.maximum? answers).getD 0 + 1 := sorry\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval numRabbits [1, 1, 2]\n\n/-\ninfo: 11\n-/\n-- #guard_msgs in\n-- #eval numRabbits [10, 10, 10]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval numRabbits []", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1739", "language": "lean", "source": "fvapps", "source-id": "fvapps_001739", "source-notes": "", "vc-description": "/-\nWrite a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock's price for the current day.\nThe span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price.\nFor example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].\n\nExample 1:\nInput: [\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"], [[],[100],[80],[60],[70],[60],[75],[85]]\nOutput: [null,1,1,1,2,1,4,6]\nExplanation: \nFirst, S = StockSpanner() is initialized.  Then:\nS.next(100) is called and returns 1,\nS.next(80) is called and returns 1,\nS.next(60) is called and returns 1,\nS.next(70) is called and returns 2,\nS.next(60) is called and returns 1,\nS.next(75) is called and returns 4,\nS.next(85) is called and returns 6.\n\nNote that (for example) S.next(75) returned 4, because the last 4 prices\n(including today's price of 75) were less than or equal to today's price.\n\nNote:\n\nCalls to StockSpanner.next(int price) will have 1 <= price <= 10^5.\nThere will be at most 10000 calls to StockSpanner.next per test case.\nThere will be at most 150000 calls to StockSpanner.next across all test cases.\nThe total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def StockSpanner.next (self : StockSpanner) (price : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem spanner_spans_positive (prices : List Nat) :\n  let spanner : StockSpanner := default\n  let spans := prices.map (StockSpanner.next spanner)\n  ∀ span ∈ spans, span > 0 :=\nsorry\n\ntheorem spanner_spans_bounded (prices : List Nat) :\n  let spanner : StockSpanner := default\n  let spans := prices.map (StockSpanner.next spanner)\n  ∀ (i : Nat), i < spans.length → spans[i]! ≤ i + 1 :=\nsorry\n\ntheorem spanner_repeated_prices (n : Nat) (price : Nat) :\n  let spanner : StockSpanner := default\n  let prices := List.replicate n price\n  let spans := prices.map (StockSpanner.next spanner)\n  ∀ (i : Nat), i < spans.length → spans[i]! = i + 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1740", "language": "lean", "source": "fvapps", "source-id": "fvapps_001740", "source-notes": "", "vc-description": "/-\nImplementing the class MajorityChecker, which has the following API:\n\nMajorityChecker(int[] arr) constructs an instance of MajorityChecker with the given array arr;\nint query(int left, int right, int threshold) has arguments such that:\n\n0 <= left <= right < arr.length representing a subarray of arr;\n2 * threshold > right - left + 1, ie. the threshold is always a strict majority of the length of the subarray\n\nEach query(...) returns the element in arr[left], arr[left+1], ..., arr[right] that occurs at least threshold times, or -1 if no such element exists.\n\nExample:\nMajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);\nmajorityChecker.query(0,5,4); // returns 1\nmajorityChecker.query(0,3,3); // returns -1\nmajorityChecker.query(2,3,2); // returns 2\n\nConstraints:\n\n1 <= arr.length <= 20000\n1 <= arr[i] <= 20000\nFor each query, 0 <= left <= right < len(arr)\nFor each query, 2 * threshold > right - left + 1\nThe number of queries is at most 10000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def MajorityChecker.query (checker : MajorityChecker) (left right threshold : Nat) : Int :=\n  sorry", "vc-theorems": "theorem queries_within_array_bounds \n  (arr : IntArray) \n  (left right threshold : Nat)\n  (checker : MajorityChecker)\n  (h1 : checker.arr = arr)\n  (h2 : left ≤ right)\n  (h3 : right < arr.length)\n  (result : Int)\n  (h4 : result = checker.query left right threshold)\n  (h5 : result ≠ -1) :\n  (List.countP (fun x => x = result) (List.take (right - left + 1) (List.drop left arr))) ≥ threshold := \n  sorry\n\ntheorem monotonic_threshold \n  (arr : IntArray)\n  (left right threshold1 threshold2 : Nat) \n  (checker : MajorityChecker)\n  (h1 : checker.arr = arr)\n  (h2 : left ≤ right)\n  (h3 : right < arr.length)\n  (h4 : threshold1 ≤ threshold2)\n  (h5 : threshold2 ≤ right - left + 1)\n  (result2 : Int)\n  (h6 : result2 = checker.query left right threshold2)\n  (h7 : result2 ≠ -1) :\n  ∃ result1, \n    result1 = checker.query left right threshold1 ∧\n    result1 ≠ -1 := \n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1741", "language": "lean", "source": "fvapps", "source-id": "fvapps_001741", "source-notes": "", "vc-description": "/-\nWe have a sequence of books: the i-th book has thickness books[i][0] and height books[i][1].\nWe want to place these books in order onto bookcase shelves that have total width shelf_width.\nWe choose some of the books to place on this shelf (such that the sum of their thickness is <= shelf_width), then build another level of shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down.  We repeat this process until there are no more books to place.\nNote again that at each step of the above process, the order of the books we place is the same order as the given sequence of books.  For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\nReturn the minimum possible height that the total bookshelf can be after placing shelves in this manner.\n\nExample 1:\n\nInput: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4\nOutput: 6\nExplanation:\nThe sum of the heights of the 3 shelves are 1 + 3 + 2 = 6.\nNotice that book number 2 does not have to be on the first shelf.\n\nConstraints:\n\n1 <= books.length <= 1000\n1 <= books[i][0] <= shelf_width <= 1000\n1 <= books[i][1] <= 1000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_height_shelves (books : Books) (width : ShelfWidth) : Nat :=\n  sorry", "vc-theorems": "theorem min_height_lower_bound_tallest (books : Books) (width : ShelfWidth)\n  (h1 : books.length > 0)\n  (h2 : width > 0) :\n  min_height_shelves books width ≥ books.foldl (λ acc b => max acc b.height) 0 :=\nsorry\n\ntheorem min_height_width_one_lower_bound (books : Books)\n  (h1 : books.length > 0)\n  (h2 : width = 1) :\n  min_height_shelves books 1 ≥ books.foldl (λ acc b => acc + b.height) 0 :=\nsorry\n\ntheorem min_height_upper_bound (books : Books) (width : ShelfWidth)\n  (h1 : books.length > 0)\n  (h2 : width > 0) :\n  min_height_shelves books width ≤ books.foldl (λ acc b => acc + b.height) 0 :=\nsorry\n\ntheorem min_height_monotonic_width (books : Books) (w1 w2 : ShelfWidth)\n  (h1 : books.length > 0)\n  (h2 : w1 > 0)\n  (h3 : w2 = w1 + 1) :\n  min_height_shelves books w2 ≤ min_height_shelves books w1 :=\nsorry\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval min_height_shelves [[1, 1], [2, 3], [2, 3], [1, 1], [1, 1], [1, 1], [1, 2]] 4\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval min_height_shelves [[1, 3], [2, 4], [3, 2]] 6\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval min_height_shelves [[1, 1]] 1", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1745", "language": "lean", "source": "fvapps", "source-id": "fvapps_001745", "source-notes": "", "vc-description": "/-\nGiven the root of a binary tree, each node has a value from 0 to 25 representing the letters 'a' to 'z': a value of 0 represents 'a', a value of 1 represents 'b', and so on.\nFind the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\n(As a reminder, any shorter prefix of a string is lexicographically smaller: for example, \"ab\" is lexicographically smaller than \"aba\".  A leaf of a node is a node that has no children.)\n\nExample 1:\n\nInput: [0,1,2,3,4,3,4]\nOutput: \"dba\"\n\nExample 2:\n\nInput: [25,1,3,1,3,0,2]\nOutput: \"adz\"\n\nExample 3:\n\nInput: [2,2,1,null,1,0,null,0]\nOutput: \"abc\"\n\nNote:\n\nThe number of nodes in the given tree will be between 1 and 8500.\nEach node in the tree will have a value between 0 and 25.\n-/", "vc-preamble": "def smallestFromLeaf : TreeNode → String := sorry\n\ntheorem smallestFromLeaf_returns_nonempty (root : TreeNode) :\n  let result := smallestFromLeaf root\n  result.length > 0 := sorry", "vc-helpers": "", "vc-definitions": "def isTreeOfSize : TreeNode → Nat → Prop \n  | TreeNode.mk _ none none, n => n = 1\n  | TreeNode.mk _ (some l) none, n => ∃ m, isTreeOfSize l m ∧ n = m + 1\n  | TreeNode.mk _ none (some r), n => ∃ m, isTreeOfSize r m ∧ n = m + 1\n  | TreeNode.mk _ (some l) (some r), n => \n    ∃ m₁ m₂, isTreeOfSize l m₁ ∧ isTreeOfSize r m₂ ∧ n = m₁ + m₂ + 1", "vc-theorems": "theorem smallestFromLeaf_returns_lowercase_chars (root : TreeNode) :\n  let result := smallestFromLeaf root\n  ∀ c ∈ result.data, 'a' ≤ c ∧ c ≤ 'z' := sorry\n\ntheorem smallestFromLeaf_length_bounded_by_tree_size (root : TreeNode) (size : Nat) :\n  let result := smallestFromLeaf root\n  isTreeOfSize root size → result.length ≤ size := sorry\n\ntheorem single_node_returns_a :\n  let root := TreeNode.mk 0 none none\n  smallestFromLeaf root = \"a\" := sorry\n\ntheorem equal_children_equal_result :\n  let root := TreeNode.mk 0 (some (TreeNode.mk 1 none none)) (some (TreeNode.mk 1 none none))\n  smallestFromLeaf root = \"ba\" := sorry\n\n/-\ninfo: 'dba'\n-/\n-- #guard_msgs in\n-- #eval smallestFromLeaf TreeNode(0)\n\n/-\ninfo: 'adz'\n-/\n-- #guard_msgs in\n-- #eval smallestFromLeaf TreeNode(25)\n\n/-\ninfo: 'abc'\n-/\n-- #guard_msgs in\n-- #eval smallestFromLeaf TreeNode(2)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1747", "language": "lean", "source": "fvapps", "source-id": "fvapps_001747", "source-notes": "", "vc-description": "/-\nYou need to find the largest value in each row of a binary tree.\n\nExample:\n\nInput: \n\n          1\n         / \\\n        3   2\n       / \\   \\  \n      5   3   9 \n\nOutput: [1, 3, 9]\n-/", "vc-preamble": "def largest_values : TreeNode α → List α := sorry\n\ndef get_height : TreeNode α → Nat := sorry", "vc-helpers": "", "vc-definitions": "def get_level_nodes : TreeNode α → Nat → List α := sorry\n\ndef list_max (l : List α) : α := \n  List.foldl max default l", "vc-theorems": "theorem empty_tree_gives_empty_list :\n  largest_values (@TreeNode.nil α) = [] := sorry\n\ntheorem single_node_gives_singleton (x : α) :\n  largest_values (@TreeNode.node α x TreeNode.nil TreeNode.nil) = [x] := sorry\n\ntheorem result_length_matches_height (t : TreeNode α) :\n  List.length (largest_values t) = get_height t := sorry\n\ntheorem level_max_appears_in_nodes (t : TreeNode α) (level : Nat) \n  (h : level < List.length (largest_values t)) :\n  List.get! (largest_values t) level = list_max (get_level_nodes t level) := sorry\n\n/-\ninfo: [1]\n-/\n-- #guard_msgs in\n-- #eval largest_values TreeNode(1)\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval largest_values None\n\n/-\ninfo: [1, 3, 9]\n-/\n-- #guard_msgs in\n-- #eval largest_values TreeNode(1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1749", "language": "lean", "source": "fvapps", "source-id": "fvapps_001749", "source-notes": "", "vc-description": "/-\nGiven a non-empty list of words, return the k most frequent elements.\nYour answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.\n\nExample 1:\n\nInput: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2\nOutput: [\"i\", \"love\"]\nExplanation: \"i\" and \"love\" are the two most frequent words.\n    Note that \"i\" comes before \"love\" due to a lower alphabetical order.\n\nExample 2:\n\nInput: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4\nOutput: [\"the\", \"is\", \"sunny\", \"day\"]\nExplanation: \"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words,\n    with the number of occurrence being 4, 3, 2 and 1 respectively.\n\nNote:\n\nYou may assume k is always valid, 1 ≤ k ≤ number of unique elements.\nInput words contain only lowercase letters.\n\nFollow up:\n\nTry to solve it in O(n log k) time and O(n) extra space.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def top_k_frequent (words : List String) (k : Nat) : List String :=\n  sorry", "vc-theorems": "theorem top_k_frequent_properties_length \n  (words : List String) (k : Nat) (h : words ≠ []) :\n  let result := top_k_frequent words k\n  List.length result = k := sorry\n\ntheorem top_k_frequent_properties_subset\n  (words : List String) (k : Nat) (h : words ≠ []) :\n  let result := top_k_frequent words k\n  ∀ x, x ∈ result → x ∈ words := sorry\n\ntheorem top_k_frequent_properties_unique\n  (words : List String) (k : Nat) (h : words ≠ []) :\n  let result := top_k_frequent words k\n  ∀ x y, x ∈ result → y ∈ result → x = y → result.indexOf x = result.indexOf y := sorry\n\ntheorem top_k_frequent_properties_order\n  (words : List String) (k : Nat) (h : words ≠ []) :\n  let result := top_k_frequent words k\n  let counts := (λ w => (words.filter (· = w)).length)\n  ∀ i < result.length - 1,\n    let curr := counts (result.get ⟨i, sorry⟩)\n    let next := counts (result.get ⟨i+1, sorry⟩)\n    curr > next ∨ (curr = next ∧ result.get ⟨i, sorry⟩ ≤ result.get ⟨i+1, sorry⟩) := sorry\n\ntheorem equal_frequencies_lexicographic_order\n  (words : List String) (k : Nat) :\n  let result := top_k_frequent words k\n  let counts := (λ w => (words.filter (· = w)).length)\n  ∀ i < result.length - 1,\n    counts (result.get ⟨i, sorry⟩) = counts (result.get ⟨i+1, sorry⟩) →\n    result.get ⟨i, sorry⟩ ≤ result.get ⟨i+1, sorry⟩ := sorry\n\n/-\ninfo: ['i', 'love']\n-/\n-- #guard_msgs in\n-- #eval top_k_frequent [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"] 2\n\n/-\ninfo: ['the', 'is', 'sunny', 'day']\n-/\n-- #guard_msgs in\n-- #eval top_k_frequent [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"] 4\n\n/-\ninfo: ['a']\n-/\n-- #guard_msgs in\n-- #eval top_k_frequent [\"a\", \"a\", \"b\"] 1", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1750", "language": "lean", "source": "fvapps", "source-id": "fvapps_001750", "source-notes": "", "vc-description": "/-\nGiven a singly linked list L: L0→L1→…→Ln-1→Ln,\nreorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…\n\nYou may not modify the values in the list's nodes, only nodes itself may be changed.\n\nExample 1:\n\nGiven 1->2->3->4, reorder it to 1->4->2->3.\n\nExample 2:\n\nGiven 1->2->3->4->5, reorder it to 1->5->2->4->3.\n-/", "vc-preamble": "def reorder_list : ListNode → ListNode :=\n  sorry\n\ndef array_to_list : List Int → ListNode :=\n  sorry", "vc-helpers": "", "vc-definitions": "def list_to_array : ListNode → List Int := \n  sorry\n\n-- Main properties", "vc-theorems": "theorem reorder_list_preserves_length {l : List Int} :\n  let list := array_to_list l\n  List.length (list_to_array (reorder_list list)) = List.length l :=\n  sorry\n\ntheorem reorder_list_preserves_first {l : List Int} (h : l ≠ []) :\n  let list := array_to_list l\n  let reordered_array := list_to_array (reorder_list list)\n  List.head! reordered_array = List.head! l :=\n  sorry\n\ntheorem reorder_list_alternates {l : List Int} (h : List.length l > 1) :\n  let list := array_to_list l\n  let reordered_array := list_to_array (reorder_list list)\n  let n := List.length l\n  let first_half := List.take ((n + 1)/2) l\n  let second_half := List.reverse (List.drop ((n + 1)/2) l)\n  ∀ i, i < List.length second_half →\n    List.get! reordered_array (2*i) = List.get! first_half i ∧\n    List.get! reordered_array (2*i + 1) = List.get! second_half i :=\n  sorry\n\ntheorem reorder_list_empty :\n  reorder_list ListNode.nil = ListNode.nil :=\n  sorry\n\ntheorem reorder_list_odd_length_ends_first_half {l : List Int} \n  (h : List.length l % 2 = 1) :\n  let list := array_to_list l\n  let reordered_array := list_to_array (reorder_list list)\n  let n := List.length l\n  let first_half := List.take ((n + 1)/2) l\n  List.get! reordered_array (List.length l - 1) = \n    List.get! first_half (List.length first_half - 1) :=\n  sorry\n\n/-\ninfo: [1, 4, 2, 3]\n-/\n-- #guard_msgs in\n-- #eval list_to_array reorder_list(head1)\n\n/-\ninfo: [1, 5, 2, 4, 3]\n-/\n-- #guard_msgs in\n-- #eval list_to_array reorder_list(head2)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1752", "language": "lean", "source": "fvapps", "source-id": "fvapps_001752", "source-notes": "", "vc-description": "/-\nGiven a rooted binary tree, return the lowest common ancestor of its deepest leaves.\nRecall that:\n\nThe node of a binary tree is a leaf if and only if it has no children\nThe depth of the root of the tree is 0, and if the depth of a node is d, the depth of each of its children is d+1.\nThe lowest common ancestor of a set S of nodes is the node A with the largest depth such that every node in S is in the subtree with root A.\n\nExample 1:\nInput: root = [1,2,3]\nOutput: [1,2,3]\nExplanation: \nThe deepest leaves are the nodes with values 2 and 3.\nThe lowest common ancestor of these leaves is the node with value 1.\nThe answer returned is a TreeNode object (not an array) with serialization \"[1,2,3]\".\n\nExample 2:\nInput: root = [1,2,3,4]\nOutput: [4]\n\nExample 3:\nInput: root = [1,2,3,4,5]\nOutput: [2,4,5]\n\nConstraints:\n\nThe given tree will have between 1 and 1000 nodes.\nEach node of the tree will have a distinct value between 1 and 1000.\n-/", "vc-preamble": "def build_tree (values : List Int) : Option TreeNode := sorry\ndef lcaDeepestLeaves (root : TreeNode) : TreeNode := sorry\n\ndef get_depth (node : TreeNode) : Int := sorry\ndef get_leaves_at_depth (node : TreeNode) (target_depth : Int) (current_depth : Int := 0) : List TreeNode := sorry", "vc-helpers": "", "vc-definitions": "def find_node (node target : TreeNode) : Bool := sorry\n\ntheorem lca_deepest_leaves_in_tree (values : List Int) (tree : TreeNode) \n  (h1 : build_tree values = some tree) :\n  find_node tree (lcaDeepestLeaves tree) = true := sorry", "vc-theorems": "theorem lca_deepest_leaves_contains_all_deepest_leaves (values : List Int) (tree : TreeNode)\n  (h1 : build_tree values = some tree)\n  (max_depth : Int)\n  (h2 : max_depth = get_depth tree)\n  (deepest_leaves : List TreeNode) \n  (h3 : deepest_leaves = get_leaves_at_depth tree max_depth) :\n  ∀ leaf, leaf ∈ deepest_leaves → find_node (lcaDeepestLeaves tree) leaf = true := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1754", "language": "lean", "source": "fvapps", "source-id": "fvapps_001754", "source-notes": "", "vc-description": "/-\nFor an integer n, we call k>=2 a good base of n, if all digits of n base k are 1.\nNow given a string representing n, you should return the smallest good base of n in string format. \n\nExample 1:\n\nInput: \"13\"\nOutput: \"3\"\nExplanation: 13 base 3 is 111.\n\nExample 2:\n\nInput: \"4681\"\nOutput: \"8\"\nExplanation: 4681 base 8 is 11111.\n\nExample 3:\n\nInput: \"1000000000000000000\"\nOutput: \"999999999999999999\"\nExplanation: 1000000000000000000 base 999999999999999999 is 11.\n\nNote:\n\nThe range of n is [3, 10^18].\nThe string representing n is always valid and will not have leading zeros.\n-/", "vc-preamble": "def log (base n : Nat) : Nat := sorry", "vc-helpers": "", "vc-definitions": "def smallest_good_base (n : String) : String :=\nsorry", "vc-theorems": "theorem smallest_good_base_result_bounds {n : Nat} (h1 : n ≥ (3 : Nat)) (h2 : n ≤ Nat.pow 10 18) :\n  let result := String.toNat! (smallest_good_base (toString n))\n  result ≥ (2 : Nat) ∧ result < n :=\nsorry\n\ntheorem smallest_good_base_all_ones {n : Nat} (h1 : n ≥ (3 : Nat)) (h2 : n ≤ Nat.pow 10 18) :\n  let result := String.toNat! (smallest_good_base (toString n))\n  let m := Nat.log result n\n  (Nat.pow result (m+1) - 1)/(result - 1) = n :=\nsorry\n\ntheorem smallest_good_base_min_input :\n  smallest_good_base \"3\" = \"2\" :=\nsorry\n\ntheorem smallest_good_base_power_two_minus_one :\n  smallest_good_base \"15\" = \"2\" :=\nsorry\n\n/-\ninfo: '3'\n-/\n-- #guard_msgs in\n-- #eval smallest_good_base \"13\"\n\n/-\ninfo: '8'\n-/\n-- #guard_msgs in\n-- #eval smallest_good_base \"4681\"\n\n/-\ninfo: '999999999999999999'\n-/\n-- #guard_msgs in\n-- #eval smallest_good_base \"1000000000000000000\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1756", "language": "lean", "source": "fvapps", "source-id": "fvapps_001756", "source-notes": "", "vc-description": "/-\nGiven a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\nReturn the number of good nodes in the binary tree.\n\nExample 1:\n\nInput: root = [3,1,4,3,null,1,5]\nOutput: 4\nExplanation: Nodes in blue are good.\nRoot Node (3) is always a good node.\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\nNode 5 -> (3,4,5) is the maximum value in the path\nNode 3 -> (3,1,3) is the maximum value in the path.\nExample 2:\n\nInput: root = [3,3,null,4,2]\nOutput: 3\nExplanation: Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it.\nExample 3:\nInput: root = [1]\nOutput: 1\nExplanation: Root is considered as good.\n\nConstraints:\n\nThe number of nodes in the binary tree is in the range [1, 10^5].\nEach node's value is between [-10^4, 10^4].\n-/", "vc-preamble": "def goodNodes : TreeNode → Nat\n  | _ => sorry\n\ndef isLinearLeft : TreeNode → List Int → Prop\n  | _ , _ => sorry\n\ndef countMaxSoFar : List Int → Nat\n  | _ => sorry \n\ndef numberOfNodes : TreeNode → Nat \n  | _ => sorry\n\ndef allNodesHaveValue : TreeNode → Int → Prop\n  | _, _ => sorry", "vc-helpers": "", "vc-definitions": "def isStrictlyDecreasing : TreeNode → Prop\n  | _ => sorry\n\n/- In a linear tree (only left children), number of good nodes equals number of values \n    that are greater than or equal to all previous values -/", "vc-theorems": "theorem goodNodes_linear_tree (tree : TreeNode) (path : List Int) :\n  isLinearLeft tree path →\n  goodNodes tree = countMaxSoFar path := sorry\n\n/- The number of good nodes is always at least 1 (root is always good) -/\n\ntheorem goodNodes_at_least_one (tree : TreeNode) :\n  goodNodes tree ≥ 1 := sorry \n\n/- The number of good nodes never exceeds total number of nodes -/\n\ntheorem goodNodes_upper_bound (tree : TreeNode) (size : Nat) :\n  numberOfNodes tree = size →\n  goodNodes tree ≤ size := sorry\n\n/- A single node tree has exactly one good node -/\n\ntheorem goodNodes_single_node (val : Int) :\n  goodNodes (TreeNode.mk val none none) = 1 := sorry\n\n/- A tree with all same values has all nodes as good nodes -/\n\ntheorem goodNodes_all_same_value (val : Int) (tree : TreeNode) :\n  allNodesHaveValue tree val →\n  goodNodes tree = numberOfNodes tree := sorry\n\n/- A strictly decreasing tree has exactly one good node -/\n\ntheorem goodNodes_strictly_decreasing (tree : TreeNode) :\n  isStrictlyDecreasing tree →\n  goodNodes tree = 1 := sorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval goodNodes TreeNode(3)\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval goodNodes TreeNode(3)\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval goodNodes TreeNode(1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1758", "language": "lean", "source": "fvapps", "source-id": "fvapps_001758", "source-notes": "", "vc-description": "/-\nStarting with an undirected graph (the \"original graph\") with nodes from 0 to N-1, subdivisions are made to some of the edges.\nThe graph is given as follows: edges[k] is a list of integer pairs (i, j, n) such that (i, j) is an edge of the original graph,\nand n is the total number of new nodes on that edge. \nThen, the edge (i, j) is deleted from the original graph, n new nodes (x_1, x_2, ..., x_n) are added to the original graph,\nand n+1 new edges (i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j) are added to the original graph.\nNow, you start at node 0 from the original graph, and in each move, you travel along one edge. \nReturn how many nodes you can reach in at most M moves.\n\nExample 1:\nInput: edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3\nOutput: 13\nExplanation: \nThe nodes that are reachable in the final graph after M = 6 moves are indicated below.\n\nExample 2:\nInput: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4\nOutput: 23\n\nNote:\n\n0 <= edges.length <= 10000\n0 <= edges[i][0] < edges[i][1] < N\nThere does not exist any i != j for which edges[i][0] == edges[j][0] and edges[i][1] == edges[j][1].\nThe original graph has no parallel edges.\n0 <= edges[i][2] <= 10000\n0 <= M <= 10^9\n1 <= N <= 3000\nA reachable node is a node that can be travelled to using at most M moves starting from node 0.\n-/", "vc-preamble": "def reachable_nodes (edges : List Edge) (M : Nat) (N : Nat) : Nat :=\n  sorry\n\ndef isValidEdgeList (edges : List Edge) (N : Nat) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def sumWeights (edges : List Edge) : Nat :=\n  edges.foldl (fun acc e => acc + e.2.2) 0", "vc-theorems": "theorem reachable_nodes_basic_properties \n  {edges : List Edge} {M N : Nat}\n  (h1 : 2 ≤ N) (h2 : N ≤ 10)\n  (h3 : 1 ≤ M) (h4 : M ≤ 20)\n  (h5 : isValidEdgeList edges N = true) :\n  let result := reachable_nodes edges M N\n  let total_intermediate := sumWeights edges\n  (0 ≤ result) ∧ \n  (result ≤ N + total_intermediate) ∧\n  (1 ≤ result) :=\nsorry\n\ntheorem empty_graph_reaches_one\n  {M N : Nat}\n  (h1 : 0 ≤ M) (h2 : M ≤ 20)\n  (h3 : 1 ≤ N) (h4 : N ≤ 10) :\n  reachable_nodes ([] : List Edge) M N = 1 :=\nsorry\n\ntheorem single_edge_properties\n  {N w : Nat}\n  (h1 : 2 ≤ N) (h2 : N ≤ 10)\n  (h3 : 0 ≤ w) (h4 : w ≤ 20) :\n  let edges := [(0, 1, w)]\n  let M := w + 1\n  let result := reachable_nodes edges M N\n  (result ≤ 2 + w) ∧ (1 ≤ result) :=\nsorry\n\n/-\ninfo: 13\n-/\n-- #guard_msgs in\n-- #eval reachable_nodes [[0, 1, 10], [0, 2, 1], [1, 2, 2]] 6 3\n\n/-\ninfo: 23\n-/\n-- #guard_msgs in\n-- #eval reachable_nodes [[0, 1, 4], [1, 2, 6], [0, 2, 8], [1, 3, 1]] 10 4", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1759", "language": "lean", "source": "fvapps", "source-id": "fvapps_001759", "source-notes": "", "vc-description": "/-\nGiven the root of a binary tree, the depth of each node is the shortest distance to the root.\nReturn the smallest subtree such that it contains all the deepest nodes in the original tree.\nA node is called the deepest if it has the largest depth possible among any node in the entire tree.\nThe subtree of a node is tree consisting of that node, plus the set of all descendants of that node.\n\nExample 1:\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4]\nOutput: [2,7,4]\nExplanation: We return the node with value 2, colored in yellow in the diagram.\nThe nodes coloured in blue are the deepest nodes of the tree.\nNotice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.\n\nExample 2:\nInput: root = [1]\nOutput: [1]\nExplanation: The root is the deepest node in the tree.\n\nExample 3:\nInput: root = [0,1,3,null,2]\nOutput: [2]\nExplanation: The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.\n\nConstraints:\n\nThe number of nodes in the tree will be in the range [1, 500].\nThe values of the nodes in the tree are unique.\n-/", "vc-preamble": "def maxDepth {α : Type} : Tree α → Nat\n  | Tree.leaf => 0\n  | Tree.node _ l r => max (maxDepth l) (maxDepth r) + 1\n\ndef getDeepestNodes {α : Type} : Tree α → Nat → List (Tree α)\n  | _, _ => sorry", "vc-helpers": "", "vc-definitions": "def subtreeWithAllDeepest {α : Type} : Tree α → Tree α\n  | t => sorry", "vc-theorems": "theorem result_non_none {α : Type} (t : Tree α) :\n  subtreeWithAllDeepest t ≠ Tree.leaf := sorry\n\ntheorem deepest_nodes_preserved {α : Type} (t : Tree α) : \n  let result := subtreeWithAllDeepest t\n  let maxDepthTree := maxDepth t\n  let maxDepthResult := maxDepth result\n  let deepestNodesTree := getDeepestNodes t maxDepthTree\n  let deepestNodesResult := getDeepestNodes result maxDepthResult\n  deepestNodesTree = deepestNodesResult := sorry\n\ntheorem smallest_possible_subtree {α : Type} (t : Tree α) :\n  let result := subtreeWithAllDeepest t\n  match result with\n  | Tree.leaf => True\n  | Tree.node _ l r => \n    let leftDepth := maxDepth l\n    let rightDepth := maxDepth r\n    leftDepth = rightDepth ∨ (leftDepth ≤ rightDepth + 1 ∧ rightDepth ≤ leftDepth + 1) := sorry\n\ntheorem single_node_case {α : Type} (x : α) :\n  subtreeWithAllDeepest (Tree.node x Tree.leaf Tree.leaf) = Tree.node x Tree.leaf Tree.leaf := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1761", "language": "lean", "source": "fvapps", "source-id": "fvapps_001761", "source-notes": "", "vc-description": "/-\nDesign a data structure that supports all following operations in average O(1) time.\n\ninsert(val): Inserts an item val to the set if not already present.\nremove(val): Removes an item val from the set if present.\ngetRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.\n\nExample:\n\n// Init an empty set.\nRandomizedSet randomSet = new RandomizedSet();\n\n// Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomSet.insert(1);\n\n// Returns false as 2 does not exist in the set.\nrandomSet.remove(2);\n\n// Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomSet.insert(2);\n\n// getRandom should return either 1 or 2 randomly.\nrandomSet.getRandom();\n\n// Removes 1 from the set, returns true. Set now contains [2].\nrandomSet.remove(1);\n\n// 2 was already in the set, so return false.\nrandomSet.insert(2);\n\n// Since 2 is the only number in the set, getRandom always return 2.\nrandomSet.getRandom();\n-/", "vc-preamble": "def RandomizedSet.insert (rs : RandomizedSet) (x : Int) : Bool :=\n  sorry\n\ndef RandomizedSet.remove (rs : RandomizedSet) (x : Int) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def RandomizedSet.getRandom (rs : RandomizedSet) : Int :=\n  sorry", "vc-theorems": "theorem insert_sequence (nums : List Int) (h : List.Nodup nums) :\n  let rs := RandomizedSet.mk [] []\n  let seen := []\n  ∀ x ∈ nums,\n    (RandomizedSet.insert rs x) = !(x ∈ seen) ∧ \n    rs.list.length = rs.dict.length ∧\n    rs.dict.length = seen.length ∧ \n    (∀ (val : Int) (idx : Fin rs.list.length), \n      (val, idx.val) ∈ rs.dict → rs.list.get idx = some val) :=\n  sorry\n\ntheorem remove_sequence (nums : List Int) (h1 : List.Nodup nums) (h2 : nums ≠ []) :\n  let rs := RandomizedSet.mk nums (List.map (fun x => (x, 0)) nums)\n  let current := nums \n  ∀ x ∈ nums,\n    (RandomizedSet.remove rs x) = (x ∈ current) ∧\n    rs.list.length = rs.dict.length ∧ \n    rs.dict.length = current.length ∧\n    (∀ (val : Int) (idx : Fin rs.list.length),\n      (val, idx.val) ∈ rs.dict → rs.list.get idx = some val) :=\n  sorry\n\ntheorem get_random_validity (nums : List Int) (h1 : List.Nodup nums) (h2 : nums ≠ []) :\n  let rs := RandomizedSet.mk nums (List.map (fun x => (x, 0)) nums)\n  let samples := List.replicate 100 (RandomizedSet.getRandom rs)\n  (∀ s, s ∈ samples → s ∈ nums) ∧\n  (nums.length > 1 → ∃ x y, x ∈ samples ∧ y ∈ samples ∧ x ≠ y) :=\n  sorry\n\ntheorem mixed_operations (ops : List (Bool × Int)) :\n  let rs := RandomizedSet.mk [] []\n  let current := []\n  ∀ op ∈ ops, match op with\n    | (true, val) => \n      (RandomizedSet.insert rs val) = !(val ∈ current) ∧\n      (current ≠ [] → RandomizedSet.getRandom rs ∈ current)\n    | (false, val) =>\n      (RandomizedSet.remove rs val) = (val ∈ current) ∧\n      (current ≠ [] → RandomizedSet.getRandom rs ∈ current) :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1765", "language": "lean", "source": "fvapps", "source-id": "fvapps_001765", "source-notes": "", "vc-description": "/-\nGiven a binary tree root, a ZigZag path for a binary tree is defined as follow:\n\nChoose any node in the binary tree and a direction (right or left).\nIf the current direction is right then move to the right child of the current node otherwise move to the left child.\nChange the direction from right to left or right to left.\nRepeat the second and third step until you can't move in the tree.\n\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\nReturn the longest ZigZag path contained in that tree.\n\nExample 1:\n\nInput: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]\nOutput: 3\nExplanation: Longest ZigZag path in blue nodes (right -> left -> right).\n\nExample 2:\n\nInput: root = [1,1,1,null,1,null,null,1,1,null,1]\nOutput: 4\nExplanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).\n\nExample 3:\nInput: root = [1]\nOutput: 0\n\nConstraints:\n\nEach tree has at most 50000 nodes..\nEach node's value is between [1, 100].\n-/", "vc-preamble": "def is_straight_path {α : Type} (t : Tree α) (xs : List α) : Prop :=\n  sorry\n\ndef build_zigzag_tree {α : Type} (n : Nat) (x : α) : Tree α :=\n  sorry\n\ndef corresponds_to_list {α : Type} (t : Tree α) (xs : List α) : Prop :=\n  sorry", "vc-helpers": "", "vc-definitions": "def longest_zigzag {α : Type} (t : Tree α) : Nat :=\n  sorry", "vc-theorems": "theorem empty_or_single_node {α : Type} (t : Tree α) : \n  (t = Tree.nil ∨ (∃ x, t = Tree.node x Tree.nil Tree.nil)) →\n  longest_zigzag t = 0 :=\nsorry\n\ntheorem straight_path_bound {α : Type} (root : Tree α) (xs : List α) :\n  is_straight_path root xs →\n  longest_zigzag root ≤ 1 :=\nsorry\n\ntheorem zigzag_monotone {α : Type} (x y z : α) :\n  let t1 := Tree.node x Tree.nil Tree.nil\n  let t2 := Tree.node x Tree.nil (Tree.node y Tree.nil Tree.nil)\n  let t3 := Tree.node x Tree.nil (Tree.node y (Tree.node z Tree.nil Tree.nil) Tree.nil)\n  longest_zigzag t1 = 0 ∧\n  longest_zigzag t2 ≥ 1 ∧  \n  longest_zigzag t3 ≥ 2 :=\nsorry\n\ntheorem perfect_zigzag_length {α : Type} (n : Nat) (x : α) :\n  longest_zigzag (build_zigzag_tree n x) = n :=\nsorry\n\ntheorem result_bounds {α : Type} (t : Tree α) (xs : List α) :\n  corresponds_to_list t xs →\n  0 ≤ longest_zigzag t ∧ longest_zigzag t ≤ xs.length - 1 :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval longest_zigzag TreeNode(1)\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval longest_zigzag TreeNode(1)\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval longest_zigzag TreeNode(1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1767", "language": "lean", "source": "fvapps", "source-id": "fvapps_001767", "source-notes": "", "vc-description": "/-\nImplement the class TweetCounts that supports two methods:\n1. recordTweet(string tweetName, int time)\n\nStores the tweetName at the recorded time (in seconds).\n\n2. getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime)\n\nReturns the total number of occurrences for the given tweetName per minute, hour, or day (depending on freq) starting from the startTime (in seconds) and ending at the endTime (in seconds).\nfreq is always minute, hour or day, representing the time interval to get the total number of occurrences for the given tweetName.\nThe first time interval always starts from the startTime, so the time intervals are [startTime, startTime + delta*1>,  [startTime + delta*1, startTime + delta*2>, [startTime + delta*2, startTime + delta*3>, ... , [startTime + delta*i, min(startTime + delta*(i+1), endTime + 1)> for some non-negative number i and delta (which depends on freq).  \n\nExample:\nInput\n[\"TweetCounts\",\"recordTweet\",\"recordTweet\",\"recordTweet\",\"getTweetCountsPerFrequency\",\"getTweetCountsPerFrequency\",\"recordTweet\",\"getTweetCountsPerFrequency\"]\n[[],[\"tweet3\",0],[\"tweet3\",60],[\"tweet3\",10],[\"minute\",\"tweet3\",0,59],[\"minute\",\"tweet3\",0,60],[\"tweet3\",120],[\"hour\",\"tweet3\",0,210]]\n\nOutput\n[null,null,null,null,[2],[2,1],null,[4]]\n\nExplanation\nTweetCounts tweetCounts = new TweetCounts();\ntweetCounts.recordTweet(\"tweet3\", 0);\ntweetCounts.recordTweet(\"tweet3\", 60);\ntweetCounts.recordTweet(\"tweet3\", 10);                             // All tweets correspond to \"tweet3\" with recorded times at 0, 10 and 60.\ntweetCounts.getTweetCountsPerFrequency(\"minute\", \"tweet3\", 0, 59); // return [2]. The frequency is per minute (60 seconds), so there is one interval of time: 1) [0, 60> - > 2 tweets.\ntweetCounts.getTweetCountsPerFrequency(\"minute\", \"tweet3\", 0, 60); // return [2, 1]. The frequency is per minute (60 seconds), so there are two intervals of time: 1) [0, 60> - > 2 tweets, and 2) [60,61> - > 1 tweet.\ntweetCounts.recordTweet(\"tweet3\", 120);                            // All tweets correspond to \"tweet3\" with recorded times at 0, 10, 60 and 120.\ntweetCounts.getTweetCountsPerFrequency(\"hour\", \"tweet3\", 0, 210);  // return [4]. The frequency is per hour (3600 seconds), so there is one interval of time: 1) [0, 211> - > 4 tweets.\n\nConstraints:\n\nThere will be at most 10000 operations considering both recordTweet and getTweetCountsPerFrequency.\n0 <= time, startTime, endTime <= 10^9\n0 <= endTime - startTime <= 10^4\n-/", "vc-preamble": "def defaultTweetMap : TweetMap := fun _ => []\n\ninstance : Inhabited TweetCounts where\n  default := ⟨defaultTweetMap⟩\n\ndef List.sorted (l : List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!\n\ndef List.isPermOf (l₁ l₂ : List Int) : Prop :=\n  l₁.length = l₂.length ∧ ∀ x, (l₁.filter (· = x)).length = (l₂.filter (· = x)).length\n\n/- Records a tweet -/\n\ndef TweetCounts.recordTweet (tc : TweetCounts) (name : String) (time : Int) : TweetCounts :=\nsorry\n\n/- Gets tweet counts per frequency -/", "vc-helpers": "", "vc-definitions": "def TweetCounts.getTweetCountsPerFrequency (tc : TweetCounts) (freq : String) (name : String) (startTime : Int) (endTime : Int) : List Int :=\nsorry\n\n/- Counting tweets in a time window returns non-empty list with non-negative counts that sum to number of tweets in window -/", "vc-theorems": "theorem tweet_count_properties (times : List Int) (name : String) (freq : String) (delta : Int)\n    (h1 : times.length > 0)\n    (h2 : delta > 0)\n    (h3 : delta ≤ 1000)\n    (h4 : ∀ t ∈ times, t ≥ 0 ∧ t ≤ 100000) :\n    let tc : TweetCounts := default\n    let tc' := times.foldl (fun acc t => TweetCounts.recordTweet acc name t) tc\n    let minTime := times.minimum?.get!\n    let result := tc'.getTweetCountsPerFrequency freq name minTime (minTime + delta)\n    result.length > 0 ∧\n    (∀ count ∈ result, count ≥ 0) ∧\n    result.length = (times.filter (fun t => minTime ≤ t ∧ t ≤ minTime + delta)).length :=\nsorry\n\n/- Recording a single tweet should store exactly that tweet -/\n\ntheorem single_tweet_record (time : Int) (name : String)\n    (h1 : time ≥ 0)\n    (h2 : time ≤ 100000) :\n    let tc : TweetCounts := default\n    let tc' := TweetCounts.recordTweet tc name time\n    tc'.tweets name = [time] :=\nsorry\n\n/- Tweet times should be stored in sorted order -/\n\ntheorem sorted_tweets (times : List Int) (name : String)\n    (h1 : times.length ≥ 2)\n    (h2 : times.length ≤ 100)\n    (h3 : ∀ t ∈ times, t ≥ 0 ∧ t ≤ 100000) :\n    let tc : TweetCounts := default\n    let tc' := times.foldl (fun acc t => TweetCounts.recordTweet acc name t) tc\n    (tc'.tweets name).sorted ∧ \n    (tc'.tweets name).isPermOf times :=\nsorry\n\n/- Getting counts for unknown tweet name should throw error -/\n\ntheorem unknown_tweet_name_error (name : String) :\n    let tc : TweetCounts := default\n    ¬(∃ result, tc.getTweetCountsPerFrequency \"minute\" name 0 10 = result) :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1769", "language": "lean", "source": "fvapps", "source-id": "fvapps_001769", "source-notes": "", "vc-description": "/-\nImplement a data structure supporting the following operations:\n\nInc(Key) - Inserts a new key  with value 1. Or increments an existing key by 1. Key is guaranteed to be a non-empty string.\nDec(Key) - If Key's value is 1, remove it from the data structure. Otherwise decrements an existing key by 1. If the key does not exist, this function does nothing. Key is guaranteed to be a non-empty string.\nGetMaxKey() - Returns one of the keys with maximal value. If no element exists, return an empty string \"\".\nGetMinKey() - Returns one of the keys with minimal value. If no element exists, return an empty string \"\".\n\nChallenge: Perform all these in O(1) time complexity.\n-/", "vc-preamble": "def AllOne.inc (a : AllOne) (key : String) : Unit := sorry\ndef AllOne.dec (a : AllOne) (key : String) : Unit := sorry\n\ndef AllOne.getMaxKey (a : AllOne) : String := sorry\ndef AllOne.getMinKey (a : AllOne) : String := sorry", "vc-helpers": "", "vc-definitions": "def countMap (keys : List String) : String → Nat\n  | s => List.length (List.filter (· = s) keys)", "vc-theorems": "theorem increment_maintains_order (keys : List String) (a : AllOne) (h : keys ≠ []) :\n  (∀ k ∈ keys, \n    let counts := countMap keys\n    let maxCount := List.foldl (fun acc k => max acc (counts k)) 0 keys\n    let maxKeys := List.filter (fun k => counts k = maxCount) keys\n    let minCount := List.foldl (fun acc k => min acc (counts k)) (maxCount + 1) keys\n    let minKeys := List.filter (fun k => counts k = minCount) keys\n    a.getMaxKey ∈ maxKeys ∧ a.getMinKey ∈ minKeys) := sorry\n\ntheorem empty_after_decrement (keys : List String) (a : AllOne) (h : keys ≠ []) :\n  a.getMaxKey = \"\" ∧ a.getMinKey = \"\" := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1770", "language": "lean", "source": "fvapps", "source-id": "fvapps_001770", "source-notes": "", "vc-description": "/-\nWe are given the head node root of a binary tree, where additionally every node's value is either a 0 or a 1.\nReturn the same tree where every subtree (of the given tree) not containing a 1 has been removed.\n(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)\nExample 1:\nInput: [1,null,0,0,1]\nOutput: [1,null,0,null,1]\n\nExplanation: \nOnly the red nodes satisfy the property \"every subtree not containing a 1\".\nThe diagram on the right represents the answer.\n\nExample 2:\nInput: [1,0,1,0,0,0,1]\nOutput: [1,null,1,null,1]\n\nExample 3:\nInput: [1,1,0,1,1,0,1,0]\nOutput: [1,1,0,1,1,null,1]\n\nNote: \n\nThe binary tree will have at most 200 nodes.\nThe value of each node will only be 0 or 1.\n-/", "vc-preamble": "def pruneTree : BTree → Option BTree \n  | BTree.nil => none\n  | BTree.node v l r => sorry\n\ndef containsValue : BTree → Nat → Bool\n  | BTree.nil, _ => false\n  | BTree.node v l r, n => v = n || containsValue l n || containsValue r n\n\ndef isLeaf : BTree → Bool\n  | BTree.nil => false\n  | BTree.node _ BTree.nil BTree.nil => true\n  | _ => false", "vc-helpers": "", "vc-definitions": "def getValue : BTree → Nat\n  | BTree.nil => 0\n  | BTree.node v _ _ => v", "vc-theorems": "theorem pruned_tree_only_zeros_and_ones {t : BTree} {pt : BTree} :\n  pruneTree t = some pt → \n  ∀ n : Nat, containsValue pt n = true → (n = 0 ∨ n = 1) := sorry\n\ntheorem pruned_leaf_nodes_are_one {t : BTree} {pt : BTree} :\n  pruneTree t = some pt →\n  isLeaf pt = true → getValue pt = 1 := sorry\n\ntheorem prune_tree_idempotent {t : BTree} :\n  pruneTree t = pruneTree (Option.getD (pruneTree t) BTree.nil) := sorry\n\ntheorem prune_tree_nil : \n  pruneTree BTree.nil = none := sorry\n\ntheorem prune_tree_zero :\n  pruneTree (BTree.node 0 BTree.nil BTree.nil) = none := sorry\n\ntheorem prune_tree_one :\n  pruneTree (BTree.node 1 BTree.nil BTree.nil) = some (BTree.node 1 BTree.nil BTree.nil) := sorry\n\n/-\ninfo: [1, None, 0, None, 1]\n-/\n-- #guard_msgs in\n-- #eval tree_to_list prune_tree(test1)\n\n/-\ninfo: [1, None, 1, None, 1]\n-/\n-- #guard_msgs in\n-- #eval tree_to_list prune_tree(test2)\n\n/-\ninfo: [1, 1, 0, 1, 1, None, 1]\n-/\n-- #guard_msgs in\n-- #eval tree_to_list prune_tree(test3)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1771", "language": "lean", "source": "fvapps", "source-id": "fvapps_001771", "source-notes": "", "vc-description": "/-\nImplement the class SubrectangleQueries which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods:\n1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)\n\nUpdates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2).\n\n2. getValue(int row, int col)\n\nReturns the current value of the coordinate (row,col) from the rectangle.\n\nExample 1:\nInput\n[\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\"]\n[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]\nOutput\n[null,1,null,5,5,null,10,5]\nExplanation\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  \n// The initial rectangle (4x3) looks like:\n// 1 2 1\n// 4 3 4\n// 3 2 1\n// 1 1 1\nsubrectangleQueries.getValue(0, 2); // return 1\nsubrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);\n// After this update the rectangle looks like:\n// 5 5 5\n// 5 5 5\n// 5 5 5\n// 5 5 5 \nsubrectangleQueries.getValue(0, 2); // return 5\nsubrectangleQueries.getValue(3, 1); // return 5\nsubrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);\n// After this update the rectangle looks like:\n// 5   5   5\n// 5   5   5\n// 5   5   5\n// 10  10  10 \nsubrectangleQueries.getValue(3, 1); // return 10\nsubrectangleQueries.getValue(0, 2); // return 5\n\nExample 2:\nInput\n[\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\"]\n[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]\nOutput\n[null,1,null,100,100,null,20]\nExplanation\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);\nsubrectangleQueries.getValue(0, 0); // return 1\nsubrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);\nsubrectangleQueries.getValue(0, 0); // return 100\nsubrectangleQueries.getValue(2, 2); // return 100\nsubrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);\nsubrectangleQueries.getValue(2, 2); // return 20\n\nConstraints:\n\nThere will be at most 500 operations considering both methods: updateSubrectangle and getValue.\n1 <= rows, cols <= 100\nrows == rectangle.length\ncols == rectangle[i].length\n0 <= row1 <= row2 < rows\n0 <= col1 <= col2 < cols\n1 <= newValue, rectangle[i][j] <= 10^9\n0 <= row < rows\n0 <= col < cols\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def getValue (s : SubrectangleQueries) (i j : Nat) : Int := sorry\n\ndef updateSubrectangle (s : SubrectangleQueries) (row1 col1 row2 col2 : Nat) (newValue : Int) : Unit := sorry", "vc-theorems": "theorem initial_rectangle_values (rectangle : List (List Int)) (i j : Nat)\n  (h1 : i < rectangle.length)\n  (h2 : j < (rectangle.head!).length)\n  (h3 : rectangle.length > 0)\n  (h4 : (rectangle.head!).length > 0) :\n  getValue { rectangle := rectangle } i j = (rectangle.get! i).get! j := sorry\n\ntheorem update_covers_entire_rectangle (rectangle : List (List Int)) (testVal : Int)\n  (h1 : rectangle.length > 0)\n  (h2 : (rectangle.head!).length > 0) :\n  let s := { rectangle := rectangle }\n  let rows := rectangle.length\n  let cols := (rectangle.head!).length\n  let _ := updateSubrectangle s 0 0 (rows - 1) (cols - 1) testVal\n  ∀ i j, i < rows → j < cols →\n    getValue s i j = testVal := sorry\n\ntheorem multiple_updates_overlap (rectangle : List (List Int))\n  (h1 : rectangle.length > 0)\n  (h2 : (rectangle.head!).length > 0) :\n  let s := { rectangle := rectangle }\n  let rows := rectangle.length\n  let cols := (rectangle.head!).length\n  let _ := updateSubrectangle s 0 0 (rows - 1) (cols - 1) 10\n  let _ := updateSubrectangle s 0 0 (rows / 2) (cols / 2) 20\n  let _ := updateSubrectangle s (rows / 2) (cols / 2) (rows - 1) (cols - 1) 30\n  ∀ i j, i ≥ rows / 2 → i < rows → j ≥ cols / 2 → j < cols →\n    getValue s i j = 30 := sorry\n\ntheorem sequential_same_region_updates (rectangle : List (List Int)) (updates : List Int)\n  (h1 : rectangle.length > 0)\n  (h2 : (rectangle.head!).length > 0)\n  (h3 : updates.length > 0) :\n  let s := { rectangle := rectangle }\n  let rows := rectangle.length\n  let cols := (rectangle.head!).length\n  ∀ val ∈ updates, ∀ i j,\n    let _ := updateSubrectangle s 0 0 (rows - 1) (cols - 1) val\n    i < rows → j < cols →\n      getValue s i j = val := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1773", "language": "lean", "source": "fvapps", "source-id": "fvapps_001773", "source-notes": "", "vc-description": "/-\nGiven a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\nreturn its level order traversal as:\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def level_order (root : Option TreeNode) : List (List Int) :=\n  sorry", "vc-theorems": "theorem level_order_of_none :\n  level_order none = [] := by sorry\n\ntheorem level_order_single_node (value : Int) :\n  level_order (some (TreeNode.mk value none none)) = [[value]] := by sorry\n\ntheorem level_order_two_nodes (root_val left_val : Int) :\n  level_order (some (TreeNode.mk root_val (some (TreeNode.mk left_val none none)) none)) = [[root_val], [left_val]] := by sorry\n\ntheorem level_order_level_sizes {root : Option TreeNode} {result : List (List Int)}\n  (h : level_order root = result) :\n  ∀ (i : Nat) (level : List Int),\n  level ∈ result →\n  level.length ≤ 2^i := by sorry\n\ntheorem level_order_nonempty_levels {root : Option TreeNode} :\n  ∀ level ∈ level_order root,\n  level ≠ [] := by sorry\n\ntheorem level_order_output_structure {root : Option TreeNode} :\n  ∀ level ∈ level_order root,\n  level.all (fun _ => true) := by sorry\n\n/-\ninfo: [[3], [9, 20], [15, 7]]\n-/\n-- #guard_msgs in\n-- #eval level_order TreeNode(3)\n\n/-\ninfo: [[1]]\n-/\n-- #guard_msgs in\n-- #eval level_order TreeNode(1)\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval level_order None", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1776", "language": "lean", "source": "fvapps", "source-id": "fvapps_001776", "source-notes": "", "vc-description": "/-\nGiven an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n.\n\nExample:\n\nInput: 3\nOutput:\n[\n  [1,null,3,2],\n  [3,2,null,1],\n  [3,1,null,null,2],\n  [2,1,3],\n  [1,null,2,null,3]\n]\nExplanation:\nThe above output corresponds to the 5 unique BST's shown below:\n\n   1         3     3      2      1\n    \\       /     /      / \\      \\\n     3     2     1      1   3      2\n    /     /       \\                 \\\n   2     1         2                 3\n-/", "vc-preamble": "def generateTrees (n : Nat) : List TreeNode :=\n  sorry\n\ndef tree_to_list (t : TreeNode) : List Nat :=\n  sorry\n\ndef is_bst_valid (t : TreeNode) (min max : Int) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def contains_all_values (t : TreeNode) (n : Nat) : Bool :=\n  sorry", "vc-theorems": "theorem generateTrees_empty (n : Nat) :\n  n = 0 → generateTrees n = [] :=\n  sorry\n\ntheorem generate_trees_count_catalan (n : Nat) :\n  n ≤ 8 →\n  let catalan := [1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862]\n  List.length (generateTrees n) = List.get! catalan n :=\n  sorry\n\ntheorem generate_trees_are_valid_bst (n : Nat) (t : TreeNode) :\n  t ∈ generateTrees n →\n  is_bst_valid t (-2^31) (2^31 - 1) = true :=\n  sorry\n\ntheorem generate_trees_contain_all_values (n : Nat) (t : TreeNode) :\n  t ∈ generateTrees n →\n  contains_all_values t n = true :=\n  sorry \n\ntheorem generate_trees_are_unique (n : Nat) :\n  let tree_lists := List.map tree_to_list (generateTrees n)\n  List.length (List.eraseDups tree_lists) = List.length (generateTrees n) :=\n  sorry\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval generateTrees 0\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval len generateTrees(1)\n\n/-\ninfo: [1]\n-/\n-- #guard_msgs in\n-- #eval tree_to_list trees[0]\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval len generateTrees(3)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1778", "language": "lean", "source": "fvapps", "source-id": "fvapps_001778", "source-notes": "", "vc-description": "/-\nThe thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night.\n\nDetermine the maximum amount of money the thief can rob tonight without alerting the police.\n\nExample 1:\n\n     3\n    / \\\n   2   3\n    \\   \\ \n     3   1\n\nMaximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n\nExample 2:\n\n     3\n    / \\\n   4   5\n  / \\   \\ \n 1   3   1\n\nMaximum amount of money the thief can rob = 4 + 5 = 9.\n\nCredits:Special thanks to @dietpepsi for adding this problem and creating all test cases.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def rob_house : TreeNode → Nat\n  | _ => sorry\n\n-- Property: Result is always natural number", "vc-theorems": "theorem rob_house_nat (t : TreeNode) : \n  rob_house t ≥ 0 := by sorry\n\n-- Base case: Empty tree returns 0\n\ntheorem rob_house_empty :\n  rob_house TreeNode.nil = 0 := by sorry\n\n-- Base case: Single node returns its value \n\ntheorem rob_house_single (n : Nat) :\n  rob_house (TreeNode.node n TreeNode.nil TreeNode.nil) = n := by sorry\n\n-- Property: Result for tree with children is at least as large as root value\n\ntheorem rob_house_with_children (v : Nat) (l r : TreeNode) :\n  rob_house (TreeNode.node v l r) ≥ v := by sorry\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval rob_house TreeNode(3)\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval rob_house TreeNode(3)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1779", "language": "lean", "source": "fvapps", "source-id": "fvapps_001779", "source-notes": "", "vc-description": "/-\nGiven a binary tree, determine if it is a valid binary search tree (BST).\n\nAssume a BST is defined as follows:\n\n       The left subtree of a node contains only nodes with keys less than the node's key.\n       The right subtree of a node contains only nodes with keys greater than the node's key.\n       Both the left and right subtrees must also be binary search trees.\n\nExample 1:\n\nInput:\n    2\n   / \\\n  1   3\nOutput: true\n\nExample 2:\n\n    5\n   / \\\n  1   4\n     / \\\n    3   6\nOutput: false\nExplanation: The input is: [5,1,4,null,null,3,6]. The root node's value\n             is 5 but its right child's value is 4.\n-/", "vc-preamble": "def isValidBST : TreeNode → Bool :=\n  sorry\n\ndef make_valid_bst : List Int → TreeNode :=\n  sorry", "vc-helpers": "", "vc-definitions": "def insertIntoBST : TreeNode → Int → TreeNode :=\n  sorry", "vc-theorems": "theorem valid_bst_from_sorted_values (values : List Int) :\n  isValidBST (make_valid_bst values) = true :=\n  sorry\n\ntheorem empty_tree_is_valid :\n  isValidBST TreeNode.leaf = true :=\n  sorry \n\ntheorem single_node_is_valid (value : Int) :\n  isValidBST (TreeNode.node value TreeNode.leaf TreeNode.leaf) = true :=\n  sorry\n\ntheorem bst_remains_valid_after_insert (tree : TreeNode) (value : Int) :\n  isValidBST tree = true →\n  isValidBST (insertIntoBST tree value) = true :=\n  sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval isValidBST TreeNode(2)\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval isValidBST TreeNode(5)\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval isValidBST TreeNode(1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1782", "language": "lean", "source": "fvapps", "source-id": "fvapps_001782", "source-notes": "", "vc-description": "/-\nGiven a binary tree with the following rules:\n\nroot.val == 0\nIf treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1\nIf treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2\n\nNow the binary tree is contaminated, which means all treeNode.val have been changed to -1.\nYou need to first recover the binary tree and then implement the FindElements class:\n\nFindElements(TreeNode* root) Initializes the object with a contamined binary tree, you need to recover it first.\nbool find(int target) Return if the target value exists in the recovered binary tree.\n\nExample 1:\n\nInput\n[\"FindElements\",\"find\",\"find\"]\n[[[-1,null,-1]],[1],[2]]\nOutput\n[null,false,true]\nExplanation\nFindElements findElements = new FindElements([-1,null,-1]); \nfindElements.find(1); // return False \nfindElements.find(2); // return True \nExample 2:\n\nInput\n[\"FindElements\",\"find\",\"find\",\"find\"]\n[[[-1,-1,-1,-1,-1]],[1],[3],[5]]\nOutput\n[null,true,true,false]\nExplanation\nFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\nfindElements.find(1); // return True\nfindElements.find(3); // return True\nfindElements.find(5); // return False\nExample 3:\n\nInput\n[\"FindElements\",\"find\",\"find\",\"find\",\"find\"]\n[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\nOutput\n[null,true,false,false,true]\nExplanation\nFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\nfindElements.find(2); // return True\nfindElements.find(3); // return False\nfindElements.find(4); // return False\nfindElements.find(5); // return True\n\nConstraints:\n\nTreeNode.val == -1\nThe height of the binary tree is less than or equal to 20\nThe total number of nodes is between [1, 10^4]\nTotal calls of find() is between [1, 10^4]\n0 <= target <= 10^6\n-/", "vc-preamble": "def make_tree (values : List Int) (max_depth : Nat := 4) : TreeNode := sorry\n\ndef initFindElements (root : TreeNode) : FindElements := {\n  root := root,\n  find := fun _ => false\n}", "vc-helpers": "", "vc-definitions": "def isNode : TreeNode → Prop\n  | TreeNode.node _ _ _ => True\n  | _ => False", "vc-theorems": "theorem initialization_valid {values : List Int} \n  (h : values.length > 0) (h2 : values.length ≤ 15) :\n  let root := make_tree values\n  ∃ fe : FindElements, True := sorry\n\ntheorem empty_tree_find {target : Int}\n  (h : target ≥ 0) (h2 : target ≤ 100) :\n  let fe := initFindElements TreeNode.nil\n  fe.find target = false := sorry\n\ntheorem negative_values_not_found {target : Int}\n  (h : target < 0) (h2 : target ≥ -100) :\n  let root := make_tree [-1, -1, -1, -1]\n  let fe := initFindElements root\n  fe.find target = false := sorry\n\ntheorem valid_indices_found {values : List Int}\n  (h : values.length > 0) (h2 : values.length ≤ 15) :\n  let root := make_tree values\n  let fe := initFindElements root\n  fe.find 0 = true ∧ \n  (isNode root → fe.find 2 = true) ∧\n  (isNode root → fe.find 1 = true) := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1785", "language": "lean", "source": "fvapps", "source-id": "fvapps_001785", "source-notes": "", "vc-description": "/-\nGiven a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes.\nIf there isn't any rectangle, return 0.\n\nExample 1:\nInput: [[1,1],[1,3],[3,1],[3,3],[2,2]]\nOutput: 4\n\nExample 2:\nInput: [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\nOutput: 2\n\nNote:\n\n1 <= points.length <= 500\n0 <= points[i][0] <= 40000\n0 <= points[i][1] <= 40000\nAll points are distinct.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Point := Prod Int Int \n\ndef min_area_rectangle (points : List Point) : Nat := sorry", "vc-theorems": "theorem min_area_rectangle_nonnegative (points : List Point) : \n  min_area_rectangle points ≥ 0 := sorry\n\ntheorem min_area_rectangle_small_lists (points : List Point) : \n  points.length < 4 → min_area_rectangle points = 0 := sorry\n\ntheorem min_area_rectangle_single_line (points : List Point) :\n  (∀ (p1 p2 : Point), p1 ∈ points → p2 ∈ points → p1.1 = p2.1) ∨ \n  (∀ (p1 p2 : Point), p1 ∈ points → p2 ∈ points → p1.2 = p2.2) →\n  min_area_rectangle points = 0 := sorry\n\ntheorem min_area_rectangle_bound (points : List Point) \n  (h : points.length ≥ 4)\n  (h2 : min_area_rectangle points > 0) :\n  let xs := points.map Prod.fst;\n  let ys := points.map Prod.snd;\n  let max_x := xs.maximum? |>.getD 0;\n  let min_x := xs.minimum? |>.getD 0;\n  let max_y := ys.maximum? |>.getD 0;\n  let min_y := ys.minimum? |>.getD 0;\n  min_area_rectangle points ≤ (max_x - min_x) * (max_y - min_y) := sorry\n\ntheorem min_area_rectangle_translation_invariant (points : List Point) (shift : Int) :\n  min_area_rectangle points = \n  min_area_rectangle (points.map fun p => (p.1 + shift, p.2 + shift)) := sorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval min_area_rectangle [[1, 1], [1, 3], [3, 1], [3, 3], [2, 2]]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval min_area_rectangle [[1, 1], [1, 3], [3, 1], [3, 3], [4, 1], [4, 3]]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval min_area_rectangle [[1, 1], [1, 2], [2, 1], [2, 2]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1787", "language": "lean", "source": "fvapps", "source-id": "fvapps_001787", "source-notes": "", "vc-description": "/-\nGiven a binary tree, return the vertical order traversal of its nodes values.\nFor each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).\nRunning a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).\nIf two nodes have the same position, then the value of the node that is reported first is the value that is smaller.\nReturn an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.\n\nExample 1:\n\nInput: [3,9,20,null,null,15,7]\nOutput: [[9],[3,15],[20],[7]]\nExplanation: \nWithout loss of generality, we can assume the root node is at position (0, 0):\nThen, the node with value 9 occurs at position (-1, -1);\nThe nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);\nThe node with value 20 occurs at position (1, -1);\nThe node with value 7 occurs at position (2, -2).\n\nExample 2:\n\nInput: [1,2,3,4,5,6,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation: \nThe node with value 5 and the node with value 6 have the same position according to the given scheme.\nHowever, in the report \"[1,5,6]\", the node value of 5 comes first since 5 is smaller than 6.\n\nNote:\n\nThe tree will have between 1 and 1000 nodes.\nEach node's value will be between 0 and 1000.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def vertical_traverse : Option TreeNode → List (List Int)\n  | none => []\n  | some _ => sorry", "vc-theorems": "theorem vertical_traverse_type_preservation (t : Option TreeNode) :\n  ∀ l ∈ vertical_traverse t, l.all (λ x => True) := by sorry\n\ntheorem vertical_traverse_elements_integers (t : Option TreeNode) :\n  ∀ l ∈ vertical_traverse t, ∀ x ∈ l, True := by sorry\n\ntheorem vertical_traverse_empty (t : Option TreeNode) :\n  t = none → vertical_traverse t = [] := by sorry\n\ntheorem vertical_traverse_single_node (v : Int) :\n  vertical_traverse (some (TreeNode.mk v none none)) = [[v]] := by sorry\n\ntheorem vertical_traverse_left_linear (v1 v2 v3 : Int) :\n  let t3 := TreeNode.mk v3 none none\n  let t2 := TreeNode.mk v2 (some t3) none\n  let t1 := TreeNode.mk v1 (some t2) none\n  vertical_traverse (some t1) = [[v3], [v2], [v1]] := by sorry\n\ntheorem vertical_traverse_right_linear (v1 v2 v3 : Int) :\n  let t3 := TreeNode.mk v3 none none\n  let t2 := TreeNode.mk v2 none (some t3)\n  let t1 := TreeNode.mk v1 none (some t2)\n  vertical_traverse (some t1) = [[v1], [v2], [v3]] := by sorry\n\n/-\ninfo: [[9], [3, 15], [20], [7]]\n-/\n-- #guard_msgs in\n-- #eval vertical_traverse TreeNode(3)\n\n/-\ninfo: [[4], [2], [1, 5, 6], [3], [7]]\n-/\n-- #guard_msgs in\n-- #eval vertical_traverse TreeNode(1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1789", "language": "lean", "source": "fvapps", "source-id": "fvapps_001789", "source-notes": "", "vc-description": "/-\nStorekeeper is a game in which the player pushes boxes around in a warehouse trying to get them to target locations.\nThe game is represented by a grid of size m x n, where each element is a wall, floor, or a box.\nYour task is move the box 'B' to the target position 'T' under the following rules:\n\nPlayer is represented by character 'S' and can move up, down, left, right in the grid if it is a floor (empy cell).\nFloor is represented by character '.' that means free cell to walk.\nWall is represented by character '#' that means obstacle  (impossible to walk there). \nThere is only one box 'B' and one target cell 'T' in the grid.\nThe box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a push.\nThe player cannot walk through the box.\n\nReturn the minimum number of pushes to move the box to the target. If there is no way to reach the target, return -1.\n\nExample 1:\n\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n               [\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\nOutput: 3\nExplanation: We return only the number of times the box is pushed.\nExample 2:\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\".\",\".\",\"B\",\".\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\nOutput: -1\n\nExample 3:\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"T\",\".\",\".\",\"#\",\"#\"],\n               [\"#\",\".\",\"#\",\"B\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\".\",\"#\"],\n               [\"#\",\".\",\".\",\".\",\"S\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\nOutput: 5\nExplanation:  push the box down, left, left, up and up.\n\nExample 4:\nInput: grid = [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],\n               [\"#\",\"S\",\"#\",\".\",\"B\",\"T\",\"#\"],\n               [\"#\",\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\nOutput: -1\n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m <= 20\n1 <= n <= 20\ngrid contains only characters '.', '#',  'S' , 'T', or 'B'.\nThere is only one character 'S', 'B' and 'T' in the grid.\n-/", "vc-preamble": "def min_push_box (grid: Grid) : Int := sorry\n\ndef charEq (c1 c2 : Char) : Bool := c1.val = c2.val\n\ndef isValidCharProp (c: Char) : Prop := \n  c = '#' ∨ c = '.' ∨ c = 'S' ∨ c = 'B' ∨ c = 'T'", "vc-helpers": "", "vc-definitions": "def isValidGrid (grid: Grid) : Prop := sorry\n\n-- All grids must have exactly one player (S), one box (B) and one target (T)", "vc-theorems": "theorem valid_grid_unique_elements (grid: Grid) (h: isValidGrid grid) :\n  ∃ (s_pos b_pos t_pos : Nat × Nat),\n    (grid.cells.get? s_pos.1).bind (·.get? s_pos.2) = some 'S' ∧ \n    (grid.cells.get? b_pos.1).bind (·.get? b_pos.2) = some 'B' ∧\n    (grid.cells.get? t_pos.1).bind (·.get? t_pos.2) = some 'T' := sorry\n\n-- A minimal valid grid should be solvable with one push\n\ntheorem minimal_valid_grid_solvable (grid: Grid) :\n  isValidGrid grid →\n  grid.cells = [['#','#','#'], ['#','S','#'], ['#','B','#'], ['#','T','#'], ['#','#','#']] →\n  min_push_box grid = 1 := sorry\n\n-- Some valid grids are unsolvable\n\ntheorem unsolvable_grid_exists (grid: Grid) :\n  isValidGrid grid →\n  grid.cells = [['#','#','#','#'], ['#','S','#','#'], ['#','B','T','#'], ['#','#','#','#']] →\n  min_push_box grid = -1 := sorry\n\n-- Empty grid is invalid and should result in error\n\ntheorem empty_grid_invalid :\n  ¬ isValidGrid ⟨[]⟩ := sorry\n\n-- Valid grid contains only allowed characters \n\ntheorem valid_grid_chars (grid: Grid) (h: isValidGrid grid) :\n  ∀ row ∈ grid.cells, ∀ c ∈ row, isValidCharProp c := sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval min_push_box [[\"#\", \"#\", \"#\", \"#\", \"#\", \"#\"], [\"#\", \"T\", \"#\", \"#\", \"#\", \"#\"], [\"#\", \".\", \".\", \"B\", \".\", \"#\"], [\"#\", \".\", \"#\", \"#\", \".\", \"#\"], [\"#\", \".\", \".\", \".\", \"S\", \"#\"], [\"#\", \"#\", \"#\", \"#\", \"#\", \"#\"]]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval min_push_box [[\"#\", \"#\", \"#\", \"#\", \"#\", \"#\"], [\"#\", \"T\", \"#\", \"#\", \"#\", \"#\"], [\"#\", \".\", \".\", \"B\", \".\", \"#\"], [\"#\", \"#\", \"#\", \"#\", \".\", \"#\"], [\"#\", \".\", \".\", \".\", \"S\", \"#\"], [\"#\", \"#\", \"#\", \"#\", \"#\", \"#\"]]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval min_push_box [[\"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\"], [\"#\", \"S\", \"#\", \".\", \"B\", \"T\", \"#\"], [\"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\"]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1791", "language": "lean", "source": "fvapps", "source-id": "fvapps_001791", "source-notes": "", "vc-description": "/-\nGiven a binary search tree, write a function kthSmallest to find the kth smallest element in it.\n\nNote: \nYou may assume k is always valid, 1 ≤ k ≤ BST's total elements.\n\nExample 1:\n\nInput: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\nOutput: 1\n\nExample 2:\n\nInput: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\nOutput: 3\n\nFollow up:\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def kthSmallest (root : TreeNode) (k : Nat) : Int := sorry\n\ndef getSortedValues (root : TreeNode) : List Int := sorry\n\n-- Main theorem for kth smallest element matching sorted list", "vc-theorems": "theorem kth_smallest_matches_sorted\n  {root : TreeNode} {vals : List Int} {k : Nat}\n  (h1 : k > 0)\n  (h2 : k ≤ vals.length)\n  (h3 : vals = getSortedValues root) :\n  kthSmallest root k = vals[k-1] := sorry\n\n-- Theorem for sorted property of values\n\ntheorem sorted_values_ordered\n  {root : TreeNode} {vals : List Int}\n  (h : vals = getSortedValues root)\n  {i : Nat} (hi : i < vals.length - 1) :\n  vals[i] ≤ vals[i+1] := sorry\n\n-- Edge case theorems\n\ntheorem single_node_kth_smallest\n  {n : Int} (root : TreeNode)\n  (h1 : root = TreeNode.mk n none none) :\n  kthSmallest root 1 = n := sorry\n\ntheorem linear_left_tree_first_element\n  (root : TreeNode)\n  (h1 : root = TreeNode.mk 3 (some (TreeNode.mk 2 (some (TreeNode.mk 1 none none)) none)) none) :\n  kthSmallest root 1 = 1 := sorry\n\ntheorem linear_right_tree_last_element\n  (root : TreeNode)\n  (h1 : root = TreeNode.mk 1 none (some (TreeNode.mk 2 none (some (TreeNode.mk 3 none none))))) :\n  kthSmallest root 3 = 3 := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1793", "language": "lean", "source": "fvapps", "source-id": "fvapps_001793", "source-notes": "", "vc-description": "/-\nWe run a preorder depth first search on the root of a binary tree.\nAt each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.  (If the depth of a node is D, the depth of its immediate child is D+1.  The depth of the root node is 0.)\nIf a node has only one child, that child is guaranteed to be the left child.\nGiven the output S of this traversal, recover the tree and return its root.\n\nExample 1:\n\nInput: \"1-2--3--4-5--6--7\"\nOutput: [1,2,5,3,4,6,7]\n\nExample 2:\n\nInput: \"1-2--3---4-5--6---7\"\nOutput: [1,2,5,3,null,6,null,4,null,7]\n\nExample 3:\n\nInput: \"1-401--349---90--88\"\nOutput: [1,401,null,349,88,90]\n\nNote:\n\nThe number of nodes in the original tree is between 1 and 1000.\nEach node will have a value between 1 and 10^9.\n-/", "vc-preamble": "def valid_preorder_string (s : String) : Bool := sorry\n\ndef depth_never_skips (s : String) : Bool := sorry", "vc-helpers": "", "vc-definitions": "def toArray {α : Type} [Inhabited α] (t : BinTree α) : Array (Option α) := sorry \n\n/- If a string is in valid preorder format, then its depths should never skip levels -/", "vc-theorems": "theorem valid_implies_no_depth_skips (s : String) :\n  valid_preorder_string s → depth_never_skips s := sorry\n\n/- When converting tree to array, it's always non-empty -/\n\ntheorem tree_to_array_nonempty {α : Type} [Inhabited α] (t : BinTree α) :\n  (toArray t).size > 0 := sorry\n\n/- When converting a tree to array, the root always exists -/\n\ntheorem tree_to_array_root_exists {α : Type} [Inhabited α] (t : BinTree α) :\n  Option.isSome ((toArray t)[0]'(sorry)) := sorry\n\n/- In array form, if left child is None then right child must be None -/  \n\ntheorem array_child_property {α : Type} [Inhabited α] (t : BinTree α) \n  (i : Nat) (h1 : 1 ≤ i) (h2 : i < (toArray t).size - 1) (h3 : i % 2 = 1) :\n  Option.isNone ((toArray t)[i]'(sorry)) → Option.isNone ((toArray t)[i+1]'(sorry)) := sorry\n\n/-\ninfo: [1, 2, 5, 3, 4, 6, 7]\n-/\n-- #guard_msgs in\n-- #eval to_array recoverFromPreorder(\"1-2--3--4-5--6--7\")\n\n/-\ninfo: [1, 2, 5, 3, None, 6, None, 4, None, 7]\n-/\n-- #guard_msgs in\n-- #eval to_array recoverFromPreorder(\"1-2--3---4-5--6---7\")\n\n/-\ninfo: [1, 401, None, 349, 88, 90]\n-/\n-- #guard_msgs in\n-- #eval to_array recoverFromPreorder(\"1-401--349---90--88\")", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1794", "language": "lean", "source": "fvapps", "source-id": "fvapps_001794", "source-notes": "", "vc-description": "/-\nGiven the root of a binary tree, find the maximum value V for which there exists different nodes A and B where V = |A.val - B.val| and A is an ancestor of B.\n(A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)\n\nExample 1:\n\nInput: [8,3,10,1,6,null,14,null,null,4,7,13]\nOutput: 7\nExplanation: \nWe have various ancestor-node differences, some of which are given below :\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\nAmong all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.\n\nNote:\n\nThe number of nodes in the tree is between 2 and 5000.\nEach node will have value between 0 and 100000.\n-/", "vc-preamble": "def maxAncestorDiff : Option TreeNode → Int\n  | none => 0\n  | some _ => sorry\n\npartial def getAllValues : Option TreeNode → List Int\n  | none => []\n  | some (TreeNode.mk v l r) => v :: (getAllValues l ++ getAllValues r)\n\ndef listMaximum (l : List Int) : Int :=\n  match l with\n  | [] => 0\n  | x::xs => List.foldl max x xs", "vc-helpers": "", "vc-definitions": "def listMinimum (l : List Int) : Int :=\n  match l with\n  | [] => 0\n  | x::xs => List.foldl min x xs", "vc-theorems": "theorem maxAncestorDiff_nonnegative (tree : Option TreeNode) :\n  maxAncestorDiff tree ≥ 0 := sorry\n\ntheorem maxAncestorDiff_single_node (v : Int) :\n  maxAncestorDiff (some (TreeNode.mk v none none)) = 0 := sorry\n\ntheorem maxAncestorDiff_empty_tree :\n  maxAncestorDiff none = 0 := sorry\n\ntheorem maxAncestorDiff_bounded (tree : Option TreeNode) :\n  tree ≠ none →\n  maxAncestorDiff tree ≤ (listMaximum (getAllValues tree) - listMinimum (getAllValues tree)) := sorry\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval maxAncestorDiff TreeNode(8)\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval maxAncestorDiff TreeNode(1)\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval maxAncestorDiff TreeNode(2)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1795", "language": "lean", "source": "fvapps", "source-id": "fvapps_001795", "source-notes": "", "vc-description": "/-\nGiven the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.\nReturn the smallest level X such that the sum of all the values of nodes at level X is maximal.\n\nExample 1:\n\nInput: root = [1,7,0,7,-8,null,null]\nOutput: 2\nExplanation: \nLevel 1 sum = 1.\nLevel 2 sum = 7 + 0 = 7.\nLevel 3 sum = 7 + -8 = -1.\nSo we return the level with the maximum sum which is level 2.\n\nExample 2:\nInput: root = [989,null,10250,98693,-89388,null,null,null,-32127]\nOutput: 2\n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 104].\n-105 <= Node.val <= 105\n-/", "vc-preamble": "def maxLevelSum : Tree Int → Nat\n  | _ => sorry\n\ndef getLevelSums : Tree Int → List Int \n  | _ => sorry\n\ndef height : Tree Int → Nat\n  | _ => sorry\n\ndef completeTree : Int → Nat → Tree Int\n  | _ , _ => sorry", "vc-helpers": "", "vc-definitions": "def sum : List Int → Int \n  | _ => sorry", "vc-theorems": "theorem maxLevelSum_positive (t : Tree Int) :\n  maxLevelSum t ≥ 1 := sorry\n\ntheorem maxLevelSum_is_level_with_max_sum (t : Tree Int) :\n  ∃ (sums : List Int), \n    sums = getLevelSums t ∧ \n    ∀ (level : Nat), level ≤ height t → \n      sum (getLevelSums t) ≥ sum (getLevelSums t) := sorry\n\ntheorem maxLevelSum_single_node (x : Int) :\n  maxLevelSum (Tree.node x Tree.leaf Tree.leaf) = 1 := sorry\n\ntheorem maxLevelSum_complete_height_2 (x y z : Int) :\n  maxLevelSum (Tree.node x \n                (Tree.node y Tree.leaf Tree.leaf)\n                (Tree.node z Tree.leaf Tree.leaf)) = 1 := sorry\n\ntheorem maxLevelSum_same_values (x : Int) (h : Nat) :\n  maxLevelSum (completeTree x h) = 1 := sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval maxLevelSum TreeNode(1)\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval maxLevelSum TreeNode(989)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1798", "language": "lean", "source": "fvapps", "source-id": "fvapps_001798", "source-notes": "", "vc-description": "/-\nGiven the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.\n\nExamples 1\nInput:\n\n  5\n /  \\\n2   -3\n\nreturn [2, -3, 4], since all the values happen only once, return all of them in any order.\n\nExamples 2\nInput:\n\n  5\n /  \\\n2   -5\n\nreturn [2], since 2 happens twice, however -5 only occur once.\n\nNote:\nYou may assume the sum of values in any subtree is in the range of 32-bit signed integer.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def make_tree (values : List Int) : TreeNode := sorry\n\ndef find_frequent_tree_sum (root : TreeNode) : List Int := sorry", "vc-theorems": "theorem find_frequent_sum_properties \n  (values : List Int) \n  (result := find_frequent_tree_sum (make_tree values)) : \n  -- Empty tree returns empty list\n  (values = [] → result = []) ∧\n  -- Result is list of integers (satisfied by type system)\n  -- All frequencies are equal\n  (result ≠ [] → \n    ∀ x y, x ∈ result → y ∈ result → \n    (List.count x result) = (List.count y result))\n  := sorry\n\ntheorem single_node_tree_property\n  (value : Int)\n  (root := TreeNode.node value TreeNode.none TreeNode.none) :\n  find_frequent_tree_sum root = [value] := sorry\n\ntheorem empty_tree_property :\n  find_frequent_tree_sum TreeNode.none = [] := sorry\n\n/-\ninfo: [2]\n-/\n-- #guard_msgs in\n-- #eval find_frequent_tree_sum TreeNode(5)\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval find_frequent_tree_sum None", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1800", "language": "lean", "source": "fvapps", "source-id": "fvapps_001800", "source-notes": "", "vc-description": "/-\nGiven the root of a binary tree, consider all root to leaf paths: paths from the root to any leaf.  (A leaf is a node with no children.)\nA node is insufficient if every such root to leaf path intersecting this node has sum strictly less than limit.\nDelete all insufficient nodes simultaneously, and return the root of the resulting binary tree.\n\nExample 1:\n\nInput: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1\n\nOutput: [1,2,3,4,null,null,7,8,9,null,14]\n\nExample 2:\n\nInput: root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22\n\nOutput: [5,4,8,11,null,17,4,7,null,null,null,5]\n\nExample 3:\n\nInput: root = [1,2,-3,-5,null,4,null], limit = -1\n\nOutput: [1,null,-3,4]\n\nNote:\n\nThe given tree will have between 1 and 5000 nodes.\n-10^5 <= node.val <= 10^5\n-10^9 <= limit <= 10^9\n-/", "vc-preamble": "def arrayToTree : List (Option Int) → Option TreeNode := sorry\ndef treeToArray : Option TreeNode → List (Option Int) := sorry\n\ndef sufficientSubset : Option TreeNode → Int → Option TreeNode := sorry\ndef is_leaf : TreeNode → Bool := sorry", "vc-helpers": "", "vc-definitions": "def path_sum : TreeNode → Int := sorry\n\ntheorem sufficient_subset_is_subset (tree : List (Option Int)) (limit : Int)\n  (h : ∃ n, n ∈ tree ∧ n ≠ none) : \n  let root := arrayToTree tree\n  let result := sufficientSubset root limit\n  let result_arr := treeToArray result\n  ∀ x ∈ result_arr, x ≠ none → x ∈ tree := sorry", "vc-theorems": "theorem sufficient_subset_preserves_root (tree : List (Option Int)) (limit : Int)\n  (h₁ : tree.length > 0)\n  (h₂ : ∃ x, tree.head? = some (some x)) :\n  let root := arrayToTree tree\n  let result := sufficientSubset root limit\n  let result_arr := treeToArray result\n  result_arr.length > 0 → result_arr.head? = tree.head? := sorry\n\ntheorem sufficient_subset_leaf_property (tree : List (Option Int)) (limit : Int)\n  (h : ∃ n, n ∈ tree ∧ n ≠ none) :\n  let root := arrayToTree tree\n  let result := sufficientSubset root limit\n  match result with\n  | none => True\n  | some node => is_leaf node → path_sum node ≥ limit := sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval treeToArray sufficientSubset(root1, 1)\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval treeToArray sufficientSubset(root2, 22)\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval treeToArray sufficientSubset(root3, -1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1802", "language": "lean", "source": "fvapps", "source-id": "fvapps_001802", "source-notes": "", "vc-description": "/-\nGiven a binary tree, return the sum of values of its deepest leaves.\n\nExample 1:\n\nInput: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\nOutput: 15\n\nConstraints:\n\nThe number of nodes in the tree is between 1 and 10^4.\nThe value of nodes is between 1 and 100.\n-/", "vc-preamble": "def deepest_leaves_sum (root : TreeNode) : Int :=\n  sorry\n\ndef makeTree (vals : List Int) : TreeNode :=\n  sorry", "vc-helpers": "", "vc-definitions": "def getDeepestLevel (t : TreeNode) : List Int :=\n  sorry", "vc-theorems": "theorem single_path_tree_deepest_sum {vals : List Int} (h : vals ≠ []) :\n  let v := vals.head!\n  let root := TreeNode.mk v none none\n  let path := vals.tail.foldl (fun acc v => \n    TreeNode.mk v (some acc) none) root\n  deepest_leaves_sum path = vals.getLast! \n  := sorry\n\ntheorem level_order_tree_deepest_sum {vals : List Int} (h : vals ≠ []) : \n  let v := vals.head!\n  let root := TreeNode.mk v none none\n  deepest_leaves_sum root = (getDeepestLevel (makeTree vals)).foldl (· + ·) 0\n  := sorry\n\ntheorem single_node_deepest_sum (v : Int) :\n  deepest_leaves_sum (TreeNode.mk v none none) = v\n  := sorry\n\ntheorem two_level_tree_deepest_sum :\n  let root := TreeNode.mk 1 \n    (some (TreeNode.mk 2 none none))\n    (some (TreeNode.mk 3 none none))\n  deepest_leaves_sum root = 5\n  := sorry\n\n/-\ninfo: 15\n-/\n-- #guard_msgs in\n-- #eval deepest_leaves_sum TreeNode(1)\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval deepest_leaves_sum TreeNode(1)\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval deepest_leaves_sum TreeNode(1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1804", "language": "lean", "source": "fvapps", "source-id": "fvapps_001804", "source-notes": "", "vc-description": "/-\nWe are given a list schedule of employees, which represents the working time for each employee.\n\nEach employee has a list of non-overlapping Intervals, and these intervals are in sorted order.\n\nReturn the list of finite intervals representing common, positive-length free time for all employees, also in sorted order.\n\nExample 1:\n\nInput: schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]\nOutput: [[3,4]]\nExplanation:\nThere are a total of three employees, and all common\nfree time intervals would be [-inf, 1], [3, 4], [10, inf].\nWe discard any intervals that contain inf as they aren't finite.\n\nExample 2:\n\nInput: schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]\nOutput: [[5,6],[7,9]]\n\n(Even though we are representing Intervals in the form [x, y], the objects inside are Intervals, not lists or arrays.  For example, schedule[0][0].start = 1, schedule[0][0].end = 2, and schedule[0][0][0] is not defined.)\n\nAlso, we wouldn't include intervals like [5, 5] in our answer, as they have zero length.\n\nNote:\nschedule and schedule[i] are lists with lengths in range [1, 50].\n0 .\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def employeeFreeTime (schedule : List (List Interval)) : List Interval :=\n  sorry\n\nvariable (schedule : List (List Interval))\nvariable (result : List Interval := employeeFreeTime schedule)\nvariable (allIntervals : List Interval := schedule.join)", "vc-theorems": "theorem free_time_sorted : \n  ∀ i : Nat, i + 1 < result.length → \n  (result[i]!).finish < (result[i+1]!).start :=\n  sorry\n\ntheorem no_overlap_with_work :\n  ∀ free work : Interval, \n  free ∈ result → work ∈ allIntervals → \n  ¬(free.start < work.finish ∧ work.start < free.finish) :=\n  sorry\n\ntheorem valid_interval_bounds :\n  ∀ i : Interval, i ∈ result → i.start < i.finish :=\n  sorry\n\ntheorem continuous_work_valid_bounds (raw_times : List (List Int)) :\n  let schedule := raw_times.map (λ times => times.map (λ t => { start := t, finish := t+1 }))\n  let result := employeeFreeTime schedule\n  ∀ i : Interval, i ∈ result → i.start < i.finish :=\n  sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval len employeeFreeTime(schedule1)\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval len employeeFreeTime(schedule2)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1808", "language": "lean", "source": "fvapps", "source-id": "fvapps_001808", "source-notes": "", "vc-description": "/-\nThere are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.\n\nGiven a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.\n\nExample 1:\n\nInput: \n[[1,1,0],\n [1,1,0],\n [0,0,1]]\nOutput: 2\nExplanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.\n\nExample 2:\n\nInput: \n[[1,1,0],\n [1,1,1],\n [0,1,1]]\nOutput: 1\nExplanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.\n\nNote:\n\nN is in range [1,200].\nM[i][i] = 1 for all students.\nIf M[i][j] = 1, then M[j][i] = 1.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_circle_num (M : Matrix) : Nat :=\n  sorry", "vc-theorems": "theorem isolated_students {n : Nat} (h : n > 0) :\n  let M : Matrix := { \n    data := List.replicate n (List.replicate n 0)\n    all_rows_same_length := sorry\n    entries_zero_or_one := sorry\n    symmetric := sorry\n    diagonal_ones := sorry\n  }\n  find_circle_num M = n :=\n  sorry\n\ntheorem fully_connected {n : Nat} (h : n > 0) :\n  let M : Matrix := { \n    data := List.replicate n (List.replicate n 1)\n    all_rows_same_length := sorry\n    entries_zero_or_one := sorry\n    symmetric := sorry\n    diagonal_ones := sorry\n  }\n  find_circle_num M = 1 :=\n  sorry\n\ntheorem circles_bound (M : Matrix) (h : M.data.length = 3) :\n  1 ≤ find_circle_num M ∧ find_circle_num M ≤ M.data.length :=\n  sorry\n\ntheorem two_by_two_circles (M : Matrix) (h : M.data.length = 2) :\n  find_circle_num M = 1 ∨ find_circle_num M = 2 :=\n  sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval find_circle_num [[1, 1, 0], [1, 1, 0], [0, 0, 1]]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval find_circle_num [[1, 1, 0], [1, 1, 1], [0, 1, 1]]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval find_circle_num [[1, 0, 0], [0, 1, 0], [0, 0, 1]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1809", "language": "lean", "source": "fvapps", "source-id": "fvapps_001809", "source-notes": "", "vc-description": "/-\nGiven the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1. \n\nThe adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree.\n\nExample 1:\n\nInput: \nA binary tree as following:\n       4\n     /   \\\n    2     6\n   / \\   / \n  3   1 5   \n\nv = 1\n\nd = 2\n\nOutput: \n       4\n      / \\\n     1   1\n    /     \\\n   2       6\n  / \\     / \n 3   1   5   \n\nExample 2:\n\nInput: \nA binary tree as following:\n      4\n     /   \n    2    \n   / \\   \n  3   1    \n\nv = 1\n\nd = 3\n\nOutput: \n      4\n     /   \n    2\n   / \\    \n  1   1\n /     \\  \n3       1\n\nNote:\n\nThe given d is in range [1, maximum depth of the given tree + 1].\nThe given binary tree has at least one tree node.\n-/", "vc-preamble": "def list_to_tree : List Int → TreeNode :=\n  sorry\n\ndef tree_to_list : TreeNode → List Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def add_one_row : TreeNode → Int → Int → TreeNode :=\n  sorry", "vc-theorems": "theorem add_one_row_result_nonempty (t : TreeNode) (v : Int) (d : Int)\n  (h1 : -100 ≤ v ∧ v ≤ 100) (h2 : 1 ≤ d ∧ d ≤ 3) :\n  ∃ l : List Int, tree_to_list (add_one_row t v d) = l ∧ l ≠ [] :=\n  sorry\n\ntheorem add_one_row_depth_one (t : TreeNode) (v : Int) (orig_val : Int)\n  (h1 : -100 ≤ v ∧ v ≤ 100) (h2 : t ≠ TreeNode.leaf) :\n  let result := add_one_row t v 1\n  let result_list := tree_to_list result\n  result_list.head? = some v ∧\n  result_list.get? 1 = some orig_val :=\n  sorry\n\ntheorem add_one_row_single_node (val v : Int) (d : Int)\n  (h1 : -100 ≤ val ∧ val ≤ 100) (h2 : -100 ≤ v ∧ v ≤ 100) (h3 : d = 1 ∨ d = 2) :\n  let t := TreeNode.node val TreeNode.leaf TreeNode.leaf\n  let result := add_one_row t v d\n  let result_list := tree_to_list result\n  (d = 1 → result_list.head? = some v ∧ result_list.get? 1 = some val) ∧\n  (d = 2 → result_list.head? = some val ∧ \n           result_list.get? 1 = some v ∧\n           result_list.get? 2 = some v) :=\n  sorry\n\n/-\ninfo: [4, 1, 1, 2, None, None, 6, 3, 1, 5]\n-/\n-- #guard_msgs in\n-- #eval tree_to_list add_one_row(root1, 1, 2)\n\n/-\ninfo: [4, 2, None, 1, 1, 3, None, None, 1]\n-/\n-- #guard_msgs in\n-- #eval tree_to_list add_one_row(root2, 1, 3)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1811", "language": "lean", "source": "fvapps", "source-id": "fvapps_001811", "source-notes": "", "vc-description": "/-\nGiven a binary tree, find the leftmost value in the last row of the tree. \n\nExample 1:\n\nInput:\n\n    2\n   / \\\n  1   3\n\nOutput:\n1\n\n  Example 2: \n\nInput:\n\n        1\n       / \\\n      2   3\n     /   / \\\n    4   5   6\n       /\n      7\n\nOutput:\n7\n\nNote:\nYou may assume the tree (i.e., the given root node) is not NULL.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_bottom_left_value {α : Type} (t : BinaryTree α) : Option α :=\n  sorry", "vc-theorems": "theorem single_path_tree {α : Type} (v₁ v₂ v₃ v₄ v₅ : α) :\n  let t := BinaryTree.node v₁\n             (BinaryTree.node v₂\n               (BinaryTree.node v₃\n                 (BinaryTree.node v₄\n                   (BinaryTree.node v₅ BinaryTree.leaf BinaryTree.leaf)\n                   BinaryTree.leaf)\n                 BinaryTree.leaf)\n               BinaryTree.leaf)\n             BinaryTree.leaf\n  find_bottom_left_value t = some v₅ :=\nsorry\n\ntheorem complete_binary_tree :\n  let t := BinaryTree.node 1\n             (BinaryTree.node 2\n               (BinaryTree.node 4 BinaryTree.leaf BinaryTree.leaf)\n               (BinaryTree.node 5 BinaryTree.leaf BinaryTree.leaf))\n             (BinaryTree.node 3\n               (BinaryTree.node 6 BinaryTree.leaf BinaryTree.leaf)\n               (BinaryTree.node 7 BinaryTree.leaf BinaryTree.leaf))\n  find_bottom_left_value t = some 4 :=\nsorry\n\ntheorem single_node_tree {α : Type} (v : α) :\n  find_bottom_left_value (BinaryTree.node v BinaryTree.leaf BinaryTree.leaf) = some v :=\nsorry\n\ntheorem asymmetric_tree :\n  let t := BinaryTree.node 1\n             (BinaryTree.node 2 BinaryTree.leaf BinaryTree.leaf)\n             (BinaryTree.node 3\n               (BinaryTree.node 4 BinaryTree.leaf BinaryTree.leaf)\n               BinaryTree.leaf)\n  find_bottom_left_value t = some 4 :=\nsorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval find_bottom_left_value TreeNode(2)\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval find_bottom_left_value TreeNode(1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1812", "language": "lean", "source": "fvapps", "source-id": "fvapps_001812", "source-notes": "", "vc-description": "/-\nThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.\n\nGiven an integer n, return all distinct solutions to the n-queens puzzle.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.\n\nExample:\n\nInput: 4\nOutput: [\n [\".Q..\",  // Solution 1\n  \"...Q\",\n  \"Q...\",\n  \"..Q.\"],\n\n [\"..Q.\",  // Solution 2\n  \"Q...\",\n  \"...Q\",\n  \".Q..\"]\n]\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above.\n-/", "vc-preamble": "def check (p1 p2: (Nat × Nat)) : Bool := sorry\n\ndef passAll (xs: List (Nat × Nat)) (q: Nat × Nat) : Bool := sorry", "vc-helpers": "", "vc-definitions": "def reconstruct (points: List Nat) (n: Nat) : List (List String) := sorry \n\ndef solveNQueens (n: Nat) : List (List (List String)) := sorry", "vc-theorems": "theorem check_symmetry (p1 p2: (Nat × Nat)) :\n  check p1 p2 = check p2 p1 := sorry\n\ntheorem check_self_conflict (p: (Nat × Nat)) : \n  check p p = true := sorry\n\ntheorem solutions_valid_size (n: Nat) (h: 0 < n ∧ n ≤ 8) :\n  ∀ board ∈ solveNQueens n,\n    (board.length = n ∧ \n     ∀ row ∈ board, row.length = n ∧\n     List.length (List.join (board.map (λ row => row.filter (· = \"Q\")))) = n) := sorry\n\ntheorem queens_dont_conflict (n: Nat) (h: 0 < n ∧ n ≤ 8) :\n  ∀ board ∈ solveNQueens n,\n    let queens := (List.range n).filterMap (λ i => \n      let row := board[i]!\n      row.findIdx? (· = \"Q\") |>.map (λ j => (i, j)))\n    ∀ i j, i < queens.length → j < queens.length → i ≠ j →\n      ¬check queens[i]! queens[j]! := sorry\n\ntheorem reconstruct_dimensions (n: Nat) :\n  let points := List.range n\n  let board := reconstruct points n\n  board.length = n ∧ ∀ row ∈ board, row.length = n := sorry\n\ntheorem handle_nonpositive_size :\n  solveNQueens 0 = [] := sorry\n\n/-\ninfo: [['Q']]\n-/\n-- #guard_msgs in\n-- #eval solveNQueens 1\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval solveNQueens 4\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval solveNQueens 2", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1813", "language": "lean", "source": "fvapps", "source-id": "fvapps_001813", "source-notes": "", "vc-description": "/-\nGiven a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.\n\nNote: A leaf is a node with no children.\n\nExample:\n\nGiven the below binary tree and sum = 22,\n\n      5\n     / \\\n    4   8\n   /   / \\\n  11  13  4\n /  \\    / \\\n7    2  5   1\n\nReturn:\n\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_path_sum : TreeNode → Int → List (List Int)\n  | _, _ => sorry", "vc-theorems": "theorem find_path_sum_valid_sums (t: TreeNode) (target: Int) :\n  ∀ path ∈ find_path_sum t target,\n  (path.foldl (· + ·) 0) = target :=\n  sorry\n\ntheorem empty_tree_no_paths (target: Int) :\n  find_path_sum TreeNode.nil target = [] :=\n  sorry\n\ntheorem single_node_match (val target: Int) :\n  find_path_sum (TreeNode.node val TreeNode.nil TreeNode.nil) target =\n    if val = target then [[val]] else [] :=\n  sorry\n\n/-\ninfo: [[5, 4, 11, 2], [5, 8, 4, 5]]\n-/\n-- #guard_msgs in\n-- #eval find_path_sum TreeNode(5) 22\n\n/-\ninfo: [[1, 2]]\n-/\n-- #guard_msgs in\n-- #eval find_path_sum TreeNode(1) 3\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval find_path_sum None 0", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1814", "language": "lean", "source": "fvapps", "source-id": "fvapps_001814", "source-notes": "", "vc-description": "/-\nGiven a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list \"parts\".\n\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than 1.  This may lead to some parts being null.\n\nThe parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.\n\nReturn a List of ListNode's representing the linked list parts that are formed.\n\nExamples\n1->2->3->4, k = 5 // 5 equal parts\n[ [1], \n[2],\n[3],\n[4],\nnull ]\n\nExample 1:\n\nInput: \nroot = [1, 2, 3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe input and each element of the output are ListNodes, not arrays.\nFor example, the input root has root.val = 1, root.next.val = 2, \\root.next.next.val = 3, and root.next.next.next = null.\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but it's string representation as a ListNode is [].\n\nExample 2:\n\nInput: \nroot = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3\nOutput: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.\n\nNote:\nThe length of root will be in the range [0, 1000].\nEach value of a node in the input will be an integer in the range [0, 999].\nk will be an integer in the range [1, 50].\n-/", "vc-preamble": "def create_linked_list {α} (values : List α) : Option (Node α) := sorry\n\ndef linked_list_to_list {α} (node : Option (Node α)) : List α := sorry", "vc-helpers": "", "vc-definitions": "def split_list_to_parts {α} (head : Option (Node α)) (k : Nat) : List (Option (Node α)) := sorry\n\ntheorem split_list_returns_k_parts {α} (values : List α) (k : Nat) (h : k > 0) :\n  let head := create_linked_list values\n  let result := split_list_to_parts head k\n  result.length = k := sorry", "vc-theorems": "theorem split_list_preserves_elements {α} (values : List α) (k : Nat) (h : k > 0) :\n  let head := create_linked_list values\n  let result := split_list_to_parts head k\n  List.join (result.map linked_list_to_list) = values := sorry\n\ntheorem split_list_balanced_sizes {α} (values : List α) (k : Nat) (h : k > 0) :\n  let head := create_linked_list values\n  let result := split_list_to_parts head k\n  let non_empty := (result.map linked_list_to_list).filter (fun l => ¬l.isEmpty)\n  ¬non_empty.isEmpty →\n  (List.maximum? (non_empty.map List.length)).get! - \n  (List.minimum? (non_empty.map List.length)).get! ≤ 1 := sorry\n\ntheorem empty_list_split {α} (k : Nat) (h : k > 0) :\n  let result := split_list_to_parts (none : Option (Node α)) k\n  result.length = k ∧ \n  result.all (fun x => x.isNone) := sorry\n\ntheorem single_part_split {α} (values : List α) (h : values ≠ []) :\n  let head := create_linked_list values\n  let result := split_list_to_parts head 1\n  result.length = 1 ∧\n  linked_list_to_list result[0]! = values := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1818", "language": "lean", "source": "fvapps", "source-id": "fvapps_001818", "source-notes": "", "vc-description": "/-\nGiven the root of a binary tree, each node in the tree has a distinct value.\nAfter deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).\nReturn the roots of the trees in the remaining forest.  You may return the result in any order.\n\nExample 1:\n\nInput: root = [1,2,3,4,5,6,7], to_delete = [3,5]\nOutput: [[1,2,null,4],[6],[7]]\n\nConstraints:\n\nThe number of nodes in the given tree is at most 1000.\nEach node has a distinct value between 1 and 1000.\nto_delete.length <= 1000\nto_delete contains distinct values between 1 and 1000.\n-/", "vc-preamble": "def arrayToTree (arr : List Int) : Option TreeNode := sorry\ndef treeToArray (t : TreeNode) : List Int := sorry", "vc-helpers": "", "vc-definitions": "def delNodes (root : Option TreeNode) (to_delete : List Int) : List TreeNode := sorry\n\ntheorem delNodes_no_deleted_values (tree : List Int) (to_delete : List Int) \n  (h : ∀ x ∈ tree, x > 0 ∧ x ≤ 100) : \n  let root := arrayToTree tree\n  let result := delNodes root to_delete\n  let result_arrays := result.map treeToArray\n  let all_vals := result_arrays.join\n  ∀ val ∈ all_vals, ¬(val ∈ to_delete) := sorry", "vc-theorems": "theorem delNodes_preserves_nondeleted (tree : List Int) (to_delete : List Int) \n  (h : ∀ x ∈ tree, x > 0 ∧ x ≤ 100) :\n  let root := arrayToTree tree\n  let result := delNodes root to_delete\n  let result_arrays := result.map treeToArray\n  let all_vals := result_arrays.join\n  let original_vals := tree.filter (fun x => ¬(x ∈ to_delete))\n  all_vals.length = original_vals.length ∧\n  ∀ x, (x ∈ all_vals ↔ x ∈ original_vals) := sorry\n\ntheorem delNodes_valid_roots (tree : List Int) (to_delete : List Int)\n  (h : ∀ x ∈ tree, x > 0 ∧ x ≤ 100) :\n  let root := arrayToTree tree\n  let result := delNodes root to_delete\n  ∀ t ∈ result, match t with\n    | TreeNode.node val _ _ => ¬(val ∈ to_delete) := sorry\n\ntheorem delNodes_empty_deletion (tree : List Int)\n  (h : ∀ x ∈ tree, x > 0 ∧ x ≤ 100) :\n  let root := arrayToTree tree\n  let result := delNodes root []\n  result.length = 1 ∧ \n  match result with\n  | [t] => treeToArray t = tree\n  | _ => false := sorry\n\ntheorem delNodes_empty_tree :\n  delNodes none [1] = [] := sorry\n\ntheorem delNodes_single_node :\n  let root := some (TreeNode.node 1 none none)\n  delNodes root [] = [TreeNode.node 1 none none] ∧\n  delNodes root [1] = [] := sorry\n\n/-\ninfo: sorted(map(str, [[1, 2, None, 4], [6], [7]]))\n-/\n-- #guard_msgs in\n-- #eval sorted map(str, result1_arrays)\n\n/-\ninfo: sorted(map(str, [[1, None, 3]]))\n-/\n-- #guard_msgs in\n-- #eval sorted map(str, result2_arrays)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1820", "language": "lean", "source": "fvapps", "source-id": "fvapps_001820", "source-notes": "", "vc-description": "/-\nGiven a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null. \n\nThe width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation.\n\nExample 1:\n\nInput: \n\n           1\n         /   \\\n        3     2\n       / \\     \\  \n      5   3     9 \n\nOutput: 4\nExplanation: The maximum width existing in the third level with the length 4 (5,3,null,9).\n\nExample 2:\n\nInput: \n\n          1\n         /  \n        3    \n       / \\       \n      5   3     \n\nOutput: 2\nExplanation: The maximum width existing in the third level with the length 2 (5,3).\n\nExample 3:\n\nInput: \n\n          1\n         / \\\n        3   2 \n       /        \n      5      \n\nOutput: 2\nExplanation: The maximum width existing in the second level with the length 2 (3,2).\n\nExample 4:\n\nInput: \n\n          1\n         / \\\n        3   2\n       /     \\  \n      5       9 \n     /         \\\n    6           7\nOutput: 8\nExplanation:The maximum width existing in the fourth level with the length 8 (6,null,null,null,null,null,null,7).\n\nNote:\nAnswer will in the range of 32-bit signed integer.\n-/", "vc-preamble": "def widthOfBinaryTree : TreeNode → Nat\n  | _ => sorry", "vc-helpers": "", "vc-definitions": "def getHeight : TreeNode → Nat\n  | TreeNode.nil => 0\n  | TreeNode.node _ l r => 1 + Nat.max (getHeight l) (getHeight r)", "vc-theorems": "theorem width_is_nonnegative (t : TreeNode) :\n  widthOfBinaryTree t ≥ 0 := \n  sorry\n\ntheorem width_bounded_by_height (t : TreeNode) :\n  widthOfBinaryTree t ≤ 2 ^ (getHeight t) :=\n  sorry\n\ntheorem empty_tree_width :\n  widthOfBinaryTree TreeNode.nil = 0 :=\n  sorry\n\ntheorem single_node_width (v : Int) :\n  widthOfBinaryTree (TreeNode.node v TreeNode.nil TreeNode.nil) = 1 :=\n  sorry\n\ntheorem linear_tree_width (v : Int) :\n  let leftTree := TreeNode.node v \n    (TreeNode.node v \n      (TreeNode.node v \n        (TreeNode.node v TreeNode.nil TreeNode.nil) \n        TreeNode.nil)\n      TreeNode.nil)\n    TreeNode.nil\n  let rightTree := TreeNode.node v \n    TreeNode.nil\n    (TreeNode.node v \n      TreeNode.nil\n      (TreeNode.node v \n        TreeNode.nil\n        (TreeNode.node v TreeNode.nil TreeNode.nil)))\n  widthOfBinaryTree leftTree = 1 ∧ widthOfBinaryTree rightTree = 1 :=\n  sorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval widthOfBinaryTree TreeNode(1)\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval widthOfBinaryTree TreeNode(1)\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval widthOfBinaryTree TreeNode(1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1826", "language": "lean", "source": "fvapps", "source-id": "fvapps_001826", "source-notes": "", "vc-description": "/-\nGiven two binary trees original and cloned and given a reference to a node target in the original tree.\nThe cloned tree is a copy of the original tree.\nReturn a reference to the same node in the cloned tree.\nNote that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.\nFollow up: Solve the problem if repeated values on the tree are allowed.\n\nExample 1:\n\nInput: tree = [7,4,3,null,null,6,19], target = 3\nOutput: 3\nExplanation: In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.\n\nExample 2:\n\nInput: tree = [7], target =  7\nOutput: 7\n\nExample 3:\n\nInput: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4\nOutput: 4\n\nExample 4:\n\nInput: tree = [1,2,3,4,5,6,7,8,9,10], target = 5\nOutput: 5\n\nExample 5:\n\nInput: tree = [1,2,null,3], target = 2\nOutput: 2\n\nConstraints:\n\nThe number of nodes in the tree is in the range [1, 10^4].\nThe values of the nodes of the tree are unique.\ntarget node is a node from the original tree and is not null.\n-/", "vc-preamble": "def TreeNode.val : TreeNode → Int\n  | mk v _ _ => v\n\ndef TreeNode.left : TreeNode → Option TreeNode\n  | mk _ l _ => l\n\ndef TreeNode.right : TreeNode → Option TreeNode\n  | mk _ _ r => r\n\ndef build_tree_from_list (values : List Int) : Option TreeNode :=\n  sorry\n\ndef clone_tree (root : Option TreeNode) : Option TreeNode :=\n  sorry\n\ndef get_leftmost_node (root : Option TreeNode) : Option TreeNode :=\n  sorry", "vc-helpers": "", "vc-definitions": "def getTargetCopy (original cloned target: Option TreeNode) : Option TreeNode :=\n  sorry", "vc-theorems": "theorem target_copy_leftmost_preserves_values\n  (values : List Int) (h : values.length > 0)\n  (original : Option TreeNode) (h₁ : original = build_tree_from_list values)\n  (cloned : Option TreeNode) (h₂ : cloned = clone_tree original)\n  (target : Option TreeNode) (h₃ : target = get_leftmost_node original) :\n  match getTargetCopy original cloned target with\n  | none => False\n  | some result => \n    match target with\n    | none => False\n    | some t =>\n      (TreeNode.val result = TreeNode.val t) ∧\n      (Option.isSome (TreeNode.left t) → \n        Option.isSome (TreeNode.left result) ∧\n        (∀ rl tl, TreeNode.left result = some rl → TreeNode.left t = some tl → \n          TreeNode.val rl = TreeNode.val tl)) ∧\n      (Option.isSome (TreeNode.right t) →\n        Option.isSome (TreeNode.right result) ∧\n        (∀ rr tr, TreeNode.right result = some rr → TreeNode.right t = some tr → \n          TreeNode.val rr = TreeNode.val tr))\n  :=\n  sorry\n\ntheorem target_copy_root_preserves_values\n  (values : List Int) (h : values.length > 0)\n  (original : Option TreeNode) (h₁ : original = build_tree_from_list values)\n  (cloned : Option TreeNode) (h₂ : cloned = clone_tree original) :\n  match getTargetCopy original cloned original, original with\n  | some result, some orig => TreeNode.val result = TreeNode.val orig\n  | _, _ => False :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1827", "language": "lean", "source": "fvapps", "source-id": "fvapps_001827", "source-notes": "", "vc-description": "/-\nGiven a complete binary tree, count the number of nodes.\n\nNote: \n\nDefinition of a complete binary tree from Wikipedia:\nIn a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\n\nExample:\n\nInput: \n    1\n   / \\\n  2   3\n / \\  /\n4  5 6\n\nOutput: 6\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def buildCompleteTree {α : Type} (values : List α) : BTree α := sorry\n\ndef countCompleteTreeNodes {α : Type} (t : BTree α) : Nat := sorry", "vc-theorems": "theorem count_matches_input_size {α : Type} (values : List α) :\n  countCompleteTreeNodes (buildCompleteTree values) = values.length := sorry\n\ntheorem perfect_tree_size (h : Nat) : \n  let t : BTree Nat := if h = 0 then BTree.leaf else buildCompleteTree (List.range (2^h - 1))\n  countCompleteTreeNodes t = if h = 0 then 0 else 2^h - 1 := sorry\n\ntheorem empty_tree_count {α : Type} :\n  countCompleteTreeNodes (BTree.leaf : BTree α) = 0 := sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval count_complete_tree_nodes TreeNode(1)\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval count_complete_tree_nodes TreeNode(1)\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval count_complete_tree_nodes TreeNode(1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1829", "language": "lean", "source": "fvapps", "source-id": "fvapps_001829", "source-notes": "", "vc-description": "/-\nGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n\nExample:\n\nGiven this linked list: 1->2->3->4->5\n\nFor k = 2, you should return: 2->1->4->3->5\n\nFor k = 3, you should return: 3->2->1->4->5\n\nNote:\n\n       Only constant extra memory is allowed.\n       You may not alter the values in the list's nodes, only nodes itself may be changed.\n-/", "vc-preamble": "def reverseKGroup (head: ListNode) (k: Nat) : ListNode :=\n  sorry\n\ndef list_to_array (head: ListNode) : List Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def array_to_list (arr: List Int) : ListNode :=\n  sorry", "vc-theorems": "theorem reverseKGroup_length_preserved \n  (lst: List Int) (k: Nat) (h: k > 0): \n  List.length (list_to_array (reverseKGroup (array_to_list lst) k)) = List.length lst :=\n  sorry\n\ntheorem reverseKGroup_elements_preserved\n  (lst: List Int) (k: Nat) (h: k > 0):\n  ∃ perm : List Int, \n    list_to_array (reverseKGroup (array_to_list lst) k) = perm ∧ \n    List.length perm = List.length lst ∧\n    ∀ x, List.count x perm = List.count x lst :=\n  sorry\n\ntheorem reverseKGroup_k_equals_one_is_identity\n  (lst: List Int):\n  list_to_array (reverseKGroup (array_to_list lst) 1) = lst :=\n  sorry\n\ntheorem reverseKGroup_subsequence_reversal\n  (lst: List Int) (k: Nat) (h: k > 0) (i: Nat) \n  (h₁: i + k ≤ List.length lst):\n  let result := list_to_array (reverseKGroup (array_to_list lst) k)\n  let sublist := List.take k (List.drop i lst)\n  List.take k (List.drop i result) = List.reverse sublist :=\n  sorry\n\n/-\ninfo: [2, 1, 4, 3, 5]\n-/\n-- #guard_msgs in\n-- #eval list_to_array reverseKGroup(head1, 2)\n\n/-\ninfo: [3, 2, 1, 4, 5]\n-/\n-- #guard_msgs in\n-- #eval list_to_array reverseKGroup(head2, 3)\n\n/-\ninfo: [1, 2, 3]\n-/\n-- #guard_msgs in\n-- #eval list_to_array reverseKGroup(head3, 1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1830", "language": "lean", "source": "fvapps", "source-id": "fvapps_001830", "source-notes": "", "vc-description": "/-\nSort a linked list in O(n log n) time using constant space complexity.\n\nExample 1:\n\nInput: 4->2->1->3\nOutput: 1->2->3->4\n\nExample 2:\n\nInput: -1->5->3->4->0\nOutput: -1->0->3->4->5\n-/", "vc-preamble": "def arrayToLinkedList : List Int → ListNode := sorry\ndef linkedListToArray : ListNode → List Int := sorry", "vc-helpers": "", "vc-definitions": "def sortList : ListNode → ListNode := sorry\n\ndef isSorted : List Int → Bool\n  | [] => true\n  | [_] => true\n  | x :: y :: rest => x ≤ y && isSorted (y :: rest)", "vc-theorems": "theorem sort_maintains_elements (arr : List Int) :\n  ∃ perm : List Int, linkedListToArray (sortList (arrayToLinkedList arr)) = perm := sorry\n\ntheorem sorted_result (arr : List Int) :\n  let result := linkedListToArray (sortList (arrayToLinkedList arr))\n  isSorted result := sorry\n\ntheorem length_preserved (arr : List Int) :\n  (linkedListToArray (sortList (arrayToLinkedList arr))).length = arr.length := sorry\n\ntheorem max_min_preserved (arr : List Int) (h : arr ≠ []) :\n  let result := linkedListToArray (sortList (arrayToLinkedList arr))\n  let min := result[0]!\n  let max := result[result.length - 1]!\n  (∀ x ∈ arr, min ≤ x) ∧ (∀ x ∈ arr, x ≤ max) := sorry\n\ntheorem empty_list :\n  sortList ListNode.nil = ListNode.nil := sorry\n\n/-\ninfo: [1, 2, 3, 4]\n-/\n-- #guard_msgs in\n-- #eval linkedListToArray sortList(head1)\n\n/-\ninfo: [-1, 0, 3, 4, 5]\n-/\n-- #guard_msgs in\n-- #eval linkedListToArray sortList(head2)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1831", "language": "lean", "source": "fvapps", "source-id": "fvapps_001831", "source-notes": "", "vc-description": "/-\nGiven many words, words[i] has weight i.\n\nDesign a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix).\nIt will return the word with given prefix and suffix with maximum weight.  If no word exists, return -1.\n\nExamples:\n\nInput:\nWordFilter([\"apple\"])\nWordFilter.f(\"a\", \"e\") // returns 0\nWordFilter.f(\"b\", \"\") // returns -1\n\nNote:\n\nwords has length in range [1, 15000].\nFor each test case, up to words.length queries WordFilter.f may be made.\nwords[i] has length in range [1, 10].\nprefix, suffix have lengths in range [0, 10].\nwords[i] and prefix, suffix queries consist of lowercase letters only.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def WordFilter.new (words : List String) : WordFilter := sorry\n\ndef mkString : List Char → String := sorry", "vc-theorems": "theorem wordfilter_result_bounds (words : List String) (wf : WordFilter)\n    (h : words ≠ []) (p s : String) :\n  wf.f p s ≤ words.length := sorry\n\ntheorem wordfilter_match_criteria (words : List String) (wf : WordFilter)\n    (h : words ≠ []) (p s : String)\n    (startsWith endsWith : String → String → Bool)\n    (h3 : wf.f p s < words.length) :\n  let matching_word := words.get! (wf.f p s)\n  startsWith matching_word p ∧ endsWith matching_word s := sorry\n\ntheorem wordfilter_last_match (words : List String) (wf : WordFilter)\n    (h : words ≠ []) (p s : String)\n    (startsWith endsWith : String → String → Bool)\n    (h3 : wf.f p s < words.length) :\n  ∀ i, wf.f p s < i → i < words.length →\n  ¬(startsWith (words.get! i) p ∧ endsWith (words.get! i) s) := sorry\n\ntheorem wordfilter_empty_strings (words : List String) (wf : WordFilter)\n    (h : words ≠ []) :\n  wf.f \"\" \"\" = words.length - 1 := sorry\n\ntheorem wordfilter_impossible_match (words : List String) (wf : WordFilter)\n    (h : words ≠ []) (maxLen : Nat) (len : String → Nat)\n    (h2 : maxLen = words.foldl (fun m w => max m (len w)) 0) :\n  wf.f (mkString (List.replicate (maxLen + 1) 'a')) \"\" = words.length := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1835", "language": "lean", "source": "fvapps", "source-id": "fvapps_001835", "source-notes": "", "vc-description": "/-\nGiven a non-empty binary tree, find the maximum path sum.\n\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\n\nExample 1:\n\nInput: [1,2,3]\n\n       1\n      / \\\n     2   3\n\nOutput: 6\n\nExample 2:\n\nInput: [-10,9,20,null,null,15,7]\n\n   -10\n   / \\\n  9  20\n    /  \\\n   15   7\n\nOutput: 42\n-/", "vc-preamble": "def maxPathSum (t : Tree Int) : Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def listMax (l : List Int) : Int :=\n  sorry", "vc-theorems": "theorem max_path_sum_geq_max_node_value (t : Tree Int) (values : List Int) \n  (h : values.length > 0) : \n  maxPathSum t ≥ listMax values := sorry\n\ntheorem max_path_sum_is_finite (t : Tree Int) :\n  ∃ (n : Int), maxPathSum t = n := sorry\n\ntheorem max_path_sum_single_node (v : Int) :\n  maxPathSum (Tree.leaf v) = v := sorry\n\ntheorem max_path_sum_linear_path (v : Int) :\n  v ≥ 0 → maxPathSum (Tree.node v (Tree.node v (Tree.leaf v) (Tree.leaf v)) (Tree.leaf v)) ≥ 2 * v := sorry\n\ntheorem max_path_sum_linear_path_neg (v : Int) :\n  v ≤ 0 → maxPathSum (Tree.node v (Tree.node v (Tree.leaf v) (Tree.leaf v)) (Tree.leaf v)) ≥ v := sorry\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval maxPathSum TreeNode(1)\n\n/-\ninfo: 42\n-/\n-- #guard_msgs in\n-- #eval maxPathSum TreeNode(-10)\n\n/-\ninfo: -3\n-/\n-- #guard_msgs in\n-- #eval maxPathSum TreeNode(-3)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1838", "language": "lean", "source": "fvapps", "source-id": "fvapps_001838", "source-notes": "", "vc-description": "/-\nThere are a total of n courses you have to take, labeled from 0 to n-1.\n\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\n\nGiven the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.\n\nThere may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.\n\nExample 1:\n\nInput: 2, [[1,0]] \nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished   \n             course 0. So the correct course order is [0,1] .\n\nExample 2:\n\nInput: 4, [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,1,2,3] or [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both     \n             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. \n             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .\n\nNote:\n\n       The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\n       You may assume that there are no duplicate edges in the input prerequisites.\n-/", "vc-preamble": "def find_course_order (numCourses : Nat) (prerequisites : List (Nat × Nat)) : List Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def isSorted (l : List Nat) : Prop :=\n  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!", "vc-theorems": "theorem empty_prerequisites (n : Nat) (h : 0 < n) :\n  let result := find_course_order n []\n  (result.length = n) ∧ \n  (isSorted result) ∧\n  (∀ i < n, i ∈ result) := by\n  sorry\n\ntheorem prerequisites_in_range (n : Nat) (prereqs : List (Nat × Nat)) (h : 0 < n) :\n  let valid_prereqs := prereqs.filter (fun p => p.1 < n ∧ p.2 < n)\n  let result := find_course_order n valid_prereqs\n  result.length ≠ 0 → \n  (result.length = n) ∧\n  (isSorted result) ∧\n  (∀ i < n, i ∈ result) ∧\n  (∀ course, ∀ post pre, \n    course ∈ result →\n    (post, pre) ∈ valid_prereqs →\n    post = course → \n    pre ∈ (result.take (result.indexOf course))) := by\n  sorry\n\ntheorem cycle_detection (n : Nat) (h : 1 < n) :\n  let cyclic_prereqs := \n    (List.range (n-1)).map (fun i => (i+1, i)) ++ [(0, n-1)]\n  find_course_order n cyclic_prereqs = [] := by\n  sorry\n\ntheorem linear_chain (n : Nat) (h : 0 < n) :\n  let linear_prereqs := \n    (List.range (n-1)).map (fun i => (i+1, i))\n  find_course_order n linear_prereqs = List.range n := by\n  sorry\n\n/-\ninfo: [0, 1]\n-/\n-- #guard_msgs in\n-- #eval find_course_order 2 [[1, 0]]\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval find_course_order 2 [[1, 0], [0, 1]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1839", "language": "lean", "source": "fvapps", "source-id": "fvapps_001839", "source-notes": "", "vc-description": "/-\nCreate a timebased key-value store class TimeMap, that supports two operations.\n1. set(string key, string value, int timestamp)\n\nStores the key and value, along with the given timestamp.\n\n2. get(string key, int timestamp)\n\nReturns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev <= timestamp.\nIf there are multiple such values, it returns the one with the largest timestamp_prev.\nIf there are no values, it returns the empty string (\"\").\n\nExample 1:\nInput: inputs = [\"TimeMap\",\"set\",\"get\",\"get\",\"set\",\"get\",\"get\"], inputs = [[],[\"foo\",\"bar\",1],[\"foo\",1],[\"foo\",3],[\"foo\",\"bar2\",4],[\"foo\",4],[\"foo\",5]]\nOutput: [null,null,\"bar\",\"bar\",null,\"bar2\",\"bar2\"]\nExplanation:   \nTimeMap kv;   \nkv.set(\"foo\", \"bar\", 1); // store the key \"foo\" and value \"bar\" along with timestamp = 1   \nkv.get(\"foo\", 1);  // output \"bar\"   \nkv.get(\"foo\", 3); // output \"bar\" since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie \"bar\"   \nkv.set(\"foo\", \"bar2\", 4);   \nkv.get(\"foo\", 4); // output \"bar2\"   \nkv.get(\"foo\", 5); //output \"bar2\"   \n\nExample 2:\nInput: inputs = [\"TimeMap\",\"set\",\"set\",\"get\",\"get\",\"get\",\"get\",\"get\"], inputs = [[],[\"love\",\"high\",10],[\"love\",\"low\",20],[\"love\",5],[\"love\",10],[\"love\",15],[\"love\",20],[\"love\",25]]\nOutput: [null,null,null,\"\",\"high\",\"high\",\"low\",\"low\"]\n\nNote:\n\nAll key/value strings are lowercase.\nAll key/value strings have length in the range [1, 100]\nThe timestamps for all TimeMap.set operations are strictly increasing.\n1 <= timestamp <= 10^7\nTimeMap.set and TimeMap.get functions will be called a total of 120000 times (combined) per test case.\n-/", "vc-preamble": "def TimeMap.set (tm : TimeMap) (key : String) (value : String) (timestamp : Nat) : TimeMap :=\n  sorry", "vc-helpers": "", "vc-definitions": "def TimeMap.get (tm : TimeMap) (key : String) (timestamp : Nat) : String :=\n  sorry", "vc-theorems": "theorem set_then_get_returns_same_value \n  (key : String) (value : String) (timestamp : Nat) :\n  ∀ tm : TimeMap,\n  TimeMap.get (TimeMap.set tm key value timestamp) key timestamp = value :=\nsorry\n\ntheorem multiple_values_preserved_order\n  (key : String) (value1 value2 : String) (ts1 ts2 : Nat) :\n  ts1 ≠ ts2 →\n  let first_ts := min ts1 ts2\n  let second_ts := max ts1 ts2\n  let first_val := if ts1 < ts2 then value1 else value2\n  let second_val := if ts1 < ts2 then value2 else value1\n  ∀ tm : TimeMap,\n  let tm' := TimeMap.set tm key first_val first_ts\n  let tm'' := TimeMap.set tm' key second_val second_ts\n  (TimeMap.get tm'' key first_ts = first_val) ∧\n  (TimeMap.get tm'' key second_ts = second_val) :=\nsorry\n\ntheorem timestamp_boundaries\n  (key : String) (value : String) (timestamp query_time : Nat) :\n  ∀ tm : TimeMap,\n  let tm' := TimeMap.set tm key value timestamp\n  (query_time < timestamp → \n    TimeMap.get tm' key query_time = \"\" ∨ \n    TimeMap.get tm' key query_time = value) ∧\n  (query_time ≥ timestamp →\n    TimeMap.get tm' key query_time = value) :=\nsorry\n\ntheorem nonexistent_key\n  (key : String) (timestamp : Nat) :\n  ∀ tm : TimeMap,\n  TimeMap.get tm key timestamp = \"\" :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1840", "language": "lean", "source": "fvapps", "source-id": "fvapps_001840", "source-notes": "", "vc-description": "/-\nYou have an infinite number of stacks arranged in a row and numbered (left to right) from 0, each of the stacks has the same maximum capacity.\nImplement the DinnerPlates class:\n\nDinnerPlates(int capacity) Initializes the object with the maximum capacity of the stacks.\nvoid push(int val) Pushes the given positive integer val into the leftmost stack with size less than capacity.\nint pop() Returns the value at the top of the rightmost non-empty stack and removes it from that stack, and returns -1 if all stacks are empty.\nint popAtStack(int index) Returns the value at the top of the stack with the given index and removes it from that stack, and returns -1 if the stack with that given index is empty.\n\nExample:\nInput: \n[\"DinnerPlates\",\"push\",\"push\",\"push\",\"push\",\"push\",\"popAtStack\",\"push\",\"push\",\"popAtStack\",\"popAtStack\",\"pop\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]]\nOutput: \n[null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1]\n\nExplanation: \nDinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2\nD.push(1);\nD.push(2);\nD.push(3);\nD.push(4);\nD.push(5);         // The stacks are now:  2  4\n                                           1  3  5\n                                           ﹈ ﹈ ﹈\nD.popAtStack(0);   // Returns 2.  The stacks are now:     4\n                                                       1  3  5\n                                                       ﹈ ﹈ ﹈\nD.push(20);        // The stacks are now: 20  4\n                                           1  3  5\n                                           ﹈ ﹈ ﹈\nD.push(21);        // The stacks are now: 20  4 21\n                                           1  3  5\n                                           ﹈ ﹈ ﹈\nD.popAtStack(0);   // Returns 20.  The stacks are now:     4 21\n                                                        1  3  5\n                                                        ﹈ ﹈ ﹈\nD.popAtStack(2);   // Returns 21.  The stacks are now:     4\n                                                        1  3  5\n                                                        ﹈ ﹈ ﹈ \nD.pop()            // Returns 5.  The stacks are now:      4\n                                                        1  3 \n                                                        ﹈ ﹈  \nD.pop()            // Returns 4.  The stacks are now:   1  3 \n                                                        ﹈ ﹈   \nD.pop()            // Returns 3.  The stacks are now:   1 \n                                                        ﹈   \nD.pop()            // Returns 1.  There are no stacks.\nD.pop()            // Returns -1.  There are still no stacks.\n\nConstraints:\n\n1 <= capacity <= 20000\n1 <= val <= 20000\n0 <= index <= 100000\nAt most 200000 calls will be made to push, pop, and popAtStack.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem test_empty_pop {α : Type} (plates : DinnerPlates α) (cap : Nat)\n    (h : cap > 0) (h2 : cap ≤ 100) :\n    plates.pop = none := sorry\n\ntheorem test_push_pop_sequence {α : Type} (plates : DinnerPlates α) \n    (cap : Nat) (values : List α)\n    (h : cap > 0) (h2 : cap ≤ 10) (h3 : values.length > 0) (h4 : values.length ≤ 20) :\n    ∀ v ∈ values, plates.pop = some v ∨ plates.pop = none := sorry\n\ntheorem test_pop_at_stack {α : Type} (plates : DinnerPlates α)\n    (cap : Nat) (values : List α) (stackIdx : Nat)\n    (h : cap > 0) (h2 : cap ≤ 10) (h3 : values.length > 0) \n    (h4 : values.length ≤ 20) (h5 : stackIdx ≤ 5) :\n    plates.stacks ≠ [] →\n    ∃ v, plates.popAtStack stackIdx = some v ∧ v ∈ values ∨ plates.popAtStack stackIdx = none := sorry\n\ntheorem test_sequential_operations {α : Type} (plates : DinnerPlates α)\n    (cap : Nat) (values : List α)\n    (h : cap > 0) (h2 : cap ≤ 10) (h3 : values.length ≤ 20) :\n    values.length > 2 →\n    ∃ v, plates.pop = some v ∧ v ∈ values ∨ plates.pop = none := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1841", "language": "lean", "source": "fvapps", "source-id": "fvapps_001841", "source-notes": "", "vc-description": "/-\nGiven a binary tree, we install cameras on the nodes of the tree. \nEach camera at a node can monitor its parent, itself, and its immediate children.\nCalculate the minimum number of cameras needed to monitor all nodes of the tree.\n\nExample 1:\n\nInput: [0,0,null,0,0]\nOutput: 1\nExplanation: One camera is enough to monitor all nodes if placed as shown.\n\nExample 2:\n\nInput: [0,0,null,0,null,0,null,null,0]\nOutput: 2\nExplanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.\n\nNote:\n\nThe number of nodes in the given tree will be in the range [1, 1000].\nEvery node has value 0.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def minCameraCover : Option TreeNode → Nat :=\n  sorry", "vc-theorems": "theorem minCameraCover_nonnegative (t : TreeNode) :\n  minCameraCover (some t) ≥ 0 := sorry\n\ntheorem minCameraCover_leaf (t : TreeNode) (v : Int) :\n  t = TreeNode.mk v none none → \n  minCameraCover (some t) = 1 := sorry\n\ntheorem minCameraCover_empty :\n  minCameraCover none = 0 := sorry\n\ntheorem minCameraCover_monotone (t t' : TreeNode) (v : Int) (r : Option TreeNode) :\n  t' = TreeNode.mk v (some t) r →\n  minCameraCover (some t') ≥ 1 := sorry\n\ntheorem minCameraCover_add_child (t root : TreeNode) (n : Nat) (v : Int) (l : Option TreeNode) :\n  minCameraCover (some root) = n →\n  root = TreeNode.mk v l (some t) →\n  minCameraCover (some root) ≥ n := sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval minCameraCover TreeNode(0)\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval minCameraCover TreeNode(0)\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval minCameraCover TreeNode(0)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1843", "language": "lean", "source": "fvapps", "source-id": "fvapps_001843", "source-notes": "", "vc-description": "/-\nA transaction is possibly invalid if:\n\nthe amount exceeds $1000, or;\nif it occurs within (and including) 60 minutes of another transaction with the same name in a different city.\n\nEach transaction string transactions[i] consists of comma separated values representing the name, time (in minutes), amount, and city of the transaction.\nGiven a list of transactions, return a list of transactions that are possibly invalid.  You may return the answer in any order.\n\nExample 1:\nInput: transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nOutput: [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nExplanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.\nExample 2:\nInput: transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\nOutput: [\"alice,50,1200,mtv\"]\n\nExample 3:\nInput: transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\nOutput: [\"bob,50,1200,mtv\"]\n\nConstraints:\n\ntransactions.length <= 1000\nEach transactions[i] takes the form \"{name},{time},{amount},{city}\"\nEach {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10.\nEach {time} consist of digits, and represent an integer between 0 and 1000.\nEach {amount} consist of digits, and represent an integer between 0 and 2000.\n-/", "vc-preamble": "def Transaction.array (t : Transaction) : String := sorry\n\ndef find_invalid_transactions (trans : List String) : List String := sorry\n\ndef abs (n : Int) : Int := \n  if n < 0 then -n else n", "vc-helpers": "", "vc-definitions": "def splitStr (s : String) : List String := sorry\n\ntheorem transaction_construction (name : String) (time amount : Int) (city : String) :\n  let t := Transaction.mk name time amount city\n  t.name = name ∧ \n  t.time = time ∧\n  t.amount = amount ∧ \n  t.city = city := sorry", "vc-theorems": "", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1844", "language": "lean", "source": "fvapps", "source-id": "fvapps_001844", "source-notes": "", "vc-description": "/-\nReturn the root node of a binary search tree that matches the given preorder traversal.\n(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value < node.val, and any descendant of node.right has a value > node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)\nIt's guaranteed that for the given test cases there is always possible to find a binary search tree with the given requirements.\nExample 1:\nInput: [8,5,1,7,10,12]\nOutput: [8,5,10,1,7,null,12]\n\nConstraints:\n\n1 <= preorder.length <= 100\n1 <= preorder[i] <= 10^8\nThe values of preorder are distinct.\n-/", "vc-preamble": "def bstFromPreorder (preorder : List Int) : TreeNode :=\n  sorry\n\ndef treeToList (root : TreeNode) : List Int :=\n  sorry\n\ndef is_valid_bst (preorder : List Int) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def is_bst (node : TreeNode) (min_val max_val : Int) : Bool :=\n  sorry", "vc-theorems": "theorem bst_from_preorder_preserves_values (preorder : List Int) :\n  is_valid_bst preorder →\n  let result := treeToList (bstFromPreorder preorder)\n  (∀ x, x ∈ preorder → x ∈ result) ∧ \n  (∀ x, x ∈ result → x ∈ preorder) :=\n  sorry\n\ntheorem bst_from_preorder_maintains_bst_property (preorder : List Int) :\n  is_valid_bst preorder →\n  is_bst (bstFromPreorder preorder) (-1000) 1000 :=\n  sorry\n\ntheorem bst_from_preorder_structure (preorder : List Int) :\n  is_valid_bst preorder →\n  treeToList (bstFromPreorder preorder) = treeToList (bstFromPreorder preorder) :=\n  sorry\n\n/-\ninfo: [8, 5, 10, 1, 7, None, 12]\n-/\n-- #guard_msgs in\n-- #eval treeToList bstFromPreorder([8, 5, 1, 7, 10, 12])\n\n/-\ninfo: [1]\n-/\n-- #guard_msgs in\n-- #eval treeToList bstFromPreorder([1])\n\n/-\ninfo: [5, 3, 7, 1, 4, 6, 8]\n-/\n-- #guard_msgs in\n-- #eval treeToList bstFromPreorder([5, 3, 1, 4, 7, 6, 8])", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1847", "language": "lean", "source": "fvapps", "source-id": "fvapps_001847", "source-notes": "", "vc-description": "/-\nGiven a nested list of integers represented as a string, implement a parser to deserialize it.\n\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\n\nNote:\nYou may assume that the string is well-formed:\n\nString is non-empty.\nString does not contain white spaces.\nString contains only digits 0-9, [, - ,, ].\n\nExample 1:\n\nGiven s = \"324\",\n\nYou should return a NestedInteger object which contains a single integer 324.\n\nExample 2:\n\nGiven s = \"[123,[456,[789]]]\",\n\nReturn a NestedInteger object containing a nested list with 2 elements:\n\n1. An integer containing value 123.\n2. A nested list containing two elements:\n    i.  An integer containing value 456.\n    ii. A nested list with one element:\n         a. An integer containing value 789.\n-/", "vc-preamble": "def deserialize (s : String) : NestedInteger :=\n  sorry\n\ndef nestedIntToPython (ni : NestedInteger) : NestedInteger :=\n  sorry\n\ndef pythonToStr (val : NestedInteger) : String :=\n  sorry\n\ndef isInteger (ni : NestedInteger) : Bool :=\n  match ni with\n  | NestedInteger.Integer _ => true\n  | _ => false", "vc-helpers": "", "vc-definitions": "def getInteger (ni : NestedInteger) : Int :=\n  match ni with\n  | NestedInteger.Integer n => n\n  | _ => 0 -- undefined behavior in this case", "vc-theorems": "theorem nested_integer_roundtrip (val : NestedInteger) :\n  nestedIntToPython (deserialize (pythonToStr val)) = val :=\n  sorry\n\ntheorem simple_integers_preserve_value (n : Int) (h : -1000 ≤ n ∧ n ≤ 1000) :\n  isInteger (deserialize (toString n)) = true ∧\n  getInteger (deserialize (toString n)) = n :=\n  sorry\n\ntheorem flat_lists_preserve_structure (lst : List Int) \n  (h : ∀ x ∈ lst, -1000 ≤ x ∧ x ≤ 1000) :\n  nestedIntToPython (deserialize (toString lst)) = \n  NestedInteger.List (lst.map NestedInteger.Integer) :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1848", "language": "lean", "source": "fvapps", "source-id": "fvapps_001848", "source-notes": "", "vc-description": "/-\nImplement the StreamChecker class as follows:\n\nStreamChecker(words): Constructor, init the data structure with the given words.\nquery(letter): returns true if and only if for some k >= 1, the last k characters queried (in order from oldest to newest, including this letter just queried) spell one of the words in the given list.\n\nExample:\nStreamChecker streamChecker = new StreamChecker([\"cd\",\"f\",\"kl\"]); // init the dictionary.\nstreamChecker.query('a');          // return false\nstreamChecker.query('b');          // return false\nstreamChecker.query('c');          // return false\nstreamChecker.query('d');          // return true, because 'cd' is in the wordlist\nstreamChecker.query('e');          // return false\nstreamChecker.query('f');          // return true, because 'f' is in the wordlist\nstreamChecker.query('g');          // return false\nstreamChecker.query('h');          // return false\nstreamChecker.query('i');          // return false\nstreamChecker.query('j');          // return false\nstreamChecker.query('k');          // return false\nstreamChecker.query('l');          // return true, because 'kl' is in the wordlist\n\nNote:\n\n1 <= words.length <= 2000\n1 <= words[i].length <= 2000\nWords will only consist of lowercase English letters.\nQueries will only consist of lowercase English letters.\nThe number of queries is at most 40000.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def StreamChecker.query : StreamChecker → String → Bool\n  | _, _ => sorry", "vc-theorems": "theorem empty_string_query_is_false (checker : StreamChecker) : \n  checker.query \"\" = false := by sorry\n\ntheorem matches_found_bounded_by_word_length (checker : StreamChecker) (words : List String) \n    (word : String) (h : word ∈ words) :\n    ∀ stream : List Char,\n    (stream.map (fun c => checker.query c.toString)).countP id ≤ word.length := by sorry\n\ntheorem binary_queries_bounded_results (checker : StreamChecker) (words : List String) \n    (h : words ≠ []) (maxlen : Nat) \n    (h_maxlen : maxlen = (List.map String.length words).foldl Nat.max 0) :\n    ∀ stream : List Char,\n    stream.length > maxlen + 1 →\n    let results := stream.map (fun c => checker.query c.toString)\n    (results.take maxlen).countP id ≤ 2 := by sorry\n\ntheorem duplicate_words_equivalent_behavior (words : List String) :\n  ∀ c : String,\n  (StreamChecker.mk words).query c = \n  (StreamChecker.mk (List.eraseDups words)).query c := by sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1849", "language": "lean", "source": "fvapps", "source-id": "fvapps_001849", "source-notes": "", "vc-description": "/-\nThere is a sale in a supermarket, there will be a discount every n customer.\nThere are some products in the supermarket where the id of the i-th product is products[i] and the price per unit of this product is prices[i].\nThe system will count the number of customers and when the n-th customer arrive he/she will have a discount on the bill. (i.e if the cost is x the new cost is x - (discount * x) / 100). Then the system will start counting customers again.\nThe customer orders a certain amount of each product where product[i] is the id of the i-th product the customer ordered and amount[i] is the number of units the customer ordered of that product.\nImplement the Cashier class:\n\nCashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, the products and their prices.\ndouble getBill(int[] product, int[] amount) returns the value of the bill and apply the discount if needed. Answers within 10^-5 of the actual value will be accepted as correct.\n\nExample 1:\nInput\n[\"Cashier\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\",\"getBill\"]\n[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]\nOutput\n[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]\nExplanation\nCashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);\ncashier.getBill([1,2],[1,2]);                        // return 500.0, bill = 1 * 100 + 2 * 200 = 500.\ncashier.getBill([3,7],[10,10]);                      // return 4000.0\ncashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0, The bill was 1600.0 but as this is the third customer, he has a discount of 50% which means his bill is only 1600 - 1600 * (50 / 100) = 800.\ncashier.getBill([4],[10]);                           // return 4000.0\ncashier.getBill([7,3],[10,10]);                      // return 4000.0\ncashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0, Bill was 14700.0 but as the system counted three more customers, he will have a 50% discount and the bill becomes 7350.0\ncashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0\n\nConstraints:\n\n1 <= n <= 10^4\n0 <= discount <= 100\n1 <= products.length <= 200\n1 <= products[i] <= 200\nThere are not repeated elements in the array products.\nprices.length == products.length\n1 <= prices[i] <= 1000\n1 <= product.length <= products.length\nproduct[i] exists in products.\namount.length == product.length\n1 <= amount[i] <= 1000\nAt most 1000 calls will be made to getBill.\nAnswers within 10^-5 of the actual value will be accepted as correct.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Cashier.getBill (c: Cashier) (selected_products: List Nat) (amounts: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem cashier_initialization_n {n disc prods prices : Nat} (c : Cashier) :\n  c.n = n → c.n > 0 :=\nsorry\n\ntheorem cashier_initialization_discount {n disc prods prices: Nat} (c : Cashier) :\n  c.discount = disc → c.discount ≥ 0 ∧ c.discount ≤ 100 :=\nsorry\n\ntheorem cashier_products_nonempty {n disc : Nat} {prods prices : List Nat} (c : Cashier) :\n  c.products.length > 0 :=\nsorry\n\ntheorem bill_nonnegative {n disc : Nat} {prods prices selected amounts : List Nat} (c : Cashier) :\n  c.getBill selected amounts ≥ 0 := \nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1850", "language": "lean", "source": "fvapps", "source-id": "fvapps_001850", "source-notes": "", "vc-description": "/-\nGiven a binary tree root and a linked list with head as the first node. \nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.\n\nExample 1:\n\nInput: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true\nExplanation: Nodes in blue form a subpath in the binary Tree.  \n\nExample 2:\n\nInput: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true\n\nExample 3:\nInput: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: false\nExplanation: There is no path in the binary tree that contains all the elements of the linked list from head.\n\nConstraints:\n\n1 <= node.val <= 100 for each node in the linked list and binary tree.\nThe given linked list will contain between 1 and 100 nodes.\nThe given binary tree will contain between 1 and 2500 nodes.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_subpath (head : Option ListNode) (root : Option TreeNode) : Bool :=\n  sorry", "vc-theorems": "theorem empty_tree_property {head : ListNode} :\n  is_subpath (some head) none = false := by\n  sorry\n\ntheorem empty_list_property {root : Option TreeNode} :\n  is_subpath none root = true := by\n  sorry\n\ntheorem single_path_property {head : ListNode} {root : TreeNode} {list_len tree_len : Nat} :\n  list_len > tree_len →\n  is_subpath (some head) (some root) = false := by\n  sorry\n\ntheorem single_node_property {val : Int} :\n  let head := ListNode.mk val none\n  let root := TreeNode.mk val none none \n  is_subpath (some head) (some root) = true := by\n  sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval is_subpath ListNode(4) TreeNode(1)\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval is_subpath ListNode(1) TreeNode(1)\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval is_subpath ListNode(1) root2", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1851", "language": "lean", "source": "fvapps", "source-id": "fvapps_001851", "source-notes": "", "vc-description": "/-\nTwo players play a turn based game on a binary tree.  We are given the root of this binary tree, and the number of nodes n in the tree.  n is odd, and each node has a distinct value from 1 to n.\nInitially, the first player names a value x with 1 <= x <= n, and the second player names a value y with 1 <= y <= n and y != x.  The first player colors the node with value x red, and the second player colors the node with value y blue.\nThen, the players take turns starting with the first player.  In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)\nIf (and only if) a player cannot choose such a node in this way, they must pass their turn.  If both players pass their turn, the game ends, and the winner is the player that colored more nodes.\nYou are the second player.  If it is possible to choose such a y to ensure you win the game, return true.  If it is not possible, return false.\n\nExample 1:\n\nInput: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3\nOutput: true\nExplanation: The second player can choose the node with value 2.\n\nConstraints:\n\nroot is the root of a binary tree with n nodes and distinct node values from 1 to n.\nn is odd.\n1 <= x <= n <= 100\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def btreeGameWinningMove (root : BTree) (n : Nat) (x : Nat) : Bool :=\n  sorry\n\n/- For any binary tree, number of nodes, and chosen node x, the winning move result is boolean -/", "vc-theorems": "theorem btree_game_winning_move_returns_bool (root : BTree) (n : Nat) (x : Nat) :\n  btreeGameWinningMove root n x = true ∨ btreeGameWinningMove root n x = false :=\nsorry\n\n/- For a single node tree (n=1), there is no winning move -/\n\ntheorem btree_game_single_node_no_win (root : BTree) :\n  btreeGameWinningMove root 1 1 = false :=\nsorry\n\n/- For a perfectly balanced tree of 7 nodes with values 1-7, choosing root node 1 has no winning move -/\n\ntheorem btree_game_balanced_seven_nodes_no_win (root : BTree) :\n  root = BTree.node 1 \n    (BTree.node 2 \n      (BTree.node 4 BTree.leaf BTree.leaf) \n      (BTree.node 5 BTree.leaf BTree.leaf))\n    (BTree.node 3\n      (BTree.node 6 BTree.leaf BTree.leaf)\n      (BTree.node 7 BTree.leaf BTree.leaf)) →\n  btreeGameWinningMove root 7 1 = false :=\nsorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval btreeGameWinningMove TreeNode(1) 3 2\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval btreeGameWinningMove TreeNode(1) 5 1\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval btreeGameWinningMove TreeNode(1) 7 4", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1852", "language": "lean", "source": "fvapps", "source-id": "fvapps_001852", "source-notes": "", "vc-description": "/-\nGiven two strings representing two complex numbers.\n\nYou need to return a string representing their multiplication. Note i2 = -1 according to the definition.\n\nExample 1:\n\nInput: \"1+1i\", \"1+1i\"\nOutput: \"0+2i\"\nExplanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.\n\nExample 2:\n\nInput: \"1+-1i\", \"1+-1i\"\nOutput: \"0+-2i\"\nExplanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.\n\nNote:\n\nThe input strings will not have extra blank.\nThe input strings will be given in the form of a+bi, where the integer a and b will both belong to the range of [-100, 100]. And the output should be also in this form.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def complex_number_multiply : Complex → Complex → Complex\n| c1, c2 => sorry", "vc-theorems": "theorem complex_multiplication_correct (a b : Complex) :\n  let result := complex_number_multiply a b\n  let expected_real := a.real * b.real - a.imag * b.imag \n  let expected_imag := a.real * b.imag + a.imag * b.real\n  result.real = expected_real ∧ result.imag = expected_imag :=\nsorry\n\ntheorem multiply_by_identity (c : Complex) :\n  complex_number_multiply c ⟨1, 0⟩ = c :=\nsorry\n\ntheorem multiply_by_zero (c : Complex) :\n  complex_number_multiply c ⟨0, 0⟩ = ⟨0, 0⟩ :=\nsorry\n\n/-\ninfo: '0+2i'\n-/\n-- #guard_msgs in\n-- #eval complex_number_multiply \"1+1i\" \"1+1i\"\n\n/-\ninfo: '0+-2i'\n-/\n-- #guard_msgs in\n-- #eval complex_number_multiply \"1+-1i\" \"1+-1i\"\n\n/-\ninfo: '23+2i'\n-/\n-- #guard_msgs in\n-- #eval complex_number_multiply \"2+3i\" \"4+-5i\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1853", "language": "lean", "source": "fvapps", "source-id": "fvapps_001853", "source-notes": "", "vc-description": "/-\nGiven a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\n\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\nreturn its zigzag level order traversal as:\n\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def zigzagLevelOrder (root : Option TreeNode) : List (List Int) :=\n  sorry", "vc-theorems": "theorem zigzagLevelOrder_valid {root : Option TreeNode} :\n  let result := zigzagLevelOrder root\n  -- Result is a list of lists\n  result.all (fun level => level.all (fun x => x ≥ -100 ∧ x ≤ 100)) ∧\n  -- Each level length is at most double the previous\n  result.tail.all (fun level => \n    match result.head? with\n    | some prev => level.length ≤ 2 * prev.length \n    | none => true) :=\n  sorry\n\ntheorem zigzagLevelOrder_empty :\n  zigzagLevelOrder none = [] :=\n  sorry\n\ntheorem zigzagLevelOrder_single_node :\n  zigzagLevelOrder (some (TreeNode.node 1 none none)) = [[1]] := \n  sorry\n\n/-\ninfo: [[3], [20, 9], [15, 7]]\n-/\n-- #guard_msgs in\n-- #eval zigzagLevelOrder TreeNode(3)\n\n/-\ninfo: [[1]]\n-/\n-- #guard_msgs in\n-- #eval zigzagLevelOrder TreeNode(1)\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval zigzagLevelOrder None", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1856", "language": "lean", "source": "fvapps", "source-id": "fvapps_001856", "source-notes": "", "vc-description": "/-\nA kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born.\nThe kingdom has a well-defined order of inheritance that consists of the king as the first member. Let's define the recursive function Successor(x, curOrder), which given a person x and the inheritance order so far, returns who should be the next person after x in the order of inheritance.\nSuccessor(x, curOrder):\n    if x has no children or all of x's children are in curOrder:\n        if x is the king return null\n        else return Successor(x's parent, curOrder)\n    else return x's oldest child who's not in curOrder\n\nFor example, assume we have a kingdom that consists of the king, his children Alice and Bob (Alice is older than Bob), and finally Alice's son Jack.\n\nIn the beginning, curOrder will be [\"king\"].\nCalling Successor(king, curOrder) will return Alice, so we append to curOrder to get [\"king\", \"Alice\"].\nCalling Successor(Alice, curOrder) will return Jack, so we append to curOrder to get [\"king\", \"Alice\", \"Jack\"].\nCalling Successor(Jack, curOrder) will return Bob, so we append to curOrder to get [\"king\", \"Alice\", \"Jack\", \"Bob\"].\nCalling Successor(Bob, curOrder) will return null. Thus the order of inheritance will be [\"king\", \"Alice\", \"Jack\", \"Bob\"].\n\nUsing the above function, we can always obtain a unique order of inheritance.\nImplement the ThroneInheritance class:\n\nThroneInheritance(string kingName) Initializes an object of the ThroneInheritance class. The name of the king is given as part of the constructor.\nvoid birth(string parentName, string childName) Indicates that parentName gave birth to childName.\nvoid death(string name) Indicates the death of name. The death of the person doesn't affect the Successor function nor the current inheritance order. You can treat it as just marking the person as dead.\nstring[] getInheritanceOrder() Returns a list representing the current order of inheritance excluding dead people.\n\nExample 1:\nInput\n[\"ThroneInheritance\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"birth\", \"getInheritanceOrder\", \"death\", \"getInheritanceOrder\"]\n[[\"king\"], [\"king\", \"andy\"], [\"king\", \"bob\"], [\"king\", \"catherine\"], [\"andy\", \"matthew\"], [\"bob\", \"alex\"], [\"bob\", \"asha\"], [null], [\"bob\"], [null]]\nOutput\n[null, null, null, null, null, null, null, [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"], null, [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]]\n\nExplanation\nThroneInheritance t= new ThroneInheritance(\"king\"); // order: king\nt.birth(\"king\", \"andy\"); // order: king > andy\nt.birth(\"king\", \"bob\"); // order: king > andy > bob\nt.birth(\"king\", \"catherine\"); // order: king > andy > bob > catherine\nt.birth(\"andy\", \"matthew\"); // order: king > andy > matthew > bob > catherine\nt.birth(\"bob\", \"alex\"); // order: king > andy > matthew > bob > alex > catherine\nt.birth(\"bob\", \"asha\"); // order: king > andy > matthew > bob > alex > asha > catherine\nt.getInheritanceOrder(); // return [\"king\", \"andy\", \"matthew\", \"bob\", \"alex\", \"asha\", \"catherine\"]\nt.death(\"bob\"); // order: king > andy > matthew > bob > alex > asha > catherine\nt.getInheritanceOrder(); // return [\"king\", \"andy\", \"matthew\", \"alex\", \"asha\", \"catherine\"]\n\nConstraints:\n\n1 <= kingName.length, parentName.length, childName.length, name.length <= 15\nkingName, parentName, childName, and name consist of lowercase English letters only.\nAll arguments childName and kingName are distinct.\nAll name arguments of death will be passed to either the constructor or as childName to birth first.\nFor each call to birth(parentName, childName), it is guaranteed that parentName is alive.\nAt most 105 calls will be made to birth and death.\nAt most 10 calls will be made to getInheritanceOrder.\n-/", "vc-preamble": "def birth (t : ThroneInheritance) (parent child : String) : ThroneInheritance := sorry\n\ndef death (t : ThroneInheritance) (name : String) : ThroneInheritance := sorry", "vc-helpers": "", "vc-definitions": "def getInheritanceOrder (t : ThroneInheritance) : List String := sorry\n\ntheorem new_kingdom_order (kingName : String) :\n  getInheritanceOrder ⟨kingName⟩ = [kingName] := sorry", "vc-theorems": "theorem single_birth_order (kingName childName : String) (h : kingName ≠ childName) :\n  let t := birth ⟨kingName⟩ kingName childName\n  getInheritanceOrder t = [kingName, childName] := sorry\n\ntheorem multiple_children_order (kingName : String) (children : List String) \n  (h1 : children.length > 0)\n  (h2 : ∀ c ∈ children, kingName ≠ c)\n  (h3 : List.Nodup children) :\n  let init := ⟨kingName⟩\n  let final := children.foldl (fun t c => birth t kingName c) init\n  getInheritanceOrder final = kingName :: children := sorry\n\ntheorem death_removes_from_order (kingName childName : String) (h : kingName ≠ childName) :\n  let t1 := birth ⟨kingName⟩ kingName childName\n  let t2 := death t1 childName\n  getInheritanceOrder t2 = [kingName] := sorry\n\ntheorem deaths_and_births (kingName : String) (children deaths : List String)\n  (h1 : children.length > 0)\n  (h2 : deaths.length ≤ 2)\n  (h3 : ∀ c ∈ children, kingName ≠ c)  \n  (h4 : List.Nodup children) :\n  let init := ⟨kingName⟩\n  let afterBirths := children.foldl (fun t c => birth t kingName c) init\n  let final := deaths.foldl (fun t d => death t d) afterBirths\n  let order := getInheritanceOrder final\n  (kingName ∉ deaths → kingName ∈ order) ∧\n  (∀ c ∈ children, c ∉ deaths → c ∈ order) ∧\n  (∀ c ∈ children, c ∈ deaths → c ∉ order) := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1858", "language": "lean", "source": "fvapps", "source-id": "fvapps_001858", "source-notes": "", "vc-description": "/-\nGiven a wordlist, we want to implement a spellchecker that converts a query word into a correct word.\nFor a given query word, the spell checker handles two categories of spelling mistakes:\n\nCapitalization: If the query matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the case in the wordlist.\n\nExample: wordlist = [\"yellow\"], query = \"YellOw\": correct = \"yellow\"\nExample: wordlist = [\"Yellow\"], query = \"yellow\": correct = \"Yellow\"\nExample: wordlist = [\"yellow\"], query = \"yellow\": correct = \"yellow\"\n\nVowel Errors: If after replacing the vowels ('a', 'e', 'i', 'o', 'u') of the query word with any vowel individually, it matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the match in the wordlist.\n\nExample: wordlist = [\"YellOw\"], query = \"yollow\": correct = \"YellOw\"\nExample: wordlist = [\"YellOw\"], query = \"yeellow\": correct = \"\" (no match)\nExample: wordlist = [\"YellOw\"], query = \"yllw\": correct = \"\" (no match)\n\nIn addition, the spell checker operates under the following precedence rules:\n\nWhen the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\nWhen the query matches a word up to capitlization, you should return the first such match in the wordlist.\nWhen the query matches a word up to vowel errors, you should return the first such match in the wordlist.\nIf the query has no matches in the wordlist, you should return the empty string.\n\nGiven some queries, return a list of words answer, where answer[i] is the correct word for query = queries[i].\n\nExample 1:\nInput: wordlist = [\"KiTe\",\"kite\",\"hare\",\"Hare\"], queries = [\"kite\",\"Kite\",\"KiTe\",\"Hare\",\"HARE\",\"Hear\",\"hear\",\"keti\",\"keet\",\"keto\"]\nOutput: [\"kite\",\"KiTe\",\"KiTe\",\"Hare\",\"hare\",\"\",\"\",\"KiTe\",\"\",\"KiTe\"]\n\nNote:\n\n1 <= wordlist.length <= 5000\n1 <= queries.length <= 5000\n1 <= wordlist[i].length <= 7\n1 <= queries[i].length <= 7\nAll strings in wordlist and queries consist only of english letters.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def spellchecker (wordlist : List String) (queries : List String) : List String :=\n  sorry", "vc-theorems": "theorem spellchecker_output_length \n  (wordlist : List String) (queries : List String) :\n  List.length (spellchecker wordlist queries) = List.length queries :=\nsorry\n\ntheorem spellchecker_result_in_wordlist\n  (wordlist : List String) (queries : List String) :\n  ∀ r ∈ spellchecker wordlist queries, r = \"\" ∨ r ∈ wordlist :=\nsorry\n\ntheorem spellchecker_exact_match\n  (wordlist : List String) (queries : List String) :\n  ∀ (q : String), q ∈ queries → q ∈ wordlist → \n  List.get! (spellchecker wordlist queries) (List.indexOf q queries) = q :=\nsorry\n\ntheorem spellchecker_case_insensitive\n  (wordlist : List String) (queries : List String) :\n  ∀ (q : String) (r : String),\n  q ∈ queries →\n  r = List.get! (spellchecker wordlist queries) (List.indexOf q queries) →\n  r ≠ \"\" →\n  String.toLower r = String.toLower q →\n  r ∈ wordlist :=\nsorry\n\ntheorem spellchecker_self_query\n  (wordlist : List String) :\n  spellchecker wordlist wordlist = wordlist :=\nsorry\n\ntheorem spellchecker_vowel_patterns\n  (wordlist : List String) (queries : List String) :\n  ∀ (q : String) (r : String),\n  q ∈ queries →\n  r = List.get! (spellchecker wordlist queries) (List.indexOf q queries) →\n  r ≠ \"\" →\n  let q_pattern := (String.toLower q).replace \"a\" \"_\"\n                    |>.replace \"e\" \"_\"\n                    |>.replace \"i\" \"_\"\n                    |>.replace \"o\" \"_\"\n                    |>.replace \"u\" \"_\"\n  let r_pattern := (String.toLower r).replace \"a\" \"_\"\n                    |>.replace \"e\" \"_\"\n                    |>.replace \"i\" \"_\"\n                    |>.replace \"o\" \"_\"\n                    |>.replace \"u\" \"_\"\n  q_pattern = r_pattern →\n  r ∈ wordlist :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1859", "language": "lean", "source": "fvapps", "source-id": "fvapps_001859", "source-notes": "", "vc-description": "/-\nWe are given a linked list with head as the first node.  Let's number the nodes in the list: node_1, node_2, node_3, ... etc.\nEach node may have a next larger value: for node_i, next_larger(node_i) is the node_j.val such that j > i, node_j.val > node_i.val, and j is the smallest possible choice.  If such a j does not exist, the next larger value is 0.\nReturn an array of integers answer, where answer[i] = next_larger(node_{i+1}).\nNote that in the example inputs (not outputs) below, arrays such as [2,1,5] represent the serialization of a linked list with a head node value of 2, second node value of 1, and third node value of 5.\n\nExample 1:\nInput: [2,1,5]\nOutput: [5,5,0]\n\nExample 2:\nInput: [2,7,4,3,5]\nOutput: [7,0,5,5,0]\n\nExample 3:\nInput: [1,7,5,1,9,2,5,1]\nOutput: [7,9,9,9,0,5,0,0]\n\nNote:\n\n1 <= node.val <= 10^9 for each node in the linked list.\nThe given list has length in the range [0, 10000].\n-/", "vc-preamble": "def nextLargerNodes (head : Option ListNode) : List Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def isDecreasing (l : List Nat) : Prop :=\n  ∀ i j, i < j → j < l.length → l.get! i ≥ l.get! j", "vc-theorems": "theorem empty_list :\n  nextLargerNodes none = [] ∧\n  nextLargerNodes (some (ListNode.mk 0 none)) = [] :=\n  sorry\n\ntheorem single_node (v : Nat) :\n  nextLargerNodes (some (ListNode.mk v none)) = [0] :=\n  sorry\n\ntheorem output_length_matches_input {vals : List Nat} {head : Option ListNode} :\n  nextLargerNodes head = vals → List.length (nextLargerNodes head) = List.length vals :=\n  sorry\n\ntheorem output_zero_or_greater {vals : List Nat} {head : Option ListNode} {i : Nat} :\n  i < List.length vals →\n  match (nextLargerNodes head).get? i with\n  | some x => x = 0 ∨ x > vals.get! i\n  | none => True\n  :=\n  sorry\n\ntheorem output_values_in_input {vals : List Nat} {head : Option ListNode} {x : Nat} :\n  x ∈ nextLargerNodes head → x = 0 ∨ x ∈ vals :=\n  sorry\n\ntheorem nonzero_has_larger_after {vals : List Nat} {head : Option ListNode} {i : Nat} :\n  i < List.length vals →\n  (nextLargerNodes head).get! i ≠ 0 →\n  ∃ j, j > i ∧ j < List.length vals ∧ vals.get! j ≥ (nextLargerNodes head).get! i :=\n  sorry\n\ntheorem decreasing_list_gives_zeros {vals : List Nat} {head : Option ListNode} :\n  List.length vals ≥ 2 →\n  isDecreasing vals →\n  nextLargerNodes head = List.replicate (List.length vals) 0 :=\n  sorry\n\n/-\ninfo: [5, 5, 0]\n-/\n-- #guard_msgs in\n-- #eval nextLargerNodes create_linked_list([2, 1, 5])\n\n/-\ninfo: [7, 0, 5, 5, 0]\n-/\n-- #guard_msgs in\n-- #eval nextLargerNodes create_linked_list([2, 7, 4, 3, 5])\n\n/-\ninfo: [7, 9, 9, 9, 0, 5, 0, 0]\n-/\n-- #guard_msgs in\n-- #eval nextLargerNodes create_linked_list([1, 7, 5, 1, 9, 2, 5, 1])", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1864", "language": "lean", "source": "fvapps", "source-id": "fvapps_001864", "source-notes": "", "vc-description": "/-\nWe are given two arrays A and B of words.  Each word is a string of lowercase letters.\nNow, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity.  For example, \"wrr\" is a subset of \"warrior\", but is not a subset of \"world\".\nNow say a word a from A is universal if for every b in B, b is a subset of a. \nReturn a list of all universal words in A.  You can return the words in any order.\n\nExample 1:\nInput: A = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], B = [\"e\",\"o\"]\nOutput: [\"facebook\",\"google\",\"leetcode\"]\n\nExample 2:\nInput: A = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], B = [\"l\",\"e\"]\nOutput: [\"apple\",\"google\",\"leetcode\"]\n\nExample 3:\nInput: A = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], B = [\"e\",\"oo\"]\nOutput: [\"facebook\",\"google\"]\n\nExample 4:\nInput: A = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], B = [\"lo\",\"eo\"]\nOutput: [\"google\",\"leetcode\"]\n\nExample 5:\nInput: A = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], B = [\"ec\",\"oc\",\"ceo\"]\nOutput: [\"facebook\",\"leetcode\"]\n\nNote:\n\n1 <= A.length, B.length <= 10000\n1 <= A[i].length, B[i].length <= 10\nA[i] and B[i] consist only of lowercase letters.\nAll words in A[i] are unique: there isn't i != j with A[i] == A[j].\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def word_subsets (A B: List String) : List String := sorry\n\ndef count_char (c: Char) (s: String) : Nat := sorry", "vc-theorems": "theorem word_subsets_result_subset\n  (A B: List String) \n  (result := word_subsets A B) :\n  ∀ x, x ∈ result → x ∈ A := sorry\n\ntheorem word_subsets_letters_count\n  (A B: List String) \n  (result := word_subsets A B) :\n  ∀ w ∈ result, ∀ b_word ∈ B, ∀ letter : Char, \n  let max_count := (List.map (fun b => count_char letter b) B).maximum?\n  match max_count with\n  | some count => count_char letter w ≥ count\n  | none => True := sorry\n\ntheorem word_subsets_single_word\n  (w: String) :\n  let result := word_subsets [w] [(w.get! 0).toString]\n  (count_char (w.get! 0) w ≥ 1) →\n  result = [w] := sorry\n\n/-\ninfo: sorted(['facebook', 'google', 'leetcode'])\n-/\n-- #guard_msgs in\n-- #eval sorted word_subsets(A1, B1)\n\n/-\ninfo: sorted(['apple', 'google', 'leetcode'])\n-/\n-- #guard_msgs in\n-- #eval sorted word_subsets(A2, B2)\n\n/-\ninfo: sorted(['facebook', 'leetcode'])\n-/\n-- #guard_msgs in\n-- #eval sorted word_subsets(A3, B3)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1865", "language": "lean", "source": "fvapps", "source-id": "fvapps_001865", "source-notes": "", "vc-description": "/-\nYou have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of points on a 2D plane. \nReturn the maximum number of points that are within or lie on any circular dartboard of radius r.\n\nExample 1:\n\nInput: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 2\nOutput: 4\nExplanation: Circle dartboard with center in (0,0) and radius = 2 contain all points.\n\nExample 2:\n\nInput: points = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5\nOutput: 5\nExplanation: Circle dartboard with center in (0,4) and radius = 5 contain all points except the point (7,8).\n\nExample 3:\nInput: points = [[-2,0],[2,0],[0,2],[0,-2]], r = 1\nOutput: 1\n\nExample 4:\nInput: points = [[1,2],[3,5],[1,-1],[2,3],[4,1],[1,3]], r = 2\nOutput: 4\n\nConstraints:\n\n1 <= points.length <= 100\npoints[i].length == 2\n-10^4 <= points[i][0], points[i][1] <= 10^4\n1 <= r <= 5000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def numPoints (points : List Point) (r : Float) : Nat :=\n  sorry", "vc-theorems": "theorem numPoints_bounds {points : List Point} {r : Float} \n  (h1 : r > 0)\n  (h2 : points ≠ []) :\n  1 ≤ numPoints points r ∧ numPoints points r ≤ points.length :=\nsorry\n\ntheorem numPoints_tiny_radius {points : List Point} \n  (h1 : points ≠ [])\n  (h2 : r = 0.1) :\n  numPoints points r = 1 :=\nsorry\n\ntheorem numPoints_huge_radius {points : List Point}\n  (h1 : points ≠ [])\n  (h2 : r = 1000) :\n  numPoints points r = points.length :=\nsorry\n\ntheorem numPoints_shuffle {points perm : List Point} {r : Float}\n  (h1 : r > 0)\n  (h2 : perm.length = points.length)\n  (h3 : ∀ p, p ∈ points ↔ p ∈ perm) :\n  numPoints points r = numPoints perm r :=\nsorry\n\ntheorem numPoints_single_point {r : Float}\n  (h : r > 0) :\n  numPoints [Point.mk 0 0] r = 1 :=\nsorry\n\ntheorem numPoints_exact_radius :\n  numPoints [Point.mk 0 0, Point.mk 2 0] 1 = 2 :=\nsorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval numPoints [[-2, 0], [2, 0], [0, 2], [0, -2]] 2\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval numPoints [[-3, 0], [3, 0], [2, 6], [5, 4], [0, 9], [7, 8]] 5\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval numPoints [[1, 2], [3, 5], [1, -1], [2, 3], [4, 1], [1, 3]] 2", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1867", "language": "lean", "source": "fvapps", "source-id": "fvapps_001867", "source-notes": "", "vc-description": "/-\nGiven a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.\n\nExample 1:\n\nInput: 1->2->3->3->4->4->5\nOutput: 1->2->5\n\nExample 2:\n\nInput: 1->1->1->2->3\nOutput: 2->3\n-/", "vc-preamble": "def array_to_list : List Int → Option ListNode := \n  sorry\n\ndef list_to_array : Option ListNode → List Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def deleteDuplicates : Option ListNode → Option ListNode :=\n  sorry", "vc-theorems": "theorem output_is_subset_of_input (arr : List Int) : \n  let result := list_to_array (deleteDuplicates (array_to_list arr))\n  ∀ x, x ∈ result → x ∈ arr :=\nsorry\n\ntheorem empty_list_gives_empty_result (arr : List Int) :\n  arr = [] → list_to_array (deleteDuplicates (array_to_list arr)) = [] :=\nsorry\n\ntheorem singleton_values_preserved (arr : List Int) (val : Int) :\n  arr ≠ [] →\n  List.countP (· = val) arr = 1 → \n  val ∈ list_to_array (deleteDuplicates (array_to_list arr)) :=\nsorry\n\n/-\ninfo: [1, 2, 5]\n-/\n-- #guard_msgs in\n-- #eval list_to_array deleteDuplicates(test1)\n\n/-\ninfo: [2, 3]\n-/\n-- #guard_msgs in\n-- #eval list_to_array deleteDuplicates(test2)\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval list_to_array deleteDuplicates(test3)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1868", "language": "lean", "source": "fvapps", "source-id": "fvapps_001868", "source-notes": "", "vc-description": "/-\nWe are given the root node of a maximum tree: a tree where every node has a value greater than any other value in its subtree.\nJust as in the previous problem, the given tree was constructed from an list A (root = Construct(A)) recursively with the following Construct(A) routine:\n\nIf A is empty, return null.\nOtherwise, let A[i] be the largest element of A.  Create a root node with value A[i].\nThe left child of root will be Construct([A[0], A[1], ..., A[i-1]])\nThe right child of root will be Construct([A[i+1], A[i+2], ..., A[A.length - 1]])\nReturn root.\n\nNote that we were not given A directly, only a root node root = Construct(A).\nSuppose B is a copy of A with the value val appended to it.  It is guaranteed that B has unique values.\nReturn Construct(B).\n\nExample 1:\n\nInput: root = [4,1,3,null,null,2], val = 5\nOutput: [5,4,null,1,3,null,null,2]\nExplanation: A = [1,4,2,3], B = [1,4,2,3,5]\n\nExample 2:\n\nInput: root = [5,2,4,null,1], val = 3\nOutput: [5,2,4,null,1,null,3]\nExplanation: A = [2,1,5,4], B = [2,1,5,4,3]\n\nExample 3:\n\nInput: root = [5,2,3,null,1], val = 4\nOutput: [5,2,4,null,1,3]\nExplanation: A = [2,1,5,3], B = [2,1,5,3,4]\n\nConstraints:\n\n1 <= B.length <= 100\n-/", "vc-preamble": "def insertIntoMaxTree (root: Option TreeNode) (val: Int) : TreeNode :=\n  sorry\n\ndef buildTree (vals: List Int) : Option TreeNode :=\n  sorry", "vc-helpers": "", "vc-definitions": "def treeToList (t: TreeNode) : List Int :=\n  sorry\n\npartial def isMaxTree : TreeNode → Bool \n| TreeNode.node v l r => \n  match l, r with\n  | none, none => true \n  | some (TreeNode.node lv ll lr), none => v ≥ lv && isMaxTree (TreeNode.node lv ll lr)\n  | none, some (TreeNode.node rv rl rr) => v ≥ rv && isMaxTree (TreeNode.node rv rl rr)\n  | some (TreeNode.node lv ll lr), some (TreeNode.node rv rl rr) => \n      v ≥ lv && v ≥ rv && \n      isMaxTree (TreeNode.node lv ll lr) && \n      isMaxTree (TreeNode.node rv rl rr)", "vc-theorems": "theorem insert_single_node (val: Int) (h: val > 0) : \n  match insertIntoMaxTree none val with\n  | TreeNode.node v l r => v = val ∧ l = none ∧ r = none :=\nsorry\n\ntheorem insert_maintains_values (vals: List Int) (new_val: Int)\n  (h1: ∀ x, x ∈ vals → x > 0)\n  (h2: new_val > 0) \n  (h3: vals ≠ [])\n  (h4: ∀ x y, x ∈ vals → y ∈ vals → x ≠ y) :\n  let root := buildTree vals\n  let result := insertIntoMaxTree root new_val\n  let result_list := treeToList result\n  (∀ x, x ∈ vals → x ∈ result_list) ∧ new_val ∈ result_list :=\nsorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1869", "language": "lean", "source": "fvapps", "source-id": "fvapps_001869", "source-notes": "", "vc-description": "/-\nReverse a linked list from position m to n. Do it in one-pass.\n\nNote: 1 ≤ m ≤ n ≤ length of list.\n\nExample:\n\nInput: 1->2->3->4->5->NULL, m = 2, n = 4\nOutput: 1->4->3->2->5->NULL\n-/", "vc-preamble": "def arrayToLinkedList : List Int → Option ListNode := sorry\ndef linkedListToArray : Option ListNode → List Int := sorry", "vc-helpers": "", "vc-definitions": "def reverseBetween : Option ListNode → Nat → Nat → Option ListNode := sorry\n\ntheorem reverse_single_element_unchanged \n    {arr : List Int} {i : Nat} \n    (h1 : arr ≠ []) \n    (h2 : i ≥ 1) \n    (h3 : i ≤ arr.length) :\n    linkedListToArray (reverseBetween (arrayToLinkedList arr) i i) = arr := sorry", "vc-theorems": "theorem reverse_entire_list\n    {arr : List Int}\n    (h : arr ≠ []) :\n    linkedListToArray (reverseBetween (arrayToLinkedList arr) 1 arr.length) = arr.reverse := sorry \n\ntheorem reverse_between_properties\n    {arr : List Int} {m n : Nat}\n    (h1 : arr ≠ [])\n    (h2 : m ≥ 1)\n    (h3 : n ≥ 1)\n    (h4 : m ≤ arr.length)\n    (h5 : n ≤ arr.length)\n    (h6 : m ≤ n) :\n    let result := linkedListToArray (reverseBetween (arrayToLinkedList arr) m n)\n    (result.length = arr.length) ∧\n    (result.take (m-1) = arr.take (m-1)) ∧\n    (result.drop n = arr.drop n) ∧\n    ((result.drop (m-1)).take (n-m+1)) = ((arr.drop (m-1)).take (n-m+1)).reverse := sorry\n\ntheorem empty_list : \n    reverseBetween none 1 1 = none := sorry\n\n/-\ninfo: [1, 4, 3, 2, 5]\n-/\n-- #guard_msgs in\n-- #eval linkedListToArray reverseBetween(test1, 2, 4)\n\n/-\ninfo: [1]\n-/\n-- #guard_msgs in\n-- #eval linkedListToArray reverseBetween(test2, 1, 1)\n\n/-\ninfo: [3, 2, 1]\n-/\n-- #guard_msgs in\n-- #eval linkedListToArray reverseBetween(test3, 1, 3)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1870", "language": "lean", "source": "fvapps", "source-id": "fvapps_001870", "source-notes": "", "vc-description": "/-\nGiven a linked list, remove the n-th node from the end of list and return its head.\n\nExample:\n\nGiven linked list: 1->2->3->4->5, and n = 2.\n\nAfter removing the second node from the end, the linked list becomes 1->2->3->5.\n\nNote:\n\nGiven n will always be valid.\n\nFollow up:\n\nCould you do this in one pass?\n-/", "vc-preamble": "def removeNthFromEnd (head : Node) (n : Nat) : Option Node :=\n  sorry\n\ndef create_linked_list (arr : List Int) : Option Node :=\n  sorry", "vc-helpers": "", "vc-definitions": "def linked_list_to_array (head : Option Node) : List Int :=\n  sorry", "vc-theorems": "theorem remove_nth_maintains_order {arr : List Int} {n : Nat} \n  (h1 : 0 < n) (h2 : n ≤ arr.length) :\n  let head := create_linked_list arr\n  let result := removeNthFromEnd (Option.get! head) n\n  let result_arr := linked_list_to_array result\n  (result_arr.length = arr.length - 1) ∧ \n  (result_arr = (arr.take (arr.length - n)) ++ (arr.drop (arr.length - n + 1))) :=\nsorry\n\ntheorem remove_first_element {arr : List Int}\n  (h : arr.length > 0) :\n  let head := create_linked_list arr\n  let result := removeNthFromEnd (Option.get! head) arr.length\n  linked_list_to_array result = arr.tail :=\nsorry\n\ntheorem remove_last_element {arr : List Int}\n  (h : arr.length > 0) :\n  let head := create_linked_list arr\n  let result := removeNthFromEnd (Option.get! head) 1\n  linked_list_to_array result = arr.dropLast :=\nsorry\n\n/-\ninfo: [1, 2, 3, 5]\n-/\n-- #guard_msgs in\n-- #eval linked_list_to_array removeNthFromEnd(head1, 2)\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval linked_list_to_array removeNthFromEnd(head2, 1)\n\n/-\ninfo: [1]\n-/\n-- #guard_msgs in\n-- #eval linked_list_to_array removeNthFromEnd(head3, 1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1871", "language": "lean", "source": "fvapps", "source-id": "fvapps_001871", "source-notes": "", "vc-description": "/-\nIn a project, you have a list of required skills req_skills, and a list of people.  The i-th person people[i] contains a list of skills that person has.\nConsider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill.  We can represent these teams by the index of each person: for example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].\nReturn any sufficient team of the smallest possible size, represented by the index of each person.\nYou may return the answer in any order.  It is guaranteed an answer exists.\n\nExample 1:\nInput: req_skills = [\"java\",\"nodejs\",\"reactjs\"], people = [[\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"]]\nOutput: [0,2]\nExample 2:\nInput: req_skills = [\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"], people = [[\"algorithms\",\"math\",\"java\"],[\"algorithms\",\"math\",\"reactjs\"],[\"java\",\"csharp\",\"aws\"],[\"reactjs\",\"csharp\"],[\"csharp\",\"math\"],[\"aws\",\"java\"]]\nOutput: [1,2]\n\nConstraints:\n\n1 <= req_skills.length <= 16\n1 <= people.length <= 60\n1 <= people[i].length, req_skills[i].length, people[i][j].length <= 16\nElements of req_skills and people[i] are (respectively) distinct.\nreq_skills[i][j], people[i][j][k] are lowercase English letters.\nEvery skill in people[i] is a skill in req_skills.\nIt is guaranteed a sufficient team exists.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_smallest_team (required_skills : List String) (people : List Person) : List Nat :=\n  sorry", "vc-theorems": "theorem find_smallest_team_result_valid\n  (required_skills : List String)\n  (people : List Person) \n  (h1 : required_skills ≠ [])\n  (h2 : people ≠ []) :\n  let result := find_smallest_team required_skills people\n  -- Result indices are valid\n  ∀ i ∈ result, i < people.length := sorry\n\ntheorem find_smallest_team_covers_skills\n  (required_skills : List String)\n  (people : List Person)\n  (h1 : required_skills ≠ [])\n  (h2 : people ≠ []) :\n  let result := find_smallest_team required_skills people\n  let covered_skills := (result.filterMap (λ i => if h : i < people.length then some (people[i]'h).skills else none)).join\n  ∀ skill ∈ required_skills, skill ∈ covered_skills := sorry\n\ntheorem find_smallest_team_singleton\n  (required_skills : List String)\n  (people : List Person)\n  (h : ∃ p ∈ people, ∀ s ∈ required_skills, s ∈ p.skills) :\n  let result := find_smallest_team required_skills people\n  result.length = 1 := sorry\n\ntheorem find_smallest_team_disjoint_skills\n  (skills : List String)\n  (people : List Person)\n  (h1 : skills.length = people.length)\n  (h2 : ∀ (i : Fin people.length), (people[i]).skills = [skills[i]]) :\n  let result := find_smallest_team skills people\n  result.length = skills.length := sorry\n\n/-\ninfo: [0, 2]\n-/\n-- #guard_msgs in\n-- #eval sorted find_smallest_team(req_skills1, people1)\n\n/-\ninfo: [1, 2]\n-/\n-- #guard_msgs in\n-- #eval sorted find_smallest_team(req_skills2, people2)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1873", "language": "lean", "source": "fvapps", "source-id": "fvapps_001873", "source-notes": "", "vc-description": "/-\nWrite a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy all of the following rules:\n\n       Each of the digits 1-9 must occur exactly once in each row.\n       Each of the digits 1-9 must occur exactly once in each column.\n       Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\n\nEmpty cells are indicated by the character '.'.\n\nA sudoku puzzle...\n\n...and its solution numbers marked in red.\n\nNote:\n\n       The given board contain only digits 1-9 and the character '.'.\n       You may assume that the given Sudoku puzzle will have a single unique solution.\n       The given board size is always 9x9.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_valid_sudoku : Array (Array String) → Bool := \n  fun _ => sorry", "vc-theorems": "theorem empty_board_valid (solver : SudokuSolver) (board : Array (Array String)) \n  (h : ∀ (i : Fin board.size) (j : Fin (board[i]!.size)), board[i]![j]! = \".\") :\n  let result := solver.solveSudoku board \n  -- Result is valid\n  (is_valid_sudoku result ∧\n  -- All cells contain digits 1-9  \n  (∀ (i : Fin result.size) (j : Fin (result[i]!.size)), \n    result[i]![j]! ∈ [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]))\n  := sorry\n\ntheorem partially_filled_board (solver : SudokuSolver)\n  (board original : Array (Array String)) \n  (h₁ : board = original) :\n  let result := solver.solveSudoku board\n  -- Result is valid \n  (is_valid_sudoku result ∧\n  -- All cells contain digits 1-9\n  (∀ (i : Fin result.size) (j : Fin (result[i]!.size)),\n    result[i]![j]! ∈ [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]) ∧ \n  -- Original numbers preserved\n  (∀ (i : Fin original.size) (j : Fin (original[i]!.size)),\n    original[i]![j]! ≠ \".\" → result[i]![j]! = original[i]![j]!))\n  := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1876", "language": "lean", "source": "fvapps", "source-id": "fvapps_001876", "source-notes": "", "vc-description": "/-\nWe stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup (250ml) of champagne.\n\nThen, some champagne is poured in the first glass at the top.  When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has it's excess champagne fall on the floor.)\n\nFor example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.\n\nNow after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)\n\nExample 1:\nInput: poured = 1, query_glass = 1, query_row = 1\nOutput: 0.0\nExplanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.\n\nExample 2:\nInput: poured = 2, query_glass = 1, query_row = 1\nOutput: 0.5\nExplanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.\n\nNote:\n\n       poured will be in the range of [0, 10 ^ 9].\n       query_glass and query_row will be in the range of [0, 99].\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def champagne_tower (poured : Float) (query_row glass : Nat) : Float := sorry\n\ntheorem champagne_tower_bounds\n  (poured : Float) (query_row glass : Nat)\n  (h1 : poured ≥ 0) :\n  let result := champagne_tower poured query_row glass\n  0 ≤ result ∧ result ≤ 1 := sorry", "vc-theorems": "theorem champagne_tower_glass_position\n  (poured : Float) (query_row glass : Nat)\n  (h1 : poured ≥ 0)\n  (h2 : glass > query_row) :\n  champagne_tower poured query_row glass = 0 := sorry\n\ntheorem champagne_tower_zero_poured\n  (query_row glass : Nat) :\n  champagne_tower 0 query_row glass = 0 := sorry\n\ntheorem champagne_tower_first_glass\n  (poured : Float)\n  (h1 : poured ≥ 0) :\n  champagne_tower poured 0 0 = min 1 poured := sorry\n\ntheorem champagne_tower_symmetry\n  (poured : Float) (row glass : Nat)\n  (h1 : poured ≥ 1)\n  (h2 : row ≥ 0)\n  (h3 : glass ≤ row) :\n  champagne_tower poured row glass = champagne_tower poured row (row - glass) := sorry\n\ntheorem champagne_tower_filled_glasses_bound_1\n  (h1 : poured = 1) :\n  (∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → True)) ∧\n  (∃ n, n ≤ 1 ∧ ∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → n > 0)) := sorry\n\ntheorem champagne_tower_filled_glasses_bound_2\n  (h1 : poured = 2) :\n  (∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → True)) ∧\n  (∃ n, n ≤ 3 ∧ ∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → n > 0)) := sorry\n\ntheorem champagne_tower_filled_glasses_bound_4\n  (h1 : poured = 4) :\n  (∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → True)) ∧\n  (∃ n, n ≤ 6 ∧ ∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → n > 0)) := sorry\n\ntheorem champagne_tower_filled_glasses_bound_8\n  (h1 : poured = 8) :\n  (∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → True)) ∧\n  (∃ n, n ≤ 10 ∧ ∀ row glass, row < 20 → glass ≤ row →\n    (champagne_tower poured row glass > 0 → n > 0)) := sorry\n\n/-\ninfo: 0.0\n-/\n-- #guard_msgs in\n-- #eval champagne_tower 1 1 1\n\n/-\ninfo: 0.5\n-/\n-- #guard_msgs in\n-- #eval champagne_tower 2 1 1\n\n/-\ninfo: 1.0\n-/\n-- #guard_msgs in\n-- #eval champagne_tower 100000009 33 17", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1878", "language": "lean", "source": "fvapps", "source-id": "fvapps_001878", "source-notes": "", "vc-description": "/-\nYou have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.\nImplement the BrowserHistory class:\n\nBrowserHistory(string homepage) Initializes the object with the homepage of the browser.\nvoid visit(string url) Visits url from the current page. It clears up all the forward history.\nstring back(int steps) Move steps back in history. If you can only return x steps in the history and steps > x, you will return only x steps. Return the current url after moving back in history at most steps.\nstring forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps > x, you will forward only x steps. Return the current url after forwarding in history at most steps.\n\nExample:\nInput:\n[\"BrowserHistory\",\"visit\",\"visit\",\"visit\",\"back\",\"back\",\"forward\",\"visit\",\"forward\",\"back\",\"back\"]\n[[\"leetcode.com\"],[\"google.com\"],[\"facebook.com\"],[\"youtube.com\"],[1],[1],[1],[\"linkedin.com\"],[2],[2],[7]]\nOutput:\n[null,null,null,null,\"facebook.com\",\"google.com\",\"facebook.com\",null,\"linkedin.com\",\"google.com\",\"leetcode.com\"]\n\nExplanation:\nBrowserHistory browserHistory = new BrowserHistory(\"leetcode.com\");\nbrowserHistory.visit(\"google.com\");       // You are in \"leetcode.com\". Visit \"google.com\"\nbrowserHistory.visit(\"facebook.com\");     // You are in \"google.com\". Visit \"facebook.com\"\nbrowserHistory.visit(\"youtube.com\");      // You are in \"facebook.com\". Visit \"youtube.com\"\nbrowserHistory.back(1);                   // You are in \"youtube.com\", move back to \"facebook.com\" return \"facebook.com\"\nbrowserHistory.back(1);                   // You are in \"facebook.com\", move back to \"google.com\" return \"google.com\"\nbrowserHistory.forward(1);                // You are in \"google.com\", move forward to \"facebook.com\" return \"facebook.com\"\nbrowserHistory.visit(\"linkedin.com\");     // You are in \"facebook.com\". Visit \"linkedin.com\"\nbrowserHistory.forward(2);                // You are in \"linkedin.com\", you cannot move forward any steps.\nbrowserHistory.back(2);                   // You are in \"linkedin.com\", move back two steps to \"facebook.com\" then to \"google.com\". return \"google.com\"\nbrowserHistory.back(7);                   // You are in \"google.com\", you can move back only one step to \"leetcode.com\". return \"leetcode.com\"\n\nConstraints:\n\n1 <= homepage.length <= 20\n1 <= url.length <= 20\n1 <= steps <= 100\nhomepage and url consist of  '.' or lower case English letters.\nAt most 5000 calls will be made to visit, back, and forward.\n-/", "vc-preamble": "def BrowserHistory.new (homepage : String) : BrowserHistory := sorry\ndef BrowserHistory.visit (self : BrowserHistory) (url : String) : BrowserHistory := sorry", "vc-helpers": "", "vc-definitions": "def BrowserHistory.back (self : BrowserHistory) (steps : Nat) : (BrowserHistory × String) := sorry\ndef BrowserHistory.forward (self : BrowserHistory) (steps : Nat) : (BrowserHistory × String) := sorry", "vc-theorems": "theorem browser_history_init (homepage : String) :\n  let browser := BrowserHistory.new homepage\n  browser.hashM[0]! = homepage ∧ \n  browser.currIndex = 0 ∧\n  browser.maxIndex = 0 := sorry\n\ntheorem sequential_visits (homepage : String) (urls : List String) :\n  let browser := BrowserHistory.new homepage\n  ∀ url ∈ urls, \n    let browser' := browser.visit url\n    browser'.hashM[browser'.currIndex]! = url ∧\n    browser'.currIndex = browser'.maxIndex := sorry\n\ntheorem back_navigation (homepage : String) (urls : List String) (steps : Nat) :\n  let browser := BrowserHistory.new homepage\n  urls.foldl (fun b url => b.visit url) browser\n  |> fun b => \n    let (b', result) := b.back steps\n    let expected_index := min b.maxIndex steps\n    b'.currIndex = expected_index ∧ \n    result = b'.hashM[expected_index]! := sorry\n\ntheorem visit_after_back_clears_forward (homepage : String) (urls : List String) (back_steps : Nat) (new_url : String) :\n  let browser := BrowserHistory.new homepage\n  let browser' := urls.foldl (fun b url => b.visit url) browser\n  let original_max := browser'.maxIndex\n  let (browser'', _) := browser'.back back_steps\n  let browser''' := browser''.visit new_url\n  browser'''.maxIndex = browser'''.currIndex ∧\n  (browser'''.maxIndex < original_max ∨ browser'''.maxIndex = urls.length) ∧\n  browser'''.hashM[browser'''.currIndex]! = new_url := sorry\n\ntheorem forward_navigation (homepage : String) (urls : List String) (steps : Nat) :\n  let browser := BrowserHistory.new homepage\n  let browser' := urls.foldl (fun b url => b.visit url) browser\n  let (browser'', _) := browser'.back steps\n  let (browser''', result) := browser''.forward steps\n  result = browser'''.hashM[browser'''.currIndex]! ∧\n  browser'''.currIndex ≤ browser'''.maxIndex := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1881", "language": "lean", "source": "fvapps", "source-id": "fvapps_001881", "source-notes": "", "vc-description": "/-\nPrint a binary tree in an m*n 2D string array following these rules: \n\nThe row number m should be equal to the height of the given binary tree.\nThe column number n should always be an odd number.\nThe root node's value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don't need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don't need to leave space for both of them. \nEach unused space should contain an empty string \"\".\nPrint the subtrees following the same rules.\n\nExample 1:\n\nInput:\n     1\n    /\n   2\nOutput:\n[[\"\", \"1\", \"\"],\n [\"2\", \"\", \"\"]]\n\nExample 2:\n\nInput:\n     1\n    / \\\n   2   3\n    \\\n     4\nOutput:\n[[\"\", \"\", \"\", \"1\", \"\", \"\", \"\"],\n [\"\", \"2\", \"\", \"\", \"\", \"3\", \"\"],\n [\"\", \"\", \"4\", \"\", \"\", \"\", \"\"]]\n\nExample 3:\n\nInput:\n      1\n     / \\\n    2   5\n   / \n  3 \n / \n4 \nOutput:\n\n[[\"\",  \"\",  \"\", \"\",  \"\", \"\", \"\", \"1\", \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]\n [\"\",  \"\",  \"\", \"2\", \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"5\", \"\", \"\", \"\"]\n [\"\",  \"3\", \"\", \"\",  \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]\n [\"4\", \"\",  \"\", \"\",  \"\", \"\", \"\", \"\",  \"\",  \"\",  \"\",  \"\",  \"\", \"\", \"\"]]\n\nNote:\nThe height of binary tree is in the range of [1, 10].\n-/", "vc-preamble": "def TreeNode.val : TreeNode → Nat\n  | mk v _ _ => v\n\ndef print_tree : Option TreeNode → List (List String)\n  | none => []\n  | some _ => sorry", "vc-helpers": "", "vc-definitions": "def get_tree_height : Option TreeNode → Nat → Nat\n  | none, _ => 0\n  | some _, _ => sorry", "vc-theorems": "theorem print_tree_props {t : TreeNode} :\n  let result := print_tree (some t)\n  -- Result is non-empty list of lists\n  (result.length > 0) ∧\n  -- All rows have same width\n  (∀ row ∈ result, row.length = result.head!.length) ∧\n  -- Width is 2^height - 1\n  (result.head!.length = (2^(get_tree_height (some t) 0)) - 1) ∧\n  -- Root in middle of first row\n  (result.head!.get! (result.head!.length/2) = toString (TreeNode.val t)) ∧\n  -- Non-empty spots are digits\n  (∀ row ∈ result, ∀ x ∈ row, x ≠ \"\" → x.all Char.isDigit) := by\n  sorry\n\ntheorem get_tree_height_props {t : TreeNode} :\n  -- Height is positive for non-empty trees\n  get_tree_height (some t) 0 > 0 ∧\n  -- Height larger than subtrees\n  match t with\n  | TreeNode.mk _ l r =>\n    ((l.map (get_tree_height · 0)).getD 0 < get_tree_height (some t) 0) ∧\n    ((r.map (get_tree_height · 0)).getD 0 < get_tree_height (some t) 0) ∧\n    (l.isNone ∧ r.isNone → get_tree_height (some t) 0 = 1)\n  := by\n  sorry\n\ntheorem print_empty_tree :\n  print_tree none = [] := by\n  sorry\n\n/-\ninfo: [['', '1', ''], ['2', '', '']]\n-/\n-- #guard_msgs in\n-- #eval print_tree TreeNode(1)\n\n/-\ninfo: [['', '', '', '1', '', '', ''], ['', '2', '', '', '', '3', ''], ['', '', '4', '', '', '', '']]\n-/\n-- #guard_msgs in\n-- #eval print_tree TreeNode(1)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1883", "language": "lean", "source": "fvapps", "source-id": "fvapps_001883", "source-notes": "", "vc-description": "/-\nGiven a rows * columns matrix mat of ones and zeros, return how many submatrices have all ones.\n\nExample 1:\nInput: mat = [[1,0,1],\n              [1,1,0],\n              [1,1,0]]\nOutput: 13\nExplanation:\nThere are 6 rectangles of side 1x1.\nThere are 2 rectangles of side 1x2.\nThere are 3 rectangles of side 2x1.\nThere is 1 rectangle of side 2x2. \nThere is 1 rectangle of side 3x1.\nTotal number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.\n\nExample 2:\nInput: mat = [[0,1,1,0],\n              [0,1,1,1],\n              [1,1,1,0]]\nOutput: 24\nExplanation:\nThere are 8 rectangles of side 1x1.\nThere are 5 rectangles of side 1x2.\nThere are 2 rectangles of side 1x3. \nThere are 4 rectangles of side 2x1.\nThere are 2 rectangles of side 2x2. \nThere are 2 rectangles of side 3x1. \nThere is 1 rectangle of side 3x2. \nTotal number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24.\n\nExample 3:\nInput: mat = [[1,1,1,1,1,1]]\nOutput: 21\n\nExample 4:\nInput: mat = [[1,0,1],[0,1,0],[1,0,1]]\nOutput: 5\n\nConstraints:\n\n1 <= rows <= 150\n1 <= columns <= 150\n0 <= mat[i][j] <= 1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_submatrices (matrix : Matrix Int) : Nat :=\n  sorry", "vc-theorems": "theorem count_submatrices_nonnegative (matrix : Matrix Int) :\n  count_submatrices matrix ≥ 0 := sorry\n\ntheorem count_submatrices_at_least_ones (matrix : Matrix Int) :\n  count_submatrices matrix ≥ ((matrix.data).join.filter (· = 1)).length := sorry\n\ntheorem count_submatrices_all_zeros (matrix : Matrix Int) :\n  ((matrix.data).all (fun row => row.all (fun x => x = 0))) → count_submatrices matrix = 0 := sorry\n\ntheorem count_submatrices_all_ones {n m : Nat} (matrix : Matrix Int) \n  (h1 : (matrix.data).length = n)\n  (h2 : ∀ row ∈ matrix.data, row.length = m)\n  (h3 : (matrix.data).all (fun row => row.all (fun x => x = 1))) :\n  count_submatrices matrix = n * m * (n * m + 1) / 2 := sorry\n\ntheorem count_submatrices_single_row_ones (n : Nat) :\n  count_submatrices ⟨[List.replicate n 1]⟩ = n * (n + 1) / 2 := sorry\n\ntheorem count_submatrices_single_col_ones (n : Nat) :\n  count_submatrices ⟨List.replicate n [1]⟩ = n * (n + 1) / 2 := sorry\n\n/-\ninfo: 13\n-/\n-- #guard_msgs in\n-- #eval count_submatrices [[1, 0, 1], [1, 1, 0], [1, 1, 0]]\n\n/-\ninfo: 24\n-/\n-- #guard_msgs in\n-- #eval count_submatrices [[0, 1, 1, 0], [0, 1, 1, 1], [1, 1, 1, 0]]\n\n/-\ninfo: 21\n-/\n-- #guard_msgs in\n-- #eval count_submatrices [[1, 1, 1, 1, 1, 1]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1884", "language": "lean", "source": "fvapps", "source-id": "fvapps_001884", "source-notes": "", "vc-description": "/-\nGiven a string S of digits, such as S = \"123456579\", we can split it into a Fibonacci-like sequence [123, 456, 579].\nFormally, a Fibonacci-like sequence is a list F of non-negative integers such that:\n\n0 <= F[i] <= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type);\nF.length >= 3;\nand F[i] + F[i+1] = F[i+2] for all 0 <= i < F.length - 2.\n\nAlso, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.\nReturn any Fibonacci-like sequence split from S, or return [] if it cannot be done.\nExample 1:\nInput: \"123456579\"\nOutput: [123,456,579]\n\nExample 2:\nInput: \"11235813\"\nOutput: [1,1,2,3,5,8,13]\n\nExample 3:\nInput: \"112358130\"\nOutput: []\nExplanation: The task is impossible.\n\nExample 4:\nInput: \"0123\"\nOutput: []\nExplanation: Leading zeroes are not allowed, so \"01\", \"2\", \"3\" is not valid.\n\nExample 5:\nInput: \"1101111\"\nOutput: [110, 1, 111]\nExplanation: The output [11, 0, 11, 11] would also be accepted.\n\nNote: \n\n1 <= S.length <= 200\nS contains only digits.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem valid_fibonacci_sequences \n  (nums: List Nat)\n  (h1: nums.length ≥ 3)\n  (h2: nums.length ≤ 10) \n  (h3: ∀ n ∈ nums, isValidInt n)\n  (h4: isFibonacciSequence nums) :\n  let s := sequenceToString nums\n  let result := splitFibonacci s\n  (result.length ≥ 3 ∧ \n   isFibonacciSequence result ∧\n   sequenceToString result = s ∧\n   ∀ x ∈ result, isValidInt x) :=\n  sorry\n\ntheorem arbitrary_strings\n  (s: String)\n  (h1: s.length ≥ 1)\n  (h2: s.length ≤ 20)\n  (h3: ∀ c ∈ s.data, c.isDigit) :\n  let result := splitFibonacci s\n  (result = [] ∨ \n   (result.length ≥ 3 ∧\n    isFibonacciSequence result ∧\n    sequenceToString result = s ∧\n    ∀ x ∈ result, isValidInt x)) :=\n  sorry\n\ntheorem single_digits\n  (d: Nat)\n  (h1: d ≥ 1)\n  (h2: d ≤ 9) :\n  splitFibonacci (toString d) = [] :=\n  sorry\n\n/-\ninfo: [123, 456, 579]\n-/\n-- #guard_msgs in\n-- #eval split_fibonacci \"123456579\"\n\n/-\ninfo: [1, 1, 2, 3, 5, 8, 13]\n-/\n-- #guard_msgs in\n-- #eval split_fibonacci \"11235813\"\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval split_fibonacci \"112358130\"", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1886", "language": "lean", "source": "fvapps", "source-id": "fvapps_001886", "source-notes": "", "vc-description": "/-\nGiven a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.\n\nAn example is the root-to-leaf path 1->2->3 which represents the number 123.\n\nFind the total sum of all root-to-leaf numbers.\n\nNote: A leaf is a node with no children.\n\nExample:\n\nInput: [1,2,3]\n    1\n   / \\\n  2   3\nOutput: 25\nExplanation:\nThe root-to-leaf path 1->2 represents the number 12.\nThe root-to-leaf path 1->3 represents the number 13.\nTherefore, sum = 12 + 13 = 25.\n\nExample 2:\n\nInput: [4,9,0,5,1]\n    4\n   / \\\n  9   0\n / \\\n5   1\nOutput: 1026\nExplanation:\nThe root-to-leaf path 4->9->5 represents the number 495.\nThe root-to-leaf path 4->9->1 represents the number 491.\nThe root-to-leaf path 4->0 represents the number 40.\nTherefore, sum = 495 + 491 + 40 = 1026.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumNumbers : Tree → Int\n  | Tree.empty => 0\n  | t => sorry", "vc-theorems": "theorem empty_tree_sum :\n  sumNumbers Tree.empty = 0 := by sorry\n\ntheorem single_node_sum (v : Int) (h : 0 ≤ v ∧ v ≤ 9):\n  sumNumbers (Tree.node v Tree.empty Tree.empty) = v := by sorry \n\ntheorem three_node_sum (root_val left_val right_val : Int)\n    (h1 : 0 ≤ root_val ∧ root_val ≤ 9)\n    (h2 : 0 ≤ left_val ∧ left_val ≤ 9) \n    (h3 : 0 ≤ right_val ∧ right_val ≤ 9):\n  sumNumbers (Tree.node root_val \n              (Tree.node left_val Tree.empty Tree.empty)\n              (Tree.node right_val Tree.empty Tree.empty)) = \n    (root_val * 10 + left_val) + (root_val * 10 + right_val) := by sorry\n\ntheorem single_path_sum (v : Int) (h : 0 ≤ v ∧ v ≤ 9):\n  sumNumbers (Tree.node v (Tree.node v Tree.empty Tree.empty) Tree.empty) = \n    v * 10 + v := by sorry\n\n/-\ninfo: 25\n-/\n-- #guard_msgs in\n-- #eval sumNumbers TreeNode(1)\n\n/-\ninfo: 1026\n-/\n-- #guard_msgs in\n-- #eval sumNumbers TreeNode(4)\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval sumNumbers TreeNode(5)", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1891", "language": "lean", "source": "fvapps", "source-id": "fvapps_001891", "source-notes": "", "vc-description": "/-\nGiven a binary tree, return the postorder traversal of its nodes' values.\n\nExample:\n\nInput: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\nOutput: [3,2,1]\n\nFollow up: Recursive solution is trivial, could you do it iteratively?\n-/", "vc-preamble": "def postorder_traversal {α : Type} (t : Tree α) : List α := sorry\n\ndef build_tree {α : Type} (vals : List α) : Tree α := sorry", "vc-helpers": "", "vc-definitions": "def get_postorder {α : Type} (t : Tree α) : List α := sorry\n\ntheorem empty_tree_postorder {α : Type} :\n  postorder_traversal (Tree.leaf : Tree α) = [] := sorry", "vc-theorems": "theorem postorder_matches_expected {α : Type} (vals : List α) :\n  vals ≠ [] →\n  let tree := build_tree vals\n  postorder_traversal tree = get_postorder tree := sorry\n\ntheorem single_node_postorder {α : Type} (v : α) :\n  postorder_traversal (Tree.node v Tree.leaf Tree.leaf) = [v] := sorry\n\ntheorem two_nodes_left_postorder {α : Type} (v1 v2 : α) :\n  postorder_traversal (Tree.node v1 (Tree.node v2 Tree.leaf Tree.leaf) Tree.leaf) = [v2, v1] := sorry\n\ntheorem two_nodes_right_postorder {α : Type} (v1 v2 : α) :\n  postorder_traversal (Tree.node v1 Tree.leaf (Tree.node v2 Tree.leaf Tree.leaf)) = [v2, v1] := sorry\n\n/-\ninfo: [3, 2, 1]\n-/\n-- #guard_msgs in\n-- #eval postorder_traversal TreeNode(1)\n\n/-\ninfo: [2, 3, 1]\n-/\n-- #guard_msgs in\n-- #eval postorder_traversal TreeNode(1)\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval postorder_traversal None", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1892", "language": "lean", "source": "fvapps", "source-id": "fvapps_001892", "source-notes": "", "vc-description": "/-\nDesign a stack which supports the following operations.\nImplement the CustomStack class:\n\nCustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack or do nothing if the stack reached the maxSize.\nvoid push(int x) Adds x to the top of the stack if the stack hasn't reached the maxSize.\nint pop() Pops and returns the top of stack or -1 if the stack is empty.\nvoid inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, just increment all the elements in the stack.\n\nExample 1:\nInput\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\nOutput\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\nExplanation\nCustomStack customStack = new CustomStack(3); // Stack is Empty []\ncustomStack.push(1);                          // stack becomes [1]\ncustomStack.push(2);                          // stack becomes [1, 2]\ncustomStack.pop();                            // return 2 --> Return top of the stack 2, stack becomes [1]\ncustomStack.push(2);                          // stack becomes [1, 2]\ncustomStack.push(3);                          // stack becomes [1, 2, 3]\ncustomStack.push(4);                          // stack still [1, 2, 3], Don't add another elements as size is 4\ncustomStack.increment(5, 100);                // stack becomes [101, 102, 103]\ncustomStack.increment(2, 100);                // stack becomes [201, 202, 103]\ncustomStack.pop();                            // return 103 --> Return top of the stack 103, stack becomes [201, 202]\ncustomStack.pop();                            // return 202 --> Return top of the stack 102, stack becomes [201]\ncustomStack.pop();                            // return 201 --> Return top of the stack 101, stack becomes []\ncustomStack.pop();                            // return -1 --> Stack is empty return -1.\n\nConstraints:\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\nAt most 1000 calls will be made to each method of increment, push and pop each separately.\n-/", "vc-preamble": "def CustomStack.new (maxSize : Nat) : CustomStack :=\n  sorry\n\ndef CustomStack.push (s : CustomStack) (x : Int) : CustomStack :=\n  sorry\n\ndef CustomStack.pop (s : CustomStack) : Int × CustomStack :=\n  sorry\n\ndef CustomStack.size (s : CustomStack) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def CustomStack.increment (s : CustomStack) (k : Nat) (val : Int) : CustomStack :=\n  sorry", "vc-theorems": "theorem stack_size_limit {maxSize : Nat} {items : List Int} (s : CustomStack) :\n  s = CustomStack.new maxSize →\n  (∀ x ∈ items, CustomStack.size (CustomStack.push s x) ≤ maxSize) :=\n  sorry\n\ntheorem pop_empty_returns_neg_one {maxSize : Nat} (s : CustomStack) :\n  s = CustomStack.new maxSize →\n  CustomStack.size s = 0 →\n  (CustomStack.pop s).1 = -1 :=\n  sorry\n\ntheorem push_pop_single {maxSize : Nat} {val : Int} (s : CustomStack) :\n  maxSize > 0 →\n  s = CustomStack.new maxSize →\n  (CustomStack.pop (CustomStack.push s val)).1 = val :=\n  sorry\n\ntheorem empty_increment_no_effect {maxSize : Nat} (s : CustomStack) :\n  s = CustomStack.new maxSize →\n  CustomStack.size s = 0 →\n  (CustomStack.pop (CustomStack.increment s 1 100)).1 = -1 :=\n  sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1893", "language": "lean", "source": "fvapps", "source-id": "fvapps_001893", "source-notes": "", "vc-description": "/-\nImplement a magic directory with buildDict, and search methods.\n\nFor the method buildDict, you'll be given a list of non-repetitive words to build a dictionary.\n\nFor the method search, you'll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built.\n\nExample 1:\n\nInput: buildDict([\"hello\", \"leetcode\"]), Output: Null\nInput: search(\"hello\"), Output: False\nInput: search(\"hhllo\"), Output: True\nInput: search(\"hell\"), Output: False\nInput: search(\"leetcoded\"), Output: False\n\nNote:\n\nYou may assume that all the inputs are consist of lowercase letters a-z.\nFor contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest.\nPlease remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def defaultMagicDictionary : MagicDictionary := {\n  l := []\n  buildDict := fun words => words\n  search := fun _ => false\n}", "vc-theorems": "theorem buildDict_preserves_words (md : MagicDictionary) (words : List String) : \n  md.buildDict words = words := sorry\n\ntheorem length_mismatch_returns_false (md : MagicDictionary) (word : String) (delta : Nat) :\n  delta ≥ 1 →\n  ¬(md.search (word ++ String.mk (List.replicate delta 'a'))) := sorry\n\ntheorem single_char_diff_returns_true (md : MagicDictionary) (word : String) (pos : Nat) :\n  pos < word.length →\n  let newChar := if word.get ⟨pos⟩ = 'x' then 'y' else 'x'\n  let modified := word.set ⟨pos⟩ newChar\n  md.search modified := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1897", "language": "lean", "source": "fvapps", "source-id": "fvapps_001897", "source-notes": "", "vc-description": "/-\nDesign a Skiplist without using any built-in libraries.\nA Skiplist is a data structure that takes O(log(n)) time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists are just simple linked lists.\nFor example: we have a Skiplist containing [30,40,50,60,70,90] and we want to add 80 and 45 into it. The Skiplist works this way:\n\nArtyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons\nYou can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add , erase and search can be faster than O(n). It can be proven that the average time complexity for each operation is O(log(n)) and space complexity is O(n).\nTo be specific, your design should include these functions:\n\nbool search(int target) : Return whether the target exists in the Skiplist or not.\nvoid add(int num): Insert a value into the SkipList. \nbool erase(int num): Remove a value in the Skiplist. If num does not exist in the Skiplist, do nothing and return false. If there exists multiple num values, removing any one of them is fine.\n\nSee more about Skiplist : https://en.wikipedia.org/wiki/Skip_list\nNote that duplicates may exist in the Skiplist, your code needs to handle this situation.\n\nExample:\nSkiplist skiplist = new Skiplist();\n\nskiplist.add(1);\nskiplist.add(2);\nskiplist.add(3);\nskiplist.search(0);   // return false.\nskiplist.add(4);\nskiplist.search(1);   // return true.\nskiplist.erase(0);    // return false, 0 is not in skiplist.\nskiplist.erase(1);    // return true.\nskiplist.search(1);   // return false, 1 has already been erased.\n\nConstraints:\n\n0 <= num, target <= 20000\nAt most 50000 calls will be made to search, add, and erase.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Skiplist.new : Skiplist := sorry\n\ndef List.toFinset (l : List Nat) : List Nat := \n  match l with\n  | [] => []\n  | h :: t => if h ∈ t then List.toFinset t else h :: List.toFinset t", "vc-theorems": "theorem add_search_property (l : List Nat) (h : ∀ x ∈ l, x ≤ 20000) :\n  let sl := Skiplist.new \n  ∀ x ∈ l.toFinset,\n    (List.foldl (λ acc n => let _ := acc.add n; acc) sl l).search x := sorry\n\ntheorem search_missing_property (l : List Nat) (n : Nat) \n    (h₁ : ∀ x ∈ l, x ≤ 20000)\n    (h₂ : n > 20000 ∨ n < 0) :\n  let sl := Skiplist.new\n  ¬((List.foldl (λ acc x => let _ := acc.add x; acc) sl l).search n) := sorry\n\ntheorem erase_property (l : List Nat) (h : ∀ x ∈ l, x ≤ 20000) :\n  let sl := Skiplist.new\n  let sl' := List.foldl (λ acc x => let _ := acc.add x; acc) sl l\n  ∀ x ∈ l.toFinset,\n    (∀ i < l.count x, sl'.erase x) ∧\n    (¬sl'.erase x) ∧\n    (¬sl'.search x) := sorry\n\ntheorem duplicate_property (n : Nat) (r : Nat)\n    (h₁ : n ≤ 20000) \n    (h₂ : 0 < r ∧ r ≤ 100) :\n  let sl := Skiplist.new\n  let sl' := List.foldl (λ acc _ => let _ := acc.add n; acc) sl (List.replicate r ())\n  (∀ i < r, sl'.erase n) ∧ \n  (¬sl'.search n) ∧\n  (¬sl'.erase n) := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1900", "language": "lean", "source": "fvapps", "source-id": "fvapps_001900", "source-notes": "", "vc-description": "/-\nGiven preorder and inorder traversal of a tree, construct the binary tree.\n\nNote:\nYou may assume that duplicates do not exist in the tree.\n\nFor example, given\n\npreorder = [3,9,20,15,7]\ninorder = [9,3,15,20,7]\n\nReturn the following binary tree:\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n-/", "vc-preamble": "def buildTree (preorder : List Int) (inorder : List Int) : Option TreeNode :=\n  sorry\n\ndef inorder_traversal (tree : Option TreeNode) : List Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def preorder_traversal (tree : Option TreeNode) : List Int :=\n  sorry", "vc-theorems": "theorem buildTree_reconstructs_traversals {size : Nat} (preorder inorder : List Int) :\n  (preorder.length = size) →\n  (inorder.length = size) →\n  size > 0 →\n  let tree := buildTree preorder inorder\n  inorder_traversal tree = inorder ∧ \n  preorder_traversal tree = preorder :=\nsorry\n\ntheorem empty_input_gives_none :\n  buildTree [] [] = none :=\nsorry\n\ntheorem single_node_preserves_value (x : Int) :\n  let tree := buildTree [x] [x]\n  match tree with\n  | some (TreeNode.node val left right) => val = x ∧ left = none ∧ right = none \n  | none => False\n:=\nsorry\n\n/-\ninfo: inorder1\n-/\n-- #guard_msgs in\n-- #eval inorder_traversal buildTree(preorder1, inorder1)\n\n/-\ninfo: preorder1\n-/\n-- #guard_msgs in\n-- #eval preorder_traversal result1\n\n/-\ninfo: inorder2\n-/\n-- #guard_msgs in\n-- #eval inorder_traversal buildTree(preorder2, inorder2)\n\n/-\ninfo: preorder2\n-/\n-- #guard_msgs in\n-- #eval preorder_traversal result2\n\n/-\ninfo: inorder3\n-/\n-- #guard_msgs in\n-- #eval inorder_traversal buildTree(preorder3, inorder3)\n\n/-\ninfo: preorder3\n-/\n-- #guard_msgs in\n-- #eval preorder_traversal result3", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1904", "language": "lean", "source": "fvapps", "source-id": "fvapps_001904", "source-notes": "", "vc-description": "/-\nConsider a directed graph, with nodes labelled 0, 1, ..., n-1.  In this graph, each edge is either red or blue, and there could be self-edges or parallel edges.\nEach [i, j] in red_edges denotes a red directed edge from node i to node j.  Similarly, each [i, j] in blue_edges denotes a blue directed edge from node i to node j.\nReturn an array answer of length n, where each answer[X] is the length of the shortest path from node 0 to node X such that the edge colors alternate along the path (or -1 if such a path doesn't exist).\n\nExample 1:\nInput: n = 3, red_edges = [[0,1],[1,2]], blue_edges = []\nOutput: [0,1,-1]\nExample 2:\nInput: n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]\nOutput: [0,1,-1]\nExample 3:\nInput: n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]\nOutput: [0,-1,-1]\nExample 4:\nInput: n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]\nOutput: [0,1,2]\nExample 5:\nInput: n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]\nOutput: [0,1,1]\n\nConstraints:\n\n1 <= n <= 100\nred_edges.length <= 400\nblue_edges.length <= 400\nred_edges[i].length == blue_edges[i].length == 2\n0 <= red_edges[i][j], blue_edges[i][j] < n\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def shortestAlternatingPaths (n : Nat) (redEdges blueEdges : List Edge) : List Int :=\n  sorry", "vc-theorems": "theorem empty_path_valid (n : Nat) (edges : List Edge) \n  (h1 : n > 0) (h2 : ∀ e ∈ edges, e.from_ < n ∧ e.to_ < n) :\n  let result := shortestAlternatingPaths n edges []\n  -- Result length matches n\n  List.length result = n\n  -- First element is 0\n  ∧ List.get! result 0 = 0 \n  -- All elements are -1 or valid length < 2n\n  ∧ ∀ x ∈ result, x ≥ -1 ∧ (x = -1 ∨ x < 2 * n) :=\nsorry\n\ntheorem alternating_path_valid (n : Nat) (redEdges blueEdges : List Edge)\n  (h1 : n > 0)\n  (h2 : ∀ e ∈ redEdges, e.from_ < n ∧ e.to_ < n)\n  (h3 : ∀ e ∈ blueEdges, e.from_ < n ∧ e.to_ < n) :\n  let result := shortestAlternatingPaths n redEdges blueEdges\n  -- Result length matches n\n  List.length result = n\n  -- First element is 0\n  ∧ List.get! result 0 = 0\n  -- All elements are -1 or valid length < 2n \n  ∧ ∀ x ∈ result, x ≥ -1 ∧ (x = -1 ∨ x < 2 * n) :=\nsorry\n\ntheorem no_edges (n : Nat) (h : n > 0) :\n  let result := shortestAlternatingPaths n ([] : List Edge) ([] : List Edge)\n  List.get! result 0 = 0\n  ∧ ∀ i, i > 0 → i < n → List.get! result i = -1 := \nsorry\n\ntheorem self_loops :\n  let n := 3\n  let result := shortestAlternatingPaths n \n    [⟨0, 0⟩] [⟨0, 0⟩]\n  List.get! result 0 = 0 :=\nsorry\n\n/-\ninfo: [0, 1, -1]\n-/\n-- #guard_msgs in\n-- #eval shortest_alternating_paths 3 [[0, 1], [1, 2]] []\n\n/-\ninfo: [0, 1, 2]\n-/\n-- #guard_msgs in\n-- #eval shortest_alternating_paths 3 [[0, 1]] [[1, 2]]\n\n/-\ninfo: [0, 1, 1]\n-/\n-- #guard_msgs in\n-- #eval shortest_alternating_paths 3 [[0, 1], [0, 2]] [[1, 0]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1909", "language": "lean", "source": "fvapps", "source-id": "fvapps_001909", "source-notes": "", "vc-description": "/-\nWe are given head, the head node of a linked list containing unique integer values.\nWe are also given the list G, a subset of the values in the linked list.\nReturn the number of connected components in G, where two values are connected if they appear consecutively in the linked list.\nExample 1:\nInput: \nhead: 0->1->2->3\nG = [0, 1, 3]\nOutput: 2\nExplanation: \n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\n\nExample 2:\nInput: \nhead: 0->1->2->3->4\nG = [0, 3, 1, 4]\nOutput: 2\nExplanation: \n0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\n\nNote: \n\nIf N is the length of the linked list given by head, 1 <= N <= 10000.\nThe value of each node in the linked list will be in the range [0, N - 1].\n1 <= G.length <= 10000.\nG is a subset of all values in the linked list.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def create_linked_list (values : List Int) : ListNode := sorry\n\ndef numComponents (head : ListNode) (values : List Int) : Nat := sorry", "vc-theorems": "theorem full_list_is_one_component (values : List Int) (h : values ≠ []) :\n  numComponents (create_linked_list values) values = 1 := sorry\n\ntheorem disjoint_lists_return_zero {values g : List Int} (h1 : values ≠ [])\n  (h2 : ∀ x, x ∈ values → x ∉ g) :\n  numComponents (create_linked_list values) g = 0 := sorry\n\ntheorem single_value_gives_one_component {values : List Int} (h1 : values ≠ [])\n  (h2 : ∀ x y, x ∈ values → y ∈ values → x ≠ y) :  \n  numComponents (create_linked_list values) [values.head!] = 1 := sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval numComponents create_linked_list([0, 1, 2, 3]) [0, 1, 3]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval numComponents create_linked_list([0, 1, 2, 3, 4]) [0, 3, 1, 4]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval numComponents create_linked_list([0, 1, 2]) [0, 2]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1910", "language": "lean", "source": "fvapps", "source-id": "fvapps_001910", "source-notes": "", "vc-description": "/-\nYou are driving a vehicle that has capacity empty seats initially available for passengers.  The vehicle only drives east (ie. it cannot turn around and drive west.)\nGiven a list of trips, trip[i] = [num_passengers, start_location, end_location] contains information about the i-th trip: the number of passengers that must be picked up, and the locations to pick them up and drop them off.  The locations are given as the number of kilometers due east from your vehicle's initial location.\nReturn true if and only if it is possible to pick up and drop off all passengers for all the given trips. \n\nExample 1:\nInput: trips = [[2,1,5],[3,3,7]], capacity = 4\nOutput: false\n\nExample 2:\nInput: trips = [[2,1,5],[3,3,7]], capacity = 5\nOutput: true\n\nExample 3:\nInput: trips = [[2,1,5],[3,5,7]], capacity = 3\nOutput: true\n\nExample 4:\nInput: trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11\nOutput: true\n\nConstraints:\n\ntrips.length <= 1000\ntrips[i].length == 3\n1 <= trips[i][0] <= 100\n0 <= trips[i][1] < trips[i][2] <= 1000\n1 <= capacity <= 100000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def carPooling (trips : List Trip) (capacity : Int) : Bool :=\n  sorry", "vc-theorems": "theorem capacity_zero (trips : List Trip) :\n  carPooling trips 0 = (trips.length = 0) :=\n  sorry\n\ntheorem timeline_under_capacity (trips : List Trip) (capacity : Int) :\n  carPooling trips capacity = true →\n  ∀ t : Int, \n    (trips.foldl (λ acc trip =>\n      if t ≥ trip.startLoc ∧ t < trip.endLoc\n      then acc + trip.passengers \n      else acc) 0) ≤ capacity :=\n  sorry\n\ntheorem large_capacity_always_works (trips : List Trip) :\n  carPooling trips 1000000 = true :=\n  sorry\n\ntheorem timeline_consistency (trips : List Trip) :\n  (trips.foldl (λ acc trip => acc + trip.passengers - trip.passengers) 0) = 0 :=\n  sorry\n\ntheorem trip_valid (t : Trip) : \n  t.passengers > 0 ∧ \n  t.passengers ≤ 1000 ∧ \n  t.startLoc ≥ 0 ∧ \n  t.startLoc < 1000 ∧ \n  t.endLoc > 0 ∧ \n  t.endLoc ≤ 1000 ∧ \n  t.startLoc < t.endLoc :=\n  sorry\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval car_pooling [[2, 1, 5], [3, 3, 7]] 4\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval car_pooling [[2, 1, 5], [3, 3, 7]] 5\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval car_pooling [[3, 2, 7], [3, 7, 9], [8, 3, 9]] 11", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1912", "language": "lean", "source": "fvapps", "source-id": "fvapps_001912", "source-notes": "", "vc-description": "/-\nGiven a list of intervals, remove all intervals that are covered by another interval in the list.\nInterval [a,b) is covered by interval [c,d) if and only if c <= a and b <= d.\nAfter doing so, return the number of remaining intervals.\n\nExample 1:\nInput: intervals = [[1,4],[3,6],[2,8]]\nOutput: 2\nExplanation: Interval [3,6] is covered by [2,8], therefore it is removed.\n\nExample 2:\nInput: intervals = [[1,4],[2,3]]\nOutput: 1\n\nExample 3:\nInput: intervals = [[0,10],[5,12]]\nOutput: 2\n\nExample 4:\nInput: intervals = [[3,10],[4,10],[5,11]]\nOutput: 2\n\nExample 5:\nInput: intervals = [[1,2],[1,4],[3,4]]\nOutput: 1\n\nConstraints:\n\n1 <= intervals.length <= 1000\nintervals[i].length == 2\n0 <= intervals[i][0] < intervals[i][1] <= 10^5\nAll the intervals are unique.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def remove_covered_intervals (intervals: List Interval) : Int :=\n  sorry", "vc-theorems": "theorem remove_covered_intervals_empty :\n  remove_covered_intervals [] = 0 :=\n  sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval remove_covered_intervals [[1, 4], [3, 6], [2, 8]]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval remove_covered_intervals [[1, 4], [2, 3]]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval remove_covered_intervals [[3, 10], [4, 10], [5, 11]]", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1913", "language": "lean", "source": "fvapps", "source-id": "fvapps_001913", "source-notes": "", "vc-description": "/-\nThere are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w.\n\nNow given all the cities and fights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.\n\nExample 1:\nInput: \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 1\nOutput: 200\nExplanation: \nThe graph looks like this:\n\nThe cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.\n\nExample 2:\nInput: \nn = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0, dst = 2, k = 0\nOutput: 500\nExplanation: \nThe graph looks like this:\n\nThe cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.\n\nNote:\n\n       The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1.\n       The size of flights will be in range [0, n * (n - 1) / 2].\n       The format of each flight will be (src, dst, price).\n       The price of each flight will be in the range [1, 10000].\n       k is in the range of [0, n - 1].\n       There will not be any duplicated flights or self cycles.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_cheapest_price (n: Nat) (flights: List Flight) (src: Nat) (dst: Nat) (k: Nat) : Int :=\nsorry", "vc-theorems": "theorem price_non_negative\n  (n: Nat) (flights: List Flight) (src dst k: Nat)\n  (h1: src < n) (h2: dst < n) (h3: src ≠ dst) :\n  let price := find_cheapest_price n flights src dst k\n  price = -1 ∨ price ≥ 0 :=\nsorry\n\ntheorem increasing_stops_never_increases_price \n  (n: Nat) (flights: List Flight) (src dst k1 k2: Nat)\n  (h1: src < n) (h2: dst < n) (h3: src ≠ dst) (h4: k1 < k2) :\n  let price1 := find_cheapest_price n flights src dst k1\n  let price2 := find_cheapest_price n flights src dst k2\n  price1 ≠ -1 → price2 ≠ -1 → price2 ≤ price1 :=\nsorry\n\ntheorem direct_flights_independent_of_k\n  (n: Nat) (flights: List Flight) (src dst: Nat)\n  (h1: src < n) (h2: dst < n) (h3: src ≠ dst)\n  (h4: ∃ f ∈ flights, f.src = src ∧ f.dst = dst) :\n  let direct_price := find_cheapest_price n flights src dst 0\n  let min_direct := List.foldl (fun acc f => \n    if f.src = src ∧ f.dst = dst \n    then min acc f.price\n    else acc) 0 flights\n  direct_price ≠ -1 → direct_price = min_direct :=\nsorry\n\ntheorem triangular_path_property\n  (n: Nat) (flights: List Flight) (src dst k: Nat)\n  (h1: src < n) (h2: dst < n) (h3: src ≠ dst) (h4: k > 0)\n  (h5: ∃ f ∈ flights, f.src = src ∨ f.dst = dst) :\n  let price := find_cheapest_price n flights src dst k\n  let min_edge := List.foldl (fun acc f =>\n    if f.src = src ∨ f.dst = dst\n    then min acc f.price \n    else acc) 0 flights\n  price ≠ -1 ∧ min_edge > 0 → price ≥ min_edge :=\nsorry\n\n/-\ninfo: 200\n-/\n-- #guard_msgs in\n-- #eval find_cheapest_price 3 [[0, 1, 100], [1, 2, 100], [0, 2, 500]] 0 2 1\n\n/-\ninfo: 500\n-/\n-- #guard_msgs in\n-- #eval find_cheapest_price n flights src dst 0\n\n/-\ninfo: 500\n-/\n-- #guard_msgs in\n-- #eval find_cheapest_price 4 [[0, 1, 100], [1, 2, 100], [2, 3, 100], [0, 3, 500]] 0 3 1", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1914", "language": "lean", "source": "fvapps", "source-id": "fvapps_001914", "source-notes": "", "vc-description": "/-\nGiven the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences.\nAfter doing so, return the head of the final linked list.  You may return any such answer.\n\n(Note that in the examples below, all sequences are serializations of ListNode objects.)\nExample 1:\nInput: head = [1,2,-3,3,1]\nOutput: [3,1]\nNote: The answer [1,2,1] would also be accepted.\n\nExample 2:\nInput: head = [1,2,3,-3,4]\nOutput: [1,2,4]\n\nExample 3:\nInput: head = [1,2,3,-3,-2]\nOutput: [1]\n\nConstraints:\n\nThe given linked list will contain between 1 and 1000 nodes.\nEach node in the linked list has -1000 <= node.val <= 1000.\n-/", "vc-preamble": "def ListNode.next : ListNode → Option ListNode\n  | mk _ next => next\n\ndef ListNode.val : ListNode → Int\n  | mk val _ => val\n\ndef removeZeroSumSublists : ListNode → Option ListNode := sorry\ndef listToArray : Option ListNode → List Int := sorry \n\ndef arrayToList : List Int → Option ListNode := sorry\n\ndef sumList (l : List Int) : Int :=\n  l.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def isSubsequence (sub post : List Int) : Bool :=\n  match sub, post with\n  | [], _ => true\n  | _, [] => false\n  | x::xs, y::ys => if x = y \n                    then isSubsequence xs ys\n                    else isSubsequence (x::xs) ys", "vc-theorems": "theorem no_zero_sum_sublists_after_removal (l : List Int) :\n  let result := listToArray (removeZeroSumSublists (arrayToList l).get!)\n  ∀ i j, i ≤ j → j < result.length →\n    sumList ((result.take (j + 1)).drop i) ≠ 0 := sorry\n\ntheorem result_is_subsequence (l : List Int) :\n  let result := listToArray (removeZeroSumSublists (arrayToList l).get!)\n  isSubsequence result l = true := sorry\n\ntheorem all_positive_unchanged (l : List Int) :\n  (∀ x ∈ l, x > 0) →\n  listToArray (removeZeroSumSublists (arrayToList l).get!) = l := sorry\n\ninductive IsAcyclic : ListNode → Prop where\n  | nil : (n : ListNode) → Option.isNone (n.next) → IsAcyclic n\n  | cons : (n : ListNode) → Option.isSome (n.next) → \n          IsAcyclic (Option.get! n.next) → IsAcyclic n\n\ntheorem linked_list_valid (l : List Int) :\n  l ≠ [] →\n  let result := (removeZeroSumSublists (arrayToList l).get!)\n  ∀ node, result = some node → IsAcyclic node := sorry", "vc-postamble": "-- Apps difficulty: interview\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1925", "language": "lean", "source": "fvapps", "source-id": "fvapps_001925", "source-notes": "", "vc-description": "/-\nLimak is a little bear who loves to play. Today he is playing by destroying block towers. He built n towers in a row. The i-th tower is made of h_{i} identical blocks. For clarification see picture for the first sample.\n\nLimak will repeat the following operation till everything is destroyed.\n\nBlock is called internal if it has all four neighbors, i.e. it has each side (top, left, down and right) adjacent to other block or to the floor. Otherwise, block is boundary. In one operation Limak destroys all boundary blocks. His paws are very fast and he destroys all those blocks at the same time.\n\nLimak is ready to start. You task is to count how many operations will it take him to destroy all towers.\n\n-----Input-----\n\nThe first line contains single integer n (1 ≤ n ≤ 10^5).\n\nThe second line contains n space-separated integers h_1, h_2, ..., h_{n} (1 ≤ h_{i} ≤ 10^9) — sizes of towers.\n\n-----Output-----\n\nPrint the number of operations needed to destroy all towers.\n\n-----Examples-----\nInput\n6\n2 1 4 6 2 2\n\nOutput\n3\n\nInput\n7\n3 3 3 1 3 3 3\n\nOutput\n2\n\n-----Note-----\n\nThe picture below shows all three operations for the first sample test. Each time boundary blocks are marked with red color.  [Image]  After first operation there are four blocks left and only one remains after second operation. This last block is destroyed in third operation.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def operations_to_destroy_towers (n : Nat) (towers : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem valid_result_props {n : Nat} {towers : List Nat} \n  (h1 : n ≥ 2) (h2 : n ≤ 100) (h3 : towers.length ≥ 2) \n  (h4 : ∀ x ∈ towers, x ≥ 1 ∧ x ≤ 100) :\n  let result := operations_to_destroy_towers n towers\n  -- result is valid\n  let final_towers := towers -- after applying operations\n  (result ≥ 1) ∧ \n  (match List.maximum? towers with\n   | none => True\n   | some max => result ≤ max) ∧\n  (final_towers.head? = some 1) ∧\n  (final_towers.get? (n-1) = some 1) :=\nsorry\n\ntheorem all_ones_case {n : Nat}\n  (h1 : n ≥ 2) (h2 : n ≤ 100) :\n  operations_to_destroy_towers n (List.replicate n 1) = 1 :=\nsorry\n\ntheorem ascending_case {n : Nat}\n  (h1 : n ≥ 2) (h2 : n ≤ 100) :\n  operations_to_destroy_towers n (List.range' 1 (n+1)) ≤ n :=\nsorry\n\ntheorem descending_case {n : Nat}\n  (h1 : n ≥ 2) (h2 : n ≤ 100) :\n  operations_to_destroy_towers n (List.range' n 0) ≤ n :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval operations_to_destroy_towers 6 [2, 1, 4, 6, 2, 2]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval operations_to_destroy_towers 7 [3, 3, 3, 1, 3, 3, 3]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval operations_to_destroy_towers 5 [1, 2, 3, 2, 1]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1927", "language": "lean", "source": "fvapps", "source-id": "fvapps_001927", "source-notes": "", "vc-description": "/-\nA permutation p of size n is the sequence p_1, p_2, ..., p_{n}, consisting of n distinct integers, each of them is from 1 to n (1 ≤ p_{i} ≤ n).\n\nA lucky permutation is such permutation p, that any integer i (1 ≤ i ≤ n) meets this condition p_{p}_{i} = n - i + 1.\n\nYou have integer n. Find some lucky permutation p of size n.\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 10^5) — the required permutation size.\n\n-----Output-----\n\nPrint \"-1\" (without the quotes) if the lucky permutation p of size n doesn't exist.\n\nOtherwise, print n distinct integers p_1, p_2, ..., p_{n} (1 ≤ p_{i} ≤ n) after a space — the required permutation.\n\nIf there are multiple answers, you can print any of them.\n\n-----Examples-----\nInput\n1\n\nOutput\n1 \n\nInput\n2\n\nOutput\n-1\n\nInput\n4\n\nOutput\n2 4 1 3 \n\nInput\n5\n\nOutput\n2 5 3 1 4\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_lucky_permutation (n : Nat) : Option (List Nat) := sorry\n\ntheorem length_property {n : Nat} {result : List Nat} \n  (h : find_lucky_permutation n = some result) : \n    result.length = n ∧ \n    (∃ m, result.minimum? = some m ∧ m = 1) ∧\n    (∃ m, result.maximum? = some m ∧ m = n) ∧\n    (∀ x ∈ result, ∀ y ∈ result, x = y → result.find? (·= x) = result.find? (·= y)) := sorry", "vc-theorems": "theorem negative_cases :\n  find_lucky_permutation 2 = none ∧ \n  find_lucky_permutation 3 = none ∧\n  find_lucky_permutation 6 = none ∧\n  find_lucky_permutation 7 = none := sorry\n\ntheorem small_valid_cases :\n  find_lucky_permutation 1 = some [1] ∧\n  (∃ result, find_lucky_permutation 4 = some result ∧ \n    result.length = 4 ∧\n    (∃ l, l = [1,2,3,4] ∧ ∀ x ∈ result, x ∈ l)) := sorry\n\ntheorem divisibility_rule {n : Nat} \n  (h : n % 4 > 1) :\n  find_lucky_permutation n = none := sorry\n\n/-\ninfo: [1]\n-/\n-- #guard_msgs in\n-- #eval find_lucky_permutation 1\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval find_lucky_permutation 2\n\n/-\ninfo: [2, 4, 1, 3]\n-/\n-- #guard_msgs in\n-- #eval find_lucky_permutation 4", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1928", "language": "lean", "source": "fvapps", "source-id": "fvapps_001928", "source-notes": "", "vc-description": "/-\nYou are given a non-empty string s consisting of lowercase English letters. You have to pick exactly one non-empty substring of s and shift all its letters 'z' $\\rightarrow$ 'y' $\\rightarrow$ 'x' $\\rightarrow \\ldots \\rightarrow$ 'b' $\\rightarrow$ 'a' $\\rightarrow$ 'z'. In other words, each character is replaced with the previous character of English alphabet and 'a' is replaced with 'z'.\n\nWhat is the lexicographically minimum string that can be obtained from s by performing this shift exactly once?\n\n-----Input-----\n\nThe only line of the input contains the string s (1 ≤ |s| ≤ 100 000) consisting of lowercase English letters.\n\n-----Output-----\n\nPrint the lexicographically minimum string that can be obtained from s by shifting letters of exactly one non-empty substring.\n\n-----Examples-----\nInput\ncodeforces\n\nOutput\nbncdenqbdr\n\nInput\nabacaba\n\nOutput\naaacaba\n\n-----Note-----\n\nString s is lexicographically smaller than some other string t of the same length if there exists some 1 ≤ i ≤ |s|, such that s_1 = t_1, s_2 = t_2, ..., s_{i} - 1 = t_{i} - 1, and s_{i} < t_{i}.\n-/", "vc-preamble": "def isLower (c : Char) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def get_min_string_after_shift (s : List Char) : List Char :=\n  sorry", "vc-theorems": "theorem output_length_matches_input\n  (s : List Char)\n  (h : ∀ c ∈ s, isLower c) :\n  (get_min_string_after_shift s).length = s.length :=\nsorry\n\ntheorem output_has_valid_chars\n  (s : List Char) \n  (h : ∀ c ∈ s, isLower c) :\n  ∀ c ∈ get_min_string_after_shift s, isLower c :=\nsorry\n\ntheorem output_changes_at_most_one_segment\n  (s : List Char)\n  (h : ∀ c ∈ s, isLower c) :\n  let result := get_min_string_after_shift s\n  let diff_positions := List.range s.length |>.filter (fun i => s.get! i ≠ result.get! i)\n  diff_positions.length > 0 →\n  (diff_positions.maximum?.getD 0) - (diff_positions.minimum?.getD 0) + 1 = diff_positions.length :=\nsorry\n\ntheorem all_a_string\n  (s : List Char)\n  (h : ∀ c ∈ s, c = 'a')\n  (h' : s.length > 0) :\n  get_min_string_after_shift s = (List.replicate (s.length - 1) 'a') ++ ['z'] :=\nsorry\n\ntheorem shifted_chars_decrease\n  (s : List Char)\n  (h : ∀ c ∈ s, isLower c) :\n  let result := get_min_string_after_shift s\n  let diff_positions := List.range s.length |>.filter (fun i => s.get! i ≠ result.get! i)\n  ∀ i ∈ diff_positions,\n    (s.get! i = 'a' → result.get! i = 'z') ∧\n    (s.get! i ≠ 'a' → (result.get! i).toNat = (s.get! i).toNat - 1) :=\nsorry\n\n/-\ninfo: 'bncdenqbdr'\n-/\n-- #guard_msgs in\n-- #eval get_min_string_after_shift \"codeforces\"\n\n/-\ninfo: 'aaacaba'\n-/\n-- #guard_msgs in\n-- #eval get_min_string_after_shift \"abacaba\"\n\n/-\ninfo: 'z'\n-/\n-- #guard_msgs in\n-- #eval get_min_string_after_shift \"a\"", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1930", "language": "lean", "source": "fvapps", "source-id": "fvapps_001930", "source-notes": "", "vc-description": "/-\nGennady is one of the best child dentists in Berland. Today n children got an appointment with him, they lined up in front of his office.\n\nAll children love to cry loudly at the reception at the dentist. We enumerate the children with integers from 1 to n in the order they go in the line. Every child is associated with the value of his cofidence p_{i}. The children take turns one after another to come into the office; each time the child that is the first in the line goes to the doctor.\n\nWhile Gennady treats the teeth of the i-th child, the child is crying with the volume of v_{i}. At that the confidence of the first child in the line is reduced by the amount of v_{i}, the second one — by value v_{i} - 1, and so on. The children in the queue after the v_{i}-th child almost do not hear the crying, so their confidence remains unchanged.\n\nIf at any point in time the confidence of the j-th child is less than zero, he begins to cry with the volume of d_{j} and leaves the line, running towards the exit, without going to the doctor's office. At this the confidence of all the children after the j-th one in the line is reduced by the amount of d_{j}.\n\nAll these events occur immediately one after the other in some order. Some cries may lead to other cries, causing a chain reaction. Once in the hallway it is quiet, the child, who is first in the line, goes into the doctor's office.\n\nHelp Gennady the Dentist to determine the numbers of kids, whose teeth he will cure. Print their numbers in the chronological order.\n\n-----Input-----\n\nThe first line of the input contains a positive integer n (1 ≤ n ≤ 4000) — the number of kids in the line. \n\nNext n lines contain three integers each v_{i}, d_{i}, p_{i} (1 ≤ v_{i}, d_{i}, p_{i} ≤ 10^6) — the volume of the cry in the doctor's office, the volume of the cry in the hall and the confidence of the i-th child.\n\n-----Output-----\n\nIn the first line print number k — the number of children whose teeth Gennady will cure.\n\nIn the second line print k integers — the numbers of the children who will make it to the end of the line in the increasing order.\n\n-----Examples-----\nInput\n5\n4 2 2\n4 1 2\n5 2 4\n3 3 5\n5 1 2\n\nOutput\n2\n1 3 \nInput\n5\n4 5 1\n5 3 9\n4 1 2\n2 1 8\n4 1 9\n\nOutput\n4\n1 2 4 5 \n\n-----Note-----\n\nIn the first example, Gennady first treats the teeth of the first child who will cry with volume 4. The confidences of the remaining children will get equal to  - 2, 1, 3, 1, respectively. Thus, the second child also cries at the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 0, 2, 0. Then the third child will go to the office, and cry with volume 5. The other children won't bear this, and with a loud cry they will run to the exit.\n\nIn the second sample, first the first child goes into the office, he will cry with volume 4. The confidence of the remaining children will be equal to 5,  - 1, 6, 8. Thus, the third child will cry with the volume of 1 and run to the exit. The confidence of the remaining children will be equal to 5, 5, 7. After that, the second child goes to the office and cry with the volume of 5. The confidences of the remaining children will be equal to 0, 3. Then the fourth child will go into the office and cry with the volume of 2. Because of this the confidence of the fifth child will be 1, and he will go into the office last.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_dentist (n : Nat) (kids : List (List Nat)) : List Nat :=\n  sorry", "vc-theorems": "theorem solve_dentist_result_valid (n : Nat) (kids : List (List Nat)) \n    (h1 : n > 0) (h2 : ∀ k ∈ kids, k.length = 3) : \n    let result := solve_dentist n kids\n    ∀ x ∈ result, 1 ≤ x ∧ x ≤ n :=\nsorry\n\ntheorem solve_dentist_result_increasing (n : Nat) (kids : List (List Nat))\n    (h1 : n > 0) (h2 : ∀ k ∈ kids, k.length = 3) :\n    let result := solve_dentist n kids\n    ∀ (a b : Nat), a ∈ result → b ∈ result → \n      result.indexOf a < result.indexOf b → a < b :=\nsorry\n\ntheorem solve_dentist_result_unique (n : Nat) (kids : List (List Nat))\n    (h1 : n > 0) (h2 : ∀ k ∈ kids, k.length = 3) :\n    let result := solve_dentist n kids\n    ∀ (x y : Nat), x ∈ result → y ∈ result → x = y → x = y :=\nsorry\n\ntheorem solve_dentist_preserves_input (n : Nat) (kids : List (List Nat))\n    (h1 : n > 0) (h2 : ∀ k ∈ kids, k.length = 3) :\n    let orig := kids\n    let _ := solve_dentist n kids\n    kids = orig :=\nsorry\n\ntheorem solve_dentist_single_kid :\n    solve_dentist 1 [[1, 1, 10]] = [1] :=\nsorry\n\ntheorem solve_dentist_zero_patience (kids : List (List Nat))\n    (h1 : ∀ k ∈ kids, k.length = 3)\n    (h2 : ∀ k ∈ kids, k.getD 2 0 = 0) :\n    let n := kids.length\n    (solve_dentist n kids).length = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1931", "language": "lean", "source": "fvapps", "source-id": "fvapps_001931", "source-notes": "", "vc-description": "/-\nAlex decided to go on a touristic trip over the country.\n\nFor simplicity let's assume that the country has $n$ cities and $m$ bidirectional roads connecting them. Alex lives in city $s$ and initially located in it. To compare different cities Alex assigned each city a score $w_i$ which is as high as interesting city seems to Alex.\n\nAlex believes that his trip will be interesting only if he will not use any road twice in a row. That is if Alex came to city $v$ from city $u$, he may choose as the next city in the trip any city connected with $v$ by the road, except for the city $u$.\n\nYour task is to help Alex plan his city in a way that maximizes total score over all cities he visited. Note that for each city its score is counted at most once, even if Alex been there several times during his trip.\n\n-----Input-----\n\nFirst line of input contains two integers $n$ and $m$, ($1 \\le n \\le 2 \\cdot 10^5$, $0 \\le m \\le 2 \\cdot 10^5$) which are numbers of cities and roads in the country.\n\nSecond line contains $n$ integers $w_1, w_2, \\ldots, w_n$ ($0 \\le w_i \\le 10^9$) which are scores of all cities.\n\nThe following $m$ lines contain description of the roads. Each of these $m$ lines contains two integers $u$ and $v$ ($1 \\le u, v \\le n$) which are cities connected by this road.\n\nIt is guaranteed that there is at most one direct road between any two cities, no city is connected to itself by the road and, finally, it is possible to go from any city to any other one using only roads.\n\nThe last line contains single integer $s$ ($1 \\le s \\le n$), which is the number of the initial city.\n\n-----Output-----\n\nOutput single integer which is the maximum possible sum of scores of visited cities.\n\n-----Examples-----\nInput\n5 7\n2 2 8 6 9\n1 2\n1 3\n2 4\n3 2\n4 5\n2 5\n1 5\n2\n\nOutput\n27\n\nInput\n10 12\n1 7 1 9 3 3 6 30 1 10\n1 2\n1 3\n3 5\n5 7\n2 3\n5 4\n6 9\n4 6\n3 7\n6 8\n9 4\n9 10\n6\n\nOutput\n61\n-/", "vc-preamble": "def List.sum [Add α] : List α → α \n  | [] => sorry\n  | (x::xs) => x + List.sum xs", "vc-helpers": "", "vc-definitions": "def max_city_score (n : Nat) (m : Nat) (weights : List Nat) (roads : List (Nat × Nat)) (start : Nat) : Nat :=\nsorry", "vc-theorems": "theorem max_city_score_lower_bound (n : Nat) (weights : List Nat) (start : Nat)\n  (h1 : n > 0)\n  (h2 : weights.length = n) \n  (h3 : start > 0)\n  (h4 : start ≤ n) :\n  let roads := List.range (n-1) |>.map (λ i => (i+1, i+2))\n  let result := max_city_score n (n-1) weights roads start\n  result ≥ weights[start-1] := sorry\n\ntheorem max_city_score_upper_bound (n : Nat) (weights : List Nat) (start : Nat)\n  (h1 : n > 0)\n  (h2 : weights.length = n)\n  (h3 : start > 0)\n  (h4 : start ≤ n) :\n  let roads := List.range (n-1) |>.map (λ i => (i+1, i+2))\n  let result := max_city_score n (n-1) weights roads start\n  result ≤ List.sum weights := sorry\n\ntheorem single_city_case (weight : Nat) :\n  max_city_score 1 0 [weight] [] 1 = weight := sorry\n\ntheorem line_graph_path_sum (n : Nat) (weights : List Nat) (start : Nat)\n  (h1 : n ≥ 2)\n  (h2 : weights.length = n)\n  (h3 : start > 0)\n  (h4 : start ≤ n) :\n  let roads := List.range (n-1) |>.map (λ i => (i+1, i+2))\n  let result := max_city_score n (n-1) weights roads start\n  let path_sum := List.sum (List.drop (start-1) weights)\n  result ≥ path_sum := sorry\n\n/-\ninfo: 27\n-/\n-- #guard_msgs in\n-- #eval max_city_score 5 7 [2, 2, 8, 6, 9] [(1, 2), (1, 3), (2, 4), (3, 2), (4, 5), (2, 5), (1, 5)] 2\n\n/-\ninfo: 61\n-/\n-- #guard_msgs in\n-- #eval max_city_score 10 12 [1, 7, 1, 9, 3, 3, 6, 30, 1, 10] [(1, 2), (1, 3), (3, 5), (5, 7), (2, 3), (5, 4), (6, 9), (4, 6), (3, 7), (6, 8), (9, 4), (9, 10)] 6\n\n/-\ninfo: 1000000000\n-/\n-- #guard_msgs in\n-- #eval max_city_score 1 0 [1000000000] [] 1", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1932", "language": "lean", "source": "fvapps", "source-id": "fvapps_001932", "source-notes": "", "vc-description": "/-\nAllen is hosting a formal dinner party. $2n$ people come to the event in $n$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $2n$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.\n\nHelp Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 100$), the number of pairs of people.\n\nThe second line contains $2n$ integers $a_1, a_2, \\dots, a_{2n}$. For each $i$ with $1 \\le i \\le n$, $i$ appears exactly twice. If $a_j = a_k = i$, that means that the $j$-th and $k$-th people in the line form a couple.\n\n-----Output-----\n\nOutput a single integer, representing the minimum number of adjacent swaps needed to line the people up so that each pair occupies adjacent positions.\n\n-----Examples-----\nInput\n4\n1 1 2 3 3 2 4 4\n\nOutput\n2\n\nInput\n3\n1 1 2 2 3 3\n\nOutput\n0\n\nInput\n3\n3 1 2 3 1 2\n\nOutput\n3\n\n-----Note-----\n\nIn the first sample case, we can transform $1 1 2 3 3 2 4 4 \\rightarrow 1 1 2 3 2 3 4 4 \\rightarrow 1 1 2 2 3 3 4 4$ in two steps. Note that the sequence $1 1 2 3 3 2 4 4 \\rightarrow 1 1 3 2 3 2 4 4 \\rightarrow 1 1 3 3 2 2 4 4$ also works in the same number of steps.\n\nThe second sample case already satisfies the constraints; therefore we need $0$ swaps.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_adjacent_swaps (n : Nat) (pairs : List Nat) : Nat := sorry\n\ndef is_valid_pairs (n : Nat) (pairs : List Nat) : Bool := sorry", "vc-theorems": "theorem identity_case_requires_zero_swaps (n : Nat) (pairs : List Nat) :\n  n > 0 →\n  pairs = (List.join (List.map (fun i => [i, i]) (List.range n))) →\n  min_adjacent_swaps n pairs = 0 := sorry\n\ntheorem worst_case_upper_bound (n : Nat) :\n  n > 0 →\n  let pairs := List.append (List.range n) (List.range n)\n  min_adjacent_swaps n pairs ≤ n * (n-1) / 2 := sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval min_adjacent_swaps 4 [1, 1, 2, 3, 3, 2, 4, 4]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval min_adjacent_swaps 3 [1, 1, 2, 2, 3, 3]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval min_adjacent_swaps 3 [3, 1, 2, 3, 1, 2]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1936", "language": "lean", "source": "fvapps", "source-id": "fvapps_001936", "source-notes": "", "vc-description": "/-\nRecently, Pari and Arya did some research about NP-Hard problems and they found the minimum vertex cover problem very interesting.\n\nSuppose the graph G is given. Subset A of its vertices is called a vertex cover of this graph, if for each edge uv there is at least one endpoint of it in this set, i.e. $u \\in A$ or $v \\in A$ (or both).\n\nPari and Arya have won a great undirected graph as an award in a team contest. Now they have to split it in two parts, but both of them want their parts of the graph to be a vertex cover.\n\nThey have agreed to give you their graph and you need to find two disjoint subsets of its vertices A and B, such that both A and B are vertex cover or claim it's impossible. Each vertex should be given to no more than one of the friends (or you can even keep it for yourself).\n\n-----Input-----\n\nThe first line of the input contains two integers n and m (2 ≤ n ≤ 100 000, 1 ≤ m ≤ 100 000) — the number of vertices and the number of edges in the prize graph, respectively.\n\nEach of the next m lines contains a pair of integers u_{i} and v_{i} (1  ≤  u_{i},  v_{i}  ≤  n), denoting an undirected edge between u_{i} and v_{i}. It's guaranteed the graph won't contain any self-loops or multiple edges.\n\n-----Output-----\n\nIf it's impossible to split the graph between Pari and Arya as they expect, print \"-1\" (without quotes).\n\nIf there are two disjoint sets of vertices, such that both sets are vertex cover, print their descriptions. Each description must contain two lines. The first line contains a single integer k denoting the number of vertices in that vertex cover, and the second line contains k integers — the indices of vertices. Note that because of m ≥ 1, vertex cover cannot be empty.\n\n-----Examples-----\nInput\n4 2\n1 2\n2 3\n\nOutput\n1\n2 \n2\n1 3 \n\nInput\n3 3\n1 2\n2 3\n1 3\n\nOutput\n-1\n\n-----Note-----\n\nIn the first sample, you can give the vertex number 2 to Arya and vertices numbered 1 and 3 to Pari and keep vertex number 4 for yourself (or give it someone, if you wish).\n\nIn the second sample, there is no way to satisfy both Pari and Arya.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_vertex_covers (n m : Nat) (edges : List (Nat × Nat)) : Option VertexCover := \n  sorry", "vc-theorems": "theorem vertex_cover_len_matches_set {n m : Nat} {edges : List (Nat × Nat)} \n  {vc : VertexCover} :\n  find_vertex_covers n m edges = some vc →\n  vc.len1 = vc.set1.length ∧ vc.len2 = vc.set2.length := sorry\n\ntheorem vertex_cover_valid_range {n m : Nat} {edges : List (Nat × Nat)}\n  {vc : VertexCover} :\n  find_vertex_covers n m edges = some vc →\n  (∀ v ∈ vc.set1, 1 ≤ v ∧ v ≤ n) ∧\n  (∀ v ∈ vc.set2, 1 ≤ v ∧ v ≤ n) := sorry\n\ntheorem vertex_cover_disjoint {n m : Nat} {edges : List (Nat × Nat)}\n  {vc : VertexCover} :\n  find_vertex_covers n m edges = some vc →\n  ∀ v, ¬(v ∈ vc.set1 ∧ v ∈ vc.set2) := sorry\n\ntheorem vertex_cover_edges_covered {n m : Nat} {edges : List (Nat × Nat)}\n  {vc : VertexCover} :\n  find_vertex_covers n m edges = some vc →\n  ∀ (u v : Nat), (u, v) ∈ edges →\n  u ∈ vc.set1 ∨ v ∈ vc.set1 ∨ u ∈ vc.set2 ∨ v ∈ vc.set2 := sorry\n\ntheorem vertex_cover_no_internal_edges {n m : Nat} {edges : List (Nat × Nat)}\n  {vc : VertexCover} :\n  find_vertex_covers n m edges = some vc →\n  (∀ u v, u ∈ vc.set1 → v ∈ vc.set1 → (u, v) ∉ edges ∧ (v, u) ∉ edges) ∧\n  (∀ u v, u ∈ vc.set2 → v ∈ vc.set2 → (u, v) ∉ edges ∧ (v, u) ∉ edges) := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1937", "language": "lean", "source": "fvapps", "source-id": "fvapps_001937", "source-notes": "", "vc-description": "/-\nStudents went into a class to write a test and sat in some way. The teacher thought: \"Probably they sat in this order to copy works of each other. I need to rearrange them in such a way that students that were neighbors are not neighbors in a new seating.\"\n\nThe class can be represented as a matrix with n rows and m columns with a student in each cell. Two students are neighbors if cells in which they sit have a common side.\n\nLet's enumerate students from 1 to n·m in order of rows. So a student who initially sits in the cell in row i and column j has a number (i - 1)·m + j. You have to find a matrix with n rows and m columns in which all numbers from 1 to n·m appear exactly once and adjacent numbers in the original matrix are not adjacent in it, or determine that there is no such matrix.\n\n-----Input-----\n\nThe only line contains two integers n and m (1 ≤ n, m ≤ 10^5; n·m ≤ 10^5) — the number of rows and the number of columns in the required matrix.\n\n-----Output-----\n\nIf there is no such matrix, output \"NO\" (without quotes). \n\nOtherwise in the first line output \"YES\" (without quotes), and in the next n lines output m integers which form the required matrix.\n\n-----Examples-----\nInput\n2 4\n\nOutput\nYES\n5 4 7 2 \n3 6 1 8 \n\nInput\n2 1\n\nOutput\nNO\n\n-----Note-----\n\nIn the first test case the matrix initially looks like this:\n\n1 2 3 4\n\n5 6 7 8\n\nIt's easy to see that there are no two students that are adjacent in both matrices.\n\nIn the second test case there are only two possible seatings and in both of them students with numbers 1 and 2 are neighbors.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def rearrange_students (n m : Nat) : String := sorry\n\n/- All results of rearrange_students must be a String -/", "vc-theorems": "theorem rearrange_students_returns_string (n m : Nat) :\n  ∃ result, rearrange_students n m = result := by sorry\n\n/- The result must start with \"YES\\n\" or be equal to \"NO\" -/\n\ntheorem rearrange_students_valid_prefix (n m : Nat) :\n  let result := rearrange_students n m\n  (result.startsWith \"YES\\n\") ∨ result = \"NO\" := by sorry\n\n/- If the result is \"NO\", it's a valid arrangement -/\n\ntheorem rearrange_students_no_valid (n m : Nat) :\n  rearrange_students n m = \"NO\" → True := by sorry\n\n/- If result starts with \"YES\", the grid must contain all numbers from 1 to n*m exactly once -/\n\ntheorem rearrange_students_yes_valid (n m : Nat) (result : String) :\n  result = rearrange_students n m →\n  result.startsWith \"YES\\n\" →\n  ∃ grid : List (List Nat),\n    let allNums := List.join grid\n    List.length allNums = n * m ∧\n    (∀ x ∈ allNums, x ≥ 1 ∧ x ≤ n * m) ∧\n    (∀ x ∈ allNums, ∀ y ∈ allNums, x = y → allNums.indexOf x = allNums.indexOf y) := by sorry\n\n/- Specific test cases must produce valid arrangements -/\n\ntheorem rearrange_students_specific_cases :\n  let cases := [(1,1), (2,1), (3,3), (2,4)]\n  ∀ (pair : Nat × Nat), List.elem pair cases →\n  let n := pair.1\n  let m := pair.2\n  (rearrange_students n m = \"NO\") ∨\n  (rearrange_students n m).startsWith \"YES\\n\" := by sorry\n\n/-\ninfo: 'YES\\n5 4 7 2\\n3 6 1 8'\n-/\n-- #guard_msgs in\n-- #eval rearrange_students 2 4\n\n/-\ninfo: 'NO'\n-/\n-- #guard_msgs in\n-- #eval rearrange_students 2 1\n\n/-\ninfo: 'YES\\n1'\n-/\n-- #guard_msgs in\n-- #eval rearrange_students 1 1", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1942", "language": "lean", "source": "fvapps", "source-id": "fvapps_001942", "source-notes": "", "vc-description": "/-\nSquirrel Liss lived in a forest peacefully, but unexpected trouble happens. Stones fall from a mountain. Initially Squirrel Liss occupies an interval [0, 1]. Next, n stones will fall and Liss will escape from the stones. The stones are numbered from 1 to n in order.\n\nThe stones always fall to the center of Liss's interval. When Liss occupies the interval [k - d, k + d] and a stone falls to k, she will escape to the left or to the right. If she escapes to the left, her new interval will be [k - d, k]. If she escapes to the right, her new interval will be [k, k + d].\n\nYou are given a string s of length n. If the i-th character of s is \"l\" or \"r\", when the i-th stone falls Liss will escape to the left or to the right, respectively. Find the sequence of stones' numbers from left to right after all the n stones falls.\n\n-----Input-----\n\nThe input consists of only one line. The only line contains the string s (1 ≤ |s| ≤ 10^6). Each character in s will be either \"l\" or \"r\".\n\n-----Output-----\n\nOutput n lines — on the i-th line you should print the i-th stone's number from the left.\n\n-----Examples-----\nInput\nllrlr\n\nOutput\n3\n5\n4\n2\n1\n\nInput\nrrlll\n\nOutput\n1\n2\n5\n4\n3\n\nInput\nlrlrr\n\nOutput\n2\n4\n5\n3\n1\n\n-----Note-----\n\nIn the first example, the positions of stones 1, 2, 3, 4, 5 will be $\\frac{1}{2}, \\frac{1}{4}, \\frac{1}{8}, \\frac{3}{16}, \\frac{5}{32}$, respectively. So you should print the sequence: 3, 5, 4, 2, 1.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_stone_positions (s : String) : List Nat := sorry\n\ntheorem stone_positions_length \n  (s : String) \n  (h : s.all (fun c => c = 'l' ∨ c = 'r')) \n  (h2 : s.length > 0) : \n  (get_stone_positions s).length = s.length := sorry", "vc-theorems": "theorem stone_positions_values_sorted \n  (s : String)\n  (h : s.all (fun c => c = 'l' ∨ c = 'r'))\n  (h2 : s.length > 0) :\n  ∃ perm : List Nat, \n    get_stone_positions s = perm ∧ \n    List.range' 1 s.length = perm.reverse.reverse := sorry\n\ntheorem right_stones_come_first\n  (s : String)\n  (h : s.all (fun c => c = 'l' ∨ c = 'r'))\n  (h2 : s.length > 0) :\n  let right_pos := List.range s.length |>.map (fun i => i + 1) \n                   |>.filter (fun i => s.data.get! (i-1) = 'r')\n  let get_index (xs : List Nat) (x : Nat) := \n    match xs.indexOf? x with\n    | some idx => idx\n    | none => 0\n  let right_idx := right_pos.map (fun p => get_index (get_stone_positions s) p)\n  right_pos ≠ [] →\n  (∀ i j, i < j → i ∈ right_idx → j ∈ right_idx → right_idx[i]! ≤ right_idx[j]!) ∧\n  (∀ i ∈ right_idx, i < s.length - (s.data.filter (·='l')).length) := sorry\n\ntheorem left_stones_come_last_reverse\n  (s : String)\n  (h : s.all (fun c => c = 'l' ∨ c = 'r'))\n  (h2 : s.length > 0) :\n  let left_pos := List.range s.length |>.map (fun i => i + 1)\n                  |>.filter (fun i => s.data.get! (i-1) = 'l')\n  let get_index (xs : List Nat) (x : Nat) := \n    match xs.indexOf? x with\n    | some idx => idx\n    | none => 0\n  let left_idx := left_pos.map (fun p => get_index (get_stone_positions s) p)\n  left_pos ≠ [] →\n  ∀ i j, i < j → i ∈ left_idx → j ∈ left_idx → left_idx[i]! ≥ left_idx[j]! := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1946", "language": "lean", "source": "fvapps", "source-id": "fvapps_001946", "source-notes": "", "vc-description": "/-\nDreamoon likes coloring cells very much.\n\nThere is a row of $n$ cells. Initially, all cells are empty (don't contain any color). Cells are numbered from $1$ to $n$.\n\nYou are given an integer $m$ and $m$ integers $l_1, l_2, \\ldots, l_m$ ($1 \\le l_i \\le n$)\n\nDreamoon will perform $m$ operations.\n\nIn $i$-th operation, Dreamoon will choose a number $p_i$ from range $[1, n-l_i+1]$ (inclusive) and will paint all cells from $p_i$ to $p_i+l_i-1$ (inclusive) in $i$-th color. Note that cells may be colored more one than once, in this case, cell will have the color from the latest operation.\n\nDreamoon hopes that after these $m$ operations, all colors will appear at least once and all cells will be colored. Please help Dreamoon to choose $p_i$ in each operation to satisfy all constraints.\n\n-----Input-----\n\nThe first line contains two integers $n,m$ ($1 \\leq m \\leq n \\leq 100\\,000$).\n\nThe second line contains $m$ integers $l_1, l_2, \\ldots, l_m$ ($1 \\leq l_i \\leq n$).\n\n-----Output-----\n\nIf it's impossible to perform $m$ operations to satisfy all constraints, print \"'-1\" (without quotes).\n\nOtherwise, print $m$ integers $p_1, p_2, \\ldots, p_m$ ($1 \\leq p_i \\leq n - l_i + 1$), after these $m$ operations, all colors should appear at least once and all cells should be colored.\n\nIf there are several possible solutions, you can print any.\n\n-----Examples-----\nInput\n5 3\n3 2 2\n\nOutput\n2 4 1\n\nInput\n10 1\n1\n\nOutput\n-1\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + xs.sum", "vc-helpers": "", "vc-definitions": "def solve_coloring (n : Nat) (m : Nat) (lengths : List Nat) : Option (List Nat) := sorry\n\ntheorem impossible_cases_sum_too_small {n m : Nat} {lengths : List Nat} \n  (h₁ : m > 0)\n  (h₂ : n > 0) \n  (h₃ : lengths.length = m)\n  (h₄ : lengths.sum < n) :\n  solve_coloring n m lengths = none := sorry", "vc-theorems": "theorem impossible_cases_lengths_too_long {n m : Nat} {lengths : List Nat}\n  (h₁ : m > 0)\n  (h₂ : n > 0)\n  (h₃ : lengths.length = m)\n  (h₄ : ∀ l ∈ lengths, l > n) :\n  solve_coloring n m lengths = none := sorry\n\ntheorem solution_basic_properties {n m : Nat} {lengths : List Nat} {result : List Nat}\n  (h₁ : m > 0)\n  (h₂ : n > 0)\n  (h₃ : lengths.length = m)\n  (h₄ : solve_coloring n m lengths = some result) :\n  result.length = m ∧ \n  (∀ x ∈ result, x > 0 ∧ x ≤ n) ∧\n  (∀ i < result.length - 1, result[i]! < result[i+1]!) := sorry\n\n/-\ninfo: [1, 2, 4]\n-/\n-- #guard_msgs in\n-- #eval solve_coloring 5 3 [3, 2, 2]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval solve_coloring 10 1 [1]\n\n/-\ninfo: [1]\n-/\n-- #guard_msgs in\n-- #eval solve_coloring 1 1 [1]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1951", "language": "lean", "source": "fvapps", "source-id": "fvapps_001951", "source-notes": "", "vc-description": "/-\nYou work in a big office. It is a 9 floor building with an elevator that can accommodate up to 4 people. It is your responsibility to manage this elevator.\n\nToday you are late, so there are queues on some floors already. For each person you know the floor where he currently is and the floor he wants to reach. Also, you know the order in which people came to the elevator.\n\nAccording to the company's rules, if an employee comes to the elevator earlier than another one, he has to enter the elevator earlier too (even if these employees stay on different floors). Note that the employees are allowed to leave the elevator in arbitrary order.\n\nThe elevator has two commands:   Go up or down one floor. The movement takes 1 second.  Open the doors on the current floor. During this operation all the employees who have reached their destination get out of the elevator. Then all the employees on the floor get in the elevator in the order they are queued up while it doesn't contradict the company's rules and there is enough space in the elevator. Each employee spends 1 second to get inside and outside the elevator. \n\nInitially the elevator is empty and is located on the floor 1.\n\nYou are interested what is the minimum possible time you need to spend to deliver all the employees to their destination. It is not necessary to return the elevator to the floor 1.\n\n-----Input-----\n\nThe first line contains an integer n (1 ≤ n ≤ 2000) — the number of employees.\n\nThe i-th of the next n lines contains two integers a_{i} and b_{i} (1 ≤ a_{i}, b_{i} ≤ 9, a_{i} ≠ b_{i}) — the floor on which an employee initially is, and the floor he wants to reach.\n\nThe employees are given in the order they came to the elevator.\n\n-----Output-----\n\nPrint a single integer — the minimal possible time in seconds.\n\n-----Examples-----\nInput\n2\n3 5\n5 3\n\nOutput\n10\nInput\n2\n5 3\n3 5\n\nOutput\n12\n\n-----Note-----\n\n Explaination for the first sample [Image] t = 0\n\n[Image] t = 2\n\n[Image] t = 3\n\n[Image] t = 5\n\n[Image] t = 6\n\n[Image] t = 7\n\n[Image] t = 9\n\n[Image] t = 10\n-/", "vc-preamble": "def List.maximum (l : List Nat) : Option Nat := \n  sorry \n\ndef List.minimum (l : List Nat) : Option Nat := \n  sorry\n\ndef time_to_get_free (payload : List Nat) (floor : Nat) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def State.hook (s : State) (floor : Nat) (a b : Nat) : State :=\n  sorry \n\n-- Empty payload should take 0 time", "vc-theorems": "theorem time_to_get_free_empty (floor : Nat) : \n  time_to_get_free [] floor = 0 := sorry\n\n-- Properties of time_to_get_free\n\ntheorem time_to_get_free_properties {payload : List Nat} {floor : Nat}\n  (h1 : payload.length > 0)\n  (h2 : ∀ x ∈ payload, x > 0 ∧ x ≤ 10) :\n  let result := time_to_get_free payload floor\n  -- Result is non-negative\n  (result ≥ 0) ∧ \n  -- Result is at least difference of max/min payload\n  (result ≥ ((List.maximum payload).getD 0 - (List.minimum payload).getD 0)) ∧\n  -- Result is at least minimum distance to floor\n  (result ≥ min (floor - (List.minimum payload).getD 0) \n              (floor - (List.maximum payload).getD 0)) := sorry\n\n-- Properties of State.hook\n\ntheorem state_hook_properties {s : State} {floor a b : Nat}\n  (h1 : a > 0 ∧ a ≤ 10)\n  (h2 : b > 0 ∧ b ≤ 10) :\n  let newState := s.hook floor a b\n  -- Time is non-negative\n  (newState.time ≥ 0) ∧\n  -- b is in new payload\n  (b ∈ newState.payload) ∧\n  -- New payload size is bounded\n  (newState.payload.length ≤ s.payload.length + 1) := sorry\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval solve 2 [(3, 5), (5, 3)]\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval solve 2 [(5, 3), (3, 5)]\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval solve 1 [(1, 9)]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1954", "language": "lean", "source": "fvapps", "source-id": "fvapps_001954", "source-notes": "", "vc-description": "/-\nIgor the analyst has adopted n little bunnies. As we all know, bunnies love carrots. Thus, Igor has bought a carrot to be shared between his bunnies. Igor wants to treat all the bunnies equally, and thus he wants to cut the carrot into n pieces of equal area. \n\nFormally, the carrot can be viewed as an isosceles triangle with base length equal to 1 and height equal to h. Igor wants to make n - 1 cuts parallel to the base to cut the carrot into n pieces. He wants to make sure that all n pieces have the same area. Can you help Igor determine where to cut the carrot so that each piece have equal area?\n\n [Image] Illustration to the first example. \n\n-----Input-----\n\nThe first and only line of input contains two space-separated integers, n and h (2 ≤ n ≤ 1000, 1 ≤ h ≤ 10^5).\n\n-----Output-----\n\nThe output should contain n - 1 real numbers x_1, x_2, ..., x_{n} - 1. The number x_{i} denotes that the i-th cut must be made x_{i} units away from the apex of the carrot. In addition, 0 < x_1 < x_2 < ... < x_{n} - 1 < h must hold. \n\nYour output will be considered correct if absolute or relative error of every number in your output doesn't exceed 10^{ - 6}.\n\nFormally, let your answer be a, and the jury's answer be b. Your answer is considered correct if $\\frac{|a - b|}{\\operatorname{max}(1, b)} \\leq 10^{-6}$.\n\n-----Examples-----\nInput\n3 2\n\nOutput\n1.154700538379 1.632993161855\n\nInput\n2 100000\n\nOutput\n70710.678118654752\n\n-----Note-----\n\nDefinition of isosceles triangle: https://en.wikipedia.org/wiki/Isosceles_triangle.\n-/", "vc-preamble": "def calculate_cuts (n: Nat) (h: Float) : Array Float := \n  sorry", "vc-helpers": "", "vc-definitions": "def calculateAreas (cuts: Array Float) (h: Float) : Array Float :=\n  sorry", "vc-theorems": "theorem calculate_cuts_length {n: Nat} {h: Float} \n  (h_n: n ≥ 2) (h_h: h > 0) :\n  (calculate_cuts n h).size = n - 1 := \n  sorry\n\ntheorem calculate_cuts_strictly_increasing {n: Nat} {h: Float}\n  (h_n: n ≥ 2) (h_h: h > 0) :\n  ∀ i: Fin ((calculate_cuts n h).size - 1),\n    (calculate_cuts n h)[i.val] < (calculate_cuts n h)[i.val + 1] :=\n  sorry\n\ntheorem calculate_cuts_bounds {n: Nat} {h: Float}\n  (h_n: n ≥ 2) (h_h: h > 0) :\n  ∀ i: Fin (calculate_cuts n h).size,\n    0 < (calculate_cuts n h)[i.val] ∧ (calculate_cuts n h)[i.val] < h :=\n  sorry\n\ntheorem calculate_cuts_equal_areas {n: Nat} {h: Float}\n  (h_n: n ≥ 2) (h_h: h > 0) :\n  let cuts := calculate_cuts n h\n  let areas := calculateAreas cuts h\n  let expectedArea := h * h / (2 * Float.ofNat n)\n  ∀ a ∈ areas, (a - expectedArea).abs < 1e-6 * expectedArea := \n  sorry\n\ntheorem calculate_cuts_minimum_n (h: Float) (h_h: h > 0) :\n  let cuts := calculate_cuts 2 h\n  have h_size : cuts.size = 1 := by apply calculate_cuts_length; exact Nat.le_refl 2; exact h_h\n  cuts.size = 1 ∧ ((cuts.get ⟨0, by simp [h_size]⟩) - h/Float.sqrt 2).abs < 1e-6 * (h/Float.sqrt 2) :=\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1958", "language": "lean", "source": "fvapps", "source-id": "fvapps_001958", "source-notes": "", "vc-description": "/-\nArkady needs your help again! This time he decided to build his own high-speed Internet exchange point. It should consist of n nodes connected with minimum possible number of wires into one network (a wire directly connects two nodes). Exactly k of the nodes should be exit-nodes, that means that each of them should be connected to exactly one other node of the network, while all other nodes should be connected to at least two nodes in order to increase the system stability.\n\nArkady wants to make the system as fast as possible, so he wants to minimize the maximum distance between two exit-nodes. The distance between two nodes is the number of wires a package needs to go through between those two nodes.\n\nHelp Arkady to find such a way to build the network that the distance between the two most distant exit-nodes is as small as possible.\n\n-----Input-----\n\nThe first line contains two integers n and k (3 ≤ n ≤ 2·10^5, 2 ≤ k ≤ n - 1) — the total number of nodes and the number of exit-nodes.\n\nNote that it is always possible to build at least one network with n nodes and k exit-nodes within the given constraints.\n\n-----Output-----\n\nIn the first line print the minimum possible distance between the two most distant exit-nodes. In each of the next n - 1 lines print two integers: the ids of the nodes connected by a wire. The description of each wire should be printed exactly once. You can print wires and wires' ends in arbitrary order. The nodes should be numbered from 1 to n. Exit-nodes can have any ids.\n\nIf there are multiple answers, print any of them.\n\n-----Examples-----\nInput\n3 2\n\nOutput\n2\n1 2\n2 3\n\nInput\n5 3\n\nOutput\n3\n1 2\n2 3\n3 4\n3 5\n\n-----Note-----\n\nIn the first example the only network is shown on the left picture.\n\nIn the second example one of optimal networks is shown on the right picture.\n\nExit-nodes are highlighted. [Image]\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_network (n k : Nat) : NetworkSolution :=\n  sorry", "vc-theorems": "theorem solve_network_valid (n k : Nat) (h1: n ≥ 2) (h2: k ≥ 1) (h3: k < n) :\n  let sol := solve_network n k\n  -- Network has valid size\n  (sol.connections.length = n - 1) ∧  \n  -- All nodes are in valid range\n  (∀ (u v : Nat), (u, v) ∈ sol.connections → u ≤ n ∧ v ≤ n) ∧\n  -- No duplicate connections\n  (∀ (u v : Nat), (u, v) ∈ sol.connections → (v, u) ∉ sol.connections) ∧\n  -- First node has k children\n  (sol.connections.filter (fun (p : Nat × Nat) => p.1 = 1)).length = k ∧\n  -- Other nodes have exactly one parent\n  (∀ v : Nat, v ≠ 1 → v ≤ n → \n    (sol.connections.filter (fun p => p.2 = v)).length = 1) :=\n  sorry\n\ntheorem solve_network_distance_positive (n k : Nat) (h1: n ≥ 2) (h2: k ≥ 1) (h3: k < n) :\n  (solve_network n k).min_dist > 0 :=\n  sorry\n\ntheorem solve_network_monotone_n (n k : Nat) (h1: n > k + 2) (h2: k ≥ 1) :\n  (solve_network n k).min_dist ≥ (solve_network (n-1) k).min_dist :=\n  sorry\n\ntheorem solve_network_monotone_k (n k : Nat) (h1: n ≥ 2) (h2: k > 1) (h3: k < n) :\n  (solve_network n k).min_dist ≤ (solve_network n (k-1)).min_dist :=\n  sorry\n\n/-\ninfo: n - 1\n-/\n-- #guard_msgs in\n-- #eval len conns\n\n/-\ninfo: n - 1\n-/\n-- #guard_msgs in\n-- #eval len conns\n\n/-\ninfo: n - 1\n-/\n-- #guard_msgs in\n-- #eval len conns", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1962", "language": "lean", "source": "fvapps", "source-id": "fvapps_001962", "source-notes": "", "vc-description": "/-\nWe all know the impressive story of Robin Hood. Robin Hood uses his archery skills and his wits to steal the money from rich, and return it to the poor.\n\nThere are n citizens in Kekoland, each person has c_{i} coins. Each day, Robin Hood will take exactly 1 coin from the richest person in the city and he will give it to the poorest person (poorest person right after taking richest's 1 coin). In case the choice is not unique, he will select one among them at random. Sadly, Robin Hood is old and want to retire in k days. He decided to spend these last days with helping poor people. \n\nAfter taking his money are taken by Robin Hood richest person may become poorest person as well, and it might even happen that Robin Hood will give his money back. For example if all people have same number of coins, then next day they will have same number of coins too. \n\nYour task is to find the difference between richest and poorest persons wealth after k days. Note that the choosing at random among richest and poorest doesn't affect the answer.\n\n-----Input-----\n\nThe first line of the input contains two integers n and k (1 ≤ n ≤ 500 000, 0 ≤ k ≤ 10^9) — the number of citizens in Kekoland and the number of days left till Robin Hood's retirement.\n\nThe second line contains n integers, the i-th of them is c_{i} (1 ≤ c_{i} ≤ 10^9) — initial wealth of the i-th person.\n\n-----Output-----\n\nPrint a single line containing the difference between richest and poorest peoples wealth.\n\n-----Examples-----\nInput\n4 1\n1 1 4 2\n\nOutput\n2\n\nInput\n3 1\n2 2 2\n\nOutput\n0\n\n-----Note-----\n\nLets look at how wealth changes through day in the first sample.  [1, 1, 4, 2]  [2, 1, 3, 2] or [1, 2, 3, 2] \n\nSo the answer is 3 - 1 = 2\n\nIn second sample wealth will remain the same for each person.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_robin_hood (n : Nat) (k : Nat) (coins : List Nat) : Nat :=\nsorry", "vc-theorems": "theorem solve_robin_hood_properties \n  {n : Nat} {k : Nat} {coins : List Nat} \n  (h1 : n ≥ 1) (h2 : n = coins.length) (h3 : ∀ x, x ∈ coins → x ≥ 1) :\n  let result := solve_robin_hood n k coins\n  (result ≥ 0) ∧ \n  (result ≤ coins.maximum?.getD 0 - coins.minimum?.getD 0) :=\nsorry\n\ntheorem equal_coins_gives_zero\n  {n : Nat} {k : Nat} {coins : List Nat}\n  (h1 : n ≥ 1) (h2 : n = coins.length) (h3 : ∀ x, x ∈ coins → x ≥ 1)\n  (h4 : ∀ x y, x ∈ coins → y ∈ coins → x = y) :\n  solve_robin_hood n k coins = 0 :=\nsorry\n\ntheorem zero_k_maintains_difference\n  {n : Nat} {coins : List Nat}\n  (h1 : n ≥ 2) (h2 : n = coins.length) (h3 : ∀ x, x ∈ coins → x ≥ 1) :\n  solve_robin_hood n 0 coins = coins.maximum?.getD 0 - coins.minimum?.getD 0 :=\nsorry\n\ntheorem larger_k_gives_smaller_difference\n  {n : Nat} {coins : List Nat}\n  (h1 : n ≥ 1) (h2 : n = coins.length) (h3 : ∀ x, x ∈ coins → x ≥ 1)\n  {k1 k2 : Nat} (h4 : k2 > k1) :\n  solve_robin_hood n k2 coins ≤ solve_robin_hood n k1 coins :=\nsorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve_robin_hood 4 1 [1, 1, 4, 2]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval solve_robin_hood 3 1 [2, 2, 2]\n\n/-\ninfo: 999999943\n-/\n-- #guard_msgs in\n-- #eval solve_robin_hood 4 42 [1, 1, 1, 1000000000]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1965", "language": "lean", "source": "fvapps", "source-id": "fvapps_001965", "source-notes": "", "vc-description": "/-\nGerald plays the following game. He has a checkered field of size n × n cells, where m various cells are banned. Before the game, he has to put a few chips on some border (but not corner) board cells. Then for n - 1 minutes, Gerald every minute moves each chip into an adjacent cell. He moves each chip from its original edge to the opposite edge. Gerald loses in this game in each of the three cases:  At least one of the chips at least once fell to the banned cell.  At least once two chips were on the same cell.  At least once two chips swapped in a minute (for example, if you stand two chips on two opposite border cells of a row with even length, this situation happens in the middle of the row). \n\nIn that case he loses and earns 0 points. When nothing like that happened, he wins and earns the number of points equal to the number of chips he managed to put on the board. Help Gerald earn the most points.\n\n-----Input-----\n\nThe first line contains two space-separated integers n and m (2 ≤ n ≤ 1000, 0 ≤ m ≤ 10^5) — the size of the field and the number of banned cells. Next m lines each contain two space-separated integers. Specifically, the i-th of these lines contains numbers x_{i} and y_{i} (1 ≤ x_{i}, y_{i} ≤ n) — the coordinates of the i-th banned cell. All given cells are distinct.\n\nConsider the field rows numbered from top to bottom from 1 to n, and the columns — from left to right from 1 to n.\n\n-----Output-----\n\nPrint a single integer — the maximum points Gerald can earn in this game.\n\n-----Examples-----\nInput\n3 1\n2 2\n\nOutput\n0\n\nInput\n3 0\n\nOutput\n1\n\nInput\n4 3\n3 1\n3 2\n3 3\n\nOutput\n1\n\n-----Note-----\n\nIn the first test the answer equals zero as we can't put chips into the corner cells.\n\nIn the second sample we can place one chip into either cell (1, 2), or cell (3, 2), or cell (2, 1), or cell (2, 3). We cannot place two chips.\n\nIn the third sample we can only place one chip into either cell (2, 1), or cell (2, 4).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_chip_game (n : Nat) (banned : List (Nat × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem empty_board_nonnegative (n : Nat) :\n  n ≥ 2 → solve_chip_game n [] ≥ 0 :=\n  sorry\n\ntheorem odd_board_has_middle (n : Nat) :\n  n ≥ 2 → n % 2 = 1 → solve_chip_game n [] ≥ 1 :=\n  sorry\n\ntheorem all_cells_banned (n : Nat) :\n  n ≥ 2 →\n  let banned := List.range n |>.bind (fun x => \n    List.range n |>.map (fun y => (x+1, y+1)))\n  solve_chip_game n banned = 0 :=\n  sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval solve_chip_game 3 [(2, 2)]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval solve_chip_game 3 []\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval solve_chip_game 4 [(3, 1), (3, 2), (3, 3)]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1966", "language": "lean", "source": "fvapps", "source-id": "fvapps_001966", "source-notes": "", "vc-description": "/-\n$n$ boys and $m$ girls came to the party. Each boy presented each girl some integer number of sweets (possibly zero). All boys are numbered with integers from $1$ to $n$ and all girls are numbered with integers from $1$ to $m$. For all $1 \\leq i \\leq n$ the minimal number of sweets, which $i$-th boy presented to some girl is equal to $b_i$ and for all $1 \\leq j \\leq m$ the maximal number of sweets, which $j$-th girl received from some boy is equal to $g_j$.\n\nMore formally, let $a_{i,j}$ be the number of sweets which the $i$-th boy give to the $j$-th girl. Then $b_i$ is equal exactly to the minimum among values $a_{i,1}, a_{i,2}, \\ldots, a_{i,m}$ and $g_j$ is equal exactly to the maximum among values $b_{1,j}, b_{2,j}, \\ldots, b_{n,j}$.\n\nYou are interested in the minimum total number of sweets that boys could present, so you need to minimize the sum of $a_{i,j}$ for all $(i,j)$ such that $1 \\leq i \\leq n$ and $1 \\leq j \\leq m$. You are given the numbers $b_1, \\ldots, b_n$ and $g_1, \\ldots, g_m$, determine this number. \n\n-----Input-----\n\nThe first line contains two integers $n$ and $m$, separated with space — the number of boys and girls, respectively ($2 \\leq n, m \\leq 100\\,000$). The second line contains $n$ integers $b_1, \\ldots, b_n$, separated by spaces — $b_i$ is equal to the minimal number of sweets, which $i$-th boy presented to some girl ($0 \\leq b_i \\leq 10^8$). The third line contains $m$ integers $g_1, \\ldots, g_m$, separated by spaces — $g_j$ is equal to the maximal number of sweets, which $j$-th girl received from some boy ($0 \\leq g_j \\leq 10^8$).\n\n-----Output-----\n\nIf the described situation is impossible, print $-1$. In another case, print the minimal total number of sweets, which boys could have presented and all conditions could have satisfied.\n\n-----Examples-----\nInput\n3 2\n1 2 1\n3 4\n\nOutput\n12\nInput\n2 2\n0 1\n1 0\n\nOutput\n-1\nInput\n2 3\n1 0\n1 1 2\n\nOutput\n4\n\n-----Note-----\n\nIn the first test, the minimal total number of sweets, which boys could have presented is equal to $12$. This can be possible, for example, if the first boy presented $1$ and $4$ sweets, the second boy presented $3$ and $2$ sweets and the third boy presented $1$ and $1$ sweets for the first and the second girl, respectively. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $12$.\n\nIn the second test, the boys couldn't have presented sweets in such way, that all statements satisfied.\n\nIn the third test, the minimal total number of sweets, which boys could have presented is equal to $4$. This can be possible, for example, if the first boy presented $1$, $1$, $2$ sweets for the first, second, third girl, respectively and the second boy didn't present sweets for each girl. It's easy to see, that all conditions are satisfied and the total number of sweets is equal to $4$.\n-/", "vc-preamble": "def List.maximum (l : List Nat) : Nat :=\n  sorry\n\ndef List.minimum (l : List Nat) : Nat :=\n  sorry\n\ndef List.sum (l : List Nat) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def min_sweets (n m : Nat) (b g : List Nat) : Int :=\n  sorry", "vc-theorems": "theorem invalid_inputs_return_negative_one (n m : Nat) (b g : List Nat)\n  (h1 : n > 0) (h2 : m > 0)\n  (h3 : b.length > 0) (h4 : g.length > 0) \n  (h5 : b.length ≤ 10) (h6 : g.length ≤ 10)\n  (h7 : ∀ x ∈ b, x ≤ 100) (h8 : ∀ x ∈ g, x ≤ 100)\n  (h9 : List.maximum b > List.minimum g) :\n  min_sweets n m b g = -1 :=\nsorry\n\ntheorem valid_inputs_result_nonnegative (n m g_len : Nat) (b g : List Nat)\n  (h1 : n > 0) (h2 : m > 0) (h3 : g_len > 0)\n  (h4 : n ≤ 10) (h5 : m ≤ 10) (h6 : g_len ≤ 10)\n  (h7 : b.length = n)\n  (h8 : g.length = g_len)\n  (h9 : ∀ x ∈ b, x ≤ 100) (h10 : ∀ x ∈ g, x ≤ 100)\n  (h11 : List.maximum b ≤ List.minimum g) :\n  min_sweets n m b g ≥ 0 :=\nsorry\n\ntheorem valid_inputs_result_exceeds_sum_girls (n m g_len : Nat) (b g : List Nat)\n  (h1 : n > 0) (h2 : m > 0) (h3 : g_len > 0)\n  (h4 : n ≤ 10) (h5 : m ≤ 10) (h6 : g_len ≤ 10)\n  (h7 : b.length = n)\n  (h8 : g.length = g_len)\n  (h9 : ∀ x ∈ b, x ≤ 100) (h10 : ∀ x ∈ g, x ≤ 100)\n  (h11 : List.maximum b ≤ List.minimum g) :\n  min_sweets n m b g ≥ List.sum g :=\nsorry\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval min_sweets 3 2 [1, 2, 1] [3, 4]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval min_sweets 2 2 [0, 1] [1, 0]\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval min_sweets 2 3 [1, 0] [1, 1, 2]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1976", "language": "lean", "source": "fvapps", "source-id": "fvapps_001976", "source-notes": "", "vc-description": "/-\n3R2 as DJ Mashiro - Happiness Breeze Ice - DJ Mashiro is dead or alive\n\nNEKO#ΦωΦ has just got a new maze game on her PC!\n\nThe game's main puzzle is a maze, in the forms of a $2 \\times n$ rectangle grid. NEKO's task is to lead a Nekomimi girl from cell $(1, 1)$ to the gate at $(2, n)$ and escape the maze. The girl can only move between cells sharing a common side.\n\nHowever, at some moments during the game, some cells may change their state: either from normal ground to lava (which forbids movement into that cell), or vice versa (which makes that cell passable again). Initially all cells are of the ground type.\n\nAfter hours of streaming, NEKO finally figured out there are only $q$ such moments: the $i$-th moment toggles the state of cell $(r_i, c_i)$ (either from ground to lava or vice versa).\n\nKnowing this, NEKO wonders, after each of the $q$ moments, whether it is still possible to move from cell $(1, 1)$ to cell $(2, n)$ without going through any lava cells.\n\nAlthough NEKO is a great streamer and gamer, she still can't get through quizzes and problems requiring large amount of Brain Power. Can you help her?\n\n-----Input-----\n\nThe first line contains integers $n$, $q$ ($2 \\le n \\le 10^5$, $1 \\le q \\le 10^5$).\n\nThe $i$-th of $q$ following lines contains two integers $r_i$, $c_i$ ($1 \\le r_i \\le 2$, $1 \\le c_i \\le n$), denoting the coordinates of the cell to be flipped at the $i$-th moment.\n\nIt is guaranteed that cells $(1, 1)$ and $(2, n)$ never appear in the query list.\n\n-----Output-----\n\nFor each moment, if it is possible to travel from cell $(1, 1)$ to cell $(2, n)$, print \"Yes\", otherwise print \"No\". There should be exactly $q$ answers, one after every update.\n\nYou can print the words in any case (either lowercase, uppercase or mixed).\n\n-----Example-----\nInput\n5 5\n2 3\n1 4\n2 4\n2 3\n1 4\n\nOutput\nYes\nNo\nNo\nNo\nYes\n\n-----Note-----\n\nWe'll crack down the example test here:  After the first query, the girl still able to reach the goal. One of the shortest path ways should be: $(1,1) \\to (1,2) \\to (1,3) \\to (1,4) \\to (1,5) \\to (2,5)$.  After the second query, it's impossible to move to the goal, since the farthest cell she could reach is $(1, 3)$.  After the fourth query, the $(2, 3)$ is not blocked, but now all the $4$-th column is blocked, so she still can't reach the goal.  After the fifth query, the column barrier has been lifted, thus she can go to the final goal again.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_maze (n: Nat) (queries: List Query) : List String := sorry\n\ntheorem solve_maze_output_length (n: Nat) (queries: List Query) \n  (h: ∀ q ∈ queries, q.col ≤ n ∧ q.row ≤ 2) :\n  queries ≠ [] → List.length (solve_maze n queries) = List.length queries := sorry", "vc-theorems": "theorem solve_maze_valid_responses (n: Nat) (queries: List Query) \n  (h: ∀ q ∈ queries, q.col ≤ n ∧ q.row ≤ 2) :\n  ∀ r ∈ solve_maze n queries, r = \"Yes\" ∨ r = \"No\" := sorry\n\ntheorem solve_maze_first_yes (n: Nat) (queries: List Query) \n  (h: ∀ q ∈ queries, q.col ≤ n ∧ q.row ≤ 2)\n  (h2: queries ≠ []) :\n  List.head! (solve_maze n queries) = \"Yes\" := sorry\n\ntheorem solve_maze_empty (n: Nat) :\n  solve_maze n [] = [] := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF1983", "language": "lean", "source": "fvapps", "source-id": "fvapps_001983", "source-notes": "", "vc-description": "/-\nEdo has got a collection of n refrigerator magnets!\n\nHe decided to buy a refrigerator and hang the magnets on the door. The shop can make the refrigerator with any size of the door that meets the following restrictions: the refrigerator door must be rectangle, and both the length and the width of the door must be positive integers.\n\nEdo figured out how he wants to place the magnets on the refrigerator. He introduced a system of coordinates on the plane, where each magnet is represented as a rectangle with sides parallel to the coordinate axes.\n\nNow he wants to remove no more than k magnets (he may choose to keep all of them) and attach all remaining magnets to the refrigerator door, and the area of ​​the door should be as small as possible. A magnet is considered to be attached to the refrigerator door if its center lies on the door or on its boundary. The relative positions of all the remaining magnets must correspond to the plan.\n\nLet us explain the last two sentences. Let's suppose we want to hang two magnets on the refrigerator. If the magnet in the plan has coordinates of the lower left corner (x_1, y_1) and the upper right corner (x_2, y_2), then its center is located at ($\\frac{x_{1} + x_{2}}{2}$, $\\frac{y_{1} + y_{2}}{2}$) (may not be integers). By saying the relative position should correspond to the plan we mean that the only available operation is translation, i.e. the vector connecting the centers of two magnets in the original plan, must be equal to the vector connecting the centers of these two magnets on the refrigerator.\n\nThe sides of the refrigerator door must also be parallel to coordinate axes.\n\n-----Input-----\n\nThe first line contains two integers n and k (1 ≤ n ≤ 100 000, 0 ≤ k ≤ min(10, n - 1)) — the number of magnets that Edo has and the maximum number of magnets Edo may not place on the refrigerator.\n\nNext n lines describe the initial plan of placing magnets. Each line contains four integers x_1, y_1, x_2, y_2 (1 ≤ x_1 < x_2 ≤ 10^9, 1 ≤ y_1 < y_2 ≤ 10^9) — the coordinates of the lower left and upper right corners of the current magnet. The magnets can partially overlap or even fully coincide.\n\n-----Output-----\n\nPrint a single integer — the minimum area of the door of refrigerator, which can be used to place at least n - k magnets, preserving the relative positions. \n\n-----Examples-----\nInput\n3 1\n1 1 2 2\n2 2 3 3\n3 3 4 4\n\nOutput\n1\n\nInput\n4 1\n1 1 2 2\n1 9 2 10\n9 9 10 10\n9 1 10 2\n\nOutput\n64\n\nInput\n3 0\n1 1 2 2\n1 1 1000000000 1000000000\n1 3 8 12\n\nOutput\n249999999000000001\n\n-----Note-----\n\nIn the first test sample it is optimal to remove either the first or the third magnet. If we remove the first magnet, the centers of two others will lie at points (2.5, 2.5) and (3.5, 3.5). Thus, it is enough to buy a fridge with door width 1 and door height 1, the area of the door also equals one, correspondingly.\n\nIn the second test sample it doesn't matter which magnet to remove, the answer will not change — we need a fridge with door width 8 and door height 8.\n\nIn the third sample you cannot remove anything as k = 0.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_magnets (n : Nat) (k : Nat) (magnets : List Magnet) : Nat :=\n  sorry", "vc-theorems": "theorem basic_case_theorem :\n  let n := 3\n  let k := 1\n  let magnets := [\n    Magnet.mk 1 1 2 2,\n    Magnet.mk 2 2 3 3,\n    Magnet.mk 3 3 4 4\n  ]\n  solve_magnets n k magnets = 1 :=\nsorry\n\ntheorem zero_k_theorem :\n  let n := 2\n  let k := 0\n  let magnets := [\n    Magnet.mk 1 1 2 2,\n    Magnet.mk 3 3 4 4\n  ]\n  solve_magnets n k magnets > 0 :=\nsorry\n\ntheorem large_gap_theorem :\n  let n := 2\n  let k := 1\n  let magnets := [\n    Magnet.mk 1 1 2 2,\n    Magnet.mk 100 100 101 101\n  ]\n  solve_magnets n k magnets = 1 :=\nsorry\n\ntheorem given_case_theorem :\n  let n := 4\n  let k := 1\n  let magnets := [\n    Magnet.mk 1 1 2 2,\n    Magnet.mk 1 9 2 10,\n    Magnet.mk 9 9 10 10,\n    Magnet.mk 9 1 10 2\n  ]\n  solve_magnets n k magnets = 64 :=\nsorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval solve_magnets 3 1 [(1, 1, 2, 2), (2, 2, 3, 3), (3, 3, 4, 4)]\n\n/-\ninfo: 64\n-/\n-- #guard_msgs in\n-- #eval solve_magnets 4 1 [(1, 1, 2, 2), (1, 9, 2, 10), (9, 9, 10, 10), (9, 1, 10, 2)]\n\n/-\ninfo: 249999999000000001\n-/\n-- #guard_msgs in\n-- #eval solve_magnets 3 0 [(1, 1, 2, 2), (1, 1, 1000000000, 1000000000), (1, 3, 8, 12)]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2003", "language": "lean", "source": "fvapps", "source-id": "fvapps_002003", "source-notes": "", "vc-description": "/-\nIvan has an array consisting of n different integers. He decided to reorder all elements in increasing order. Ivan loves merge sort so he decided to represent his array with one or several increasing sequences which he then plans to merge into one sorted array.\n\nIvan represent his array with increasing sequences with help of the following algorithm.\n\nWhile there is at least one unused number in array Ivan repeats the following procedure:  iterate through array from the left to the right;  Ivan only looks at unused numbers on current iteration;  if current number is the first unused number on this iteration or this number is greater than previous unused number on current iteration, then Ivan marks the number as used and writes it down. \n\nFor example, if Ivan's array looks like [1, 3, 2, 5, 4] then he will perform two iterations. On first iteration Ivan will use and write numbers [1, 3, 5], and on second one — [2, 4].\n\nWrite a program which helps Ivan and finds representation of the given array with one or several increasing sequences in accordance with algorithm described above.\n\n-----Input-----\n\nThe first line contains a single integer n (1 ≤ n ≤ 2·10^5) — the number of elements in Ivan's array.\n\nThe second line contains a sequence consisting of distinct integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 10^9) — Ivan's array.\n\n-----Output-----\n\nPrint representation of the given array in the form of one or more increasing sequences in accordance with the algorithm described above. Each sequence must be printed on a new line.\n\n-----Examples-----\nInput\n5\n1 3 2 5 4\n\nOutput\n1 3 5 \n2 4 \n\nInput\n4\n4 3 2 1\n\nOutput\n4 \n3 \n2 \n1 \n\nInput\n4\n10 30 50 101\n\nOutput\n10 30 50 101\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_sequences (n : Nat) (arr : List Int) : List (List Int) :=\n  sorry", "vc-theorems": "theorem find_sequences_structure \n  (n : Nat) (arr : List Int) (h : arr.length > 0) :\n  let result := find_sequences n arr;\n  -- Result is list of lists\n  result.length > 0\n  -- All elements from input appear in output with same count\n  ∧ List.length result.join = List.length arr := by\n  sorry\n\ntheorem find_sequences_positive_elements\n  (n : Nat) (arr : List Int) \n  (h1 : arr.length > 0)\n  (h2 : ∀ x ∈ arr, x > 0) :\n  let result := find_sequences n arr;\n  -- At least one sequence\n  result.length ≥ 1 \n  -- All elements remain positive\n  ∧ ∀ x ∈ result.join, x > 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2006", "language": "lean", "source": "fvapps", "source-id": "fvapps_002006", "source-notes": "", "vc-description": "/-\nYou are given a sequence a_1, a_2, ..., a_{n} consisting of different integers. It is required to split this sequence into the maximum number of subsequences such that after sorting integers in each of them in increasing order, the total sequence also will be sorted in increasing order.\n\nSorting integers in a subsequence is a process such that the numbers included in a subsequence are ordered in increasing order, and the numbers which are not included in a subsequence don't change their places.\n\nEvery element of the sequence must appear in exactly one subsequence.\n\n-----Input-----\n\nThe first line of input data contains integer n (1 ≤ n ≤ 10^5) — the length of the sequence.\n\nThe second line of input data contains n different integers a_1, a_2, ..., a_{n} ( - 10^9 ≤ a_{i} ≤ 10^9) — the elements of the sequence. It is guaranteed that all elements of the sequence are distinct.\n\n-----Output-----\n\nIn the first line print the maximum number of subsequences k, which the original sequence can be split into while fulfilling the requirements.\n\nIn the next k lines print the description of subsequences in the following format: the number of elements in subsequence c_{i} (0 < c_{i} ≤ n), then c_{i} integers l_1, l_2, ..., l_{c}_{i} (1 ≤ l_{j} ≤ n) — indices of these elements in the original sequence. \n\nIndices could be printed in any order. Every index from 1 to n must appear in output exactly once.\n\nIf there are several possible answers, print any of them.\n\n-----Examples-----\nInput\n6\n3 2 1 6 5 4\n\nOutput\n4\n2 1 3\n1 2\n2 4 6\n1 5\n\nInput\n6\n83 -75 -49 11 37 62\n\nOutput\n1\n6 1 2 3 4 5 6\n\n-----Note-----\n\nIn the first sample output:\n\nAfter sorting the first subsequence we will get sequence 1 2 3 6 5 4.\n\nSorting the second subsequence changes nothing.\n\nAfter sorting the third subsequence we will get sequence 1 2 3 4 5 6.\n\nSorting the last subsequence changes nothing.\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat := \n  sorry\n\ndef max_subsequences (n : Nat) (arr : List Int) : List (List Nat) :=\n  sorry", "vc-helpers": "", "vc-definitions": "def is_valid_result (n : Nat) (result : List (List Nat)) : Bool :=\n  sorry", "vc-theorems": "theorem max_subsequences_valid {n : Nat} {arr : List Int} \n  (h1 : n > 0) \n  (h2 : n = arr.length)\n  (h3 : ∀ x ∈ arr, -1000 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ (i : Fin arr.length) (j : Fin arr.length), i ≠ j → arr[i] ≠ arr[j]) :\n  is_valid_result n (max_subsequences n arr) := by\n  sorry\n\ntheorem max_subsequences_bounds {n : Nat} {arr : List Int} \n  (h1 : n > 0)\n  (h2 : n = arr.length)\n  (h3 : ∀ x ∈ arr, -1000 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ (i : Fin arr.length) (j : Fin arr.length), i ≠ j → arr[i] ≠ arr[j]) :\n  let result := max_subsequences n arr\n  1 ≤ result.head!.head! ∧ result.head!.head! ≤ n := by\n  sorry\n\ntheorem max_subsequences_sum {n : Nat} {arr : List Int}\n  (h1 : n > 0)\n  (h2 : n = arr.length)\n  (h3 : ∀ x ∈ arr, -1000 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ (i : Fin arr.length) (j : Fin arr.length), i ≠ j → arr[i] ≠ arr[j]) :\n  let result := max_subsequences n arr\n  List.sum (result.tail.map (λ subseq => subseq.head!)) = n := by\n  sorry\n\ntheorem max_subsequences_lengths {n : Nat} {arr : List Int}\n  (h1 : n > 0)\n  (h2 : n = arr.length) \n  (h3 : ∀ x ∈ arr, -1000 ≤ x ∧ x ≤ 1000)\n  (h4 : ∀ (i : Fin arr.length) (j : Fin arr.length), i ≠ j → arr[i] ≠ arr[j]) :\n  let result := max_subsequences n arr\n  ∀ subseq ∈ result.tail, subseq.head! ≥ 1 := by\n  sorry\n\n/-\ninfo: list(range(1, n1 + 1))\n-/\n-- #guard_msgs in\n-- #eval sorted sum([x[1:] for x in result1[1:]], [])\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval len result2[1]\n\n/-\ninfo: list(range(1, n2 + 1))\n-/\n-- #guard_msgs in\n-- #eval sorted result2[1][1:]\n\n/-\ninfo: list(range(1, n3 + 1))\n-/\n-- #guard_msgs in\n-- #eval sorted sum([x[1:] for x in result3[1:]], [])", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2022", "language": "lean", "source": "fvapps", "source-id": "fvapps_002022", "source-notes": "", "vc-description": "/-\nJeff has become friends with Furik. Now these two are going to play one quite amusing game.\n\nAt the beginning of the game Jeff takes a piece of paper and writes down a permutation consisting of n numbers: p_1, p_2, ..., p_{n}. Then the guys take turns to make moves, Jeff moves first. During his move, Jeff chooses two adjacent permutation elements and then the boy swaps them. During his move, Furic tosses a coin and if the coin shows \"heads\" he chooses a random pair of adjacent elements with indexes i and i + 1, for which an inequality p_{i} > p_{i} + 1 holds, and swaps them. But if the coin shows \"tails\", Furik chooses a random pair of adjacent elements with indexes i and i + 1, for which the inequality p_{i} < p_{i} + 1 holds, and swaps them. If the coin shows \"heads\" or \"tails\" and Furik has multiple ways of adjacent pairs to take, then he uniformly takes one of the pairs. If Furik doesn't have any pair to take, he tosses a coin one more time. The game ends when the permutation is sorted in the increasing order.\n\nJeff wants the game to finish as quickly as possible (that is, he wants both players to make as few moves as possible). Help Jeff find the minimum mathematical expectation of the number of moves in the game if he moves optimally well.\n\nYou can consider that the coin shows the heads (or tails) with the probability of 50 percent.\n\n-----Input-----\n\nThe first line contains integer n (1 ≤ n ≤ 3000). The next line contains n distinct integers p_1, p_2, ..., p_{n} (1 ≤ p_{i} ≤ n) — the permutation p. The numbers are separated by spaces.\n\n-----Output-----\n\nIn a single line print a single real value — the answer to the problem. The answer will be considered correct if the absolute or relative error doesn't exceed 10^{ - 6}.\n\n-----Examples-----\nInput\n2\n1 2\n\nOutput\n0.000000\n\nInput\n5\n3 5 2 4 1\n\nOutput\n13.000000\n\n-----Note-----\n\nIn the first test the sequence is already sorted, so the answer is 0.\n-/", "vc-preamble": "def CumTree.vstavi : CumTree → Int → Unit := sorry\ndef CumTree.manjsi : CumTree → Int → Int := sorry", "vc-helpers": "", "vc-definitions": "def solve_game : Nat → List Int → Int := sorry\n\ninductive Sorted {α : Type} (r : α → α → Prop) : List α → Prop\n  | nil : Sorted r []\n  | single : (a : α) → Sorted r [a]\n  | cons : (a b : α) → (l : List α) → r a b → Sorted r (b::l) → Sorted r (a::b::l)", "vc-theorems": "theorem cumtree_single_value (val : Int) \n  (h1 : 1 ≤ val) (h2 : val ≤ 4096) :\n  let ct := CumTree.mk 1 4096;\n  ct.manjsi val = 0 ∧ \n  ct.manjsi (val + 1) = 1 ∧\n  ct.manjsi (val - 1) = 0 := sorry\n\ntheorem solve_game_basic_properties {n : Nat} {nums : List Int}\n  (h1 : ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 4096)\n  (h2 : nums.length = n)\n  (h3 : nums.Nodup) :\n  solve_game n nums ≥ 0 ∧ \n  ∃ k : Int, solve_game n nums = k := sorry\n\ntheorem solve_game_sorted_zero {n : Nat} {nums : List Int}\n  (h1 : ∀ x ∈ nums, 1 ≤ x ∧ x ≤ 4096)\n  (h2 : nums.length = n)\n  (h3 : nums.Nodup)\n  (h4 : Sorted (· < ·) nums) : \n  solve_game n nums = 0 := sorry\n\ntheorem solve_game_two_elements {a b : Int}\n  (h1 : 1 ≤ a ∧ a ≤ 4096)\n  (h2 : 1 ≤ b ∧ b ≤ 4096)\n  (h3 : a ≠ b) :\n  solve_game 2 [a, b] = if a > b then 1 else 0 := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2023", "language": "lean", "source": "fvapps", "source-id": "fvapps_002023", "source-notes": "", "vc-description": "/-\nDZY loves Physics, and he enjoys calculating density.\n\nAlmost everything has density, even a graph. We define the density of a non-directed graph (nodes and edges of the graph have some values) as follows: $\\left\\{\\begin{array}{ll}{\\frac{v}{e}} & {(e > 0)} \\\\{0} & {(e = 0)} \\end{array} \\right.$ where v is the sum of the values of the nodes, e is the sum of the values of the edges.\n\nOnce DZY got a graph G, now he wants to find a connected induced subgraph G' of the graph, such that the density of G' is as large as possible.\n\nAn induced subgraph G'(V', E') of a graph G(V, E) is a graph that satisfies:  $V^{\\prime} \\subseteq V$;  edge $(a, b) \\in E^{\\prime}$ if and only if $a \\in V^{\\prime}, b \\in V^{\\prime}$, and edge $(a, b) \\in E$;  the value of an edge in G' is the same as the value of the corresponding edge in G, so as the value of a node. \n\nHelp DZY to find the induced subgraph with maximum density. Note that the induced subgraph you choose must be connected. [Image] \n\n-----Input-----\n\nThe first line contains two space-separated integers n (1 ≤ n ≤ 500), $m(0 \\leq m \\leq \\frac{n(n - 1)}{2})$. Integer n represents the number of nodes of the graph G, m represents the number of edges.\n\nThe second line contains n space-separated integers x_{i} (1 ≤ x_{i} ≤ 10^6), where x_{i} represents the value of the i-th node. Consider the graph nodes are numbered from 1 to n.\n\nEach of the next m lines contains three space-separated integers a_{i}, b_{i}, c_{i} (1 ≤ a_{i} < b_{i} ≤ n; 1 ≤ c_{i} ≤ 10^3), denoting an edge between node a_{i} and b_{i} with value c_{i}. The graph won't contain multiple edges.\n\n-----Output-----\n\nOutput a real number denoting the answer, with an absolute or relative error of at most 10^{ - 9}.\n\n-----Examples-----\nInput\n1 0\n1\n\nOutput\n0.000000000000000\n\nInput\n2 1\n1 2\n1 2 1\n\nOutput\n3.000000000000000\n\nInput\n5 6\n13 56 73 98 17\n1 2 56\n1 3 29\n1 4 42\n2 3 95\n2 4 88\n3 4 63\n\nOutput\n2.965517241379311\n\n-----Note-----\n\nIn the first sample, you can only choose an empty subgraph, or the subgraph containing only node 1.\n\nIn the second sample, choosing the whole graph is optimal.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_density_subgraph (n : Nat) (m : Nat) (node_values : List Nat) (edges : List Edge) : Float :=\n  sorry", "vc-theorems": "theorem max_density_properties (n : Nat) (node_values : List Nat) (edges : List Edge) \n  (h1 : n = node_values.length)\n  (h2 : ∀ e, match e with \n    | Edge.mk f t _ => f ≤ n ∧ t ≤ n) :\n  let result := max_density_subgraph n edges.length node_values edges;\n  -- Result is non-negative\n  (result ≥ 0)\n  ∧ \n  -- Empty edges case\n  (edges.length = 0 → result = 0)\n  ∧\n  -- Upper bound when edges exist\n  (edges.length > 0 →\n    match edges.head? with\n    | none => True \n    | some (Edge.mk _ _ initial_weight) => \n      let max_node_sum := edges.foldl (λ acc e => match e with\n        | Edge.mk f t _ => max acc (node_values[f - 1]! + node_values[t - 1]!)) 0\n      let min_weight := edges.foldl (λ acc e => match e with \n        | Edge.mk _ _ w => min acc w) initial_weight\n      result ≤ (Float.ofNat max_node_sum) / (Float.ofNat min_weight)) := by\n  sorry\n\ntheorem single_edge_density (node_values : List Nat) \n  (h1 : node_values.length ≥ 2) :\n  let n := node_values.length\n  max_density_subgraph n 1 node_values [Edge.mk 1 2 1] = Float.ofNat (node_values[0]! + node_values[1]!) := by\n  sorry\n\ntheorem empty_case :\n  max_density_subgraph 1 0 [1] ([] : List Edge) = 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2043", "language": "lean", "source": "fvapps", "source-id": "fvapps_002043", "source-notes": "", "vc-description": "/-\nIn the spirit of the holidays, Saitama has given Genos two grid paths of length n (a weird gift even by Saitama's standards). A grid path is an ordered sequence of neighbouring squares in an infinite grid. Two squares are neighbouring if they share a side.\n\nOne example of a grid path is (0, 0) → (0, 1) → (0, 2) → (1, 2) → (1, 1) → (0, 1) → ( - 1, 1). Note that squares in this sequence might be repeated, i.e. path has self intersections.\n\nMovement within a grid path is restricted to adjacent squares within the sequence. That is, from the i-th square, one can only move to the (i - 1)-th or (i + 1)-th squares of this path. Note that there is only a single valid move from the first and last squares of a grid path. Also note, that even if there is some j-th square of the path that coincides with the i-th square, only moves to (i - 1)-th and (i + 1)-th squares are available. For example, from the second square in the above sequence, one can only move to either the first or third squares.\n\nTo ensure that movement is not ambiguous, the two grid paths will not have an alternating sequence of three squares. For example, a contiguous subsequence (0, 0) → (0, 1) → (0, 0) cannot occur in a valid grid path.\n\nOne marble is placed on the first square of each grid path. Genos wants to get both marbles to the last square of each grid path. However, there is a catch. Whenever he moves one marble, the other marble will copy its movement if possible. For instance, if one marble moves east, then the other marble will try and move east as well. By try, we mean if moving east is a valid move, then the marble will move east.\n\nMoving north increases the second coordinate by 1, while moving south decreases it by 1. Similarly, moving east increases first coordinate by 1, while moving west decreases it.\n\nGiven these two valid grid paths, Genos wants to know if it is possible to move both marbles to the ends of their respective paths. That is, if it is possible to move the marbles such that both marbles rest on the last square of their respective paths.\n\n-----Input-----\n\nThe first line of the input contains a single integer n (2 ≤ n ≤ 1 000 000) — the length of the paths.\n\nThe second line of the input contains a string consisting of n - 1 characters (each of which is either 'N', 'E', 'S', or 'W') — the first grid path. The characters can be thought of as the sequence of moves needed to traverse the grid path. For example, the example path in the problem statement can be expressed by the string \"NNESWW\".\n\nThe third line of the input contains a string of n - 1 characters (each of which is either 'N', 'E', 'S', or 'W') — the second grid path.\n\n-----Output-----\n\nPrint \"YES\" (without quotes) if it is possible for both marbles to be at the end position at the same time. Print \"NO\" (without quotes) otherwise. In both cases, the answer is case-insensitive.\n\n-----Examples-----\nInput\n7\nNNESWW\nSWSWSW\n\nOutput\nYES\n\nInput\n3\nNN\nSS\n\nOutput\nNO\n\n-----Note-----\n\nIn the first sample, the first grid path is the one described in the statement. Moreover, the following sequence of moves will get both marbles to the end: NNESWWSWSW.\n\nIn the second sample, no sequence of moves can get both marbles to the end.\n-/", "vc-preamble": "def flipDir : Direction → Direction \n  | Direction.N => Direction.S\n  | Direction.S => Direction.N\n  | Direction.E => Direction.W\n  | Direction.W => Direction.E\n\ndef flipPath (path : List Direction) : List Direction :=\n  path.map flipDir\n\ndef opposite (d : Direction) : Direction :=\n  flipDir d", "vc-helpers": "", "vc-definitions": "def solvable (p1 p2 : List Direction) : Bool :=\n  sorry", "vc-theorems": "theorem solvable_with_self_inverse (path : List Direction) :\n  ¬(solvable path (flipPath path)) := by sorry\n\ntheorem solvable_symmetry (path : List Direction) :\n  let rev := (path.reverse.map opposite)\n  solvable path rev = solvable rev path := by sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval solvable \"NNESWW\" \"SWSWSW\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval solvable \"NN\" \"SS\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval solvable \"ES\" \"NW\"", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2049", "language": "lean", "source": "fvapps", "source-id": "fvapps_002049", "source-notes": "", "vc-description": "/-\nEvlampiy was gifted a rooted tree. The vertices of the tree are numbered from $1$ to $n$. Each of its vertices also has an integer $a_i$ written on it. For each vertex $i$, Evlampiy calculated $c_i$ — the number of vertices $j$ in the subtree of vertex $i$, such that $a_j < a_i$. [Image]Illustration for the second example, the first integer is $a_i$ and the integer in parentheses is $c_i$\n\nAfter the new year, Evlampiy could not remember what his gift was! He remembers the tree and the values of $c_i$, but he completely forgot which integers $a_i$ were written on the vertices.\n\nHelp him to restore initial integers!\n\n-----Input-----\n\nThe first line contains an integer $n$ $(1 \\leq n \\leq 2000)$ — the number of vertices in the tree.\n\nThe next $n$ lines contain descriptions of vertices: the $i$-th line contains two integers $p_i$ and $c_i$ ($0 \\leq p_i \\leq n$; $0 \\leq c_i \\leq n-1$), where $p_i$ is the parent of vertex $i$ or $0$ if vertex $i$ is root, and $c_i$ is the number of vertices $j$ in the subtree of vertex $i$, such that $a_j < a_i$.\n\nIt is guaranteed that the values of $p_i$ describe a rooted tree with $n$ vertices.\n\n-----Output-----\n\nIf a solution exists, in the first line print \"YES\", and in the second line output $n$ integers $a_i$ $(1 \\leq a_i \\leq {10}^{9})$. If there are several solutions, output any of them. One can prove that if there is a solution, then there is also a solution in which all $a_i$ are between $1$ and $10^9$.\n\nIf there are no solutions, print \"NO\".\n\n-----Examples-----\nInput\n3\n2 0\n0 2\n2 0\n\nOutput\nYES\n1 2 1 \nInput\n5\n0 1\n1 3\n2 1\n3 0\n2 0\n\nOutput\nYES\n2 3 2 1 2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_rooted_tree (n : Nat) (parents_and_counts : List (Nat × Nat)) : \n  String × List Nat := sorry", "vc-theorems": "theorem minimal_single_node_case (n : Nat) (parents_and_counts : List (Nat × Nat)) :\n  n = 1 → parents_and_counts = [(0,0)] → \n  solve_rooted_tree n parents_and_counts = (\"YES\", [1]) := sorry\n\ntheorem invalid_counts_yields_no (n : Nat) (parents_and_counts : List (Nat × Nat)) :\n  n = 3 → parents_and_counts = [(2,3), (3,3), (0,3)] →\n  solve_rooted_tree n parents_and_counts = (\"NO\", []) := sorry\n\ntheorem valid_tree_properties (n : Nat) (parents_and_counts : List (Nat × Nat)) \n  (result : String) (nums : List Nat) :\n  n = 3 → parents_and_counts = [(2,0), (0,2), (2,0)] →\n  solve_rooted_tree n parents_and_counts = (result, nums) →\n  result = \"YES\" ∧ \n  nums.length = n ∧\n  (∀ x ∈ nums, x ∈ [1,2,3]) := sorry\n\ntheorem output_properties (n : Nat) (parents_and_counts : List (Nat × Nat)) \n  (result : String) (nums : List Nat) :\n  n = 5 → parents_and_counts = [(0,1), (1,3), (2,1), (3,0), (2,0)] →\n  solve_rooted_tree n parents_and_counts = (result, nums) →\n  (result = \"YES\" ∨ result = \"NO\") ∧\n  (result = \"YES\" → \n    nums.length = n ∧\n    (∀ x ∈ nums, 1 ≤ x ∧ x ≤ n) ∧\n    (∀ x ∈ nums, ∀ y ∈ nums, x ≠ y → nums.indexOf x ≠ nums.indexOf y)) := sorry\n\n/-\ninfo: n\n-/\n-- #guard_msgs in\n-- #eval len nums\n\n/-\ninfo: n\n-/\n-- #guard_msgs in\n-- #eval len nums", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2051", "language": "lean", "source": "fvapps", "source-id": "fvapps_002051", "source-notes": "", "vc-description": "/-\nArkady plays Gardenscapes a lot. Arkady wants to build two new fountains. There are n available fountains, for each fountain its beauty and cost are known. There are two types of money in the game: coins and diamonds, so each fountain cost can be either in coins or diamonds. No money changes between the types are allowed.\n\nHelp Arkady to find two fountains with maximum total beauty so that he can buy both at the same time.\n\n-----Input-----\n\nThe first line contains three integers n, c and d (2 ≤ n ≤ 100 000, 0 ≤ c, d ≤ 100 000) — the number of fountains, the number of coins and diamonds Arkady has.\n\nThe next n lines describe fountains. Each of these lines contain two integers b_{i} and p_{i} (1 ≤ b_{i}, p_{i} ≤ 100 000) — the beauty and the cost of the i-th fountain, and then a letter \"C\" or \"D\", describing in which type of money is the cost of fountain i: in coins or in diamonds, respectively.\n\n-----Output-----\n\nPrint the maximum total beauty of exactly two fountains Arkady can build. If he can't build two fountains, print 0.\n\n-----Examples-----\nInput\n3 7 6\n10 8 C\n4 3 C\n5 6 D\n\nOutput\n9\n\nInput\n2 4 5\n2 5 C\n2 1 D\n\nOutput\n0\n\nInput\n3 10 10\n5 5 C\n5 5 C\n10 11 D\n\nOutput\n10\n\n-----Note-----\n\nIn the first example Arkady should build the second fountain with beauty 4, which costs 3 coins. The first fountain he can't build because he don't have enough coins. Also Arkady should build the third fountain with beauty 5 which costs 6 diamonds. Thus the total beauty of built fountains is 9.\n\nIn the second example there are two fountains, but Arkady can't build both of them, because he needs 5 coins for the first fountain, and Arkady has only 4 coins.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def max_fountain_beauty (n : Nat) (coins : Nat) (diamonds : Nat) (fountains : List Fountain) : Nat :=\n  sorry", "vc-theorems": "theorem max_fountain_beauty_non_negative (n : Nat) (coins : Nat) (diamonds : Nat) \n    (fountains : List Fountain) :\n  max_fountain_beauty n coins diamonds fountains ≥ 0 := sorry\n\ntheorem max_fountain_beauty_zero_when_insufficient_fountains (n : Nat) (coins : Nat) \n    (diamonds : Nat) (fountains : List Fountain) :\n  let coin_fountains := fountains.filter (fun f => f.type = 'C' ∧ f.price ≤ coins)\n  let diamond_fountains := fountains.filter (fun f => f.type = 'D' ∧ f.price ≤ diamonds)\n  ¬(coin_fountains.length ≥ 2 ∨ diamond_fountains.length ≥ 2) ∧ \n  ¬(coin_fountains.length ≥ 1 ∧ diamond_fountains.length ≥ 1) →\n  max_fountain_beauty n coins diamonds fountains = 0 := sorry\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval max_fountain_beauty 3 7 6 [(10, 8, \"C\"), (4, 3, \"C\"), (5, 6, \"D\")]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval max_fountain_beauty 2 4 5 [(2, 5, \"C\"), (2, 1, \"D\")]\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval max_fountain_beauty 3 10 10 [(5, 5, \"C\"), (5, 5, \"C\"), (10, 11, \"D\")]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2055", "language": "lean", "source": "fvapps", "source-id": "fvapps_002055", "source-notes": "", "vc-description": "/-\nZiota found a video game called \"Monster Invaders\".\n\nSimilar to every other shooting RPG game, \"Monster Invaders\" involves killing monsters and bosses with guns.\n\nFor the sake of simplicity, we only consider two different types of monsters and three different types of guns.\n\nNamely, the two types of monsters are:   a normal monster with $1$ hp.  a boss with $2$ hp. \n\nAnd the three types of guns are:   Pistol, deals $1$ hp in damage to one monster, $r_1$ reloading time  Laser gun, deals $1$ hp in damage to all the monsters in the current level (including the boss), $r_2$ reloading time  AWP, instantly kills any monster, $r_3$ reloading time \n\nThe guns are initially not loaded, and the Ziota can only reload 1 gun at a time.\n\nThe levels of the game can be considered as an array $a_1, a_2, \\ldots, a_n$, in which the $i$-th stage has $a_i$ normal monsters and 1 boss. Due to the nature of the game, Ziota cannot use the Pistol (the first type of gun) or AWP (the third type of gun) to shoot the boss before killing all of the $a_i$ normal monsters.\n\nIf Ziota damages the boss but does not kill it immediately, he is forced to move out of the current level to an arbitrary adjacent level (adjacent levels of level $i$ $(1 < i < n)$ are levels $i - 1$ and $i + 1$, the only adjacent level of level $1$ is level $2$, the only adjacent level of level $n$ is level $n - 1$). Ziota can also choose to move to an adjacent level at any time. Each move between adjacent levels are managed by portals with $d$ teleportation time.\n\nIn order not to disrupt the space-time continuum within the game, it is strictly forbidden to reload or shoot monsters during teleportation. \n\nZiota starts the game at level 1. The objective of the game is rather simple, to kill all the bosses in all the levels. He is curious about the minimum time to finish the game (assuming it takes no time to shoot the monsters with a loaded gun and Ziota has infinite ammo on all the three guns). Please help him find this value.\n\n-----Input-----\n\nThe first line of the input contains five integers separated by single spaces: $n$ $(2 \\le n \\le 10^6)$ — the number of stages, $r_1, r_2, r_3$ $(1 \\le r_1 \\le r_2 \\le r_3 \\le 10^9)$ — the reload time of the three guns respectively, $d$ $(1 \\le d \\le 10^9)$ — the time of moving between adjacent levels.\n\nThe second line of the input contains $n$ integers separated by single spaces $a_1, a_2, \\dots, a_n$ $(1 \\le a_i \\le 10^6, 1 \\le i \\le n)$.\n\n-----Output-----\n\nPrint one integer, the minimum time to finish the game.\n\n-----Examples-----\nInput\n4 1 3 4 3\n3 2 5 1\n\nOutput\n34\nInput\n4 2 4 4 1\n4 5 1 2\n\nOutput\n31\n\n-----Note-----\n\nIn the first test case, the optimal strategy is:  Use the pistol to kill three normal monsters and AWP to kill the boss (Total time $1\\cdot3+4=7$)  Move to stage two (Total time $7+3=10$)  Use the pistol twice and AWP to kill the boss (Total time $10+1\\cdot2+4=16$)  Move to stage three (Total time $16+3=19$)  Use the laser gun and forced to move to either stage four or two, here we move to stage four (Total time $19+3+3=25$)  Use the pistol once, use AWP to kill the boss (Total time $25+1\\cdot1+4=30$)  Move back to stage three (Total time $30+3=33$)  Kill the boss at stage three with the pistol (Total time $33+1=34$) \n\nNote that here, we do not finish at level $n$, but when all the bosses are killed.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (h::t) => h + sum t", "vc-helpers": "", "vc-definitions": "def solve_monster_invaders (n : Nat) (r1 r2 r3 d : Nat) (monsters : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem solve_monster_invaders_nonnegative (n : Nat) (r1 r2 r3 d : Nat) (monsters : List Nat)\n  (h1 : n > 0) (h2 : n ≤ 100)\n  (h3 : r1 > 0) (h4 : r1 ≤ 10)\n  (h5 : r2 > 0) (h6 : r2 ≤ 10)\n  (h7 : r3 > 0) (h8 : r3 ≤ 10)\n  (h9 : d > 0) (h10 : d ≤ 10)\n  (h11 : monsters.length = n)\n  (h12 : ∀ m ∈ monsters, m ≥ 0 ∧ m ≤ 10) :\n  solve_monster_invaders n r1 r2 r3 d monsters ≥ 0 :=\n  sorry\n\ntheorem solve_monster_invaders_upper_bound (n : Nat) (r1 r2 r3 d : Nat) (monsters : List Nat)\n  (h1 : n > 0) (h2 : n ≤ 100)\n  (h3 : r1 > 0) (h4 : r1 ≤ 10)\n  (h5 : r2 > 0) (h6 : r2 ≤ 10)\n  (h7 : r3 > 0) (h8 : r3 ≤ 10)\n  (h9 : d > 0) (h10 : d ≤ 10)\n  (h11 : monsters.length = n)\n  (h12 : ∀ m ∈ monsters, m ≥ 0 ∧ m ≤ 10) :\n  solve_monster_invaders n r1 r2 r3 d monsters ≤ (n-1)*d + (List.map (λ m => (m+2)*r1) monsters).sum + n*(r2+r3) :=\n  sorry\n\ntheorem solve_monster_invaders_monotone_r1 (n : Nat) (r1 r2 r3 d : Nat) (monsters : List Nat)\n  (h1 : n > 0) (h2 : n ≤ 100)\n  (h3 : r1 > 0) (h4 : r1 ≤ 9)\n  (h5 : r2 > 0) (h6 : r2 ≤ 10)\n  (h7 : r3 > 0) (h8 : r3 ≤ 10)\n  (h9 : d > 0) (h10 : d ≤ 10)\n  (h11 : monsters.length = n)\n  (h12 : ∀ m ∈ monsters, m ≥ 0 ∧ m ≤ 10) :\n  solve_monster_invaders n (r1+1) r2 r3 d monsters ≥ solve_monster_invaders n r1 r2 r3 d monsters :=\n  sorry\n\ntheorem solve_monster_invaders_monotone_r2 (n : Nat) (r1 r2 r3 d : Nat) (monsters : List Nat)\n  (h1 : n > 0) (h2 : n ≤ 100)\n  (h3 : r1 > 0) (h4 : r1 ≤ 10)\n  (h5 : r2 > 0) (h6 : r2 ≤ 9)\n  (h7 : r3 > 0) (h8 : r3 ≤ 10)\n  (h9 : d > 0) (h10 : d ≤ 10)\n  (h11 : monsters.length = n)\n  (h12 : ∀ m ∈ monsters, m ≥ 0 ∧ m ≤ 10) :\n  solve_monster_invaders n r1 (r2+1) r3 d monsters ≥ solve_monster_invaders n r1 r2 r3 d monsters :=\n  sorry\n\ntheorem solve_monster_invaders_monotone_r3 (n : Nat) (r1 r2 r3 d : Nat) (monsters : List Nat)\n  (h1 : n > 0) (h2 : n ≤ 100)\n  (h3 : r1 > 0) (h4 : r1 ≤ 10)\n  (h5 : r2 > 0) (h6 : r2 ≤ 10)\n  (h7 : r3 > 0) (h8 : r3 ≤ 9)\n  (h9 : d > 0) (h10 : d ≤ 10)\n  (h11 : monsters.length = n)\n  (h12 : ∀ m ∈ monsters, m ≥ 0 ∧ m ≤ 10) :\n  solve_monster_invaders n r1 r2 (r3+1) d monsters ≥ solve_monster_invaders n r1 r2 r3 d monsters :=\n  sorry\n\ntheorem solve_monster_invaders_monotone_d (n : Nat) (r1 r2 r3 d : Nat) (monsters : List Nat)\n  (h1 : n > 0) (h2 : n ≤ 100)\n  (h3 : r1 > 0) (h4 : r1 ≤ 10)\n  (h5 : r2 > 0) (h6 : r2 ≤ 10)\n  (h7 : r3 > 0) (h8 : r3 ≤ 10)\n  (h9 : d > 0) (h10 : d ≤ 9)\n  (h11 : monsters.length = n)\n  (h12 : ∀ m ∈ monsters, m ≥ 0 ∧ m ≤ 10) :\n  solve_monster_invaders n r1 r2 r3 (d+1) monsters ≥ solve_monster_invaders n r1 r2 r3 d monsters :=\n  sorry\n\n/-\ninfo: 34\n-/\n-- #guard_msgs in\n-- #eval solve_monster_invaders 4 1 3 4 3 [3, 2, 5, 1]\n\n/-\ninfo: 31\n-/\n-- #guard_msgs in\n-- #eval solve_monster_invaders 4 2 4 4 1 [4, 5, 1, 2]\n\n/-\ninfo: 23\n-/\n-- #guard_msgs in\n-- #eval solve_monster_invaders 2 2 5 7 3 [4, 5]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2059", "language": "lean", "source": "fvapps", "source-id": "fvapps_002059", "source-notes": "", "vc-description": "/-\nThis is the easier version of the problem. In this version, $1 \\le n \\le 10^5$ and $0 \\le a_i \\le 1$. You can hack this problem only if you solve and lock both problems.\n\nChristmas is coming, and our protagonist, Bob, is preparing a spectacular present for his long-time best friend Alice. This year, he decides to prepare $n$ boxes of chocolate, numbered from $1$ to $n$. Initially, the $i$-th box contains $a_i$ chocolate pieces.\n\nSince Bob is a typical nice guy, he will not send Alice $n$ empty boxes. In other words, at least one of $a_1, a_2, \\ldots, a_n$ is positive. Since Alice dislikes coprime sets, she will be happy only if there exists some integer $k > 1$ such that the number of pieces in each box is divisible by $k$. Note that Alice won't mind if there exists some empty boxes. \n\nCharlie, Alice's boyfriend, also is Bob's second best friend, so he decides to help Bob by rearranging the chocolate pieces. In one second, Charlie can pick up a piece in box $i$ and put it into either box $i-1$ or box $i+1$ (if such boxes exist). Of course, he wants to help his friend as quickly as possible. Therefore, he asks you to calculate the minimum number of seconds he would need to make Alice happy.\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\le n \\le 10^5$) — the number of chocolate boxes.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 1$) — the number of chocolate pieces in the $i$-th box.\n\nIt is guaranteed that at least one of $a_1, a_2, \\ldots, a_n$ is positive.\n\n-----Output-----\n\nIf there is no way for Charlie to make Alice happy, print $-1$.\n\nOtherwise, print a single integer $x$ — the minimum number of seconds for Charlie to help Bob make Alice happy.\n\n-----Examples-----\nInput\n3\n1 0 1\n\nOutput\n2\n\nInput\n1\n1\n\nOutput\n-1\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat := \n  xs.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def solve_christmas_boxes (n: Nat) (boxes: List Nat) : Int :=\nsorry", "vc-theorems": "theorem solve_christmas_boxes_result_valid {n: Nat} {boxes: List Nat} :\n  let result := solve_christmas_boxes n boxes \n  result ≥ -1 :=\nsorry\n\ntheorem solve_christmas_boxes_single_one_impossible {n: Nat} {boxes: List Nat} :\n  boxes.length = n →\n  boxes.sum = 1 →\n  solve_christmas_boxes n boxes = -1 :=\nsorry\n\ntheorem solve_christmas_boxes_result_positive {n: Nat} {boxes: List Nat} :\n  let result := solve_christmas_boxes n boxes\n  result ≠ -1 → result > 0 :=\nsorry\n\ntheorem solve_christmas_boxes_length_matches {n: Nat} {boxes: List Nat} :\n  solve_christmas_boxes n boxes = solve_christmas_boxes n boxes →\n  boxes.length = n :=\nsorry\n\ntheorem solve_christmas_boxes_valid_values {n: Nat} {boxes: List Nat} :\n  solve_christmas_boxes n boxes = solve_christmas_boxes n boxes →\n  ∀ x ∈ boxes, x = 0 ∨ x = 1 :=\nsorry\n\ntheorem solve_christmas_boxes_all_ones {n: Nat} :\n  let boxes := List.replicate n 1\n  solve_christmas_boxes n boxes ≥ -1 :=\nsorry\n\ntheorem solve_christmas_boxes_all_zeros {n: Nat} :\n  let boxes := List.replicate n 0\n  solve_christmas_boxes n boxes = -1 :=\nsorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve_christmas_boxes 3 [1, 0, 1]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval solve_christmas_boxes 1 [1]\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval solve_christmas_boxes 6 [1, 1, 0, 0, 0, 1]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2063", "language": "lean", "source": "fvapps", "source-id": "fvapps_002063", "source-notes": "", "vc-description": "/-\nOne of Timofey's birthday presents is a colourbook in a shape of an infinite plane. On the plane n rectangles with sides parallel to coordinate axes are situated. All sides of the rectangles have odd length. Rectangles cannot intersect, but they can touch each other.\n\nHelp Timofey to color his rectangles in 4 different colors in such a way that every two rectangles touching each other by side would have different color, or determine that it is impossible.\n\nTwo rectangles intersect if their intersection has positive area. Two rectangles touch by sides if there is a pair of sides such that their intersection has non-zero length [Image] The picture corresponds to the first example \n\n-----Input-----\n\nThe first line contains single integer n (1 ≤ n ≤ 5·10^5) — the number of rectangles.\n\nn lines follow. The i-th of these lines contains four integers x_1, y_1, x_2 and y_2 ( - 10^9 ≤ x_1 < x_2 ≤ 10^9,  - 10^9 ≤ y_1 < y_2 ≤ 10^9), that means that points (x_1, y_1) and (x_2, y_2) are the coordinates of two opposite corners of the i-th rectangle.\n\nIt is guaranteed, that all sides of the rectangles have odd lengths and rectangles don't intersect each other.\n\n-----Output-----\n\nPrint \"NO\" in the only line if it is impossible to color the rectangles in 4 different colors in such a way that every two rectangles touching each other by side would have different color.\n\nOtherwise, print \"YES\" in the first line. Then print n lines, in the i-th of them print single integer c_{i} (1 ≤ c_{i} ≤ 4) — the color of i-th rectangle.\n\n-----Example-----\nInput\n8\n0 0 5 3\n2 -1 5 0\n-3 -4 2 -1\n-1 -1 2 0\n-3 0 0 5\n5 2 10 3\n7 -3 10 2\n4 -2 7 -1\n\nOutput\nYES\n1\n2\n2\n3\n2\n2\n4\n1\n-/", "vc-preamble": "def colorRectangles (rectangles : List (Int × Int × Int × Int)) : String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def parseColors (s : String) : List Int :=\n  sorry", "vc-theorems": "theorem colorRectangles_valid_format (rectangles : List (Int × Int × Int × Int)) :\n  let result := colorRectangles rectangles\n  result.startsWith \"YES\\n\" := by sorry\n\ntheorem colorRectangles_output_length {rectangles : List (Int × Int × Int × Int)} :\n  let colors := parseColors (colorRectangles rectangles)\n  colors.length = rectangles.length := by sorry\n\ntheorem colorRectangles_valid_colors {rectangles : List (Int × Int × Int × Int)} :\n  let colors := parseColors (colorRectangles rectangles)\n  ∀ c ∈ colors, 1 ≤ c ∧ c ≤ 4 := by sorry\n\ntheorem colorRectangles_parity_color_assignment \n  {rectangles : List (Int × Int × Int × Int)} :\n  let colors := parseColors (colorRectangles rectangles)\n  ∀ (rect : Int × Int × Int × Int) (color : Int),\n    rect ∈ rectangles →\n    color ∈ colors →\n    (Int.mod (Prod.fst rect) 2 = 0 ∧ Int.mod (Prod.fst (Prod.snd rect)) 2 = 0 → color = 1) ∧\n    (Int.mod (Prod.fst rect) 2 = 0 ∧ Int.mod (Prod.fst (Prod.snd rect)) 2 ≠ 0 → color = 2) ∧\n    (Int.mod (Prod.fst rect) 2 ≠ 0 ∧ Int.mod (Prod.fst (Prod.snd rect)) 2 = 0 → color = 3) ∧\n    (Int.mod (Prod.fst rect) 2 ≠ 0 ∧ Int.mod (Prod.fst (Prod.snd rect)) 2 ≠ 0 → color = 4) := by sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2066", "language": "lean", "source": "fvapps", "source-id": "fvapps_002066", "source-notes": "", "vc-description": "/-\nPolycarp is making a quest for his friends. He has already made n tasks, for each task the boy evaluated how interesting it is as an integer q_{i}, and the time t_{i} in minutes needed to complete the task. \n\nAn interesting feature of his quest is: each participant should get the task that is best suited for him, depending on his preferences. The task is chosen based on an interactive quiz that consists of some questions. The player should answer these questions with \"yes\" or \"no\". Depending on the answer to the question, the participant either moves to another question or goes to one of the tasks that are in the quest. In other words, the quest is a binary tree, its nodes contain questions and its leaves contain tasks. \n\nWe know that answering any of the questions that are asked before getting a task takes exactly one minute from the quest player. Polycarp knows that his friends are busy people and they can't participate in the quest for more than T minutes. Polycarp wants to choose some of the n tasks he made, invent the corresponding set of questions for them and use them to form an interactive quiz as a binary tree so that no matter how the player answers quiz questions, he spends at most T minutes on completing the whole quest (that is, answering all the questions and completing the task). Specifically, the quest can contain zero questions and go straight to the task. Each task can only be used once (i.e., the people who give different answers to questions should get different tasks).\n\nPolycarp wants the total \"interest\" value of the tasks involved in the quest to be as large as possible. Help him determine the maximum possible total interest value of the task considering that the quest should be completed in T minutes at any variant of answering questions.\n\n-----Input-----\n\nThe first line contains two integers n and T (1 ≤ n ≤ 1000, 1 ≤ T ≤ 100) — the number of tasks made by Polycarp and the maximum time a quest player should fit into.\n\nNext n lines contain two integers t_{i}, q_{i} (1 ≤ t_{i} ≤ T, 1 ≤ q_{i} ≤ 1000) each — the time in minutes needed to complete the i-th task and its interest value.\n\n-----Output-----\n\nPrint a single integer — the maximum possible total interest value of all the tasks in the quest.\n\n-----Examples-----\nInput\n5 5\n1 1\n1 1\n2 2\n3 3\n4 4\n\nOutput\n11\n\nInput\n5 5\n4 1\n4 2\n4 3\n4 4\n4 5\n\nOutput\n9\n\nInput\n2 2\n1 1\n2 10\n\nOutput\n10\n\n-----Note-----\n\nIn the first sample test all the five tasks can be complemented with four questions and joined into one quest.\n\nIn the second sample test it is impossible to use all the five tasks, but you can take two of them, the most interesting ones.\n\nIn the third sample test the optimal strategy is to include only the second task into the quest.\n\nHere is the picture that illustrates the answers to the sample tests. The blue circles represent the questions, the two arrows that go from every circle represent where a person goes depending on his answer to that question. The tasks are the red ovals. [Image]\n-/", "vc-preamble": "def List.sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def List.sort (lt : α → α → Bool) (l : List α) : List α := sorry\n\ndef max_quest_interest (n : Nat) (T : Nat) (tasks : List (Nat × Nat)) : Nat := sorry", "vc-theorems": "theorem max_quest_interest_non_negative (n T : Nat) (tasks : List (Nat × Nat)) :\n  max_quest_interest n T tasks ≥ 0 := sorry\n\ntheorem max_quest_interest_bounded_by_sum (n T : Nat) (tasks : List (Nat × Nat)) :\n  let interest_values := tasks.map (fun p => p.2)\n  max_quest_interest n T tasks ≤ interest_values.sum := sorry\n\ntheorem max_quest_interest_time_constraint (n T : Nat) (tasks : List (Nat × Nat)) :\n  let max_possible := min n (2^T)\n  let interest_values := tasks.map (fun p => p.2)\n  let sorted_interests := interest_values.sort (fun a b => b ≤ a)\n  let max_interests := sorted_interests.take max_possible\n  max_quest_interest n T tasks ≤ max_interests.sum := sorry\n\ntheorem same_time_tasks_property (n T : Nat) (tasks : List (Nat × Nat)) \n    (h : ∀ t ∈ tasks.map Prod.fst, t = 1) :\n  let interest_values := tasks.map (fun p => p.2)\n  let sorted_interests := interest_values.sort (fun a b => b ≤ a)\n  let feasible_interests := sorted_interests.take (2^(T-1))\n  max_quest_interest n T tasks ≤ feasible_interests.sum := sorry\n\ntheorem small_time_constraint_property (n T : Nat) (tasks : List (Nat × Nat)) (h : T ≤ 4) :\n  let max_quests := 2^(T-1)\n  let interest_values := tasks.map (fun p => p.2)\n  let sorted_interests := interest_values.sort (fun a b => b ≤ a)\n  let max_interests := sorted_interests.take max_quests\n  max_quest_interest n T tasks ≤ max_interests.sum := sorry\n\n/-\ninfo: 11\n-/\n-- #guard_msgs in\n-- #eval max_quest_interest 5 5 [(1, 1), (1, 1), (2, 2), (3, 3), (4, 4)]\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval max_quest_interest 5 5 [(4, 1), (4, 2), (4, 3), (4, 4), (4, 5)]\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval max_quest_interest 2 2 [(1, 1), (2, 10)]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2068", "language": "lean", "source": "fvapps", "source-id": "fvapps_002068", "source-notes": "", "vc-description": "/-\nJust to remind, girls in Arpa's land are really nice.\n\nMehrdad wants to invite some Hoses to the palace for a dancing party. Each Hos has some weight w_{i} and some beauty b_{i}. Also each Hos may have some friends. Hoses are divided in some friendship groups. Two Hoses x and y are in the same friendship group if and only if there is a sequence of Hoses a_1, a_2, ..., a_{k} such that a_{i} and a_{i} + 1 are friends for each 1 ≤ i < k, and a_1 = x and a_{k} = y.\n\n [Image] \n\nArpa allowed to use the amphitheater of palace to Mehrdad for this party. Arpa's amphitheater can hold at most w weight on it. \n\nMehrdad is so greedy that he wants to invite some Hoses such that sum of their weights is not greater than w and sum of their beauties is as large as possible. Along with that, from each friendship group he can either invite all Hoses, or no more than one. Otherwise, some Hoses will be hurt. Find for Mehrdad the maximum possible total beauty of Hoses he can invite so that no one gets hurt and the total weight doesn't exceed w.\n\n-----Input-----\n\nThe first line contains integers n, m and w (1  ≤  n  ≤  1000, $0 \\leq m \\leq \\operatorname{min}(\\frac{n \\cdot(n - 1)}{2}, 10^{5})$, 1 ≤ w ≤ 1000) — the number of Hoses, the number of pair of friends and the maximum total weight of those who are invited.\n\nThe second line contains n integers w_1, w_2, ..., w_{n} (1 ≤ w_{i} ≤ 1000) — the weights of the Hoses.\n\nThe third line contains n integers b_1, b_2, ..., b_{n} (1 ≤ b_{i} ≤ 10^6) — the beauties of the Hoses.\n\nThe next m lines contain pairs of friends, the i-th of them contains two integers x_{i} and y_{i} (1 ≤ x_{i}, y_{i} ≤ n, x_{i} ≠ y_{i}), meaning that Hoses x_{i} and y_{i} are friends. Note that friendship is bidirectional. All pairs (x_{i}, y_{i}) are distinct.\n\n-----Output-----\n\nPrint the maximum possible total beauty of Hoses Mehrdad can invite so that no one gets hurt and the total weight doesn't exceed w.\n\n-----Examples-----\nInput\n3 1 5\n3 2 5\n2 4 2\n1 2\n\nOutput\n6\n\nInput\n4 2 11\n2 4 6 6\n6 4 2 1\n1 2\n2 3\n\nOutput\n7\n\n-----Note-----\n\nIn the first sample there are two friendship groups: Hoses {1, 2} and Hos {3}. The best way is to choose all of Hoses in the first group, sum of their weights is equal to 5 and sum of their beauty is 6.\n\nIn the second sample there are two friendship groups: Hoses {1, 2, 3} and Hos {4}. Mehrdad can't invite all the Hoses from the first group because their total weight is 12 > 11, thus the best way is to choose the first Hos from the first group and the only one from the second group. The total weight will be 8, and the total beauty will be 7.\n-/", "vc-preamble": "def List.sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum xs\n\ndef List.minimum : List Nat → Nat \n  | [] => 0\n  | [x] => x\n  | x::xs => Nat.min x (minimum xs)", "vc-helpers": "", "vc-definitions": "def solve_party_weights (n m w : Nat) (weights beauties : List Nat) \n  (friend_pairs : List (Nat × Nat)) : Int :=\n  sorry", "vc-theorems": "theorem party_weights_result_bounded \n  (n m w : Nat) \n  (weights beauties : List Nat)\n  (friend_pairs : List (Nat × Nat))\n  (h1 : n ≥ 1) (h2 : n ≤ 20)\n  (h3 : m ≥ 0) (h4 : m ≤ 10)\n  (h5 : w ≥ 1) (h6 : w ≤ 100)\n  (h7 : weights.length = n)\n  (h8 : beauties.length = n)\n  (h9 : ∀ x ∈ weights, x ≥ 1 ∧ x ≤ 50)\n  (h10 : ∀ x ∈ beauties, x ≥ 1 ∧ x ≤ 20)\n  (h11 : friend_pairs.length ≤ 10)\n  (h12 : ∀ p ∈ friend_pairs, p.1 ≥ 1 ∧ p.1 ≤ 20 ∧ p.2 ≥ 1 ∧ p.2 ≤ 20) :\n  let result := solve_party_weights n m w weights beauties friend_pairs\n  (result ≥ -1 ∧ result ≤ beauties.sum) :=\n  sorry\n\ntheorem party_weights_invalid_when_weight_too_small\n  (n m w : Nat)\n  (weights beauties : List Nat)\n  (friend_pairs : List (Nat × Nat))\n  (h1 : n ≥ 1) (h2 : n ≤ 20)\n  (h3 : m ≥ 0) (h4 : m ≤ 10)\n  (h5 : w ≥ 1) (h6 : w ≤ 100)\n  (h7 : weights.length = n)\n  (h8 : beauties.length = n)\n  (h9 : ∀ x ∈ weights, x ≥ 1 ∧ x ≤ 50)\n  (h10 : w < weights.minimum) :\n  solve_party_weights n m w weights beauties friend_pairs = -1 :=\n  sorry\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval solve_party_weights 3 1 5 [3, 2, 5] [2, 4, 2] [(1, 2)]\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval solve_party_weights 4 2 11 [2, 4, 6, 6] [6, 4, 2, 1] [(1, 2), (2, 3)]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2069", "language": "lean", "source": "fvapps", "source-id": "fvapps_002069", "source-notes": "", "vc-description": "/-\nConsider a tree $T$ (that is, a connected graph without cycles) with $n$ vertices labelled $1$ through $n$. We start the following process with $T$: while $T$ has more than one vertex, do the following:\n\n choose a random edge of $T$ equiprobably;\n\n shrink the chosen edge: if the edge was connecting vertices $v$ and $u$, erase both $v$ and $u$ and create a new vertex adjacent to all vertices previously adjacent to either $v$ or $u$. The new vertex is labelled either $v$ or $u$ equiprobably.\n\nAt the end of the process, $T$ consists of a single vertex labelled with one of the numbers $1, \\ldots, n$. For each of the numbers, what is the probability of this number becoming the label of the final vertex?\n\n-----Input-----\n\nThe first line contains a single integer $n$ ($1 \\leq n \\leq 50$).\n\nThe following $n - 1$ lines describe the tree edges. Each of these lines contains two integers $u_i, v_i$ — labels of vertices connected by the respective edge ($1 \\leq u_i, v_i \\leq n$, $u_i \\neq v_i$). It is guaranteed that the given graph is a tree.\n\n-----Output-----\n\nPrint $n$ floating numbers — the desired probabilities for labels $1, \\ldots, n$ respectively. All numbers should be correct up to $10^{-6}$ relative or absolute precision.\n\n-----Examples-----\nInput\n4\n1 2\n1 3\n1 4\n\nOutput\n0.1250000000\n0.2916666667\n0.2916666667\n0.2916666667\n\nInput\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n\nOutput\n0.0850694444\n0.0664062500\n0.0664062500\n0.1955295139\n0.1955295139\n0.1955295139\n0.1955295139\n\n-----Note-----\n\nIn the first sample, the resulting vertex has label 1 if and only if for all three edges the label 1 survives, hence the probability is $1/2^3 = 1/8$. All other labels have equal probability due to symmetry, hence each of them has probability $(1 - 1/8) / 3 = 7/24$.\n-/", "vc-preamble": "def abs (x : Float) : Float :=\nsorry\n\ndef List.sum (xs : List Float) : Float :=\nsorry", "vc-helpers": "", "vc-definitions": "def tree_shrinking_probabilities (n : Nat) (edges : List (Nat × Nat)) : List Float :=\nsorry", "vc-theorems": "theorem tree_shrinking_probabilities_length_matches_input (n : Nat) (edges : List (Nat × Nat)) :\n  List.length (tree_shrinking_probabilities n edges) = n :=\nsorry\n\ntheorem tree_shrinking_probabilities_in_probability_range (n : Nat) (edges : List (Nat × Nat)) :\n  ∀ p ∈ tree_shrinking_probabilities n edges, 0 ≤ p ∧ p ≤ 1 :=\nsorry\n\ntheorem tree_shrinking_probabilities_sum_to_one (n : Nat) (edges : List (Nat × Nat)) :\n  let probs := tree_shrinking_probabilities n edges \n  Float.abs (List.sum probs - 1) < 1e-6 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2071", "language": "lean", "source": "fvapps", "source-id": "fvapps_002071", "source-notes": "", "vc-description": "/-\nEverybody seems to think that the Martians are green, but it turns out they are metallic pink and fat. Ajs has two bags of distinct nonnegative integers. The bags are disjoint, and the union of the sets of numbers in the bags is $\\{0,1,…,M-1\\}$, for some positive integer $M$. Ajs draws a number from the first bag and a number from the second bag, and then sums them modulo $M$.\n\nWhat are the residues modulo $M$ that Ajs cannot obtain with this action?\n\n-----Input-----\n\nThe first line contains two positive integer $N$ ($1 \\leq N \\leq 200\\,000$) and $M$ ($N+1 \\leq M \\leq 10^{9}$), denoting the number of the elements in the first bag and the modulus, respectively.\n\nThe second line contains $N$ nonnegative integers $a_1,a_2,\\ldots,a_N$ ($0 \\leq a_1<a_2< \\ldots< a_N<M$), the contents of the first bag.\n\n-----Output-----\n\nIn the first line, output the cardinality $K$ of the set of residues modulo $M$ which Ajs cannot obtain.\n\nIn the second line of the output, print $K$ space-separated integers greater or equal than zero and less than $M$, which represent the residues Ajs cannot obtain. The outputs should be sorted in increasing order of magnitude. If $K$=0, do not output the second line.\n\n-----Examples-----\nInput\n2 5\n3 4\n\nOutput\n1\n2\n\nInput\n4 1000000000\n5 25 125 625\n\nOutput\n0\n\nInput\n2 4\n1 3\n\nOutput\n2\n0 2\n\n-----Note-----\n\nIn the first sample, the first bag and the second bag contain $\\{3,4\\}$ and $\\{0,1,2\\}$, respectively. Ajs can obtain every residue modulo $5$ except the residue $2$: $ 4+1 \\equiv 0, \\, 4+2 \\equiv 1, \\, 3+0 \\equiv 3, \\, 3+1 \\equiv 4 $ modulo $5$. One can check that there is no choice of elements from the first and the second bag which sum to $2$ modulo $5$.\n\nIn the second sample, the contents of the first bag are $\\{5,25,125,625\\}$, while the second bag contains all other nonnegative integers with at most $9$ decimal digits. Every residue modulo $1\\,000\\,000\\,000$ can be obtained as a sum of an element in the first bag and an element in the second bag.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_impossible_sums (n : Int) (m : Int) (first_bag : List Int) : FindImpossibleSums :=\n  sorry", "vc-theorems": "theorem find_impossible_sums_properties\n  {n m : Int}\n  {first_bag : List Int}\n  (h1 : 1 ≤ n ∧ n ≤ 10) \n  (h2 : 2 ≤ m)\n  (h3 : first_bag.length = n)\n  (h4 : ∀ x ∈ first_bag, 0 ≤ x ∧ x < m) :\n  let result := find_impossible_sums n m first_bag\n  -- Count matches length of sums\n  result.count = result.sums.length ∧\n  -- All sums are within modulo m  \n  (∀ x ∈ result.sums, 0 ≤ x ∧ x < m) ∧\n  -- Sums are increasing\n  List.Pairwise (fun a b => a < b) result.sums ∧\n  -- Count is non-negative and at most n\n  0 ≤ result.count ∧ result.count ≤ n :=\n  sorry\n\ntheorem find_impossible_sums_unique_sorted\n  {n m : Int}\n  {first_bag : List Int}\n  (h1 : 1 ≤ n ∧ n ≤ 10)\n  (h2 : 2 ≤ m ∧ m ≤ 100)\n  (h3 : first_bag.length = n)\n  (h4 : ∀ x ∈ first_bag, 0 ≤ x ∧ x < m) :\n  let result := find_impossible_sums n m first_bag\n  -- All sums less than modulo\n  (∀ x ∈ result.sums, x < m) ∧\n  -- No duplicates\n  result.sums.Nodup :=\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2092", "language": "lean", "source": "fvapps", "source-id": "fvapps_002092", "source-notes": "", "vc-description": "/-\nJzzhu has picked n apples from his big apple tree. All the apples are numbered from 1 to n. Now he wants to sell them to an apple store. \n\nJzzhu will pack his apples into groups and then sell them. Each group must contain two apples, and the greatest common divisor of numbers of the apples in each group must be greater than 1. Of course, each apple can be part of at most one group.\n\nJzzhu wonders how to get the maximum possible number of groups. Can you help him?\n\n-----Input-----\n\nA single integer n (1 ≤ n ≤ 10^5), the number of the apples.\n\n-----Output-----\n\nThe first line must contain a single integer m, representing the maximum number of groups he can get. Each of the next m lines must contain two integers — the numbers of apples in the current group.\n\nIf there are several optimal answers you can print any of them.\n\n-----Examples-----\nInput\n6\n\nOutput\n2\n6 3\n2 4\n\nInput\n9\n\nOutput\n3\n9 3\n2 4\n6 8\n\nInput\n2\n\nOutput\n0\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_max_pairs (n: Nat) : List (Nat × Nat) := sorry\n\ntheorem find_max_pairs_range {n: Nat} (h: n ≥ 2) :\n  let result := find_max_pairs n\n  let flat_nums := result.bind (λ p => [p.1, p.2])\n  ∀ x ∈ flat_nums, 1 ≤ x ∧ x ≤ n := \nsorry", "vc-theorems": "theorem find_max_pairs_unique {n: Nat} (h: n ≥ 2) :\n  let result := find_max_pairs n\n  let flat_nums := result.bind (λ p => [p.1, p.2])\n  ∀ x ∈ flat_nums, ∀ y ∈ flat_nums, x ≠ y → \n    flat_nums.indexOf x ≠ flat_nums.indexOf y :=\nsorry\n\n/-\ninfo: expected_groups\n-/\n-- #guard_msgs in\n-- #eval len find_max_pairs(n)\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval len pair", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2093", "language": "lean", "source": "fvapps", "source-id": "fvapps_002093", "source-notes": "", "vc-description": "/-\nToday Sonya learned about long integers and invited all her friends to share the fun. Sonya has an initially empty multiset with integers. Friends give her t queries, each of one of the following type:   +  a_{i} — add non-negative integer a_{i} to the multiset. Note, that she has a multiset, thus there may be many occurrences of the same integer.   -  a_{i} — delete a single occurrence of non-negative integer a_{i} from the multiset. It's guaranteed, that there is at least one a_{i} in the multiset.  ? s — count the number of integers in the multiset (with repetitions) that match some pattern s consisting of 0 and 1. In the pattern, 0 stands for the even digits, while 1 stands for the odd. Integer x matches the pattern s, if the parity of the i-th from the right digit in decimal notation matches the i-th from the right digit of the pattern. If the pattern is shorter than this integer, it's supplemented with 0-s from the left. Similarly, if the integer is shorter than the pattern its decimal notation is supplemented with the 0-s from the left. \n\nFor example, if the pattern is s = 010, than integers 92, 2212, 50 and 414 match the pattern, while integers 3, 110, 25 and 1030 do not.\n\n-----Input-----\n\nThe first line of the input contains an integer t (1 ≤ t ≤ 100 000) — the number of operation Sonya has to perform.\n\nNext t lines provide the descriptions of the queries in order they appear in the input file. The i-th row starts with a character c_{i} — the type of the corresponding operation. If c_{i} is equal to '+' or '-' then it's followed by a space and an integer a_{i} (0 ≤ a_{i} < 10^18) given without leading zeroes (unless it's 0). If c_{i} equals '?' then it's followed by a space and a sequence of zeroes and onse, giving the pattern of length no more than 18.\n\nIt's guaranteed that there will be at least one query of type '?'.\n\nIt's guaranteed that any time some integer is removed from the multiset, there will be at least one occurrence of this integer in it.\n\n-----Output-----\n\nFor each query of the third type print the number of integers matching the given pattern. Each integer is counted as many times, as it appears in the multiset at this moment of time.\n\n-----Examples-----\nInput\n12\n+ 1\n+ 241\n? 1\n+ 361\n- 241\n? 0101\n+ 101\n? 101\n- 101\n? 101\n+ 4000\n? 0\n\nOutput\n2\n1\n2\n1\n1\n\nInput\n4\n+ 200\n+ 200\n- 200\n? 0\n\nOutput\n1\n\n-----Note-----\n\nConsider the integers matching the patterns from the queries of the third type. Queries are numbered in the order they appear in the input.   1 and 241.  361.  101 and 361.  361.  4000.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_pattern_matching (ops : List String) : List Nat :=\n  sorry", "vc-theorems": "theorem add_remove_cancel (num : Nat) (count : Nat) (h : 0 < count ∧ count ≤ 5) : \n  let ops := List.join (List.replicate count [s!\"+ {num}\", s!\"- {num}\"]) ++ [s!\"? {toString num}\"]\n  solve_pattern_matching ops = [0]\n  := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2101", "language": "lean", "source": "fvapps", "source-id": "fvapps_002101", "source-notes": "", "vc-description": "/-\nYou are given a string A. Find a string B, where B is a palindrome and A is a subsequence of B.\n\nA subsequence of a string is a string that can be derived from it by deleting some (not necessarily consecutive) characters without changing the order of the remaining characters. For example, \"cotst\" is a subsequence of \"contest\".\n\nA palindrome is a string that reads the same forward or backward.\n\nThe length of string B should be at most 10^4. It is guaranteed that there always exists such string.\n\nYou do not need to find the shortest answer, the only restriction is that the length of string B should not exceed 10^4.\n\n-----Input-----\n\nFirst line contains a string A (1 ≤ |A| ≤ 10^3) consisting of lowercase Latin letters, where |A| is a length of A.\n\n-----Output-----\n\nOutput single line containing B consisting of only lowercase Latin letters. You do not need to find the shortest answer, the only restriction is that the length of string B should not exceed 10^4. If there are many possible B, print any of them.\n\n-----Examples-----\nInput\naba\n\nOutput\naba\nInput\nab\n\nOutput\naabaa\n\n-----Note-----\n\nIn the first example, \"aba\" is a subsequence of \"aba\" which is a palindrome.\n\nIn the second example, \"ab\" is a subsequence of \"aabaa\" which is a palindrome.\n-/", "vc-preamble": "def isPalindrome (s : String) : Bool := sorry\n\ndef isSubsequence (sub orig : String) : Bool := sorry\n\ndef startsWithStr (s pre : String) : Bool := sorry\n\n/- Function that finds a palindrome supersequence of a given string -/", "vc-helpers": "", "vc-definitions": "def find_palindrome_supersequence (s : String) : String := sorry\n\n/- The result is a palindrome -/", "vc-theorems": "theorem result_is_palindrome (s : String) :\n  let result := find_palindrome_supersequence s\n  isPalindrome result = true := sorry\n\n/- The original string is a subsequence of the result -/\n\ntheorem original_is_subsequence (s : String) :\n  let result := find_palindrome_supersequence s\n  isSubsequence s result = true := sorry\n\n/- The length of the result is twice the original length -/\n\ntheorem length_property (s : String) :\n  let result := find_palindrome_supersequence s\n  result.length = 2 * s.length := sorry\n\n/- The result starts with the original string -/\n\ntheorem starts_with_original (s : String) :\n  let result := find_palindrome_supersequence s\n  startsWithStr result s = true := sorry\n\n/- Empty string case -/\n\ntheorem empty_string :\n  find_palindrome_supersequence \"\" = \"\" := sorry\n\nend PalindromeSupersequence\n\n/-\ninfo: 'abaaba'\n-/\n-- #guard_msgs in\n-- #eval find_palindrome_supersequence \"aba\"\n\n/-\ninfo: 'abba'\n-/\n-- #guard_msgs in\n-- #eval find_palindrome_supersequence \"ab\"\n\n/-\ninfo: 'abcabbacba'\n-/\n-- #guard_msgs in\n-- #eval find_palindrome_supersequence \"abcab\"", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2111", "language": "lean", "source": "fvapps", "source-id": "fvapps_002111", "source-notes": "", "vc-description": "/-\nPolycarpus is a system administrator. There are two servers under his strict guidance — a and b. To stay informed about the servers' performance, Polycarpus executes commands \"ping a\" and \"ping b\". Each ping command sends exactly ten packets to the server specified in the argument of the command. Executing a program results in two integers x and y (x + y = 10; x, y ≥ 0). These numbers mean that x packets successfully reached the corresponding server through the network and y packets were lost.\n\nToday Polycarpus has performed overall n ping commands during his workday. Now for each server Polycarpus wants to know whether the server is \"alive\" or not. Polycarpus thinks that the server is \"alive\", if at least half of the packets that we send to this server reached it successfully along the network.\n\nHelp Polycarpus, determine for each server, whether it is \"alive\" or not by the given commands and their results.\n\n-----Input-----\n\nThe first line contains a single integer n (2 ≤ n ≤ 1000) — the number of commands Polycarpus has fulfilled. Each of the following n lines contains three integers — the description of the commands. The i-th of these lines contains three space-separated integers t_{i}, x_{i}, y_{i} (1 ≤ t_{i} ≤ 2; x_{i}, y_{i} ≥ 0; x_{i} + y_{i} = 10). If t_{i} = 1, then the i-th command is \"ping a\", otherwise the i-th command is \"ping b\". Numbers x_{i}, y_{i} represent the result of executing this command, that is, x_{i} packets reached the corresponding server successfully and y_{i} packets were lost.\n\nIt is guaranteed that the input has at least one \"ping a\" command and at least one \"ping b\" command.\n\n-----Output-----\n\nIn the first line print string \"LIVE\" (without the quotes) if server a is \"alive\", otherwise print \"DEAD\" (without the quotes).\n\nIn the second line print the state of server b in the similar format.\n\n-----Examples-----\nInput\n2\n1 5 5\n2 6 4\n\nOutput\nLIVE\nLIVE\n\nInput\n3\n1 0 10\n2 0 10\n1 10 0\n\nOutput\nLIVE\nDEAD\n\n-----Note-----\n\nConsider the first test case. There 10 packets were sent to server a, 5 of them reached it. Therefore, at least half of all packets sent to this server successfully reached it through the network. Overall there were 10 packets sent to server b, 6 of them reached it. Therefore, at least half of all packets sent to this server successfully reached it through the network.\n\nConsider the second test case. There were overall 20 packages sent to server a, 10 of them reached it. Therefore, at least half of all packets sent to this server successfully reached it through the network. Overall 10 packets were sent to server b, 0 of them reached it. Therefore, less than half of all packets sent to this server successfully reached it through the network.\n-/", "vc-preamble": "def check_servers_alive (cmds: List Command) : List Status := sorry\n\ntheorem check_servers_alive_length (cmds: List Command) : \n  cmds.length > 0 → (check_servers_alive cmds).length = 2 := sorry", "vc-helpers": "", "vc-definitions": "def isLive (total: Nat) (failures: Nat) : Bool :=\n  total = 0 || (total - failures ≥ total / 2)", "vc-theorems": "theorem check_servers_alive_valid_statuses (cmds: List Command) :\n  cmds.length > 0 → ∀ s ∈ check_servers_alive cmds, s = Status.LIVE ∨ s = Status.DEAD := sorry\n\ntheorem check_servers_alive_server_a (cmds: List Command) (ta da: Nat) :\n  ta = (cmds.filter (λ c => c.server = 1)).foldr (λ c acc => c.success + c.failure + acc) 0 →\n  da = (cmds.filter (λ c => c.server = 1)).foldr (λ c acc => c.failure + acc) 0 →\n  cmds.length > 0 →\n  (check_servers_alive cmds)[0]! = \n    if isLive ta da then Status.LIVE else Status.DEAD := sorry\n\ntheorem check_servers_alive_server_b (cmds: List Command) (tb db: Nat) :\n  tb = (cmds.filter (λ c => c.server = 2)).foldr (λ c acc => c.success + c.failure + acc) 0 →\n  db = (cmds.filter (λ c => c.server = 2)).foldr (λ c acc => c.failure + acc) 0 →\n  cmds.length > 0 →\n  (check_servers_alive cmds)[1]! = \n    if isLive tb db then Status.LIVE else Status.DEAD := sorry\n\ntheorem check_servers_alive_all_success (n: Nat) :\n  n > 0 →\n  check_servers_alive [(Command.mk 1 n 0), (Command.mk 2 n 0)] = [Status.LIVE, Status.LIVE] := sorry\n\n/-\ninfo: ['LIVE', 'LIVE']\n-/\n-- #guard_msgs in\n-- #eval check_servers_alive [(1, 5, 5), (2, 6, 4)]\n\n/-\ninfo: ['LIVE', 'DEAD']\n-/\n-- #guard_msgs in\n-- #eval check_servers_alive [(1, 0, 10), (2, 0, 10), (1, 10, 0)]\n\n/-\ninfo: ['DEAD', 'DEAD']\n-/\n-- #guard_msgs in\n-- #eval check_servers_alive [(1, 7, 3), (1, 0, 10), (1, 7, 3), (1, 1, 9), (2, 2, 8), (2, 0, 10)]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2119", "language": "lean", "source": "fvapps", "source-id": "fvapps_002119", "source-notes": "", "vc-description": "/-\nSereja loves all sorts of algorithms. He has recently come up with a new algorithm, which receives a string as an input. Let's represent the input string of the algorithm as q = q_1q_2... q_{k}. The algorithm consists of two steps:\n\n  Find any continuous subsequence (substring) of three characters of string q, which doesn't equal to either string \"zyx\", \"xzy\", \"yxz\". If q doesn't contain any such subsequence, terminate the algorithm, otherwise go to step 2.  Rearrange the letters of the found subsequence randomly and go to step 1. \n\nSereja thinks that the algorithm works correctly on string q if there is a non-zero probability that the algorithm will be terminated. But if the algorithm anyway will work for infinitely long on a string, then we consider the algorithm to work incorrectly on this string.\n\nSereja wants to test his algorithm. For that, he has string s = s_1s_2... s_{n}, consisting of n characters. The boy conducts a series of m tests. As the i-th test, he sends substring s_{l}_{i}s_{l}_{i} + 1... s_{r}_{i} (1 ≤ l_{i} ≤ r_{i} ≤ n) to the algorithm input. Unfortunately, the implementation of his algorithm works too long, so Sereja asked you to help. For each test (l_{i}, r_{i}) determine if the algorithm works correctly on this test or not.\n\n-----Input-----\n\nThe first line contains non-empty string s, its length (n) doesn't exceed 10^5. It is guaranteed that string s only contains characters: 'x', 'y', 'z'.\n\nThe second line contains integer m (1 ≤ m ≤ 10^5) — the number of tests. Next m lines contain the tests. The i-th line contains a pair of integers l_{i}, r_{i} (1 ≤ l_{i} ≤ r_{i} ≤ n).\n\n-----Output-----\n\nFor each test, print \"YES\" (without the quotes) if the algorithm works correctly on the corresponding test and \"NO\" (without the quotes) otherwise.\n\n-----Examples-----\nInput\nzyxxxxxxyyz\n5\n5 5\n1 3\n1 11\n1 4\n3 6\n\nOutput\nYES\nYES\nNO\nYES\nNO\n\n-----Note-----\n\nIn the first example, in test one and two the algorithm will always be terminated in one step. In the fourth test you can get string \"xzyx\" on which the algorithm will terminate. In all other tests the algorithm doesn't work correctly.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def checkAlgorithmTermination (s : String) (ranges : List (Nat × Nat)) : List Answer := sorry\n\n/- For ranges of length 1 or 2, the algorithm always terminates -/", "vc-theorems": "theorem singleOrPairTerminates {s : String} {start finish : Nat} :\n  finish - start + 1 ≤ 2 → \n  checkAlgorithmTermination s [(start, finish)] = [Answer.YES] :=\n  sorry\n\n/- For any range, termination depends on character count distribution -/\n\ntheorem terminationCondition {s : String} {start finish : Nat} {x y z : Nat} :\n  (x = y ∧ y = z) ∨\n  (x = y ∧ z = y + 1) ∨\n  (y = z ∧ x = y - 1) ↔\n  checkAlgorithmTermination s [(start, finish)] = [Answer.YES] :=\n  sorry\n\n/- Single character ranges always terminate -/\n\ntheorem singleCharTerminates {s : String} {i : Nat} :\n  i < s.length →\n  checkAlgorithmTermination s [(i+1, i+1)] = [Answer.YES] :=\n  sorry\n\n/- Equal character counts lead to termination -/\n\ntheorem equalCountsTerminate {s : String} {x y z : Nat} :\n  x = y ∧ y = z →\n  checkAlgorithmTermination s [(1, s.length)] = [Answer.YES] :=\n  sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval check_algorithm_termination \"zyxxxxxxyyz\" [(5, 5), (1, 3), (1, 11), (1, 4), (3, 6)]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval check_algorithm_termination \"x\" [(1, 1)]\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval check_algorithm_termination \"xyz\" [(1, 3)]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2120", "language": "lean", "source": "fvapps", "source-id": "fvapps_002120", "source-notes": "", "vc-description": "/-\nLeha plays a computer game, where is on each level is given a connected graph with n vertices and m edges. Graph can contain multiple edges, but can not contain self loops. Each vertex has an integer d_{i}, which can be equal to 0, 1 or  - 1. To pass the level, he needs to find a «good» subset of edges of the graph or say, that it doesn't exist. Subset is called «good», if by by leaving only edges from this subset in the original graph, we obtain the following: for every vertex i, d_{i} =  - 1 or it's degree modulo 2 is equal to d_{i}. Leha wants to pass the game as soon as possible and ask you to help him. In case of multiple correct answers, print any of them.\n\n-----Input-----\n\nThe first line contains two integers n, m (1 ≤ n ≤ 3·10^5, n - 1 ≤ m ≤ 3·10^5) — number of vertices and edges.\n\nThe second line contains n integers d_1, d_2, ..., d_{n} ( - 1 ≤ d_{i} ≤ 1) — numbers on the vertices.\n\nEach of the next m lines contains two integers u and v (1 ≤ u, v ≤ n) — edges. It's guaranteed, that graph in the input is connected.\n\n-----Output-----\n\nPrint  - 1 in a single line, if solution doesn't exist. Otherwise in the first line k — number of edges in a subset. In the next k lines indexes of edges. Edges are numerated in order as they are given in the input, starting from 1.\n\n-----Examples-----\nInput\n1 0\n1\n\nOutput\n-1\n\nInput\n4 5\n0 0 0 -1\n1 2\n2 3\n3 4\n1 4\n2 4\n\nOutput\n0\n\nInput\n2 1\n1 1\n1 2\n\nOutput\n1\n1\n\nInput\n3 3\n0 -1 1\n1 2\n2 3\n1 3\n\nOutput\n1\n2\n\n-----Note-----\n\nIn the first sample we have single vertex without edges. It's degree is 0 and we can not get 1.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem empty_graph_theorem (n : Nat) (degrees : List Int) :\n  n > 0 →\n  degrees.length ≤ n →\n  List.Mem (1 : Int) degrees →\n  solve_graph_subset n 0 degrees [] = [(0:Nat)] := sorry\n\ntheorem empty_graph_valid_theorem (n : Nat) (degrees : List Int) :\n  n > 0 → \n  degrees.length ≤ n →\n  ¬List.Mem (1 : Int) degrees →\n  solve_graph_subset n 0 degrees [] = [] := sorry\n\ntheorem valid_solution_edges_theorem (n m : Nat) (degrees : List Int) (edges : List (Nat × Nat)) :\n  n ≥ 2 →\n  degrees.length = n →\n  edges.length = m →\n  (∀ (e : Nat × Nat), List.Mem e edges → e.1 ≠ e.2) →\n  (∀ (e : Nat × Nat), List.Mem e edges → e.1 ≤ n ∧ e.2 ≤ n) →\n  List.Nodup edges →\n  let result := solve_graph_subset n m degrees edges\n  result ≠ [(0:Nat)] →\n  (∀ e, List.Mem e result → e ≤ m ∧ e ≥ 1) ∧ List.Nodup result := sorry\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval solve_graph_subset 1 0 [1] []\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval solve_graph_subset 4 5 [0, 0, 0, -1] [(1, 2), (2, 3), (3, 4), (1, 4), (2, 4)]\n\n/-\ninfo: [1]\n-/\n-- #guard_msgs in\n-- #eval solve_graph_subset 2 1 [1, 1] [(1, 2)]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2125", "language": "lean", "source": "fvapps", "source-id": "fvapps_002125", "source-notes": "", "vc-description": "/-\nYou've got a list of program warning logs. Each record of a log stream is a string in this format:  \"2012-MM-DD HH:MM:SS:MESSAGE\" (without the quotes). \n\nString \"MESSAGE\" consists of spaces, uppercase and lowercase English letters and characters \"!\", \".\", \",\", \"?\". String \"2012-MM-DD\" determines a correct date in the year of 2012. String \"HH:MM:SS\" determines a correct time in the 24 hour format.\n\nThe described record of a log stream means that at a certain time the record has got some program warning (string \"MESSAGE\" contains the warning's description).\n\nYour task is to print the first moment of time, when the number of warnings for the last n seconds was not less than m.\n\n-----Input-----\n\nThe first line of the input contains two space-separated integers n and m (1 ≤ n, m ≤ 10000).\n\nThe second and the remaining lines of the input represent the log stream. The second line of the input contains the first record of the log stream, the third line contains the second record and so on. Each record of the log stream has the above described format. All records are given in the chronological order, that is, the warning records are given in the order, in which the warnings appeared in the program. \n\nIt is guaranteed that the log has at least one record. It is guaranteed that the total length of all lines of the log stream doesn't exceed 5·10^6 (in particular, this means that the length of some line does not exceed 5·10^6 characters). It is guaranteed that all given dates and times are correct, and the string 'MESSAGE\" in all records is non-empty.\n\n-----Output-----\n\nIf there is no sought moment of time, print -1. Otherwise print a string in the format \"2012-MM-DD HH:MM:SS\" (without the quotes) — the first moment of time when the number of warnings for the last n seconds got no less than m.\n\n-----Examples-----\nInput\n60 3\n2012-03-16 16:15:25: Disk size is\n2012-03-16 16:15:25: Network failute\n2012-03-16 16:16:29: Cant write varlog\n2012-03-16 16:16:42: Unable to start process\n2012-03-16 16:16:43: Disk size is too small\n2012-03-16 16:16:53: Timeout detected\n\nOutput\n2012-03-16 16:16:43\n\nInput\n1 2\n2012-03-16 23:59:59:Disk size\n2012-03-17 00:00:00: Network\n2012-03-17 00:00:01:Cant write varlog\n\nOutput\n-1\n\nInput\n2 2\n2012-03-16 23:59:59:Disk size is too sm\n2012-03-17 00:00:00:Network failute dete\n2012-03-17 00:00:01:Cant write varlogmysq\n\nOutput\n2012-03-17 00:00:00\n-/", "vc-preamble": "def parseDateTime (s : String) : Option DateTime := sorry\n\n/- Convert timestamp to datetime string -/\n\ndef formatDateTime (dt : DateTime) : String := sorry\n\n/- Find first warning threshold function signature -/", "vc-helpers": "", "vc-definitions": "def findFirstWarningThreshold (n m : Nat) (logs : List String) : String := sorry\n\ntheorem find_first_warning_result_format\n  (n m : Nat) (logs : List String)\n  (h1 : n > 0) (h2 : n ≤ 3600)\n  (h3 : m > 0) (h4 : m ≤ 10)\n  (h5 : logs.length > 0) (h6 : logs.length ≤ 20) :\n  let result := findFirstWarningThreshold n m logs\n  result = \"-1\" ∨ (∃ dt : DateTime, formatDateTime dt = result) := sorry", "vc-theorems": "theorem find_first_warning_result_in_logs\n  (n m : Nat) (logs : List String)\n  (h1 : n > 0) (h2 : n ≤ 3600)\n  (h3 : m > 0) (h4 : m ≤ 10)\n  (h5 : logs.length > 0) (h6 : logs.length ≤ 20) :\n  let result := findFirstWarningThreshold n m logs\n  result = \"-1\" ∨ ∃ log ∈ logs, result.isPrefixOf log := sorry\n\ntheorem find_first_warning_window_count\n  (n m : Nat) (logs : List String)\n  (h1 : n > 0) (h2 : n ≤ 3600)\n  (h3 : m > 0) (h4 : m ≤ 10)\n  (h5 : logs.length > 0) (h6 : logs.length ≤ 20) :\n  let result := findFirstWarningThreshold n m logs\n  let resultDt := parseDateTime result\n  match resultDt with\n  | none => result = \"-1\"\n  | some dt =>\n    ∃ windowEvents : List String,\n    windowEvents.length ≥ m ∧\n    ∀ log ∈ windowEvents,\n    match parseDateTime (log.take 19) with\n    | some logDt => logDt.toNat - dt.toNat ≤ n\n    | none => False := sorry\n\ntheorem find_first_warning_empty_cases\n  (logs : List String)\n  (h1 : logs.length > 0) (h2 : logs.length ≤ 20) :\n  findFirstWarningThreshold 0 1 logs = \"-1\" := sorry\n\ntheorem find_first_warning_impossible_cases\n  (n : Nat) (logs : List String)\n  (h1 : logs.length > 0) (h2 : logs.length ≤ 20) :\n  findFirstWarningThreshold n (logs.length + 1) logs = \"-1\" := sorry\n\n/-\ninfo: '2012-03-16 16:16:43'\n-/\n-- #guard_msgs in\n-- #eval find_first_warning_threshold 60 3 [\"2012-03-16 16:15:25: Disk size is\", \"2012-03-16 16:15:25: Network failute\", \"2012-03-16 16:16:29: Cant write varlog\", \"2012-03-16 16:16:42: Unable to start process\", \"2012-03-16 16:16:43: Disk size is too small\", \"2012-03-16 16:16:53: Timeout detected\"]\n\n/-\ninfo: '-1'\n-/\n-- #guard_msgs in\n-- #eval find_first_warning_threshold 1 2 [\"2012-03-16 23:59:59:Disk size\", \"2012-03-17 00:00:00: Network\", \"2012-03-17 00:00:01:Cant write varlog\"]\n\n/-\ninfo: '2012-03-17 00:00:00'\n-/\n-- #guard_msgs in\n-- #eval find_first_warning_threshold 2 2 [\"2012-03-16 23:59:59:Disk size is too sm\", \"2012-03-17 00:00:00:Network failute dete\", \"2012-03-17 00:00:01:Cant write varlogmysq\"]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2127", "language": "lean", "source": "fvapps", "source-id": "fvapps_002127", "source-notes": "", "vc-description": "/-\nFor strings s and t, we will say that s and t are prefix-free when neither is a prefix of the other.\nLet L be a positive integer. A set of strings S is a good string set when the following conditions hold true:\n - Each string in S has a length between 1 and L (inclusive) and consists of the characters 0 and 1.\n - Any two distinct strings in S are prefix-free.\nWe have a good string set S = \\{ s_1, s_2, ..., s_N \\}. Alice and Bob will play a game against each other. They will alternately perform the following operation, starting from Alice:\n - Add a new string to S. After addition, S must still be a good string set.\nThe first player who becomes unable to perform the operation loses the game. Determine the winner of the game when both players play optimally.\n\n-----Constraints-----\n - 1 \\leq N \\leq 10^5\n - 1 \\leq L \\leq 10^{18}\n - s_1, s_2, ..., s_N are all distinct.\n - { s_1, s_2, ..., s_N } is a good string set.\n - |s_1| + |s_2| + ... + |s_N| \\leq 10^5\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN L\ns_1\ns_2\n:\ns_N\n\n-----Output-----\nIf Alice will win, print Alice; if Bob will win, print Bob.\n\n-----Sample Input-----\n2 2\n00\n01\n\n-----Sample Output-----\nAlice\n\nIf Alice adds 1, Bob will be unable to add a new string.\n-/", "vc-preamble": "def solve_prefix_free_game (g : PrefixFreeGame) : Result :=\n  sorry", "vc-helpers": "", "vc-definitions": "def grundy (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem grundy_positive (n : Nat) : \n  0 < grundy n :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2128", "language": "lean", "source": "fvapps", "source-id": "fvapps_002128", "source-notes": "", "vc-description": "/-\nZookeeper is buying a carton of fruit to feed his pet wabbit. The fruits are a sequence of apples and oranges, which is represented by a binary string $s_1s_2\\ldots s_n$ of length $n$. $1$ represents an apple and $0$ represents an orange.\n\nSince wabbit is allergic to eating oranges, Zookeeper would like to find the longest contiguous sequence of apples. Let $f(l,r)$ be the longest contiguous sequence of apples in the substring $s_{l}s_{l+1}\\ldots s_{r}$. \n\nHelp Zookeeper find $\\sum_{l=1}^{n} \\sum_{r=l}^{n} f(l,r)$, or the sum of $f$ across all substrings.\n\n-----Input-----\n\nThe first line contains a single integer $n$ $(1 \\leq n \\leq 5 \\cdot 10^5)$.\n\n The next line contains a binary string $s$ of length $n$ $(s_i \\in \\{0,1\\})$ \n\n-----Output-----\n\nPrint a single integer: $\\sum_{l=1}^{n} \\sum_{r=l}^{n} f(l,r)$. \n\n-----Examples-----\nInput\n4\n0110\n\nOutput\n12\n\nInput\n7\n1101001\n\nOutput\n30\n\nInput\n12\n011100011100\n\nOutput\n156\n\n-----Note-----\n\nIn the first test, there are ten substrings. The list of them (we let $[l,r]$ be the substring $s_l s_{l+1} \\ldots s_r$):  $[1,1]$: 0  $[1,2]$: 01  $[1,3]$: 011  $[1,4]$: 0110  $[2,2]$: 1  $[2,3]$: 11  $[2,4]$: 110  $[3,3]$: 1  $[3,4]$: 10  $[4,4]$: 0 \n\nThe lengths of the longest contiguous sequence of ones in each of these ten substrings are $0,1,2,2,1,2,2,1,1,0$ respectively. Hence, the answer is $0+1+2+2+1+2+2+1+1+0 = 12$.\n-/", "vc-preamble": "def SegmentTree.query (tree : SegmentTree) (i j : Nat) : Nat :=\n  sorry\n\ndef longest_apple_sequence (n : Nat) (s : List Bool) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def list_max : List Nat → Nat \n| [] => 0\n| [x] => x\n| (x::xs) => max x (list_max xs)", "vc-theorems": "theorem query_matches_slice_max {lst : List Nat} {tree : SegmentTree} \n  (h : tree.lst = lst) :\n  ∀ i j, i < j → j ≤ lst.length →\n  tree.query i j = list_max (List.drop i (List.take j lst)) :=\n  sorry\n\ntheorem query_whole_list {lst : List Nat} {tree : SegmentTree}\n  (h : tree.lst = lst) :\n  tree.query 0 lst.length = list_max lst :=\n  sorry\n\ntheorem query_single_element {lst : List Nat} {tree : SegmentTree}\n  (h : tree.lst = lst) :\n  ∀ (i : Nat) (h : i < lst.length),\n  tree.query i (i+1) = lst[i]'h :=\n  sorry\n\ntheorem longest_apple_sequence_non_negative \n  (n : Nat) (s : List Bool) :\n  longest_apple_sequence n s ≥ 0 :=\n  sorry\n\ntheorem all_zeros_gives_zero (n : Nat) (s : List Bool)\n  (h : ∀ x ∈ s, x = false) :\n  longest_apple_sequence n s = 0 :=\n  sorry\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval longest_apple_sequence 4 \"0110\"\n\n/-\ninfo: 30\n-/\n-- #guard_msgs in\n-- #eval longest_apple_sequence 7 \"1101001\"\n\n/-\ninfo: 156\n-/\n-- #guard_msgs in\n-- #eval longest_apple_sequence 12 \"011100011100\"", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2133", "language": "lean", "source": "fvapps", "source-id": "fvapps_002133", "source-notes": "", "vc-description": "/-\nYou are an all-powerful being and you have created a rectangular world. In fact, your world is so bland that it could be represented by a $r \\times c$ grid. Each cell on the grid represents a country. Each country has a dominant religion. There are only two religions in your world. One of the religions is called Beingawesomeism, who do good for the sake of being good. The other religion is called Pushingittoofarism, who do murders for the sake of being bad.\n\nOh, and you are actually not really all-powerful. You just have one power, which you can use infinitely many times! Your power involves missionary groups. When a missionary group of a certain country, say $a$, passes by another country $b$, they change the dominant religion of country $b$ to the dominant religion of country $a$.\n\nIn particular, a single use of your power is this:   You choose a horizontal $1 \\times x$ subgrid or a vertical $x \\times 1$ subgrid. That value of $x$ is up to you;  You choose a direction $d$. If you chose a horizontal subgrid, your choices will either be NORTH or SOUTH. If you choose a vertical subgrid, your choices will either be EAST or WEST;  You choose the number $s$ of steps;  You command each country in the subgrid to send a missionary group that will travel $s$ steps towards direction $d$. In each step, they will visit (and in effect convert the dominant religion of) all $s$ countries they pass through, as detailed above.  The parameters $x$, $d$, $s$ must be chosen in such a way that any of the missionary groups won't leave the grid. \n\nThe following image illustrates one possible single usage of your power. Here, A represents a country with dominant religion Beingawesomeism and P represents a country with dominant religion Pushingittoofarism. Here, we've chosen a $1 \\times 4$ subgrid, the direction NORTH, and $s = 2$ steps.  [Image] \n\nYou are a being which believes in free will, for the most part. However, you just really want to stop receiving murders that are attributed to your name. Hence, you decide to use your powers and try to make Beingawesomeism the dominant religion in every country.\n\nWhat is the minimum number of usages of your power needed to convert everyone to Beingawesomeism?\n\nWith god, nothing is impossible. But maybe you're not god? If it is impossible to make Beingawesomeism the dominant religion in all countries, you must also admit your mortality and say so.\n\n-----Input-----\n\nThe first line of input contains a single integer $t$ ($1 \\le t \\le 2\\cdot 10^4$) denoting the number of test cases.\n\nThe first line of each test case contains two space-separated integers $r$ and $c$ denoting the dimensions of the grid ($1 \\le r, c \\le 60$). The next $r$ lines each contains $c$ characters describing the dominant religions in the countries. In particular, the $j$-th character in the $i$-th line describes the dominant religion in the country at the cell with row $i$ and column $j$, where:  \"A\" means that the dominant religion is Beingawesomeism;  \"P\" means that the dominant religion is Pushingittoofarism. \n\nIt is guaranteed that the grid will only contain \"A\" or \"P\" characters. It is guaranteed that the sum of the $r \\cdot c$ in a single file is at most $3 \\cdot 10^6$.\n\n-----Output-----\n\nFor each test case, output a single line containing the minimum number of usages of your power needed to convert everyone to Beingawesomeism, or the string \"MORTAL\" (without quotes) if it is impossible to do so. \n\n-----Example-----\nInput\n4\n7 8\nAAPAAAAA\nPPPPAAAA\nPPPPAAAA\nAPAAPPPP\nAPAPPAPP\nAAAAPPAP\nAAAAPPAA\n6 5\nAAAAA\nAAAAA\nAAPAA\nAAPAP\nAAAPP\nAAAPP\n4 4\nPPPP\nPPPP\nPPPP\nPPPP\n3 4\nPPPP\nPAAP\nPPPP\n\nOutput\n2\n1\nMORTAL\n4\n\n-----Note-----\n\nIn the first test case, it can be done in two usages, as follows:\n\nUsage 1: [Image] \n\nUsage 2: [Image] \n\nIn the second test case, it can be done with just one usage of the power. \n\nIn the third test case, it is impossible to convert everyone to Beingawesomeism, so the answer is \"MORTAL\".\n-/", "vc-preamble": "def solve_religion_grid (r c : Nat) (grid : Grid) : Answer := sorry\n\ntheorem output_format (r c : Nat) (grid : Grid) :\n  let result := solve_religion_grid r c grid\n  result = \"0\" ∨ result = \"1\" ∨ result = \"2\" ∨ result = \"3\" ∨ result = \"4\" ∨ result = \"MORTAL\" :=\nsorry", "vc-helpers": "", "vc-definitions": "def inList {α : Type} (x : α) (xs : List α) : Prop := x ∈ xs\n\ntheorem all_p_is_mortal (r c : Nat) (grid : Grid) :\n  (∀ (row : List GridChar), inList row grid → \n   ∀ (cell : GridChar), inList cell row → cell = GridChar.P) →\n  solve_religion_grid r c grid = \"MORTAL\" :=\nsorry", "vc-theorems": "theorem all_a_is_zero (r c : Nat) (grid : Grid) :\n  (∀ (row : List GridChar), inList row grid → \n   ∀ (cell : GridChar), inList cell row → cell = GridChar.A) →\n  solve_religion_grid r c grid = \"0\" :=\nsorry\n\ntheorem grid_dimensions (r c : Nat) (grid : Grid) :\n  List.length grid = r ∧\n  (∀ (row : List GridChar), inList row grid → List.length row = c) :=\nsorry\n\ntheorem valid_chars (r c : Nat) (grid : Grid) :\n  ∀ (row : List GridChar), inList row grid → \n  ∀ (cell : GridChar), inList cell row → cell = GridChar.A ∨ cell = GridChar.P :=\nsorry\n\ntheorem single_cell (r c : Nat) (grid : Grid) :\n  r = 1 →\n  c = 1 →\n  grid ≠ [] →\n  grid.head! ≠ [] →\n  let result := solve_religion_grid r c grid\n  (grid.head!.head! = GridChar.A → result = \"0\") ∧\n  (grid.head!.head! = GridChar.P → result = \"MORTAL\") :=\nsorry\n\n/-\ninfo: '2'\n-/\n-- #guard_msgs in\n-- #eval solve_religion_grid 7 8 [\"AAPAAAAA\", \"PPPPAAAA\", \"PPPPAAAA\", \"APAAPPPP\", \"APAPPAPP\", \"AAAAPPAP\", \"AAAAPPAA\"]\n\n/-\ninfo: 'MORTAL'\n-/\n-- #guard_msgs in\n-- #eval solve_religion_grid 4 4 [\"PPPP\", \"PPPP\", \"PPPP\", \"PPPP\"]\n\n/-\ninfo: '0'\n-/\n-- #guard_msgs in\n-- #eval solve_religion_grid 1 1 [\"A\"]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2162", "language": "lean", "source": "fvapps", "source-id": "fvapps_002162", "source-notes": "", "vc-description": "/-\nSnuke is playing a puzzle game.\nIn this game, you are given a rectangular board of dimensions R × C, filled with numbers. Each integer i from 1 through N is written twice, at the coordinates (x_{i,1},y_{i,1}) and (x_{i,2},y_{i,2}).\nThe objective is to draw a curve connecting the pair of points where the same integer is written, for every integer from 1 through N.\nHere, the curves may not go outside the board or cross each other.\nDetermine whether this is possible.\n\n-----Constraints-----\n - 1 ≤ R,C ≤ 10^8\n - 1 ≤ N ≤ 10^5\n - 0 ≤ x_{i,1},x_{i,2} ≤ R(1 ≤ i ≤ N)\n - 0 ≤ y_{i,1},y_{i,2} ≤ C(1 ≤ i ≤ N)\n - All given points are distinct.\n - All input values are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nR C N\nx_{1,1} y_{1,1} x_{1,2} y_{1,2}\n:\nx_{N,1} y_{N,1} x_{N,2} y_{N,2}\n\n-----Output-----\nPrint YES if the objective is achievable; print NO otherwise.\n\n-----Sample Input-----\n4 2 3\n0 1 3 1\n1 1 4 1\n2 0 2 2\n\n-----Sample Output-----\nYES\n\nThe above figure shows a possible solution.\n-/", "vc-preamble": "def isOnPerimeter (p : Point) (R C : Int) : Bool :=\n  sorry\n\ndef validPairs (p1 p2 : Point) (R C : Int) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def canDrawCurves (R C N : Int) (pairs : List (Point × Point)) : String :=\n  sorry\n\n-- Theorem: Output is either YES or NO", "vc-theorems": "theorem output_format (R C N : Int) (pairs : List (Point × Point)) :\n  (canDrawCurves R C N pairs = \"YES\") ∨ (canDrawCurves R C N pairs = \"NO\") :=\n  sorry\n\n-- Theorem: Empty list of pairs always returns YES\n\ntheorem empty_pairs_is_yes (R C : Int) :\n  canDrawCurves R C 0 [] = \"YES\" :=\n  sorry\n\n-- Theorem: Same point pairs always return YES\n\ntheorem same_point_pairs (R C : Int) (p : Point) :\n  isOnPerimeter p R C → canDrawCurves R C 1 [(p, p)] = \"YES\" :=\n  sorry\n\n/-\ninfo: 'YES'\n-/\n-- #guard_msgs in\n-- #eval can_draw_curves 4 2 3 [[0, 1, 3, 1], [1, 1, 4, 1], [2, 0, 2, 2]]\n\n/-\ninfo: 'NO'\n-/\n-- #guard_msgs in\n-- #eval can_draw_curves 2 2 4 [[0, 0, 2, 2], [2, 0, 0, 1], [0, 2, 1, 2], [1, 1, 2, 1]]\n\n/-\ninfo: 'NO'\n-/\n-- #guard_msgs in\n-- #eval can_draw_curves 1 1 2 [[0, 0, 1, 1], [1, 0, 0, 1]]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2163", "language": "lean", "source": "fvapps", "source-id": "fvapps_002163", "source-notes": "", "vc-description": "/-\nYou are given a string S consisting of a,b and c. Find the number of strings that can be possibly obtained by repeatedly performing the following operation zero or more times, modulo 998244353:\n - Choose an integer i such that 1\\leq i\\leq |S|-1 and the i-th and (i+1)-th characters in S are different. Replace each of the i-th and (i+1)-th characters in S with the character that differs from both of them (among a, b and c).\n\n-----Constraints-----\n - 2 \\leq |S| \\leq 2 × 10^5\n - S consists of a, b and c.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nS\n\n-----Output-----\nPrint the number of strings that can be possibly obtained by repeatedly performing the operation, modulo 998244353.\n\n-----Sample Input-----\nabc\n\n-----Sample Output-----\n3\n\nabc, aaa and ccc can be obtained.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_abc_strings (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem output_range (s : String) \n  (h : ∀ c ∈ s.data, c = 'a' ∨ c = 'b' ∨ c = 'c') \n  (h2 : s ≠ \"\") : \n  let result := solve_abc_strings s\n  0 ≤ result ∧ result < 998244353 := sorry\n\ntheorem single_char_repeated (n : Nat) (c : Char)\n  (h : c = 'a' ∨ c = 'b' ∨ c = 'c')\n  (h2 : n > 0) :\n  solve_abc_strings (String.mk (List.replicate n c)) = 1 := sorry\n\ntheorem alternating_pattern (n : Nat)\n  (h : n > 0) :\n  solve_abc_strings (String.mk (List.join (List.replicate n ['a', 'b']))) ≠ 1 ∧\n  solve_abc_strings (String.mk (List.join (List.replicate n ['b', 'c']))) ≠ 1 ∧ \n  solve_abc_strings (String.mk (List.join (List.replicate n ['a', 'c']))) ≠ 1 := sorry\n\ntheorem empty_string :\n  solve_abc_strings \"\" = 0 := sorry\n\ntheorem single_char (c : Char)\n  (h : c = 'a' ∨ c = 'b' ∨ c = 'c') :\n  solve_abc_strings (String.mk [c]) = 1 := sorry\n\ntheorem valid_chars (s : String) :\n  ∀ c ∈ s.data, c = 'a' ∨ c = 'b' ∨ c = 'c' := sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval solve_abc_strings \"abc\"\n\n/-\ninfo: 65\n-/\n-- #guard_msgs in\n-- #eval solve_abc_strings \"abbac\"\n\n/-\ninfo: 6310\n-/\n-- #guard_msgs in\n-- #eval solve_abc_strings \"babacabac\"", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2166", "language": "lean", "source": "fvapps", "source-id": "fvapps_002166", "source-notes": "", "vc-description": "/-\nThere are M chairs arranged in a line. The coordinate of the i-th chair (1 ≤ i ≤ M) is i.\nN people of the Takahashi clan played too much games, and they are all suffering from backaches. They need to sit in chairs and rest, but they are particular about which chairs they sit in. Specifically, the i-th person wishes to sit in a chair whose coordinate is not greater than L_i, or not less than R_i. Naturally, only one person can sit in the same chair.\nIt may not be possible for all of them to sit in their favorite chairs, if nothing is done.\nAoki, who cares for the health of the people of the Takahashi clan, decides to provide additional chairs so that all of them can sit in chairs at their favorite positions.\nAdditional chairs can be placed at arbitrary real coordinates. Find the minimum required number of additional chairs.\n\n-----Constraints-----\n - 1 ≤ N,M ≤ 2 × 10^5\n - 0 ≤ L_i < R_i ≤ M + 1(1 ≤ i ≤ N)\n - All input values are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nL_1 R_1\n:\nL_N R_N\n\n-----Output-----\nPrint the minimum required number of additional chairs.\n\n-----Sample Input-----\n4 4\n0 3\n2 3\n1 3\n3 4\n\n-----Sample Output-----\n0\n\nThe four people can sit in chairs at the coordinates 3, 2, 1 and 4, respectively, and no more chair is needed.\n-/", "vc-preamble": "def initTree (M : Nat) : LazySegmentTree M := sorry\ndef updateTree (M : Nat) : LazySegmentTree M → Nat → Nat → Int → LazySegmentTree M := sorry\n\ndef queryTree (M : Nat) : LazySegmentTree M → Nat → Nat → Int := sorry\n\ndef LV : Nat := sorry", "vc-helpers": "", "vc-definitions": "def N0 : Nat := sorry\ndef INF : Int := sorry", "vc-theorems": "theorem lst_initialization_invariants {M : Nat} (h : M > 0) (h2 : M ≤ 100) :\n  N0 = 2^LV ∧ N0 > 0 := by sorry\n\ntheorem segment_tree_operations_sound {M : Nat} (l r : Nat) (x : Int)\n  (h1 : l ≤ r) (h2 : r < M) (h3 : M > 0)\n  (h4 : l ≤ 10) (h5 : r ≤ 10) (h6 : x ≥ -100) (h7 : x ≤ 100) :\n  let lst := initTree M\n  let lst' := updateTree M lst l r x\n  let result := queryTree M lst' l r \n  x ≥ 0 → result ≤ INF := by sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval solve 4 4 [(0, 3), (2, 3), (1, 3), (3, 4)]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve 7 6 [(0, 7), (1, 5), (3, 6), (2, 7), (1, 6), (2, 6), (3, 7)]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve 3 1 [(1, 2), (1, 2), (1, 2)]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2171", "language": "lean", "source": "fvapps", "source-id": "fvapps_002171", "source-notes": "", "vc-description": "/-\nWe have a permutation of the integers from 1 through N, p_1, p_2, .., p_N.\nWe also have M pairs of two integers between 1 and N (inclusive), represented as (x_1,y_1), (x_2,y_2), .., (x_M,y_M).\nAtCoDeer the deer is going to perform the following operation on p as many times as desired so that the number of i (1 ≤ i ≤ N) such that p_i = i is maximized:\n - Choose j such that 1 ≤ j ≤ M, and swap p_{x_j} and p_{y_j}.\nFind the maximum possible number of i such that p_i = i after operations.\n\n-----Constraints-----\n - 2 ≤ N ≤ 10^5\n - 1 ≤ M ≤ 10^5\n - p is a permutation of integers from 1 through N.\n - 1 ≤ x_j,y_j ≤ N\n - x_j ≠ y_j\n - If i ≠ j, \\{x_i,y_i\\} ≠ \\{x_j,y_j\\}.\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\np_1 p_2 .. p_N\nx_1 y_1\nx_2 y_2\n:\nx_M y_M\n\n-----Output-----\nPrint the maximum possible number of i such that p_i = i after operations.\n\n-----Sample Input-----\n5 2\n5 3 1 4 2\n1 3\n5 4\n\n-----Sample Output-----\n2\n\nIf we perform the operation by choosing j=1, p becomes 1 3 5 4 2, which is optimal, so the answer is 2.\n-/", "vc-preamble": "def UnionFind.new (n : Nat) : UnionFind := sorry\ndef UnionFind.isConnected (uf : UnionFind) (x y : Nat) : Bool := sorry\n\ndef UnionFind.unite (uf : UnionFind) (x y : Nat) : UnionFind := sorry\ndef solve (n m : Nat) (p : List Nat) (swaps : List (Nat × Nat)) : Nat := sorry", "vc-helpers": "", "vc-definitions": "def isValidPerm (arr : List Nat) : Bool := sorry\n\ntheorem solve_permutation_property (p : List Nat) \n  (h1 : p.length ≤ 20) (h2 : p.length > 0)\n  (h3 : isValidPerm (p.map (·-1)) = true) :\n  let n := p.length;\n  let result := solve n 0 p [];\n  0 ≤ result ∧ result ≤ n := by sorry", "vc-theorems": "theorem UnionFind_init (n : Nat) (h : 0 < n) (h2 : n ≤ 100) :\n  let uf := UnionFind.new n;\n  Array.size (UnionFind.size uf) = n ∧ \n  Array.size (UnionFind.parent uf) = n ∧\n  (∀ i, i < n → (UnionFind.size uf)[i]! = 1) ∧\n  (∀ i, i < n → (UnionFind.parent uf)[i]! = i) := by sorry\n\ntheorem UnionFind_reflexive (n : Nat) (h : 0 < n) (h2 : n ≤ 100) :\n  let uf := UnionFind.new n;\n  ∀ i, i < n → UnionFind.isConnected uf i i = true := by sorry\n\ntheorem UnionFind_symmetry (n : Nat) (h : 1 < n) (h2 : n ≤ 100) :\n  let uf := UnionFind.new n;\n  ∀ i, i < n-1 → \n    let uf' := UnionFind.unite uf i (i+1);\n    UnionFind.isConnected uf' i (i+1) = true ∧ \n    UnionFind.isConnected uf' (i+1) i = true := by sorry\n\ntheorem solve_no_swaps (n m : Nat) (h1 : 0 < n) (h2 : n ≤ 20) (h3 : m ≤ 10) :\n  let p := List.range n;\n  let swaps := [];\n  solve n m (p.map (·+1)) swaps = n := by sorry\n\ntheorem solve_valid_swaps (n : Nat) (swaps : List (Nat × Nat)) \n  (h1 : 0 < n) (h2 : n ≤ 20) (h3 : swaps.length ≤ 10) :\n  let p := List.range n |>.map (·+1);\n  let result := solve n swaps.length p swaps;\n  0 ≤ result ∧ result ≤ n := by sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval solve 5 2 #[5, 3, 1, 4, 2] #[(1, 3), (5, 4)]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval solve 3 2 #[3, 2, 1] #[(1, 2), (2, 3)]\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval solve 5 1 #[1, 2, 3, 4, 5] #[(1, 5)]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2186", "language": "lean", "source": "fvapps", "source-id": "fvapps_002186", "source-notes": "", "vc-description": "/-\nWe have a tree with N vertices. The vertices are numbered 1, 2, ..., N. The i-th (1 ≦ i ≦ N - 1) edge connects the two vertices A_i and B_i.\nTakahashi wrote integers into K of the vertices. Specifically, for each 1 ≦ j ≦ K, he wrote the integer P_j into vertex V_j. The remaining vertices are left empty. After that, he got tired and fell asleep.\nThen, Aoki appeared. He is trying to surprise Takahashi by writing integers into all empty vertices so that the following condition is satisfied:\n - Condition: For any two vertices directly connected by an edge, the integers written into these vertices differ by exactly 1.\nDetermine if it is possible to write integers into all empty vertices so that the condition is satisfied. If the answer is positive, find one specific way to satisfy the condition.\n\n-----Constraints-----\n - 1 ≦ N ≦ 10^5\n - 1 ≦ K ≦ N\n - 1 ≦ A_i, B_i ≦ N (1 ≦ i ≦ N - 1)\n - 1 ≦ V_j ≦ N (1 ≦ j ≦ K) (21:18, a mistake in this constraint was corrected)\n - 0 ≦ P_j ≦ 10^5 (1 ≦ j ≦ K)\n - The given graph is a tree.\n - All v_j are distinct.\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN\nA_1 B_1\nA_2 B_2\n:\nA_{N-1} B_{N-1}\nK\nV_1 P_1\nV_2 P_2\n:\nV_K P_K\n\n-----Output-----\nIf it is possible to write integers into all empty vertices so that the condition is satisfied, print Yes. Otherwise, print No.\nIf it is possible to satisfy the condition, print N lines in addition. The v-th (1 ≦ v ≦ N) of these N lines should contain the integer that should be written into vertex v. If there are multiple ways to satisfy the condition, any of those is accepted.\n\n-----Sample Input-----\n5\n1 2\n3 1\n4 3\n3 5\n2\n2 6\n5 7\n\n-----Sample Output-----\nYes\n5\n6\n6\n5\n7\n\nThe figure below shows the tree when Takahashi fell asleep. For each vertex, the integer written beside it represents the index of the vertex, and the integer written into the vertex is the integer written by Takahashi.\nAoki can, for example, satisfy the condition by writing integers into the remaining vertices as follows:\nThis corresponds to Sample Output 1. Note that other outputs that satisfy the condition will also be accepted, such as:\nYes\n7\n6\n8\n7\n7\n-/", "vc-preamble": "def solve_tree_labeling (N : Nat) (edges : List (Nat × Nat)) (K : Nat) \n    (labels : List (Nat × Int)) : Option (List Int) :=\n  sorry\n\ndef valid_solution (g : Graph) (labels : List (Nat × Int)) (result : List Int) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def abs (x : Int) : Int :=\n  if x < 0 then -x else x", "vc-theorems": "theorem line_graph_solution_valid {N K : Nat} {base : Int}\n    (h1 : K ≤ N) (h2 : 0 < N) : \n    let edges := List.range (N-1) |>.map (fun i => (i+1, i+2))\n    let labels := List.range K |>.map (fun i => (i+1, base - ↑i))\n    match solve_tree_labeling N edges K labels with\n    | none => ∀ i j, i < K → j < K → \n        abs (↑(labels.get! i).1 - ↑(labels.get! j).1) = 1 → \n        abs ((labels.get! i).2 - (labels.get! j).2) ≠ 1\n    | some result => valid_solution ⟨N, edges⟩ labels result = true\n    := sorry\n\ntheorem star_graph_solution_exists {N : Nat} {center : Int}\n    (h : 2 < N) :\n    let edges := List.range (N-1) |>.map (fun i => (1, i+2))\n    let labels := [(1, center)]\n    (solve_tree_labeling N edges 1 labels).isSome ∧\n    match solve_tree_labeling N edges 1 labels with\n    | none => False  \n    | some result => valid_solution ⟨N, edges⟩ labels result = true\n    := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2196", "language": "lean", "source": "fvapps", "source-id": "fvapps_002196", "source-notes": "", "vc-description": "/-\nThere is a simple undirected graph with N vertices and M edges.\nThe vertices are numbered 1 through N, and the edges are numbered 1 through M.\nEdge i connects Vertex U_i and V_i.\nAlso, Vertex i has two predetermined integers A_i and B_i.\nYou will play the following game on this graph.\nFirst, choose one vertex and stand on it, with W yen (the currency of Japan) in your pocket.\nHere, A_s \\leq W must hold, where s is the vertex you choose.\nThen, perform the following two kinds of operations any number of times in any order:\n - Choose one vertex v that is directly connected by an edge to the vertex you are standing on, and move to vertex v. Here, you need to have at least A_v yen in your pocket when you perform this move.\n - Donate B_v yen to the vertex v you are standing on. Here, the amount of money in your pocket must not become less than 0 yen.\nYou win the game when you donate once to every vertex.\nFind the smallest initial amount of money W that enables you to win the game.\n\n-----Constraints-----\n - 1 \\leq N \\leq 10^5\n - N-1 \\leq M \\leq 10^5\n - 1 \\leq A_i,B_i \\leq 10^9\n - 1 \\leq U_i < V_i \\leq N\n - The given graph is connected and simple (there is at most one edge between any pair of vertices).\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN M\nA_1 B_1\nA_2 B_2\n:\nA_N B_N\nU_1 V_1\nU_2 V_2\n:\nU_M V_M\n\n-----Output-----\nPrint the smallest initial amount of money W that enables you to win the game.\n\n-----Sample Input-----\n4 5\n3 1\n1 2\n4 1\n6 2\n1 2\n2 3\n2 4\n1 4\n3 4\n\n-----Sample Output-----\n6\n\nIf you have 6 yen initially, you can win the game as follows:\n - Stand on Vertex 4. This is possible since you have not less than 6 yen.\n - Donate 2 yen to Vertex 4. Now you have 4 yen.\n - Move to Vertex 3. This is possible since you have not less than 4 yen.\n - Donate 1 yen to Vertex 3. Now you have 3 yen.\n - Move to Vertex 2. This is possible since you have not less than 1 yen.\n - Move to Vertex 1. This is possible since you have not less than 3 yen.\n - Donate 1 yen to Vertex 1. Now you have 2 yen.\n - Move to Vertex 2. This is possible since you have not less than 1 yen.\n - Donate 2 yen to Vertex 2. Now you have 0 yen.\nIf you have less than 6 yen initially, you cannot win the game. Thus, the answer is 6.\n-/", "vc-preamble": "def DSU.merge (dsu : DSU n) (a b : Nat) : Nat := sorry\ndef DSU.leader (dsu : DSU n) (a : Nat) : Nat := sorry", "vc-helpers": "", "vc-definitions": "def solve_game (n m : Nat) (required gain : Array Int) (edges : Array (Nat × Nat)) : Int := sorry\n\ntheorem single_node_property (n : Nat) :\n  n > 0 →\n  solve_game 1 0 #[n] #[0] #[] = n := sorry", "vc-theorems": "/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval solve_game 4 5 #[3, 1, 4, 6] #[1, 2, 1, 2] #[(1, 2), (2, 3), (2, 4), (1, 4), (3, 4)]\n\n/-\ninfo: 44\n-/\n-- #guard_msgs in\n-- #eval solve_game 5 8 #[6, 15, 15, 15, 20] #[4, 13, 19, 1, 7] #[(1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 5), (4, 5)]\n\n/-\ninfo: 582\n-/\n-- #guard_msgs in\n-- #eval solve_game 9 10 #[131, 98, 242, 231, 382, 224, 140, 209, 164] #[2, 79, 32, 38, 82, 22, 88, 70, 64] #[(6, 8), (1, 6), (1, 4), (1, 3), (4, 7), (4, 9), (3, 7), (3, 9), (5, 9), (2, 5)]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2200", "language": "lean", "source": "fvapps", "source-id": "fvapps_002200", "source-notes": "", "vc-description": "/-\nYou are in charge of controlling a dam. The dam can store at most L liters of water. Initially, the dam is empty. Some amount of water flows into the dam every morning, and any amount of water may be discharged every night, but this amount needs to be set so that no water overflows the dam the next morning.\nIt is known that v_i liters of water at t_i degrees Celsius will flow into the dam on the morning of the i-th day.\nYou are wondering about the maximum possible temperature of water in the dam at noon of each day, under the condition that there needs to be exactly L liters of water in the dam at that time. For each i, find the maximum possible temperature of water in the dam at noon of the i-th day. Here, consider each maximization separately, that is, the amount of water discharged for the maximization of the temperature on the i-th day, may be different from the amount of water discharged for the maximization of the temperature on the j-th day (j≠i).\nAlso, assume that the temperature of water is not affected by anything but new water that flows into the dam. That is, when V_1 liters of water at T_1 degrees Celsius and V_2 liters of water at T_2 degrees Celsius are mixed together, they will become V_1+V_2 liters of water at \\frac{T_1*V_1+T_2*V_2}{V_1+V_2} degrees Celsius, and the volume and temperature of water are not affected by any other factors.\n\n-----Constraints-----\n - 1≤ N ≤ 5*10^5\n - 1≤ L ≤ 10^9\n - 0≤ t_i ≤ 10^9(1≤i≤N)\n - 1≤ v_i ≤ L(1≤i≤N)\n - v_1 = L\n - L, each t_i and v_i are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN L\nt_1 v_1\nt_2 v_2\n:\nt_N v_N\n\n-----Output-----\nPrint N lines. The i-th line should contain the maximum temperature such that it is possible to store L liters of water at that temperature in the dam at noon of the i-th day.\nEach of these values is accepted if the absolute or relative error is at most 10^{-6}.\n\n-----Sample Input-----\n3 10\n10 10\n20 5\n4 3\n\n-----Sample Output-----\n10.0000000\n15.0000000\n13.2000000\n\n - On the first day, the temperature of water in the dam is always 10 degrees: the temperature of the only water that flows into the dam on the first day.\n - 10 liters of water at 15 degrees of Celsius can be stored on the second day, by discharging 5 liters of water on the night of the first day, and mix the remaining water with the water that flows into the dam on the second day.\n - 10 liters of water at 13.2 degrees of Celsius can be stored on the third day, by discharging 8 liters of water on the night of the first day, and mix the remaining water with the water that flows into the dam on the second and third days.\n-/", "vc-preamble": "def Water.subtract (w : Water) (v : Float) : Water :=\n  sorry", "vc-helpers": "", "vc-definitions": "def Water.add (w1 w2 : Water) : Water :=\n  sorry\n\ninstance : LE Water where\n  le := sorry", "vc-theorems": "theorem water_reflexivity (temp vol : Float) (h1 : temp > -1000) (h2 : temp < 1000) \n    (h3 : vol > 0.1) (h4 : vol < 1000) :\n  let w := { temp := temp, volume := vol : Water }\n  w ≤ w :=\nsorry\n\ntheorem water_antisymmetry (temp1 vol1 temp2 vol2 : Float)\n    (h1 : temp1 > -1000) (h2 : temp1 < 1000) (h3 : vol1 > 0.1) (h4 : vol1 < 1000)\n    (h5 : temp2 > -1000) (h6 : temp2 < 1000) (h7 : vol2 > 0.1) (h8 : vol2 < 1000) :\n  let w1 := { temp := temp1, volume := vol1 : Water }\n  let w2 := { temp := temp2, volume := vol2 : Water }\n  w1 ≤ w2 → w2 ≤ w1 → w1.temp_vol/w1.volume = w2.temp_vol/w2.volume :=\nsorry\n\ntheorem water_subtract_preserves_temp (temp vol subtract : Float)\n    (h1 : temp > -1000) (h2 : temp < 1000)\n    (h3 : vol > 0.1) (h4 : vol < 1000)\n    (h5 : subtract > 0.1) (h6 : subtract < 1000)\n    (h7 : subtract < vol) :\n  let w := { temp := temp, volume := vol : Water }\n  let w' := w.subtract subtract\n  w'.volume = vol - subtract ∧ w'.temp_vol/w'.volume = temp :=\nsorry\n\ntheorem water_add_properties (temp1 vol1 temp2 vol2 : Float)\n    (h1 : temp1 > -1000) (h2 : temp1 < 1000) (h3 : vol1 > 0.1) (h4 : vol1 < 1000)\n    (h5 : temp2 > -1000) (h6 : temp2 < 1000) (h7 : vol2 > 0.1) (h8 : vol2 < 1000) :\n  let w1 := { temp := temp1, volume := vol1 : Water }\n  let w2 := { temp := temp2, volume := vol2 : Water }\n  let w' := w1.add w2\n  w'.volume = vol1 + vol2 ∧ w'.temp_vol = temp1 * vol1 + temp2 * vol2 :=\nsorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2201", "language": "lean", "source": "fvapps", "source-id": "fvapps_002201", "source-notes": "", "vc-description": "/-\nAlice lives on a line. Today, she will travel to some place in a mysterious vehicle.\nInitially, the distance between Alice and her destination is D. When she input a number x to the vehicle, it will travel in the direction of the destination by a distance of x if this move would shorten the distance between the vehicle and the destination, and it will stay at its position otherwise. Note that the vehicle may go past the destination when the distance between the vehicle and the destination is less than x.\nAlice made a list of N numbers. The i-th number in this list is d_i. She will insert these numbers to the vehicle one by one.\nHowever, a mischievous witch appeared. She is thinking of rewriting one number in the list so that Alice will not reach the destination after N moves.\nShe has Q plans to do this, as follows:\n - Rewrite only the q_i-th number in the list with some integer so that Alice will not reach the destination.\nWrite a program to determine whether each plan is feasible.\n\n-----Constraints-----\n - 1≤ N ≤ 5*10^5\n - 1≤ Q ≤ 5*10^5\n - 1≤ D ≤ 10^9\n - 1≤ d_i ≤ 10^9(1≤i≤N)\n - 1≤ q_i ≤ N(1≤i≤Q)\n - D and each d_i are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nN D\nd_1 d_2 ... d_N\nQ\nq_1 q_2 ... q_Q\n\n-----Output-----\nPrint Q lines. The i-th line should contain YES if the i-th plan is feasible, and NO otherwise.\n\n-----Sample Input-----\n4 10\n3 4 3 3\n2\n4 3\n\n-----Sample Output-----\nNO\nYES\n\nFor the first plan, Alice will already arrive at the destination by the first three moves, and therefore the answer is NO.\nFor the second plan, rewriting the third number in the list with 5 will prevent Alice from reaching the destination as shown in the following figure, and thus the answer is YES.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_witch_prevent_finish (n: Nat) (d: Nat) (distances: List Nat) (queries: List Nat) : List Answer :=\n  sorry", "vc-theorems": "theorem result_length_matches_queries \n  (n d: Nat) (distances queries: List Nat) \n  (h1: n > 0) (h2: d > 0) \n  (h3: distances.length = n)\n  (h4: queries.length > 0)\n  (h5: ∀ q ∈ queries, q ≤ n)\n  (h6: ∀ x ∈ distances, x > 0) :\n  (can_witch_prevent_finish n d distances queries).length = queries.length := by\n  sorry\n\ntheorem results_are_yes_or_no\n  (n d: Nat) (distances queries: List Nat)\n  (h1: n > 0) (h2: d > 0)\n  (h3: distances.length = n)\n  (h4: queries.length > 0)\n  (h5: ∀ q ∈ queries, q ≤ n)\n  (h6: ∀ x ∈ distances, x > 0) :\n  ∀ x ∈ can_witch_prevent_finish n d distances queries, x = Answer.YES ∨ x = Answer.NO := by\n  sorry\n\ntheorem query_order_independence\n  (n d: Nat) (distances queries: List Nat)\n  (h1: n > 0) (h2: d > 0)\n  (h3: distances.length = n)\n  (h4: queries.length > 0)\n  (h5: ∀ q ∈ queries, q ≤ n)\n  (h6: ∀ x ∈ distances, x > 0) :\n  can_witch_prevent_finish n d distances queries =\n  List.reverse (can_witch_prevent_finish n d distances (List.reverse queries)) := by\n  sorry\n\ntheorem single_query_consistency\n  (n d: Nat) (distances queries: List Nat)\n  (h1: n > 0) (h2: d > 0)\n  (h3: distances.length = n)\n  (h4: queries.length > 0)\n  (h5: ∀ q ∈ queries, q ≤ n)\n  (h6: ∀ x ∈ distances, x > 0) :\n  ∀ i, i < queries.length →\n    (can_witch_prevent_finish n d distances [queries[i]!]).get! 0 =\n    (can_witch_prevent_finish n d distances queries).get! i := by\n  sorry\n\n/-\ninfo: ['NO', 'YES']\n-/\n-- #guard_msgs in\n-- #eval can_witch_prevent_finish 4 10 [3, 4, 3, 3] [4, 3]\n\n/-\ninfo: ['YES', 'YES', 'YES', 'YES', 'YES']\n-/\n-- #guard_msgs in\n-- #eval can_witch_prevent_finish 5 9 [4, 4, 2, 3, 2] [1, 4, 2, 3, 5]\n\n/-\ninfo: ['NO', 'NO', 'YES', 'NO', 'NO', 'YES']\n-/\n-- #guard_msgs in\n-- #eval can_witch_prevent_finish 6 15 [4, 3, 5, 4, 2, 1] [1, 2, 3, 4, 5, 6]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2203", "language": "lean", "source": "fvapps", "source-id": "fvapps_002203", "source-notes": "", "vc-description": "/-\nTakahashi has an ability to generate a tree using a permutation (p_1,p_2,...,p_n) of (1,2,...,n), in the following process:\nFirst, prepare Vertex 1, Vertex 2, ..., Vertex N.\nFor each i=1,2,...,n, perform the following operation:\n - If p_i = 1, do nothing.\n - If p_i \\neq 1, let j' be the largest j such that p_j < p_i. Span an edge between Vertex i and Vertex j'.\nTakahashi is trying to make his favorite tree with this ability.\nHis favorite tree has n vertices from Vertex 1 through Vertex n, and its i-th edge connects Vertex v_i and w_i.\nDetermine if he can make a tree isomorphic to his favorite tree by using a proper permutation.\nIf he can do so, find the lexicographically smallest such permutation.\n\n-----Notes-----\nFor the definition of isomorphism of trees, see wikipedia. Intuitively, two trees are isomorphic when they are the \"same\" if we disregard the indices of their vertices.\n\n-----Constraints-----\n - 2 \\leq n \\leq 10^5\n - 1 \\leq v_i, w_i \\leq n\n - The given graph is a tree.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nn\nv_1 w_1\nv_2 w_2\n:\nv_{n-1} w_{n-1}\n\n-----Output-----\nIf there is no permutation that can generate a tree isomorphic to Takahashi's favorite tree, print -1.\nIf it exists, print the lexicographically smallest such permutation, with spaces in between.\n\n-----Sample Input-----\n6\n1 2\n1 3\n1 4\n1 5\n5 6\n\n-----Sample Output-----\n1 2 4 5 3 6\n\nIf the permutation (1, 2, 4, 5, 3, 6) is used to generate a tree, it looks as follows:\n\nThis is isomorphic to the given graph.\n-/", "vc-preamble": "def solve_tree_problem (n : Nat) (edges : List Edge) : List Nat :=\n  sorry\n\ndef is_tree (n : Nat) (edges : List Edge) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def degree (edges : List Edge) (node : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem valid_solution_exists (n : Nat) (edges : List Edge) \n  (h1 : n > 0)\n  (h2 : ∀ e ∈ edges, e.u ≤ n ∧ e.v ≤ n)\n  (h3 : ∀ e ∈ edges, e.u ≠ e.v)\n  (h4 : is_tree n edges = true) :\n  ∃ result : List Nat,\n    (result.length = n) ∧ \n    (∀ x ∈ result, 1 ≤ x ∧ x ≤ n) ∧\n    (∀ i h_idx (h_lt : i < n - 1), degree edges (result.get ⟨i, h_idx⟩) ≤ 3) ∧\n    (∀ h_idx, degree edges (result.get ⟨n-1, h_idx⟩) ≤ 2) :=\n  sorry\n\ntheorem line_graph_has_solution (n : Nat) (edges : List Edge)\n  (h1 : n ≥ 2)\n  (h2 : edges = List.map (fun i => ⟨i, i+1⟩) (List.range (n-1))) :\n  ∃ result : List Nat,\n    (result.length = n) ∧\n    (∀ x ∈ result, 1 ≤ x ∧ x ≤ n) :=\n  sorry\n\ntheorem star_graph_has_solution (n : Nat) (edges : List Edge)\n  (h1 : n ≥ 4)\n  (h2 : edges = List.map (fun i => ⟨1, i+2⟩) (List.range (n-1))) :\n  ∃ result : List Nat,\n    (result.length = n) :=\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2207", "language": "lean", "source": "fvapps", "source-id": "fvapps_002207", "source-notes": "", "vc-description": "/-\nMasha and Grisha like studying sets of positive integers.\n\nOne day Grisha has written a set A containing n different integers a_{i} on a blackboard. Now he asks Masha to create a set B containing n different integers b_{j} such that all n^2 integers that can be obtained by summing up a_{i} and b_{j} for all possible pairs of i and j are different.\n\nBoth Masha and Grisha don't like big numbers, so all numbers in A are from 1 to 10^6, and all numbers in B must also be in the same range.\n\nHelp Masha to create the set B that satisfies Grisha's requirement.\n\n-----Input-----\n\nInput data contains multiple test cases. The first line contains an integer t — the number of test cases (1 ≤ t ≤ 100).\n\nEach test case is described in the following way: the first line of the description contains one integer n — the number of elements in A (1 ≤ n ≤ 100).\n\nThe second line contains n integers a_{i} — the elements of A (1 ≤ a_{i} ≤ 10^6). \n\n-----Output-----\n\nFor each test first print the answer:   NO, if Masha's task is impossible to solve, there is no way to create the required set B.  YES, if there is the way to create the required set. In this case the second line must contain n different positive integers b_{j} — elements of B (1 ≤ b_{j} ≤ 10^6). If there are several possible sets, output any of them. \n\n-----Example-----\nInput\n3\n3\n1 10 100\n1\n1\n2\n2 4\n\nOutput\nYES\n1 2 3 \nYES\n1 \nYES\n1 2\n-/", "vc-preamble": "def solve (n : Nat) (arr : List Nat) : List Nat × List Nat := sorry\n\ndef abs (n m : Nat) : Nat :=\n  if n ≥ m then n - m else m - n", "vc-helpers": "", "vc-definitions": "def allDiffs (nums : List Nat) : List Nat :=\n  (List.range nums.length).bind (fun i =>\n    (List.range (nums.length - i - 1)).map (fun j =>\n      abs (nums[i]!) (nums[i + j + 1]!)))\n\ndef disjoint (l1 l2 : List Nat) : Prop :=\n  ∀ x, x ∈ l1 → x ∉ l2", "vc-theorems": "theorem solve_output_length {n : Nat} {arr : List Nat} :\n  let (_, nums) := solve n arr\n  nums.length = n :=\nsorry\n\ntheorem solve_different_diffs {n : Nat} {arr : List Nat} :\n  let (_, nums) := solve n arr\n  disjoint (allDiffs nums) (allDiffs arr) :=\nsorry\n\ntheorem solve_positive {n : Nat} {arr : List Nat} :\n  let (_, nums) := solve n arr\n  ∀ i, i < nums.length → nums[i]! > 0 :=\nsorry\n\ntheorem solve_increasing {n : Nat} {arr : List Nat} :\n  let (_, nums) := solve n arr\n  ∀ i, i < nums.length - 1 → nums[i]! < nums[i + 1]! :=\nsorry\n\ntheorem solve_works {arr : List Nat} (h : arr.length > 0) :\n  let (res, nums) := solve arr.length arr\n  nums.length = arr.length ∧\n  disjoint (allDiffs nums) (allDiffs arr) ∧\n  (∀ i, i < nums.length → nums[i]! > 0) ∧\n  (∀ i, i < nums.length - 1 → nums[i]! < nums[i + 1]!) :=\nsorry\n\n/-\ninfo: ('YES', [1, 2, 3])\n-/\n-- #guard_msgs in\n-- #eval solve 3 [1, 10, 100]\n\n/-\ninfo: ('YES', [1])\n-/\n-- #guard_msgs in\n-- #eval solve 1 [1]\n\n/-\ninfo: ('YES', [1, 2])\n-/\n-- #guard_msgs in\n-- #eval solve 2 [2, 4]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2214", "language": "lean", "source": "fvapps", "source-id": "fvapps_002214", "source-notes": "", "vc-description": "/-\nKoa the Koala and her best friend want to play a game.\n\nThe game starts with an array $a$ of length $n$ consisting of non-negative integers. Koa and her best friend move in turns and each have initially a score equal to $0$. Koa starts.\n\nLet's describe a move in the game:  During his move, a player chooses any element of the array and removes it from this array, xor-ing it with the current score of the player.\n\n More formally: if the current score of the player is $x$ and the chosen element is $y$, his new score will be $x \\oplus y$. Here $\\oplus$ denotes bitwise XOR operation.\n\n Note that after a move element $y$ is removed from $a$.\n\n  The game ends when the array is empty. \n\nAt the end of the game the winner is the player with the maximum score. If both players have the same score then it's a draw.\n\nIf both players play optimally find out whether Koa will win, lose or draw the game.\n\n-----Input-----\n\nEach test contains multiple test cases. The first line contains $t$ ($1 \\le t \\le 10^4$) — the number of test cases. Description of the test cases follows.\n\nThe first line of each test case contains the integer $n$ ($1 \\le n \\le 10^5$) — the length of $a$.\n\nThe second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 10^9$) — elements of $a$.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n\n-----Output-----\n\nFor each test case print:  WIN if Koa will win the game.  LOSE if Koa will lose the game.  DRAW if the game ends in a draw. \n\n-----Examples-----\nInput\n3\n3\n1 2 2\n3\n2 2 3\n5\n0 0 0 2 2\n\nOutput\nWIN\nLOSE\nDRAW\n\nInput\n4\n5\n4 1 5 1 3\n4\n1 0 1 6\n1\n0\n2\n5 4\n\nOutput\nWIN\nWIN\nDRAW\nWIN\n\n-----Note-----\n\nIn testcase $1$ of the first sample we have:\n\n$a = [1, 2, 2]$. Here Koa chooses $1$, other player has to choose $2$, Koa chooses another $2$. Score for Koa is $1 \\oplus 2 = 3$ and score for other player is $2$ so Koa wins.\n-/", "vc-preamble": "def solve (n : Nat) (a : List Nat) : GameResult :=\n  sorry", "vc-helpers": "", "vc-definitions": "def isValidResult (result : GameResult) : Bool :=\n  match result with\n  | GameResult.WIN => true\n  | GameResult.LOSE => true\n  | GameResult.DRAW => true", "vc-theorems": "theorem solve_output_is_valid {n : Nat} {a : List Nat} (h: n > 0) (h2: a.length = n):\n  isValidResult (solve n a) = true := by\n  sorry\n\ntheorem solve_consistent_result {n : Nat} {a : List Nat} (h: n > 0) (h2: a.length = n):\n  solve n a = solve n a := by\n  sorry\n\ntheorem solve_invariant_under_reordering {n : Nat} {a b : List Nat} \n  (h: n > 0) (h2: a.length = n) (h3: b.length = n)\n  (h4: ∃ p : List Nat, b = p ++ a):\n  solve n a = solve n b := by\n  sorry\n\ntheorem solve_all_same_numbers {n : Nat} {val : Nat} (h: n > 0):\n  isValidResult (solve n (List.replicate n val)) = true := by\n  sorry\n\n/-\ninfo: 'WIN'\n-/\n-- #guard_msgs in\n-- #eval solve 3 [1, 2, 2]\n\n/-\ninfo: 'LOSE'\n-/\n-- #guard_msgs in\n-- #eval solve 3 [2, 2, 3]\n\n/-\ninfo: 'DRAW'\n-/\n-- #guard_msgs in\n-- #eval solve 5 [0, 0, 0, 2, 2]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2215", "language": "lean", "source": "fvapps", "source-id": "fvapps_002215", "source-notes": "", "vc-description": "/-\nYou have an array $a$ of length $n$. For every positive integer $x$ you are going to perform the following operation during the $x$-th second:\n\n  Select some distinct indices $i_{1}, i_{2}, \\ldots, i_{k}$ which are between $1$ and $n$ inclusive, and add $2^{x-1}$ to each corresponding position of $a$. Formally, $a_{i_{j}} := a_{i_{j}} + 2^{x-1}$ for $j = 1, 2, \\ldots, k$. Note that you are allowed to not select any indices at all. \n\nYou have to make $a$ nondecreasing as fast as possible. Find the smallest number $T$ such that you can make the array nondecreasing after at most $T$ seconds.\n\nArray $a$ is nondecreasing if and only if $a_{1} \\le a_{2} \\le \\ldots \\le a_{n}$.\n\nYou have to answer $t$ independent test cases.\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 10^{4}$) — the number of test cases.\n\nThe first line of each test case contains single integer $n$ ($1 \\le n \\le 10^{5}$) — the length of array $a$. It is guaranteed that the sum of values of $n$ over all test cases in the input does not exceed $10^{5}$.\n\nThe second line of each test case contains $n$ integers $a_{1}, a_{2}, \\ldots, a_{n}$ ($-10^{9} \\le a_{i} \\le 10^{9}$).\n\n-----Output-----\n\nFor each test case, print the minimum number of seconds in which you can make $a$ nondecreasing.\n\n-----Example-----\nInput\n3\n4\n1 7 6 5\n5\n1 2 3 4 5\n2\n0 -4\n\nOutput\n2\n0\n3\n\n-----Note-----\n\nIn the first test case, if you select indices $3, 4$ at the $1$-st second and $4$ at the $2$-nd second, then $a$ will become $[1, 7, 7, 8]$. There are some other possible ways to make $a$ nondecreasing in $2$ seconds, but you can't do it faster.\n\nIn the second test case, $a$ is already nondecreasing, so answer is $0$.\n\nIn the third test case, if you do nothing at first $2$ seconds and select index $2$ at the $3$-rd second, $a$ will become $[0, 0]$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_seconds_to_nondecreasing (n : Nat) (arr : Array Int) : Nat := sorry\n\ntheorem already_nondecreasing {n : Nat} {arr : Array Int} \n  (h1 : n ≥ 2)\n  (h2 : n ≤ 100)\n  (h3 : arr.size = n)\n  (h4 : ∀ i j, i < j → j < n → arr[i]! ≤ arr[j]!) \n  : min_seconds_to_nondecreasing n arr = 0 := sorry", "vc-theorems": "theorem result_valid {n : Nat} {arr : Array Int}\n  (h1 : arr.size = n)\n  (h2 : n ≥ 2)\n  (h3 : n ≤ 100)\n  (h4 : ∀ x, x ∈ arr.data → -1000 ≤ x ∧ x ≤ 1000)\n  : let result := min_seconds_to_nondecreasing n arr\n    result ≥ 0 ∧ ∀ i j, i < j → j < n → arr[i]! ≤ arr[j]! := sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval min_seconds_to_nondecreasing 4 #[1, 7, 6, 5]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval min_seconds_to_nondecreasing 5 #[1, 2, 3, 4, 5]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval min_seconds_to_nondecreasing 2 #[0, -4]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2218", "language": "lean", "source": "fvapps", "source-id": "fvapps_002218", "source-notes": "", "vc-description": "/-\nRoger is a robot. He has an arm that is a series of n segments connected to each other. The endpoints of the i-th segment are initially located at points (i - 1, 0) and (i, 0). The endpoint at (i - 1, 0) is colored red and the endpoint at (i, 0) is colored blue for all segments. Thus, the blue endpoint of the i-th segment is touching the red endpoint of the (i + 1)-th segment for all valid i.\n\nRoger can move his arm in two different ways:   He can choose some segment and some value. This is denoted as choosing the segment number i and picking some positive l. This change happens as follows: the red endpoint of segment number i and segments from 1 to i - 1 are all fixed in place. Imagine a ray from the red endpoint to the blue endpoint. The blue endpoint and segments i + 1 through n are translated l units in the direction of this ray.\n\n [Image] [Image] \n\nIn this picture, the red point labeled A and segments before A stay in place, while the blue point labeled B and segments after B gets translated.\n\n He can choose a segment and rotate it. This is denoted as choosing the segment number i, and an angle a. The red endpoint of the i-th segment will stay fixed in place. The blue endpoint of that segment and segments i + 1 to n will rotate clockwise by an angle of a degrees around the red endpoint.\n\n [Image] [Image] \n\nIn this picture, the red point labeled A and segments before A stay in place, while the blue point labeled B and segments after B get rotated around point A. \n\nRoger will move his arm m times. These transformations are a bit complicated, and Roger easily loses track of where the blue endpoint of the last segment is. Help him compute the coordinates of the blue endpoint of the last segment after applying each operation. Note that these operations are cumulative, and Roger's arm may intersect itself arbitrarily during the moves.\n\n-----Input-----\n\nThe first line of the input will contain two integers n and m (1 ≤ n, m ≤ 300 000) — the number of segments and the number of operations to perform.\n\nEach of the next m lines contains three integers x_{i}, y_{i} and z_{i} describing a move. If x_{i} = 1, this line describes a move of type 1, where y_{i} denotes the segment number and z_{i} denotes the increase in the length. If x_{i} = 2, this describes a move of type 2, where y_{i} denotes the segment number, and z_{i} denotes the angle in degrees. (1 ≤ x_{i} ≤ 2, 1 ≤ y_{i} ≤ n, 1 ≤ z_{i} ≤ 359)\n\n-----Output-----\n\nPrint m lines. The i-th line should contain two real values, denoting the coordinates of the blue endpoint of the last segment after applying operations 1, ..., i. Your answer will be considered correct if its absolute or relative error does not exceed 10^{ - 4}.\n\nNamely, let's assume that your answer for a particular value of a coordinate is a and the answer of the jury is b. The checker program will consider your answer correct if $\\frac{|a - b|}{\\operatorname{max}(1, b)} \\leq 10^{-4}$ for all coordinates.\n\n-----Examples-----\nInput\n5 4\n1 1 3\n2 3 90\n2 5 48\n1 4 1\n\nOutput\n8.0000000000 0.0000000000\n5.0000000000 -3.0000000000\n4.2568551745 -2.6691306064\n4.2568551745 -3.6691306064\n\n-----Note-----\n\nThe following pictures shows the state of the arm after each operation. The coordinates of point F are printed after applying each operation. For simplicity, we only show the blue endpoints of a segment (with the exception for the red endpoint of the first segment). For instance, the point labeled B is the blue endpoint for segment 1 and also the red endpoint for segment 2.\n\nInitial state:  [Image]  Extend segment 1 by 3.  [Image]  Rotate segment 3 by 90 degrees clockwise.  [Image]  Rotate segment 5 by 48 degrees clockwise.  [Image]  Extend segment 4 by 1.  [Image]\n-/", "vc-preamble": "def robot_arm (n : Nat) (moves : List (Nat × Nat × Float)) : List (Float × Float) := sorry\n\n/- Vector sum of two complex numbers represented as coordinate pairs -/\n\ndef vsum (v1 v2 : Float × Float) : Float × Float := sorry\n\n/- Converts polar coordinates to rectangular coordinates -/", "vc-helpers": "", "vc-definitions": "def degrect (r : Float) (phi : Int) : Float × Float := sorry\n\n/- Properties of robot_arm:\n    1. Output list length equals input moves list length\n    2. Each output element is coordinate pair of reals -/", "vc-theorems": "theorem robot_arm_properties {n : Nat} {moves : List (Nat × Nat × Float)} :\n  let results := robot_arm n moves\n  (List.length results = List.length moves) ∧ \n  (∀ res ∈ results, ∃ x y : Float, res = (x,y)) := sorry\n\n/- Properties of SegmentTree with vector sum:\n    The sum over full range equals manual calculation of vector sum -/\n\ntheorem segment_tree_vsum_properties {segments : List (Float × Int)} :\n  let segPairs := List.map (fun (r,phi) => (degrect r phi, degrect r phi)) segments\n  let tree : SegmentTree (Float × Float) := { \n    segments := segPairs,\n    combine := vsum,\n    query := fun _ _ => (0, 0)\n  }\n  let manualCalc := List.foldl vsum (0,0) (List.map (fun (r,phi) => degrect r phi) segments)\n  tree.query 0 (List.length segments) = manualCalc := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2219", "language": "lean", "source": "fvapps", "source-id": "fvapps_002219", "source-notes": "", "vc-description": "/-\nYou are working for the Gryzzl company, headquartered in Pawnee, Indiana.\n\nThe new national park has been opened near Pawnee recently and you are to implement a geolocation system, so people won't get lost. The concept you developed is innovative and minimalistic. There will be $n$ antennas located somewhere in the park. When someone would like to know their current location, their Gryzzl hologram phone will communicate with antennas and obtain distances from a user's current location to all antennas.\n\nKnowing those distances and antennas locations it should be easy to recover a user's location... Right? Well, almost. The only issue is that there is no way to distinguish antennas, so you don't know, which distance corresponds to each antenna. Your task is to find a user's location given as little as all antennas location and an unordered multiset of distances.\n\n-----Input-----\n\nThe first line of input contains a single integer $n$ ($2 \\leq n \\leq 10^5$) which is the number of antennas.\n\nThe following $n$ lines contain coordinates of antennas, $i$-th line contain two integers $x_i$ and $y_i$ ($0 \\leq x_i,y_i \\leq 10^8$). It is guaranteed that no two antennas coincide.\n\nThe next line of input contains integer $m$ ($1 \\leq n \\cdot m \\leq 10^5$), which is the number of queries to determine the location of the user.\n\nFollowing $m$ lines contain $n$ integers $0 \\leq d_1 \\leq d_2 \\leq \\dots \\leq d_n \\leq 2 \\cdot 10^{16}$ each. These integers form a multiset of squared distances from unknown user's location $(x;y)$ to antennas.\n\nFor all test cases except the examples it is guaranteed that all user's locations $(x;y)$ were chosen uniformly at random, independently from each other among all possible integer locations having $0 \\leq x, y \\leq 10^8$.\n\n-----Output-----\n\nFor each query output $k$, the number of possible a user's locations matching the given input and then output the list of these locations in lexicographic order.\n\nIt is guaranteed that the sum of all $k$ over all points does not exceed $10^6$.\n\n-----Examples-----\nInput\n3\n0 0\n0 1\n1 0\n1\n1 1 2\n\nOutput\n1 1 1 \n\nInput\n4\n0 0\n0 1\n1 0\n1 1\n2\n0 1 1 2\n2 5 5 8\n\nOutput\n4 0 0 0 1 1 0 1 1 \n4 -1 -1 -1 2 2 -1 2 2 \n\n-----Note-----\n\nAs you see in the second example, although initially a user's location is picked to have non-negative coordinates, you have to output all possible integer locations.\n-/", "vc-preamble": "def solve_gryzzl_location (coords : List (Int × Int)) (queries : List (List Int)) : List String :=\n  sorry\n\ndef getMaximumD (l : List Int) : Int :=\n  match l.maximum? with\n  | some x => x\n  | none => 0", "vc-helpers": "", "vc-definitions": "def getMinimumD (l : List Int) : Int :=\n  match l.minimum? with\n  | some x => x\n  | none => 0", "vc-theorems": "theorem antenna_coords_basic_types {coords : List (Int × Int)} \n  {queries : List (List Int)} \n  (h1 : coords.length ≥ 2)\n  (h2 : queries.length > 0) :\n  let result := solve_gryzzl_location coords queries\n  result.length = queries.length\n  := sorry\n\ntheorem antenna_coord_result_format {coords : List (Int × Int)}\n  {queries : List (List Int)}\n  (h1 : coords.length ≥ 2)\n  (h2 : queries.length > 0)\n  (minX maxX minY maxY : Int) :\n  let result := solve_gryzzl_location coords queries\n  let coordsX := coords.map Prod.fst\n  let coordsY := coords.map Prod.snd\n  let queryMax := getMaximumD (queries.map getMaximumD)\n  minX = getMinimumD coordsX - queryMax ∧\n  maxX = getMaximumD coordsX + queryMax ∧\n  minY = getMinimumD coordsY - queryMax ∧\n  maxY = getMaximumD coordsY + queryMax →\n  ∀ res ∈ result,\n    let nums := res.split (· = ' ')\n    let count := nums.length\n    nums.length ≥ 1 ∧\n    -- Coordinate range checks\n    ∀ i, i < count →\n      let x := -1  -- placeholder since we can't parse string to int\n      let y := -1  -- placeholder since we can't parse string to int\n      minX - 1 ≤ x ∧ x ≤ maxX + 1 ∧\n      minY - 1 ≤ y ∧ y ≤ maxY + 1\n  := sorry\n\ntheorem sqrt_distance_property {coords : List (Int × Int)}\n  (h1 : coords.length ≥ 2) :\n  let (x1, y1) := coords[0]!\n  let (x2, y2) := coords[1]!\n  let d := (x2 - x1)^2 + (y2 - y1)^2\n  let result := solve_gryzzl_location coords [List.replicate coords.length d]\n  result.length = 1\n  := sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2227", "language": "lean", "source": "fvapps", "source-id": "fvapps_002227", "source-notes": "", "vc-description": "/-\nThere are $n$ cities in Berland and some pairs of them are connected by two-way roads. It is guaranteed that you can pass from any city to any other, moving along the roads. Cities are numerated from $1$ to $n$.\n\nTwo fairs are currently taking place in Berland — they are held in two different cities $a$ and $b$ ($1 \\le a, b \\le n$; $a \\ne b$).\n\nFind the number of pairs of cities $x$ and $y$ ($x \\ne a, x \\ne b, y \\ne a, y \\ne b$) such that if you go from $x$ to $y$ you will have to go through both fairs (the order of visits doesn't matter). Formally, you need to find the number of pairs of cities $x,y$ such that any path from $x$ to $y$ goes through $a$ and $b$ (in any order).\n\nPrint the required number of pairs. The order of two cities in a pair does not matter, that is, the pairs $(x,y)$ and $(y,x)$ must be taken into account only once.\n\n-----Input-----\n\nThe first line of the input contains an integer $t$ ($1 \\le t \\le 4\\cdot10^4$) — the number of test cases in the input. Next, $t$ test cases are specified.\n\nThe first line of each test case contains four integers $n$, $m$, $a$ and $b$ ($4 \\le n \\le 2\\cdot10^5$, $n - 1 \\le m \\le 5\\cdot10^5$, $1 \\le a,b \\le n$, $a \\ne b$) — numbers of cities and roads in Berland and numbers of two cities where fairs are held, respectively.\n\nThe following $m$ lines contain descriptions of roads between cities. Each of road description contains a pair of integers $u_i, v_i$ ($1 \\le u_i, v_i \\le n$, $u_i \\ne v_i$) — numbers of cities connected by the road.\n\nEach road is bi-directional and connects two different cities. It is guaranteed that from any city you can pass to any other by roads. There can be more than one road between a pair of cities.\n\nThe sum of the values of $n$ for all sets of input data in the test does not exceed $2\\cdot10^5$. The sum of the values of $m$ for all sets of input data in the test does not exceed $5\\cdot10^5$.\n\n-----Output-----\n\nPrint $t$ integers — the answers to the given test cases in the order they are written in the input.\n\n-----Example-----\nInput\n3\n7 7 3 5\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 5\n4 5 2 3\n1 2\n2 3\n3 4\n4 1\n4 2\n4 3 2 1\n1 2\n2 3\n4 1\n\nOutput\n4\n0\n1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countSeparatedCityPairs (n : Nat) (m : Nat) (a : Nat) (b : Nat) (edges : List (Nat × Nat)) : Nat :=\n  sorry", "vc-theorems": "theorem countSeparatedCityPairs_result_nonneg (n m a b : Nat) (edges : List (Nat × Nat)) \n    (hn : n ≥ 2) (ha : a ≤ n) (hb : b ≤ n) (hab : a ≠ b) :\n    countSeparatedCityPairs n m a b edges ≥ 0 := sorry\n\ntheorem countSeparatedCityPairs_upper_bound (n m a b : Nat) (edges : List (Nat × Nat))\n    (hn : n ≥ 2) (ha : a ≤ n) (hb : b ≤ n) (hab : a ≠ b) :\n    countSeparatedCityPairs n m a b edges ≤ (n-2) * (n-2) := sorry\n\ntheorem countSeparatedCityPairs_empty_graph (n m a b : Nat) (edges : List (Nat × Nat))\n    (hn : n ≥ 2) (ha : a ≤ n) (hb : b ≤ n) (hab : a ≠ b)\n    (he : edges = []) :\n    countSeparatedCityPairs n m a b edges ≥ 0 := sorry\n\ntheorem countSeparatedCityPairs_sparse_graph (n m a b : Nat) (edges : List (Nat × Nat))\n    (hn : n ≥ 2) (ha : a ≤ n) (hb : b ≤ n) (hab : a ≠ b)\n    (hm : m < n-1) :\n    countSeparatedCityPairs n m a b edges ≥ 0 := sorry\n\ntheorem countSeparatedCityPairs_path_graph (n : Nat) (hn : n ≥ 2) :\n  let edges := List.range (n-1) |>.map (fun i => (i+1, i+2))\n  let m := n-1\n  let a := 1\n  let b := n \n  countSeparatedCityPairs n m a b edges ≥ 0 ∧\n  countSeparatedCityPairs n m a b edges ≤ (n-2) * (n-2) := sorry\n\ntheorem countSeparatedCityPairs_complete_graph (n a b : Nat)\n    (hn : n ≥ 3) (ha : a ≤ n) (hb : b ≤ n) (hab : a ≠ b) :\n  let edges := List.join (List.range n |>.map (fun i => \n                List.range (n-i) |>.map (fun j => (i+1, i+j+2))))\n  let m := (n * (n-1)) / 2\n  countSeparatedCityPairs n m a b edges = 0 := sorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval count_separated_city_pairs 7 7 3 5 [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 5)]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval count_separated_city_pairs 4 5 2 3 [(1, 2), (2, 3), (3, 4), (4, 1), (4, 2)]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval count_separated_city_pairs 4 3 2 1 [(1, 2), (2, 3), (4, 1)]", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2242", "language": "lean", "source": "fvapps", "source-id": "fvapps_002242", "source-notes": "", "vc-description": "/-\nN hotels are located on a straight line. The coordinate of the i-th hotel (1 \\leq i \\leq N) is x_i.\nTak the traveler has the following two personal principles:\n - He never travels a distance of more than L in a single day.\n - He never sleeps in the open. That is, he must stay at a hotel at the end of a day.\nYou are given Q queries. The j-th (1 \\leq j \\leq Q) query is described by two distinct integers a_j and b_j.\nFor each query, find the minimum number of days that Tak needs to travel from the a_j-th hotel to the b_j-th hotel following his principles.\nIt is guaranteed that he can always travel from the a_j-th hotel to the b_j-th hotel, in any given input.\n\n-----Constraints-----\n - 2 \\leq N \\leq 10^5\n - 1 \\leq L \\leq 10^9\n - 1 \\leq Q \\leq 10^5\n - 1 \\leq x_i < x_2 < ... < x_N \\leq 10^9\n - x_{i+1} - x_i \\leq L\n - 1 \\leq a_j,b_j \\leq N\n - a_j \\neq b_j\n - N,\\,L,\\,Q,\\,x_i,\\,a_j,\\,b_j are integers.\n\n-----Partial Score-----\n - 200 points will be awarded for passing the test set satisfying N \\leq 10^3 and Q \\leq 10^3.\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN\nx_1 x_2 ... x_N\nL\nQ\na_1 b_1\na_2 b_2\n:\na_Q b_Q\n\n-----Output-----\nPrint Q lines.\nThe j-th line (1 \\leq j \\leq Q) should contain the minimum number of days that Tak needs to travel from the a_j-th hotel to the b_j-th hotel.\n\n-----Sample Input-----\n9\n1 3 6 13 15 18 19 29 31\n10\n4\n1 8\n7 3\n6 7\n8 5\n\n-----Sample Output-----\n4\n2\n1\n2\n\nFor the 1-st query, he can travel from the 1-st hotel to the 8-th hotel in 4 days, as follows:\n - Day 1: Travel from the 1-st hotel to the 2-nd hotel. The distance traveled is 2.\n - Day 2: Travel from the 2-nd hotel to the 4-th hotel. The distance traveled is 10.\n - Day 3: Travel from the 4-th hotel to the 7-th hotel. The distance traveled is 6.\n - Day 4: Travel from the 7-th hotel to the 8-th hotel. The distance traveled is 10.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_hotel_path (hotels : List Nat) (L : Nat) (queries : List (Nat × Nat)) : List Nat :=\n  sorry", "vc-theorems": "theorem hotel_path_basic_test (h : hotels = [1, 3, 6]) (l : L = 3) :\n  solve_hotel_path hotels L [(1, 3)] = [2] :=\n  sorry\n\ntheorem hotel_path_symmetric (h : hotels = [1, 3, 6]) (l : L = 3) :\n  solve_hotel_path hotels L [(1, 3)] = solve_hotel_path hotels L [(3, 1)] :=\n  sorry\n\ntheorem hotel_path_self (h : hotels = [1, 3, 6]) (l : L = 3) :\n  solve_hotel_path hotels L [(1, 1)] = [0] :=\n  sorry\n\ntheorem hotel_path_output_positive (h : hotels = [1, 3, 6, 10]) (l : L = 4) :\n  let result := solve_hotel_path hotels L [(1, 4), (2, 3)]\n  ∀ x ∈ result, x ≥ 0 :=\n  sorry\n\ntheorem hotel_path_output_length (h : hotels = [1, 3, 6, 10]) (l : L = 4) :\n  let result := solve_hotel_path hotels L [(1, 4), (2, 3)]\n  result.length = 2 :=\n  sorry", "vc-postamble": "-- Apps difficulty: competition\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2254", "language": "lean", "source": "fvapps", "source-id": "fvapps_002254", "source-notes": "", "vc-description": "/-\nThere are $n$ athletes in front of you. Athletes are numbered from $1$ to $n$ from left to right. You know the strength of each athlete — the athlete number $i$ has the strength $s_i$.\n\nYou want to split all athletes into two teams. Each team must have at least one athlete, and each athlete must be exactly in one team.\n\nYou want the strongest athlete from the first team to differ as little as possible from the weakest athlete from the second team. Formally, you want to split the athletes into two teams $A$ and $B$ so that the value $|\\max(A) - \\min(B)|$ is as small as possible, where $\\max(A)$ is the maximum strength of an athlete from team $A$, and $\\min(B)$ is the minimum strength of an athlete from team $B$.\n\nFor example, if $n=5$ and the strength of the athletes is $s=[3, 1, 2, 6, 4]$, then one of the possible split into teams is:   first team: $A = [1, 2, 4]$,  second team: $B = [3, 6]$. \n\nIn this case, the value $|\\max(A) - \\min(B)|$ will be equal to $|4-3|=1$. This example illustrates one of the ways of optimal split into two teams.\n\nPrint the minimum value $|\\max(A) - \\min(B)|$.\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 1000$) — the number of test cases in the input. Then $t$ test cases follow.\n\nEach test case consists of two lines. \n\nThe first line contains positive integer $n$ ($2 \\le n \\le 50$) — number of athletes. \n\nThe second line contains $n$ positive integers $s_1, s_2, \\ldots, s_n$ ($1 \\le s_i \\le 1000$), where $s_i$ — is the strength of the $i$-th athlete. Please note that $s$ values may not be distinct.\n\n-----Output-----\n\nFor each test case print one integer — the minimum value of $|\\max(A) - \\min(B)|$ with the optimal split of all athletes into two teams. Each of the athletes must be a member of exactly one of the two teams.\n\n-----Example-----\nInput\n5\n5\n3 1 2 6 4\n6\n2 1 3 2 4 3\n4\n7 9 3 1\n2\n1 1000\n3\n100 150 200\n\nOutput\n1\n0\n2\n999\n50\n\n-----Note-----\n\nThe first test case was explained in the statement. In the second test case, one of the optimal splits is $A=[2, 1]$, $B=[3, 2, 4, 3]$, so the answer is $|2-2|=0$.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_min_team_diff (n : Nat) (strengths : List Int) : Int :=\n  sorry", "vc-theorems": "theorem min_team_diff_non_negative (n : Nat) (strengths : List Int)\n  (h1 : n ≥ 2)\n  (h2 : strengths.length ≥ n) :\n  solve_min_team_diff n strengths ≥ 0 :=\nsorry\n\ntheorem min_team_diff_upper_bound (n : Nat) (strengths : List Int)\n  (h1 : n ≥ 2)\n  (h2 : strengths.length ≥ n) :\n  solve_min_team_diff n strengths ≤ (List.maximum? strengths).getD 0 - (List.minimum? strengths).getD 0 :=\nsorry\n\ntheorem min_team_diff_is_minimum (n : Nat) (strengths : List Int)\n  (h1 : n ≥ 2)  \n  (h2 : strengths.length ≥ n) :\n  ∃ min_diff : Int,\n    solve_min_team_diff n strengths = min_diff ∧\n    ∀ (x y : Int), x ∈ strengths → y ∈ strengths → x ≤ y → min_diff ≤ y - x :=\nsorry\n\ntheorem min_team_diff_two_elements (a b : Int) :\n  solve_min_team_diff 2 [a, b] = Int.natAbs (b - a) :=\nsorry\n\ntheorem min_team_diff_identical {x : Int} {n : Nat} (lst : List Int)\n  (h1 : n ≥ 2)\n  (h2 : lst.length = n)\n  (h3 : ∀ (i : Fin lst.length), lst.get i = x) :\n  solve_min_team_diff n lst = 0 :=\nsorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval solve_min_team_diff 5 [3, 1, 2, 6, 4]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval solve_min_team_diff 6 [2, 1, 3, 2, 4, 3]\n\n/-\ninfo: 999\n-/\n-- #guard_msgs in\n-- #eval solve_min_team_diff 2 [1, 1000]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2255", "language": "lean", "source": "fvapps", "source-id": "fvapps_002255", "source-notes": "", "vc-description": "/-\nYou are given an undirected unweighted graph consisting of $n$ vertices and $m$ edges (which represents the map of Bertown) and the array of prices $p$ of length $m$. It is guaranteed that there is a path between each pair of vertices (districts).\n\nMike has planned a trip from the vertex (district) $a$ to the vertex (district) $b$ and then from the vertex (district) $b$ to the vertex (district) $c$. He can visit the same district twice or more. But there is one issue: authorities of the city want to set a price for using the road so if someone goes along the road then he should pay the price corresponding to this road (he pays each time he goes along the road). The list of prices that will be used $p$ is ready and they just want to distribute it between all roads in the town in such a way that each price from the array corresponds to exactly one road.\n\nYou are a good friend of Mike (and suddenly a mayor of Bertown) and want to help him to make his trip as cheap as possible. So, your task is to distribute prices between roads in such a way that if Mike chooses the optimal path then the price of the trip is the minimum possible. Note that you cannot rearrange prices after the start of the trip.\n\nYou have to answer $t$ independent test cases.\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains five integers $n, m, a, b$ and $c$ ($2 \\le n \\le 2 \\cdot 10^5$, $n-1 \\le m \\le min(\\frac{n(n-1)}{2}, 2 \\cdot 10^5)$, $1 \\le a, b, c \\le n$) — the number of vertices, the number of edges and districts in Mike's trip.\n\nThe second line of the test case contains $m$ integers $p_1, p_2, \\dots, p_m$ ($1 \\le p_i \\le 10^9$), where $p_i$ is the $i$-th price from the array.\n\nThe following $m$ lines of the test case denote edges: edge $i$ is represented by a pair of integers $v_i$, $u_i$ ($1 \\le v_i, u_i \\le n$, $u_i \\ne v_i$), which are the indices of vertices connected by the edge. There are no loops or multiple edges in the given graph, i. e. for each pair ($v_i, u_i$) there are no other pairs ($v_i, u_i$) or ($u_i, v_i$) in the array of edges, and for each pair $(v_i, u_i)$ the condition $v_i \\ne u_i$ is satisfied. It is guaranteed that the given graph is connected.\n\nIt is guaranteed that the sum of $n$ (as well as the sum of $m$) does not exceed $2 \\cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$, $\\sum m \\le 2 \\cdot 10^5$).\n\n-----Output-----\n\nFor each test case, print the answer — the minimum possible price of Mike's trip if you distribute prices between edges optimally.\n\n-----Example-----\nInput\n2\n4 3 2 3 4\n1 2 3\n1 2\n1 3\n1 4\n7 9 1 5 7\n2 10 4 8 5 6 7 3 3\n1 2\n1 3\n1 4\n3 2\n3 5\n4 2\n5 6\n1 7\n6 7\n\nOutput\n7\n12\n\n-----Note-----\n\nOne of the possible solution to the first test case of the example:\n\n[Image]\n\nOne of the possible solution to the second test case of the example:\n\n[Image]\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (h::t) => h + sum t", "vc-helpers": "", "vc-definitions": "def solve_min_cost_trip (n m a b c : Nat) (prices : List Nat) (edges : List (Nat × Nat)) : Nat :=\nsorry", "vc-theorems": "theorem solve_min_cost_trip_non_negative (n m a b c : Nat) (prices : List Nat) \n    (edges : List (Nat × Nat)) : \n    solve_min_cost_trip n m a b c prices edges ≥ 0 :=\nsorry\n\ntheorem solve_min_cost_trip_bounded (n m a b c : Nat) (prices : List Nat)\n    (edges : List (Nat × Nat)) :\n    solve_min_cost_trip n m a b c prices edges ≤ \n    (List.take m prices).sum :=\nsorry\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval solve_min_cost_trip 4 3 2 3 4 [1, 2, 3] [(1, 2), (1, 3), (1, 4)]\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval solve_min_cost_trip 7 9 1 5 7 [2, 10, 4, 8, 5, 6, 7, 3, 3] [(1, 2), (1, 3), (1, 4), (3, 2), (3, 5), (4, 2), (5, 6), (1, 7), (6, 7)]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2260", "language": "lean", "source": "fvapps", "source-id": "fvapps_002260", "source-notes": "", "vc-description": "/-\nThis problem is a version of problem D from the same contest with some additional constraints and tasks.\n\nThere are $n$ candies in a candy box. The type of the $i$-th candy is $a_i$ ($1 \\le a_i \\le n$). \n\nYou have to prepare a gift using some of these candies with the following restriction: the numbers of candies of each type presented in a gift should be all distinct (i. e. for example, a gift having two candies of type $1$ and two candies of type $2$ is bad).\n\nIt is possible that multiple types of candies are completely absent from the gift. It is also possible that not all candies of some types will be taken to a gift.\n\nYou really like some of the candies and don't want to include them into the gift, but you want to eat them yourself instead. For each candy, a number $f_i$ is given, which is equal to $0$ if you really want to keep $i$-th candy for yourself, or $1$ if you don't mind including it into your gift. It is possible that two candies of the same type have different values of $f_i$.\n\nYou want your gift to be as large as possible, but you don't want to include too many of the candies you want to eat into the gift. So, you want to calculate the maximum possible number of candies that can be included into a gift, and among all ways to choose maximum number of candies, you want to maximize the number of candies having $f_i = 1$ in your gift.\n\nYou have to answer $q$ independent queries.\n\nIf you are Python programmer, consider using PyPy instead of Python when you submit your code.\n\n-----Input-----\n\nThe first line of the input contains one integer $q$ ($1 \\le q \\le 2 \\cdot 10^5$) — the number of queries.\n\nThe first line of each query contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) — the number of candies.\n\nThen $n$ lines follow, each containing two integers $a_i$ and $f_i$ ($1 \\le a_i \\le n$, $0 \\le f_i \\le 1$), where $a_i$ is the type of the $i$-th candy, and $f_i$ denotes whether you want to keep the $i$-th candy for yourself ($0$ if you want to keep it, $1$ if you don't mind giving it away).\n\nIt is guaranteed that the sum of $n$ over all queries does not exceed $2 \\cdot 10^5$.\n\n-----Output-----\n\nFor each query print two integers:\n\n  the maximum number of candies in a gift you can compose, according to the constraints in the statement;  the maximum number of candies having $f_i = 1$ in a gift you can compose that contains the maximum possible number of candies.  \n\n-----Example-----\nInput\n3\n8\n1 0\n4 1\n2 0\n4 1\n5 1\n6 1\n3 0\n2 0\n4\n1 1\n1 1\n2 1\n2 1\n9\n2 0\n2 0\n4 1\n4 1\n4 1\n7 0\n7 1\n7 0\n7 1\n\nOutput\n3 3\n3 3\n9 5\n\n-----Note-----\n\nIn the first query, you can include two candies of type $4$ and one candy of type $5$. All of them have $f_i = 1$ and you don't mind giving them away as part of the gift.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x :: xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def solveCandyBox (n : Nat) (types : List (Nat × Nat)) (flags : List Nat) : Nat × Nat := sorry\n\ntheorem all_flagged_small {n : Nat} {types : List (Nat × Nat)} {flags : List Nat}\n  (h1 : n = 3)\n  (h2 : types = [(1,0), (2,0), (3,0)])\n  (h3 : flags = [1,1,1]) :\n  let (candies, given) := solveCandyBox n types flags\n  given = candies := sorry", "vc-theorems": "theorem none_flagged_small {n : Nat} {types : List (Nat × Nat)} {flags : List Nat}\n  (h1 : n = 3)\n  (h2 : types = [(1,0), (2,0), (3,0)])\n  (h3 : flags = [0,0,0]) :\n  let (candies, given) := solveCandyBox n types flags\n  given = 0 := sorry\n\ntheorem candy_box_properties {n : Nat} {types : List (Nat × Nat)} {flags : List Nat}\n  (h1 : n = types.length)\n  (h2 : n = flags.length)\n  (h3 : ∀ t, t ∈ types → t.1 ≥ 1 ∧ t.1 ≤ 100 ∧ t.2 = 0)\n  (h4 : ∀ f, f ∈ flags → f = 0 ∨ f = 1) :\n  let (candies, given) := solveCandyBox n types flags\n  given ≤ candies ∧ candies ≤ n ∧ given ≤ flags.sum := sorry\n\n/-\ninfo: (3, 3)\n-/\n-- #guard_msgs in\n-- #eval solve_candy_box 8 [(1, 0), (4, 1), (2, 0), (4, 1), (5, 1), (6, 1), (3, 0), (2, 0)] [0, 1, 0, 1, 1, 1, 0, 0]\n\n/-\ninfo: (3, 3)\n-/\n-- #guard_msgs in\n-- #eval solve_candy_box 4 [(1, 1), (1, 1), (2, 1), (2, 1)] [1, 1, 1, 1]\n\n/-\ninfo: (9, 5)\n-/\n-- #guard_msgs in\n-- #eval solve_candy_box 9 [(2, 0), (2, 0), (4, 1), (4, 1), (4, 1), (7, 0), (7, 1), (7, 0), (7, 1)] [0, 0, 1, 1, 1, 0, 1, 0, 1]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2274", "language": "lean", "source": "fvapps", "source-id": "fvapps_002274", "source-notes": "", "vc-description": "/-\nThere is a rectangular grid of size $n \\times m$. Each cell of the grid is colored black ('0') or white ('1'). The color of the cell $(i, j)$ is $c_{i, j}$. You are also given a map of directions: for each cell, there is a direction $s_{i, j}$ which is one of the four characters 'U', 'R', 'D' and 'L'.\n\n  If $s_{i, j}$ is 'U' then there is a transition from the cell $(i, j)$ to the cell $(i - 1, j)$;  if $s_{i, j}$ is 'R' then there is a transition from the cell $(i, j)$ to the cell $(i, j + 1)$;  if $s_{i, j}$ is 'D' then there is a transition from the cell $(i, j)$ to the cell $(i + 1, j)$;  if $s_{i, j}$ is 'L' then there is a transition from the cell $(i, j)$ to the cell $(i, j - 1)$. \n\nIt is guaranteed that the top row doesn't contain characters 'U', the bottom row doesn't contain characters 'D', the leftmost column doesn't contain characters 'L' and the rightmost column doesn't contain characters 'R'.\n\nYou want to place some robots in this field (at most one robot in a cell). The following conditions should be satisfied.\n\n  Firstly, each robot should move every time (i.e. it cannot skip the move). During one move each robot goes to the adjacent cell depending on the current direction.  Secondly, you have to place robots in such a way that there is no move before which two different robots occupy the same cell (it also means that you cannot place two robots in the same cell). I.e. if the grid is \"RL\" (one row, two columns, colors does not matter there) then you can place two robots in cells $(1, 1)$ and $(1, 2)$, but if the grid is \"RLL\" then you cannot place robots in cells $(1, 1)$ and $(1, 3)$ because during the first second both robots will occupy the cell $(1, 2)$. \n\nThe robots make an infinite number of moves.\n\nYour task is to place the maximum number of robots to satisfy all the conditions described above and among all such ways, you have to choose one where the number of black cells occupied by robots before all movements is the maximum possible. Note that you can place robots only before all movements.\n\nYou have to answer $t$ independent test cases.\n\n-----Input-----\n\nThe first line of the input contains one integer $t$ ($1 \\le t \\le 5 \\cdot 10^4$) — the number of test cases. Then $t$ test cases follow.\n\nThe first line of the test case contains two integers $n$ and $m$ ($1 < nm \\le 10^6$) — the number of rows and the number of columns correspondingly.\n\nThe next $n$ lines contain $m$ characters each, where the $j$-th character of the $i$-th line is $c_{i, j}$ ($c_{i, j}$ is either '0' if the cell $(i, j)$ is black or '1' if the cell $(i, j)$ is white).\n\nThe next $n$ lines also contain $m$ characters each, where the $j$-th character of the $i$-th line is $s_{i, j}$ ($s_{i, j}$ is 'U', 'R', 'D' or 'L' and describes the direction of the cell $(i, j)$).\n\nIt is guaranteed that the sum of the sizes of fields does not exceed $10^6$ ($\\sum nm \\le 10^6$).\n\n-----Output-----\n\nFor each test case, print two integers — the maximum number of robots you can place to satisfy all the conditions described in the problem statement and the maximum number of black cells occupied by robots before all movements if the number of robots placed is maximized. Note that you can place robots only before all movements.\n\n-----Example-----\nInput\n3\n1 2\n01\nRL\n3 3\n001\n101\n110\nRLL\nDLD\nULL\n3 3\n000\n000\n000\nRRD\nRLD\nULL\n\nOutput\n2 1\n4 3\n2 2\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat :=\n  xs.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def find_max_robots_and_black_cells (n m : Nat) (colors directions : List String) : Nat × Nat := sorry\n\ntheorem output_types_and_ranges {n m : Nat} {colors directions : List String}\n  (h : n > 0 ∧ m > 0)\n  (hlen : colors.length = n ∧ directions.length = n)\n  (hcolors : ∀ row ∈ colors, row.length = m ∧ (∀ c ∈ String.toList row, c = '0' ∨ c = '1'))\n  (hdirs : ∀ row ∈ directions, row.length = m ∧ (∀ d ∈ String.toList row, d = 'U' ∨ d = 'D' ∨ d = 'R' ∨ d = 'L')) :\n  let (robots, black_cells) := find_max_robots_and_black_cells n m colors directions;\n  robots ≥ 0 ∧ \n  black_cells ≥ 0 ∧\n  black_cells ≤ robots ∧\n  black_cells ≤ (List.map (λ row => List.length (List.filter (λ x => x = '0') (String.toList row))) colors).sum := sorry", "vc-theorems": "/-\ninfo: (2, 1)\n-/\n-- #guard_msgs in\n-- #eval find_max_robots_and_black_cells 1 2 [\"01\"] [\"RL\"]\n\n/-\ninfo: (4, 3)\n-/\n-- #guard_msgs in\n-- #eval find_max_robots_and_black_cells 3 3 [\"001\", \"101\", \"110\"] [\"RLL\", \"DLD\", \"ULL\"]\n\n/-\ninfo: (2, 2)\n-/\n-- #guard_msgs in\n-- #eval find_max_robots_and_black_cells 3 3 [\"000\", \"000\", \"000\"] [\"RRD\", \"RLD\", \"ULL\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2277", "language": "lean", "source": "fvapps", "source-id": "fvapps_002277", "source-notes": "", "vc-description": "/-\nYou are given an undirected unweighted connected graph consisting of $n$ vertices and $m$ edges. It is guaranteed that there are no self-loops or multiple edges in the given graph.\n\nYour task is to choose at most $\\lfloor\\frac{n}{2}\\rfloor$ vertices in this graph so each unchosen vertex is adjacent (in other words, connected by an edge) to at least one of chosen vertices.\n\nIt is guaranteed that the answer exists. If there are multiple answers, you can print any.\n\nYou will be given multiple independent queries to answer.\n\n-----Input-----\n\nThe first line contains a single integer $t$ ($1 \\le t \\le 2 \\cdot 10^5$) — the number of queries.\n\nThen $t$ queries follow.\n\nThe first line of each query contains two integers $n$ and $m$ ($2 \\le n \\le 2 \\cdot 10^5$, $n - 1 \\le m \\le min(2 \\cdot 10^5, \\frac{n(n-1)}{2})$) — the number of vertices and the number of edges, respectively.\n\nThe following $m$ lines denote edges: edge $i$ is represented by a pair of integers $v_i$, $u_i$ ($1 \\le v_i, u_i \\le n$, $u_i \\ne v_i$), which are the indices of vertices connected by the edge.\n\nThere are no self-loops or multiple edges in the given graph, i. e. for each pair ($v_i, u_i$) there are no other pairs ($v_i, u_i$) or ($u_i, v_i$) in the list of edges, and for each pair ($v_i, u_i$) the condition $v_i \\ne u_i$ is satisfied. It is guaranteed that the given graph is connected.\n\nIt is guaranteed that $\\sum m \\le 2 \\cdot 10^5$ over all queries.\n\n-----Output-----\n\nFor each query print two lines.\n\nIn the first line print $k$ ($1 \\le \\lfloor\\frac{n}{2}\\rfloor$) — the number of chosen vertices.\n\nIn the second line print $k$ distinct integers $c_1, c_2, \\dots, c_k$ in any order, where $c_i$ is the index of the $i$-th chosen vertex.\n\nIt is guaranteed that the answer exists. If there are multiple answers, you can print any.\n\n-----Example-----\nInput\n2\n4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n6 8\n2 5\n5 4\n4 3\n4 1\n1 3\n2 3\n2 6\n5 6\n\nOutput\n2\n1 3\n3\n4 3 6\n\n-----Note-----\n\nIn the first query any vertex or any pair of vertices will suffice.\n\n [Image] \n\nNote that you don't have to minimize the number of chosen vertices. In the second query two vertices can be enough (vertices $2$ and $4$) but three is also ok.\n\n [Image]\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_graph_cover (test_cases : List (Nat × Nat × List (Nat × Nat))) : \n  List (Nat × List Nat) := sorry", "vc-theorems": "theorem graph_cover_size_matches_vertices {n m : Nat} {edges : List (Nat × Nat)}\n  {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(n,m,edges)] = [(result_size, result_vertices)] →\n  result_size = result_vertices.length := sorry\n\ntheorem graph_cover_vertices_valid {n m : Nat} {edges : List (Nat × Nat)}\n  {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(n,m,edges)] = [(result_size, result_vertices)] →\n  ∀ v ∈ result_vertices, 1 ≤ v ∧ v ≤ n := sorry\n\ntheorem graph_cover_vertices_no_duplicates {n m : Nat} {edges : List (Nat × Nat)}\n  {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(n,m,edges)] = [(result_size, result_vertices)] →\n  ∀ x ∈ result_vertices, ∀ y ∈ result_vertices, x = y → \n  result_vertices.indexOf x = result_vertices.indexOf y := sorry\n\ntheorem graph_cover_size_bound {n m : Nat} {edges : List (Nat × Nat)}\n  {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(n,m,edges)] = [(result_size, result_vertices)] →\n  result_size ≤ (n + 1) / 2 := sorry\n\ntheorem minimal_graph_cover {result_size : Nat} {result_vertices : List Nat} :\n  solve_graph_cover [(2, 1, [(1,2)])] = [(result_size, result_vertices)] →\n  result_size = 1 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2282", "language": "lean", "source": "fvapps", "source-id": "fvapps_002282", "source-notes": "", "vc-description": "/-\nPolygon is not only the best platform for developing problems but also a square matrix with side $n$, initially filled with the character 0.\n\nOn the polygon, military training was held. The soldiers placed a cannon above each cell in the first row and a cannon to the left of each cell in the first column. Thus, exactly $2n$ cannons were placed. [Image] Initial polygon for $n=4$. \n\nCannons shoot character 1. At any moment of time, no more than one cannon is shooting. When a 1 flies out of a cannon, it flies forward (in the direction of the shot) until it collides with a polygon border or another 1. After that, it takes the cell in which it was before the collision and remains there. Take a look at the examples for better understanding.\n\nMore formally:   if a cannon stands in the row $i$, to the left of the first column, and shoots with a 1, then the 1 starts its flight from the cell ($i, 1$) and ends in some cell ($i, j$);  if a cannon stands in the column $j$, above the first row, and shoots with a 1, then the 1 starts its flight from the cell ($1, j$) and ends in some cell ($i, j$). \n\nFor example, consider the following sequence of shots: [Image] \n\n 1. Shoot the cannon in the row $2$.                         2. Shoot the cannon in the row $2$.                         3. Shoot the cannon in column $3$. \n\nYou have a report from the military training on your desk. This report is a square matrix with side length $n$ consisting of 0 and 1. You wonder if the training actually happened. In other words, is there a sequence of shots such that, after the training, you get the given matrix?\n\nEach cannon can make an arbitrary number of shots. Before the training, each cell of the polygon contains 0.\n\n-----Input-----\n\nThe first line contains an integer $t$ ($1 \\le t \\le 1000$) — the number of test cases. Then $t$ test cases follow.\n\nEach test case starts with a line containing an integer $n$ ($1 \\le n \\le 50$) — the size of the polygon.\n\nThis is followed by $n$ lines of length $n$, consisting of 0 and 1 — the polygon matrix after the training.\n\nThe total area of the matrices in all test cases in one test does not exceed $10^5$.\n\n-----Output-----\n\nFor each test case print:  YES if there is a sequence of shots leading to a given matrix;  NO if such a sequence does not exist. \n\nThe letters in the words YES and NO can be printed in any case.\n\n-----Example-----\nInput\n5\n4\n0010\n0011\n0000\n0000\n2\n10\n01\n2\n00\n00\n4\n0101\n1111\n0101\n0111\n4\n0100\n1110\n0101\n0111\n\nOutput\nYES\nNO\nYES\nYES\nNO\n\n-----Note-----\n\nThe first test case was explained in the statement.\n\nThe answer to the second test case is NO, since a 1 in a cell ($1, 1$) flying out of any cannon would continue its flight further.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def can_create_pattern (n : Nat) (mat : Matrix) : Bool :=\n  sorry", "vc-theorems": "theorem empty_matrix_is_valid (n : Nat) (h : n > 0) :\n  let mat := List.replicate n (List.replicate n '0')\n  can_create_pattern n mat = true := by\n  sorry\n\ntheorem single_edge_ones_are_valid (n : Nat) (h : n > 0) :\n  let emptyMat := List.replicate n (List.replicate n '0')\n  let lastRow := List.replicate n '1'\n  let mat := List.take (n-1) emptyMat ++ [lastRow]\n  can_create_pattern n mat = true := by\n  sorry\n\ntheorem no_isolated_ones (n : Nat) (mat : Matrix) (h1 : n > 0)\n  (h2 : mat.length = n)\n  (h3 : ∀ row ∈ mat, row.length = n)\n  (h4 : ∀ row ∈ mat, ∀ c ∈ row, c = '0' ∨ c = '1') :\n  ∀ i j, i < n → j < n →\n    (mat.get! i).get! j = '1' →\n    (i = n-1 ∨ j = n-1 ∨ \n     (j < n-1 ∧ (mat.get! i).get! (j+1) = '1') ∨\n     (i < n-1 ∧ (mat.get! (i+1)).get! j = '1')) ∨\n    can_create_pattern n mat = false := by\n  sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval can_create_pattern 4 [\"0010\", \"0011\", \"0000\", \"0000\"]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval can_create_pattern 2 [\"10\", \"01\"]\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval can_create_pattern 2 [\"00\", \"00\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2289", "language": "lean", "source": "fvapps", "source-id": "fvapps_002289", "source-notes": "", "vc-description": "/-\nThe round carousel consists of $n$ figures of animals. Figures are numbered from $1$ to $n$ in order of the carousel moving. Thus, after the $n$-th figure the figure with the number $1$ follows. Each figure has its own type — the type of the animal corresponding to this figure (the horse, the tiger and so on). The type of animal of the $i$-th figure equals $t_i$. [Image] The example of the carousel for $n=9$ and $t=[5, 5, 1, 15, 1, 5, 5, 1, 1]$. \n\nYou want to color each figure in one of the colors. You think that it's boring if the carousel contains two different figures (with the distinct types of animals) going one right after another and colored in the same color.\n\nYour task is to color the figures in such a way that the number of distinct colors used is the minimum possible and there are no figures of the different types going one right after another and colored in the same color. If you use exactly $k$ distinct colors, then the colors of figures should be denoted with integers from $1$ to $k$.\n\n-----Input-----\n\nThe input contains one or more test cases.\n\nThe first line contains one integer $q$ ($1 \\le q \\le 10^4$) — the number of test cases in the test. Then $q$ test cases follow. One test case is given on two lines.\n\nThe first line of the test case contains one integer $n$ ($3 \\le n \\le 2 \\cdot 10^5$) — the number of figures in the carousel. Figures are numbered from $1$ to $n$ in order of carousel moving. Assume that after the $n$-th figure the figure $1$ goes.\n\nThe second line of the test case contains $n$ integers $t_1, t_2, \\dots, t_n$ ($1 \\le t_i \\le 2 \\cdot 10^5$), where $t_i$ is the type of the animal of the $i$-th figure.\n\nThe sum of $n$ over all test cases does not exceed $2\\cdot10^5$.\n\n-----Output-----\n\nPrint $q$ answers, for each test case print two lines.\n\nIn the first line print one integer $k$ — the minimum possible number of distinct colors of figures.\n\nIn the second line print $n$ integers $c_1, c_2, \\dots, c_n$ ($1 \\le c_i \\le k$), where $c_i$ is the color of the $i$-th figure. If there are several answers, you can print any.\n\n-----Example-----\nInput\n4\n5\n1 2 1 2 2\n6\n1 2 2 1 2 2\n5\n1 2 1 2 3\n3\n10 10 10\n\nOutput\n2\n1 2 1 2 2\n2\n2 1 2 1 2 1\n3\n2 3 2 3 1\n1\n1 1 1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_carousel_coloring (n : Nat) (types : List Nat) : CarouselResult :=\n  sorry", "vc-theorems": "theorem color_count_valid {n : Nat} {types : List Nat}\n  (h1 : n > 0) (h2 : types.length = n) :\n  let result := solve_carousel_coloring n types\n  result.colorCount ≤ 3 ∧ \n  ∀ c ∈ result.colors, 1 ≤ c ∧ c ≤ result.colorCount := \n  sorry\n\ntheorem output_length {n : Nat} {types : List Nat} \n  (h1 : n > 0) (h2 : types.length = n) :\n  (solve_carousel_coloring n types).colors.length = n :=\n  sorry\n\ntheorem same_type_same_color {n : Nat} {types : List Nat}\n  (h1 : n > 0) (h2 : types.length = n)\n  (h3 : ∀ i j, i < types.length → j < types.length → types[i]! = types[j]!) :\n  let result := solve_carousel_coloring n types\n  result.colorCount = 1 ∧ \n  ∀ c ∈ result.colors, c = 1 :=\n  sorry\n\ntheorem even_length_alternating {n : Nat}\n  (h1 : n > 1) (h2 : n % 2 = 0) :\n  let types := List.join (List.replicate (n/2) [1,2])\n  let result := solve_carousel_coloring n types\n  result.colorCount = 2 ∧ result.colors.length = n :=\n  sorry\n\n/-\ninfo: n1\n-/\n-- #guard_msgs in\n-- #eval len colors1\n\n/-\ninfo: n2\n-/\n-- #guard_msgs in\n-- #eval len colors2", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2314", "language": "lean", "source": "fvapps", "source-id": "fvapps_002314", "source-notes": "", "vc-description": "/-\nGiven an array A of integers, for each integer A[i] we may choose any x with -K <= x <= K, and add x to A[i].\nAfter this process, we have some array B.\nReturn the smallest possible difference between the maximum value of B and the minimum value of B.\n\nExample 1:\nInput: A = [1], K = 0\nOutput: 0\nExplanation: B = [1]\n\nExample 2:\nInput: A = [0,10], K = 2\nOutput: 6\nExplanation: B = [2,8]\n\nExample 3:\nInput: A = [1,3,6], K = 3\nOutput: 0\nExplanation: B = [3,3,3] or B = [4,4,4]\n\nNote:\n\n1 <= A.length <= 10000\n0 <= A[i] <= 10000\n0 <= K <= 10000\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def smallest_range_i (arr : List Int) (k : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem smallest_range_i_non_negative {arr : List Int} {k : Nat} (h : arr.length > 0) :\n  smallest_range_i arr k ≥ 0 := sorry\n\ntheorem smallest_range_i_single_element {arr : List Int} {k : Nat} (h : arr.length = 1) : \n  smallest_range_i arr k = 0 := sorry\n\ntheorem smallest_range_i_bound {arr : List Int} {k : Nat} (h : arr.length > 0) :\n  smallest_range_i arr k ≤ (arr.maximum?.getD 0) - (arr.minimum?.getD 0) := sorry\n\ntheorem smallest_range_i_reduction {arr : List Int} {k : Nat} (h : arr.length > 0) :\n  smallest_range_i arr k = max 0 ((arr.maximum?.getD 0) - (arr.minimum?.getD 0) - 2 * k) := sorry\n\ntheorem smallest_range_i_zero_k {arr : List Int} (h₁ : arr.length > 0) (h₂ : arr.length > 1) :\n  smallest_range_i arr 0 = (arr.maximum?.getD 0) - (arr.minimum?.getD 0) := sorry\n\ntheorem smallest_range_i_large_k {arr : List Int} {k : Nat} (h₁ : arr.length > 0)\n  (h₂ : k ≥ (arr.maximum?.getD 0) - (arr.minimum?.getD 0)) :\n  smallest_range_i arr k = 0 := sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval smallest_range_i [1] 0\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval smallest_range_i [0, 10] 2\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval smallest_range_i [1, 3, 6] 3", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2320", "language": "lean", "source": "fvapps", "source-id": "fvapps_002320", "source-notes": "", "vc-description": "/-\nYou're now a baseball game point recorder.\n\nGiven a list of strings, each string can be one of the 4 following types:\n\nInteger (one round's score): Directly represents the number of points you get in this round.\n\"+\" (one round's score): Represents that the points you get in this round are the sum of the last two valid round's points.\n\"D\" (one round's score): Represents that the points you get in this round are the doubled data of the last valid round's points.\n\"C\" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed.\n\nEach round's operation is permanent and could have an impact on the round before and the round after.\n\nYou need to return the sum of the points you could get in all the rounds.\n\nExample 1:\n\nInput: [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation: \nRound 1: You could get 5 points. The sum is: 5.\nRound 2: You could get 2 points. The sum is: 7.\nOperation 1: The round 2's data was invalid. The sum is: 5.  \nRound 3: You could get 10 points (the round 2's data has been removed). The sum is: 15.\nRound 4: You could get 5 + 10 = 15 points. The sum is: 30.\n\nExample 2:\n\nInput: [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation: \nRound 1: You could get 5 points. The sum is: 5.\nRound 2: You could get -2 points. The sum is: 3.\nRound 3: You could get 4 points. The sum is: 7.\nOperation 1: The round 3's data is invalid. The sum is: 3.  \nRound 4: You could get -4 points (the round 3's data has been removed). The sum is: -1.\nRound 5: You could get 9 points. The sum is: 8.\nRound 6: You could get -4 + 9 = 5 points. The sum is 13.\nRound 7: You could get 9 + 5 = 14 points. The sum is 27.\n\nNote:\nThe size of the input list will be between 1 and 1000.\nEvery integer represented in the list will be between -30000 and 30000.\n-/", "vc-preamble": "def List.sum : List Int → Int \n  | [] => 0\n  | x::xs => x + List.sum xs", "vc-helpers": "", "vc-definitions": "def cal_points (ops : List String) : Int := sorry\n\ntheorem cal_points_basic_two_numbers :\n  cal_points [\"5\", \"2\"] = 7 := sorry", "vc-theorems": "theorem cal_points_basic_double :\n  cal_points [\"1\", \"D\"] = 3 := sorry\n\ntheorem cal_points_basic_plus :\n  cal_points [\"1\", \"2\", \"+\"] = 6 := sorry\n\n/-\ninfo: 30\n-/\n-- #guard_msgs in\n-- #eval cal_points [\"5\", \"2\", \"C\", \"D\", \"+\"]\n\n/-\ninfo: 27\n-/\n-- #guard_msgs in\n-- #eval cal_points [\"5\", \"-2\", \"4\", \"C\", \"D\", \"9\", \"+\", \"+\"]\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval cal_points [\"1\", \"2\", \"+\", \"D\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2335", "language": "lean", "source": "fvapps", "source-id": "fvapps_002335", "source-notes": "", "vc-description": "/-\nGiven an array of unique integers salary where salary[i] is the salary of the employee i.\nReturn the average salary of employees excluding the minimum and maximum salary.\n\nExample 1:\nInput: salary = [4000,3000,1000,2000]\nOutput: 2500.00000\nExplanation: Minimum salary and maximum salary are 1000 and 4000 respectively.\nAverage salary excluding minimum and maximum salary is (2000+3000)/2= 2500\n\nExample 2:\nInput: salary = [1000,2000,3000]\nOutput: 2000.00000\nExplanation: Minimum salary and maximum salary are 1000 and 3000 respectively.\nAverage salary excluding minimum and maximum salary is (2000)/1= 2000\n\nExample 3:\nInput: salary = [6000,5000,4000,3000,2000,1000]\nOutput: 3500.00000\n\nExample 4:\nInput: salary = [8000,9000,2000,3000,6000,1000]\nOutput: 4750.00000\n\nConstraints:\n\n3 <= salary.length <= 100\n10^3 <= salary[i] <= 10^6\nsalary[i] is unique.\nAnswers within 10^-5 of the actual value will be accepted as correct.\n-/", "vc-preamble": "def calculate_average_salary (salaries : List Nat) : Float := sorry\n\ndef isUnique (l : List Nat) : Bool := sorry", "vc-helpers": "", "vc-definitions": "def list_to_float (n : Nat) : Float := sorry\n\ndef insertSort (l : List Nat) : List Nat := sorry", "vc-theorems": "theorem average_salary_between_min_max \n  (salaries : List Nat)\n  (h1 : salaries.length ≥ 3)\n  (h2 : isUnique salaries) : \n  match salaries.minimum?, salaries.maximum? with\n  | some min, some max => \n      let result := calculate_average_salary salaries\n      list_to_float min ≤ result ∧ result ≤ list_to_float max\n  | _, _ => True\n  := sorry\n\ntheorem average_salary_matches_expected\n  (salaries : List Nat)\n  (h1 : salaries.length ≥ 3)\n  (h2 : isUnique salaries) :\n  let sorted := insertSort salaries\n  let expected := list_to_float (sorted.get? 1).get! + \n                  list_to_float (sorted.get? (sorted.length - 2)).get! / 2\n  Float.abs (calculate_average_salary salaries - expected) < 1e-10 :=\nsorry\n\ntheorem average_salary_order_invariant\n  (salaries shuffled : List Nat)\n  (h1 : salaries.length ≥ 3)\n  (h2 : isUnique salaries)\n  (h3 : shuffled.length = salaries.length)\n  (h4 : ∀ x, x ∈ salaries ↔ x ∈ shuffled) :\n  Float.abs (calculate_average_salary salaries - calculate_average_salary shuffled) < 1e-10 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2342", "language": "lean", "source": "fvapps", "source-id": "fvapps_002342", "source-notes": "", "vc-description": "/-\nGiven an array of integers nums, write a method that returns the \"pivot\" index of this array.\n\nWe define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.\n\nIf no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.\n\nExample 1:\n\nInput: \nnums = [1, 7, 3, 6, 5, 6]\nOutput: 3\nExplanation: \nThe sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.\nAlso, 3 is the first index where this occurs.\n\nExample 2:\n\nInput: \nnums = [1, 2, 3]\nOutput: -1\nExplanation: \nThere is no index that satisfies the conditions in the problem statement.\n\nNote:\nThe length of nums will be in the range [0, 10000].\nEach element nums[i] will be an integer in the range [-1000, 1000].\n-/", "vc-preamble": "def List.sum (l : List Int) : Int :=\n  sorry\n\ndef Nat.toInt (n : Nat) : Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def find_pivot_index (nums : List Int) : Int :=\n  sorry", "vc-theorems": "theorem pivot_index_empty :\n  find_pivot_index [] = -1 := sorry\n\ntheorem pivot_index_single {n : Int} :\n  find_pivot_index [n] = 0 := sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval find_pivot_index [1, 7, 3, 6, 5, 6]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval find_pivot_index [1, 2, 3]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval find_pivot_index [2, 1, -1]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2343", "language": "lean", "source": "fvapps", "source-id": "fvapps_002343", "source-notes": "", "vc-description": "/-\nBalanced strings are those who have equal quantity of 'L' and 'R' characters.\nGiven a balanced string s split it in the maximum amount of balanced strings.\nReturn the maximum amount of splitted balanced strings.\n\nExample 1:\nInput: s = \"RLRRLLRLRL\"\nOutput: 4\nExplanation: s can be split into \"RL\", \"RRLL\", \"RL\", \"RL\", each substring contains same number of 'L' and 'R'.\n\nExample 2:\nInput: s = \"RLLLLRRRLR\"\nOutput: 3\nExplanation: s can be split into \"RL\", \"LLLRRR\", \"LR\", each substring contains same number of 'L' and 'R'.\n\nExample 3:\nInput: s = \"LLLLRRRR\"\nOutput: 1\nExplanation: s can be split into \"LLLLRRRR\".\n\nExample 4:\nInput: s = \"RLRRRLLRLL\"\nOutput: 2\nExplanation: s can be split into \"RL\", \"RRRLLRLL\", since each substring contains an equal number of 'L' and 'R'\n\nConstraints:\n\n1 <= s.length <= 1000\ns[i] = 'L' or 'R'\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def balanced_string_split (s: String) : Nat :=\n  sorry", "vc-theorems": "theorem empty_string_split:\n  balanced_string_split \"\" = 0 :=\n  sorry\n\ntheorem single_char_split:\n  balanced_string_split \"R\" = 0 ∧ balanced_string_split \"L\" = 0 :=\n  sorry\n\ntheorem balanced_blocks_split (n: Nat) (h: n > 0):\n  balanced_string_split (String.mk (List.join (List.replicate n ['R', 'R', 'L', 'L']))) = n :=\n  sorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval balanced_string_split \"RLRRLLRLRL\"\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval balanced_string_split \"RLLLLRRRLR\"\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval balanced_string_split \"LLLLRRRR\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2345", "language": "lean", "source": "fvapps", "source-id": "fvapps_002345", "source-notes": "", "vc-description": "/-\nGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\nExample:\n\nInput: [-2,1,-3,4,-1,2,1,-5,4],\nOutput: 6\nExplanation: [4,-1,2,1] has the largest sum = 6.\n\nFollow up:\n\nIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\n-/", "vc-preamble": "def maxSubArray (nums : List Int) : Int := sorry\n\ndef List.sum (l : List Int) : Int := sorry", "vc-helpers": "", "vc-definitions": "def List.max (l : List Int) : Int := sorry\n\ntheorem maxSubArray_geq_max (nums : List Int) (h: nums ≠ []) :\n  maxSubArray nums ≥ List.max nums := sorry", "vc-theorems": "theorem maxSubArray_all_positive (nums : List Int) (h1: nums ≠ []) \n  (h2: ∀ x ∈ nums, x > 0) :\n  maxSubArray nums = List.sum nums := sorry\n\ntheorem maxSubArray_geq_elements (nums : List Int) (h: nums ≠ []) :\n  ∀ x ∈ nums, maxSubArray nums ≥ x := sorry\n\ntheorem maxSubArray_exists_subarray (nums : List Int) (h: nums ≠ []) :\n  ∃ i j, i ≤ j ∧ j < nums.length ∧ \n    List.sum (List.take (j - i + 1) (List.drop i nums)) = maxSubArray nums := sorry\n\ntheorem maxSubArray_binary (nums : List Int) (h1: nums ≠ [])\n  (h2: ∀ x ∈ nums, x ≥ -1 ∧ x ≤ 1) :\n  maxSubArray nums = List.max nums ∨ maxSubArray nums > 0 := sorry\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval maxSubArray #[-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval maxSubArray #[-1]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval maxSubArray #[1, 2, -1, -2, 2, 1, -2, 1]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2353", "language": "lean", "source": "fvapps", "source-id": "fvapps_002353", "source-notes": "", "vc-description": "/-\nTic-tac-toe is played by two players A and B on a 3 x 3 grid.\nHere are the rules of Tic-Tac-Toe:\n\nPlayers take turns placing characters into empty squares (\" \").\nThe first player A always places \"X\" characters, while the second player B always places \"O\" characters.\n\"X\" and \"O\" characters are always placed into empty squares, never on filled ones.\nThe game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.\nThe game also ends if all squares are non-empty.\nNo more moves can be played if the game is over.\n\nGiven an array moves where each element is another array of size 2 corresponding to the row and column of the grid where they mark their respective character in the order in which A and B play.\nReturn the winner of the game if it exists (A or B), in case the game ends in a draw return \"Draw\", if there are still movements to play return \"Pending\".\nYou can assume that moves is valid (It follows the rules of Tic-Tac-Toe), the grid is initially empty and A will play first.\n\nExample 1:\nInput: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]\nOutput: \"A\"\nExplanation: \"A\" wins, he always plays first.\n\"X  \"    \"X  \"    \"X  \"    \"X  \"    \"X  \"\n\"   \" -> \"   \" -> \" X \" -> \" X \" -> \" X \"\n\"   \"    \"O  \"    \"O  \"    \"OO \"    \"OOX\"\n\nExample 2:\nInput: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]\nOutput: \"B\"\nExplanation: \"B\" wins.\n\"X  \"    \"X  \"    \"XX \"    \"XXO\"    \"XXO\"    \"XXO\"\n\"   \" -> \" O \" -> \" O \" -> \" O \" -> \"XO \" -> \"XO \" \n\"   \"    \"   \"    \"   \"    \"   \"    \"   \"    \"O  \"\n\nExample 3:\nInput: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]\nOutput: \"Draw\"\nExplanation: The game ends in a draw since there are no moves to make.\n\"XXO\"\n\"OOX\"\n\"XOX\"\n\nExample 4:\nInput: moves = [[0,0],[1,1]]\nOutput: \"Pending\"\nExplanation: The game has not finished yet.\n\"X  \"\n\" O \"\n\"   \"\n\nConstraints:\n\n1 <= moves.length <= 9\nmoves[i].length == 2\n0 <= moves[i][j] <= 2\nThere are no repeated elements on moves.\nmoves follow the rules of tic tac toe.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Move := Nat × Nat\n\ndef tictactoe (moves: List Move) : String :=\n  sorry", "vc-theorems": "theorem valid_output (moves: List Move) :\n  let result := tictactoe moves\n  result = \"A\" ∨ result = \"B\" ∨ result = \"Draw\" ∨ result = \"Pending\" := by\n  sorry\n\ntheorem moves_in_bounds (moves: List Move) :\n  ∀ move ∈ moves, move.1 ≤ 2 ∧ move.2 ≤ 2 := by \n  sorry\n\ntheorem alternating_players (moves: List Move) :\n  moves.length ≥ 2 →\n  let player_a := (List.enum moves).filter (λ x => x.1 % 2 = 0)\n  let player_b := (List.enum moves).filter (λ x => x.1 % 2 = 1)\n  player_a.length ≥ player_b.length ∧ \n  player_a.length - player_b.length ≤ 1 := by\n  sorry\n\ntheorem win_implies_three_in_line (moves: List Move) :\n  let result := tictactoe moves\n  (result = \"A\" → ((List.enum moves).filter (λ x => x.1 % 2 = 0)).length ≥ 3) ∧\n  (result = \"B\" → ((List.enum moves).filter (λ x => x.1 % 2 = 1)).length ≥ 3) := by\n  sorry\n\ntheorem draw_implies_full_board (moves: List Move) :\n  tictactoe moves = \"Draw\" → moves.length = 9 := by\n  sorry\n\n/-\ninfo: 'A'\n-/\n-- #guard_msgs in\n-- #eval tictactoe [[0, 0], [2, 0], [1, 1], [2, 1], [2, 2]]\n\n/-\ninfo: 'B'\n-/\n-- #guard_msgs in\n-- #eval tictactoe [[0, 0], [1, 1], [0, 1], [0, 2], [1, 0], [2, 0]]\n\n/-\ninfo: 'Draw'\n-/\n-- #guard_msgs in\n-- #eval tictactoe [[0, 0], [1, 1], [2, 0], [1, 0], [1, 2], [2, 1], [0, 1], [0, 2], [2, 2]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2363", "language": "lean", "source": "fvapps", "source-id": "fvapps_002363", "source-notes": "", "vc-description": "/-\nGiven two strings s and t which consist of only lowercase letters.\n\nString t is generated by random shuffling string s and then add one more letter at a random position.\n\nFind the letter that was added in t.\n\nExample:\n\nInput:\ns = \"abcd\"\nt = \"abcde\"\n\nOutput:\ne\n\nExplanation:\n'e' is the letter that was added.\n-/", "vc-preamble": "def sumList : List Nat → Nat \n  | [] => 0\n  | x :: xs => x + sumList xs", "vc-helpers": "", "vc-definitions": "def find_the_difference (s t : String) : Char := sorry\n\ntheorem find_difference_finds_added_char (s : String) (extra_char : Char) :\n  find_the_difference s (s.push extra_char) = extra_char := sorry", "vc-theorems": "theorem find_difference_order_independent (s : String) (t : String) (extra_char : Char) \n    (h : t = s.push extra_char) :\n  ∀ perm : String, Perm t perm → find_the_difference s perm = extra_char := sorry\n\ntheorem find_difference_empty_source (c : Char) :\n  find_the_difference \"\" (String.mk [c]) = c := sorry\n\ntheorem find_difference_ord_sum (s : String) (extra_char : Char) :\n  let t := s.push extra_char\n  Char.toNat (find_the_difference s t) = \n    sumList (t.data.map Char.toNat) - sumList (s.data.map Char.toNat) := sorry\n\n/-\ninfo: 'e'\n-/\n-- #guard_msgs in\n-- #eval find_the_difference \"abcd\" \"abcde\"\n\n/-\ninfo: 'y'\n-/\n-- #guard_msgs in\n-- #eval find_the_difference \"\" \"y\"\n\n/-\ninfo: '2'\n-/\n-- #guard_msgs in\n-- #eval find_the_difference \"hello\" \"hello2\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2380", "language": "lean", "source": "fvapps", "source-id": "fvapps_002380", "source-notes": "", "vc-description": "/-\nGiven a date, return the corresponding day of the week for that date.\nThe input is given as three integers representing the day, month and year respectively.\nReturn the answer as one of the following values {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}.\n\nExample 1:\nInput: day = 31, month = 8, year = 2019\nOutput: \"Saturday\"\n\nExample 2:\nInput: day = 18, month = 7, year = 1999\nOutput: \"Sunday\"\n\nExample 3:\nInput: day = 15, month = 8, year = 1993\nOutput: \"Sunday\"\n\nConstraints:\n\nThe given dates are valid dates between the years 1971 and 2100.\n-/", "vc-preamble": "def day_of_the_week (day month year : Nat) : Day :=\n  sorry\n\ndef isValidDate (day month year : Nat) : Prop :=\n  day ≥ 1 ∧ day ≤ 31 ∧ month ≥ 1 ∧ month ≤ 12", "vc-helpers": "", "vc-definitions": "def isLeapYear (year : Nat) : Prop :=\n  year % 4 = 0 ∧ (year % 100 ≠ 0 ∨ year = 2000)", "vc-theorems": "theorem valid_dates {day month year : Nat} \n  (hday : day ≥ 1 ∧ day ≤ 31)\n  (hmonth : month ≥ 1 ∧ month ≤ 12)\n  (hyear : year ≥ 1971 ∧ year ≤ 2100)\n  (hvalid : isValidDate day month year) :\n  ∃ d : Day, day_of_the_week day month year = d :=\nsorry\n\ntheorem leap_year {year month : Nat}\n  (hyear : year ≥ 1971 ∧ year ≤ 2100)\n  (hmonth : month = 2)\n  (hleap : isLeapYear year) :\n  ∃ d : Day, day_of_the_week 29 2 year = d :=\nsorry\n\ntheorem year_boundaries {year : Nat}\n  (hyear : year ≥ 1971 ∧ year ≤ 2100) :\n  ∃ d1 d2 : Day, \n    day_of_the_week 1 1 year = d1 ∧\n    day_of_the_week 31 12 year = d2 :=\nsorry\n\n/-\ninfo: 'Saturday'\n-/\n-- #guard_msgs in\n-- #eval day_of_the_week 31 8 2019\n\n/-\ninfo: 'Sunday'\n-/\n-- #guard_msgs in\n-- #eval day_of_the_week 18 7 1999\n\n/-\ninfo: 'Sunday'\n-/\n-- #guard_msgs in\n-- #eval day_of_the_week 15 8 1993", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2383", "language": "lean", "source": "fvapps", "source-id": "fvapps_002383", "source-notes": "", "vc-description": "/-\nIn a deck of cards, each card has an integer written on it.\nReturn true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:\n\nEach group has exactly X cards.\nAll the cards in each group have the same integer.\n\nExample 1:\nInput: deck = [1,2,3,4,4,3,2,1]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[3,3],[4,4].\n\nExample 2:\nInput: deck = [1,1,1,2,2,2,3,3]\nOutput: false´\nExplanation: No possible partition.\n\nExample 3:\nInput: deck = [1]\nOutput: false\nExplanation: No possible partition.\n\nExample 4:\nInput: deck = [1,1]\nOutput: true\nExplanation: Possible partition [1,1].\n\nExample 5:\nInput: deck = [1,1,2,2,2,2]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[2,2].\n\nConstraints:\n\n1 <= deck.length <= 10^4\n0 <= deck[i] < 10^4\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def has_groups_size_x (deck : List Int) : Bool := sorry\n\n@[simp]", "vc-theorems": "theorem unique_elements_no_groups (deck : List Int) \n  (h : ∀ x ∈ deck, (List.count x deck) = 1) : \n  ¬has_groups_size_x deck := sorry\n\ntheorem repeating_elements_divisible \n  (group_size : Nat) (num_groups : Nat)\n  (h1 : group_size ≥ 2) (h2 : num_groups ≥ 1)\n  (deck : List Int)\n  (h3 : deck = List.join (List.map (fun i => List.replicate group_size (Int.ofNat i)) (List.range num_groups))) :\n  has_groups_size_x deck := sorry\n\ntheorem mixed_groups_common_factor\n  (size1 size2 : Nat)\n  (h1 : size1 ≥ 2) (h2 : size2 ≥ 2)\n  (deck : List Int)\n  (h3 : ∃ k ≥ 2, size1 % k = 0 ∧ size2 % k = 0)\n  (h4 : deck = List.replicate size1 1 ++ List.replicate size2 2) :\n  has_groups_size_x deck := sorry\n\ntheorem permutation_invariant\n  (deck1 deck2 : List Int)\n  (h : List.Perm deck1 deck2) :\n  has_groups_size_x deck1 = has_groups_size_x deck2 := sorry\n\ntheorem doubled_deck_property\n  (deck : List Int)\n  (h : deck.length ≥ 1) :\n  has_groups_size_x deck ≤ has_groups_size_x (deck ++ deck) := sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval has_groups_size_x [1, 2, 3, 4, 4, 3, 2, 1]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval has_groups_size_x [1, 1, 1, 2, 2, 2, 3, 3]\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval has_groups_size_x [1, 1, 2, 2, 2, 2]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2389", "language": "lean", "source": "fvapps", "source-id": "fvapps_002389", "source-notes": "", "vc-description": "/-\nAn axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\nTwo rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.\nGiven two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.\n\nExample 1:\nInput: rec1 = [0,0,2,2], rec2 = [1,1,3,3]\nOutput: true\nExample 2:\nInput: rec1 = [0,0,1,1], rec2 = [1,0,2,1]\nOutput: false\nExample 3:\nInput: rec1 = [0,0,1,1], rec2 = [2,2,3,3]\nOutput: false\n\nConstraints:\n\nrect1.length == 4\nrect2.length == 4\n-109 <= rec1[i], rec2[i] <= 109\nrec1[0] <= rec1[2] and rec1[1] <= rec1[3]\nrec2[0] <= rec2[2] and rec2[1] <= rec2[3]\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_rectangles_overlap (r1 r2 : Rectangle) : Bool :=\n  sorry", "vc-theorems": "theorem overlap_symmetric {r1 r2 : Rectangle} :\n  is_rectangles_overlap r1 r2 = is_rectangles_overlap r2 r1 := by\n  sorry\n\ntheorem self_overlap {r : Rectangle} :\n  is_rectangles_overlap r r = true := by\n  sorry\n\ntheorem far_apart_no_overlap {r1 : Rectangle} {w h : Int}\n  (hw : w > 0) (hh : h > 0) :\n  let r2 := Rectangle.mk (r1.x2 + 1) (r1.y2 + 1) (r1.x2 + 2) (r1.y2 + 2)\n  is_rectangles_overlap r1 r2 = false := by\n  sorry\n\ntheorem touching_right_no_overlap {x y w h : Int}\n  (hw : w > 0) (hh : h > 0) : \n  let r1 := Rectangle.mk x y (x + w) (y + h)\n  let r2 := Rectangle.mk (x + w) y (x + w + 1) (y + h)\n  is_rectangles_overlap r1 r2 = false := by\n  sorry\n\ntheorem touching_top_no_overlap {x y w h : Int}\n  (hw : w > 0) (hh : h > 0) :\n  let r1 := Rectangle.mk x y (x + w) (y + h)\n  let r2 := Rectangle.mk x (y + h) (x + w) (y + h + 1)\n  is_rectangles_overlap r1 r2 = false := by\n  sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval is_rectangles_overlap [0, 0, 2, 2] [1, 1, 3, 3]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval is_rectangles_overlap [0, 0, 1, 1] [1, 0, 2, 1]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval is_rectangles_overlap [0, 0, 1, 1] [2, 2, 3, 3]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2395", "language": "lean", "source": "fvapps", "source-id": "fvapps_002395", "source-notes": "", "vc-description": "/-\nIn a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.\nReturn the element repeated N times.\n\nExample 1:\nInput: [1,2,3,3]\nOutput: 3\n\nExample 2:\nInput: [2,1,2,5,3,2]\nOutput: 2\n\nExample 3:\nInput: [5,1,5,2,5,3,5,4]\nOutput: 5\n\nNote:\n\n4 <= A.length <= 10000\n0 <= A[i] < 10000\nA.length is even\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def repeated_n_times (arr : List Int) : Option Int := sorry\n\ntheorem repeated_n_times_first_repeat {arr : List Int} {n : Int}\n  (h : repeated_n_times arr = some n) :\n  ∀ x : Int, x ∈ arr → x ≠ n → \n  (arr.take (arr.indexOf x)).count x ≤ 1 := sorry", "vc-theorems": "/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval repeated_n_times [1, 2, 3, 3]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval repeated_n_times [2, 1, 2, 5, 3, 2]\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval repeated_n_times [5, 1, 5, 2, 5, 3, 5, 4]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2426", "language": "lean", "source": "fvapps", "source-id": "fvapps_002426", "source-notes": "", "vc-description": "/-\nOn an 8 x 8 chessboard, there is one white rook.  There also may be empty squares, white bishops, and black pawns.  These are given as characters 'R', '.', 'B', and 'p' respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces.\nThe rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.  Also, rooks cannot move into the same square as other friendly bishops.\nReturn the number of pawns the rook can capture in one move.\n\nExample 1:\n\nInput: [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 3\nExplanation: \nIn this example the rook is able to capture all the pawns.\n\nExample 2:\n\nInput: [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 0\nExplanation: \nBishops are blocking the rook to capture any pawn.\n\nExample 3:\n\nInput: [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\nOutput: 3\nExplanation: \nThe rook can capture the pawns at positions b5, d6 and f5.\n\nNote:\n\nboard.length == board[i].length == 8\nboard[i][j] is either 'R', '.', 'B', or 'p'\nThere is exactly one cell with board[i][j] == 'R'\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def num_rook_captures (board: Board) : Nat :=\n  sorry", "vc-theorems": "theorem rook_captures_bounds {b : List (List Char)} : \n  b.length = 8 ∧ \n  (∀ r ∈ b, r.length = 8) →\n  let board := Board.mk b\n  let captures := num_rook_captures board \n  0 ≤ captures ∧ captures ≤ 4 := \n  sorry\n\ntheorem rook_presence {b : List (List Char)} :\n  b.length = 8 ∧\n  (∀ r ∈ b, r.length = 8) →\n  let board := Board.mk b\n  ((b.map (fun row => row.filter (· = 'R'))).join).length = 1 :=\n  sorry\n\ntheorem blocked_by_bishop {b : List (List Char)} :\n  b.length = 8 ∧\n  (∀ r ∈ b, r.length = 8) →\n  let board := Board.mk b\n  let blocked_pawns := -- count of pawns blocked by bishops\n    0 -- placeholder\n  num_rook_captures board ≤ 4 - blocked_pawns :=\n  sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval num_rook_captures [[\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"], [\".\", \".\", \".\", \"p\", \".\", \".\", \".\", \".\"], [\".\", \".\", \".\", \"R\", \".\", \".\", \".\", \"p\"], [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"], [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"], [\".\", \".\", \".\", \"p\", \".\", \".\", \".\", \".\"], [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"], [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval num_rook_captures [[\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"], [\".\", \"p\", \"p\", \"p\", \"p\", \"p\", \".\", \".\"], [\".\", \"p\", \"p\", \"B\", \"p\", \"p\", \".\", \".\"], [\".\", \"p\", \"B\", \"R\", \"B\", \"p\", \".\", \".\"], [\".\", \"p\", \"p\", \"B\", \"p\", \"p\", \".\", \".\"], [\".\", \"p\", \"p\", \"p\", \"p\", \"p\", \".\", \".\"], [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"], [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2428", "language": "lean", "source": "fvapps", "source-id": "fvapps_002428", "source-notes": "", "vc-description": "/-\nGiven a m * n matrix grid which is sorted in non-increasing order both row-wise and column-wise. \nReturn the number of negative numbers in grid.\n\nExample 1:\nInput: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\nOutput: 8\nExplanation: There are 8 negatives number in the matrix.\n\nExample 2:\nInput: grid = [[3,2],[1,0]]\nOutput: 0\n\nExample 3:\nInput: grid = [[1,-1],[-1,-1]]\nOutput: 3\n\nExample 4:\nInput: grid = [[-1]]\nOutput: 1\n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def count_negatives (grid : List (List Int)) : Nat := sorry\n\ntheorem count_negatives_matches_direct_count (grid : List (List Int)) : \n  count_negatives grid = (grid.bind (·.filter (·<0))).length := sorry", "vc-theorems": "theorem count_negatives_nonnegative (grid : List (List Int)) :\n  count_negatives grid ≥ 0 := sorry\n\n/-\ninfo: 8\n-/\n-- #guard_msgs in\n-- #eval count_negatives [[4, 3, 2, -1], [3, 2, 1, -1], [1, 1, -1, -2], [-1, -1, -2, -3]]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval count_negatives [[3, 2], [1, 0]]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval count_negatives [[1, -1], [-1, -1]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2436", "language": "lean", "source": "fvapps", "source-id": "fvapps_002436", "source-notes": "", "vc-description": "/-\n=====Function Descriptions=====\n.remove(x)\n\nThis operation removes element x from the set.\nIf element x does not exist, it raises a KeyError.\nThe .remove(x) operation returns None.\n\nExample\n\n>>> s = set([1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> s.remove(5)\n>>> print s\nset([1, 2, 3, 4, 6, 7, 8, 9])\n>>> print s.remove(4)\nNone\n>>> print s\nset([1, 2, 3, 6, 7, 8, 9])\n>>> s.remove(0)\nKeyError: 0\n\n.discard(x)\n\nThis operation also removes element x from the set.\nIf element x does not exist, it does not raise a KeyError.\nThe .discard(x) operation returns None.\n\nExample\n\n>>> s = set([1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> s.discard(5)\n>>> print s\nset([1, 2, 3, 4, 6, 7, 8, 9])\n>>> print s.discard(4)\nNone\n>>> print s\nset([1, 2, 3, 6, 7, 8, 9])\n>>> s.discard(0)\n>>> print s\nset([1, 2, 3, 6, 7, 8, 9])\n\n.pop()\n\nThis operation removes and return an arbitrary element from the set.\nIf there are no elements to remove, it raises a KeyError.\n\nExample\n\n>>> s = set([1])\n>>> print s.pop()\n1\n>>> print s\nset([])\n>>> print s.pop()\nKeyError: pop from an empty set\n\n=====Problem Statement=====\nYou have a non-empty set s, and you have to execute N commands given in N lines.\nThe commands will be pop, remove and discard. \n\n=====Input Format=====\nThe first line contains integer n, the number of elements in the set s.\nThe second line contains n space separated elements of set s. All of the elements are non-negative integers, less than or equal to 9.\nThe third line contains integer N, the number of commands.\nThe next N lines contains either pop, remove and/or discard commands followed by their associated value.\n\n=====Constraints=====\n0 < n < 20\n0 < N < 20\n\n=====Output Format====\nPrint the sum of the elements of set s on a single line.\n-/", "vc-preamble": "def sumSet (s : SetInt) : Int := sorry\ndef process_set_commands (elements : List Int) (commands : List String) : Int := sorry", "vc-helpers": "", "vc-definitions": "def pop_element_from_set (s : SetInt) : SetInt := sorry\ndef contains (s : SetInt) (x : Int) : Bool := sorry", "vc-theorems": "theorem pop_reduces_size (elements : List Int) (h : elements ≠ []) : \n  let s := SetInt.mk elements\n  let after_pop := pop_element_from_set s\n  List.length after_pop.elements = List.length s.elements - 1 ∧ \n  process_set_commands elements [\"pop\"] = sumSet after_pop := sorry\n\ntheorem remove_vs_discard (elements : List Int) (value : Int) :\n  let s := SetInt.mk elements\n  let remove_result := process_set_commands elements [s!\"remove {value}\"]\n  let discard_result := process_set_commands elements [s!\"discard {value}\"]\n  if contains s value then\n    remove_result = discard_result\n  else\n    discard_result = sumSet s := sorry\n\ntheorem limited_pops (elements : List Int) (num_pops : Nat) \n  (h1 : elements ≠ []) \n  (h2 : List.length elements > num_pops)\n  (h3 : num_pops ≤ 3) :\n  let commands := List.replicate num_pops \"pop\"\n  let s := SetInt.mk elements\n  let result := process_set_commands elements commands\n  let final_set := (List.foldl (fun acc _ => pop_element_from_set acc) s commands)\n  result = sumSet final_set := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2438", "language": "lean", "source": "fvapps", "source-id": "fvapps_002438", "source-notes": "", "vc-description": "/-\n=====Function Descriptions=====\nitertools.product()\n\nThis tool computes the cartesian product of input iterables.\nIt is equivalent to nested for-loops.\nFor example, product(A, B) returns the same as ((x,y) for x in A for y in B).\n\nSample Code\n\n>>> from itertools import product\n>>>\n>>> print list(product([1,2,3],repeat = 2))\n[(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]\n>>>\n>>> print list(product([1,2,3],[3,4]))\n[(1, 3), (1, 4), (2, 3), (2, 4), (3, 3), (3, 4)]\n>>>\n>>> A = [[1,2,3],[3,4,5]]\n>>> print list(product(*A))\n[(1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 3), (3, 4), (3, 5)]\n>>>\n>>> B = [[1,2,3],[3,4,5],[7,8]]\n>>> print list(product(*B))\n[(1, 3, 7), (1, 3, 8), (1, 4, 7), (1, 4, 8), (1, 5, 7), (1, 5, 8), (2, 3, 7), (2, 3, 8), (2, 4, 7), (2, 4, 8), (2, 5, 7), (2, 5, 8), (3, 3, 7), (3, 3, 8), (3, 4, 7), (3, 4, 8), (3, 5, 7), (3, 5, 8)]\n\n=====Problem Statement=====\nYou are given a two lists A and B. Your task is to compute their cartesian product AXB.\nExample\nA = [1, 2]\nB = [3, 4]\n\nAxB = [(1, 3), (1, 4), (2, 3), (2, 4)]\nNote: A and B are sorted lists, and the cartesian product's tuples should be output in sorted order.\n\n=====Input Format=====\nThe first line contains the space separated elements of list A.\nThe second line contains the space separated elements of list B.\nBoth lists have no duplicate integer elements.\n\n=====Constraints=====\n0<A<30\n0<B<30\n\n=====Output Format=====\nOutput the space separated tuples of the cartesian product.\n-/", "vc-preamble": "def List.size {α} : List α → Nat \n  | [] => 0\n  | (_::xs) => 1 + xs.size", "vc-helpers": "", "vc-definitions": "def computeProduct {α} (xs : List α) (ys : List β) : List (α × β) :=\n  sorry", "vc-theorems": "theorem computeProduct_matches_itertools {α} (xs : List α) (ys : List β) \n  (h1 : xs.size > 0) (h2 : xs.size ≤ 10)\n  (h3 : ys.size > 0) (h4 : ys.size ≤ 10) :\n  computeProduct xs ys = List.join (xs.map (λ x => ys.map (λ y => (x, y)))) :=\nsorry\n\n/-\ninfo: '(1, 3) (1, 4) (2, 3) (2, 4)'\n-/\n-- #guard_msgs in\n-- #eval compute_product [1, 2] [3, 4]\n\n/-\ninfo: '(1, 3) (1, 4) (1, 5)'\n-/\n-- #guard_msgs in\n-- #eval compute_product [1] [3, 4, 5]\n\n/-\ninfo: '(1, 4) (2, 4) (3, 4)'\n-/\n-- #guard_msgs in\n-- #eval compute_product [1, 2, 3] [4]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2443", "language": "lean", "source": "fvapps", "source-id": "fvapps_002443", "source-notes": "", "vc-description": "/-\n=====Function Descriptions=====\ninner\n\nThe inner tool returns the inner product of two arrays.\n\nimport numpy\n\nA = numpy.array([0, 1])\nB = numpy.array([3, 4])\n\nprint numpy.inner(A, B)     #Output : 4\n\nouter\n\nThe outer tool returns the outer product of two arrays.\n\nimport numpy\n\nA = numpy.array([0, 1])\nB = numpy.array([3, 4])\n\nprint numpy.outer(A, B)     #Output : [[0 0]\n                            #          [3 4]]\n\n=====Problem Statement=====\nYou are given two arrays: A and B.\nYour task is to compute their inner and outer product.\n\n=====Input Format=====\nThe first line contains the space separated elements of array A.\nThe second line contains the space separated elements of array B.\n\n=====Output Format=====\nFirst, print the inner product.\nSecond, print the outer product.\n-/", "vc-preamble": "def inner_product (v1 v2 : Vec Int) : Int := sorry \n\ndef outer_product (v1 v2 : Vec Int) : Vec (Vec Int) := sorry\n\ndef vec_length {α : Type} (v : Vec α) : Nat :=\n  match v with\n  | Vec.nil => 0\n  | Vec.cons _ rest => 1 + vec_length rest\n\ndef vec_sum_squares (v : Vec Int) : Int := sorry\n\ndef vec_transpose (m : Vec (Vec Int)) : Vec (Vec Int) := sorry", "vc-helpers": "", "vc-definitions": "def vec_zip_with {α β γ : Type} (f : α → β → γ) : Vec α → Vec β → Vec γ := sorry\n\ndef vec_elem_prod (v1 v2 : Vec Int) : Int := sorry\n\n-- Inner product equals element-wise product sum", "vc-theorems": "theorem inner_product_equals_elemprod {v1 v2 : Vec Int} (h : vec_length v1 = vec_length v2) :\n  inner_product v1 v2 = vec_elem_prod v1 v2 :=\nsorry\n\n-- Shape of outer product\n\ntheorem outer_product_dimensions {v1 v2 : Vec Int} :\n  vec_length (outer_product v1 v2) = vec_length v1 :=\nsorry\n\n-- Inner product with self equals sum of squares \n\ntheorem inner_product_self {v : Vec Int} :\n  inner_product v v = vec_sum_squares v :=\nsorry\n\n-- Outer product transpose property\n\ntheorem outer_product_transpose_prop {v1 v2 : Vec Int} (h : vec_length v1 = vec_length v2) :\n  outer_product v1 v2 = vec_transpose (outer_product v2 v1) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2471", "language": "lean", "source": "fvapps", "source-id": "fvapps_002471", "source-notes": "", "vc-description": "/-\n=====Problem Statement=====\nYou are given n words. Some words may repeat. For each word, output its number of occurrences. The output order should correspond with the input order of appearance of the word. See the sample input/output for clarification.\n\nNote: Each input line ends with a \"\\n\" character.\n\n=====Constraints=====\n1≤n≤10^5\nThe sum of the lengths of all the words do not exceed 10^6\nAll the words are composed of lowercase English letters only.\n\n=====Input Format=====\nThe first line contains the integer, n.\nThe next n lines each contain a word.\n\n=====Output Format=====\nOutput 2 lines.\nOn the first line, output the number of distinct words from the input.\nOn the second line, output the number of occurrences for each distinct word according to their appearance in the input.\n-/", "vc-preamble": "def List.sum : List Nat → Nat\n  | [] => 0\n  | (h::t) => h + sum t", "vc-helpers": "", "vc-definitions": "def count_word_occurrences (words : List String) : WordCountResult :=\n  sorry", "vc-theorems": "theorem count_word_occurrences_empty_input :\n  count_word_occurrences [] = ⟨0, []⟩ :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2473", "language": "lean", "source": "fvapps", "source-id": "fvapps_002473", "source-notes": "", "vc-description": "/-\n=====Function Descriptions=====\nA set is an unordered collection of elements without duplicate entries.\nWhen printed, iterated or converted into a sequence, its elements will appear in an arbitrary order.\n\n=====Example=====\n>>> print set()\nset([])\n\n>>> print set('HackerRank')\nset(['a', 'c', 'e', 'H', 'k', 'n', 'r', 'R'])\n\n>>> print set([1,2,1,2,3,4,5,6,0,9,12,22,3])\nset([0, 1, 2, 3, 4, 5, 6, 9, 12, 22])\n\n>>> print set((1,2,3,4,5,5))\nset([1, 2, 3, 4, 5])\n\n>>> print set(set(['H','a','c','k','e','r','r','a','n','k']))\nset(['a', 'c', 'r', 'e', 'H', 'k', 'n'])\n\n>>> print set({'Hacker' : 'DOSHI', 'Rank' : 616 })\nset(['Hacker', 'Rank'])\n\n>>> print set(enumerate(['H','a','c','k','e','r','r','a','n','k']))\nset([(6, 'r'), (7, 'a'), (3, 'k'), (4, 'e'), (5, 'r'), (9, 'k'), (2, 'c'), (0, 'H'), (1, 'a'), (8, 'n')])\n\nBasically, sets are used for membership testing and eliminating duplicate entries.\n\n=====Problem Statement=====\nNow, let's use our knowledge of sets and help Mickey.\n\nMs. Gabriel Williams is a botany professor at District College. One day, she asked her student Mickey to compute the average of all the plants with distinct heights in her greenhouse.\n\nFormula used: \nAverage = Sum of Distinct Heights / Total Number of Distinct Heights\n\n=====Input Format=====\nThe first line contains the integer, N, the total number of plants.\nThe second line contains the N space separated heights of the plants.\n\n=====Constraints=====\n0<N≤100\n\n=====Output Format=====\nOutput the average height value on a single line.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculateDistinctPlantHeightsAvg (n : Nat) (heights : String) : Float := sorry\n\ntheorem avg_between_min_max \n  (n : Nat) (heights : List Nat) (h₁ : ∀ x ∈ heights, 1 ≤ x ∧ x ≤ 1000) (h₂ : heights ≠ []) :\n  let result := calculateDistinctPlantHeightsAvg n (heights.toString)\n  let min_height := heights.minimum?.get!\n  let max_height := heights.maximum?.get!\n  Float.ofNat min_height ≤ result ∧ result ≤ Float.ofNat max_height := sorry", "vc-theorems": "theorem duplicate_heights_same_avg \n  (n : Nat) (heights : List Nat) (h₁ : ∀ x ∈ heights, 1 ≤ x ∧ x ≤ 1000) (h₂ : heights ≠ []) :\n  let result₁ := calculateDistinctPlantHeightsAvg n (heights.toString)\n  let result₂ := calculateDistinctPlantHeightsAvg (2*n) (heights.toString ++ heights.toString)\n  (result₁ - result₂).abs < 0.0001 := sorry\n\ntheorem sorted_heights_avg \n  (n : Nat) (heights : List Nat) (h₁ : ∀ x ∈ heights, 1 ≤ x ∧ x ≤ 1000) \n  (h₂ : heights ≠ []) (h₃ : ∀ i j, i < j → j < heights.length → heights[i]! ≤ heights[j]!) :\n  let result := calculateDistinctPlantHeightsAvg n (heights.toString)\n  let distinct := heights.eraseDups\n  let total : Nat := distinct.foldl (init := 0) (·+·)\n  let expected := (Float.ofNat total) / (Float.ofNat distinct.length)\n  (result - expected).abs < 0.0001 := sorry\n\ntheorem single_height (h : 1 ≤ 5 ∧ 5 ≤ 1000) :\n  calculateDistinctPlantHeightsAvg 1 \"5\" = 5.0 := sorry\n\ntheorem same_heights (h : 1 ≤ 7 ∧ 7 ≤ 1000) :\n  calculateDistinctPlantHeightsAvg 3 \"7 7 7\" = 7.0 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2478", "language": "lean", "source": "fvapps", "source-id": "fvapps_002478", "source-notes": "", "vc-description": "/-\n=====Function Descriptions=====\nTranspose\n\nWe can generate the transposition of an array using the tool numpy.transpose.\nIt will not affect the original array, but it will create a new array.\n\nimport numpy\n\nmy_array = numpy.array([[1,2,3],\n                        [4,5,6]])\nprint numpy.transpose(my_array)\n\n#Output\n[[1 4]\n [2 5]\n [3 6]]\n\nFlatten\n\nThe tool flatten creates a copy of the input array flattened to one dimension.\n\nimport numpy\n\nmy_array = numpy.array([[1,2,3],\n                        [4,5,6]])\nprint my_array.flatten()\n\n#Output\n[1 2 3 4 5 6]\n\n=====Problem Statement=====\nYou are given a NXM integer array matrix with space separated elements (N = rows and M = columns).\nYour task is to print the transpose and flatten results.\n\n=====Input Format=====\nThe first line contains the space separated values of N and M.\nThe next N lines contains the space separated elements of M columns.\n\n=====Output Format=====\nFirst, print the transpose array and then print the flatten.\n-/", "vc-preamble": "def process_matrix (n m : Nat) (matrix : List (List Nat)) : \n  (List (List Nat)) × (List Nat) := sorry", "vc-helpers": "", "vc-definitions": "def transpose (matrix : List (List Nat)) : List (List Nat) := sorry\n\ntheorem process_matrix_dimensions {n m : Nat} {matrix : List (List Nat)}\n  (hn : n > 0) (hm : m > 0) (hmatrix : matrix.length = n ∧ \n  ∀ row ∈ matrix, row.length = m) :\n  let (transposed, flattened) := process_matrix n m matrix\n  transposed.length = m ∧ \n  (∀ row ∈ transposed, row.length = n) ∧\n  flattened.length = n * m := sorry", "vc-theorems": "theorem process_matrix_transpose {n m : Nat} {matrix : List (List Nat)}\n  (hn : n > 0) (hm : m > 0) (hmatrix : matrix.length = n ∧ \n  ∀ row ∈ matrix, row.length = m) :\n  let (transposed, _) := process_matrix n m matrix\n  matrix = transpose transposed := sorry\n\ntheorem process_matrix_flatten {n m : Nat} {matrix : List (List Nat)}\n  (hn : n > 0) (hm : m > 0) (hmatrix : matrix.length = n ∧ \n  ∀ row ∈ matrix, row.length = m) :\n  let (_, flattened) := process_matrix n m matrix\n  flattened = matrix.join := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2486", "language": "lean", "source": "fvapps", "source-id": "fvapps_002486", "source-notes": "", "vc-description": "/-\n=====Function Descriptions=====\n.intersection()\n\nThe .intersection() operator returns the intersection of a set and the set of elements in an iterable.\nSometimes, the & operator is used in place of the .intersection() operator, but it only operates on the set of elements in set.\nThe set is immutable to the .intersection() operation (or & operation).\n\n>>> s = set(\"Hacker\")\n>>> print s.intersection(\"Rank\")\nset(['a', 'k'])\n\n>>> print s.intersection(set(['R', 'a', 'n', 'k']))\nset(['a', 'k'])\n\n>>> print s.intersection(['R', 'a', 'n', 'k'])\nset(['a', 'k'])\n\n>>> print s.intersection(enumerate(['R', 'a', 'n', 'k']))\nset([])\n\n>>> print s.intersection({\"Rank\":1})\nset([])\n\n>>> s & set(\"Rank\")\nset(['a', 'k'])\n\n=====Problem Statement=====\nThe students of District College have subscriptions to English and French newspapers. Some students have subscribed only to English, some have subscribed only to French, and some have subscribed to both newspapers.\n\nYou are given two sets of student roll numbers. One set has subscribed to the English newspaper, one set has subscribed to the French newspaper. Your task is to find the total number of students who have subscribed to both newspapers.\n\n=====Input Format=====\nThe first line contains n, the number of students who have subscribed to the English newspaper.\nThe second line contains n space separated roll numbers of those students.\nThe third line contains b, the number of students who have subscribed to the French newspaper.\nThe fourth line contains b space separated roll numbers of those students.\n\n=====Constraints=====\n0 < Total number of students in college < 1000\n\n=====Output Format=====\nOutput the total number of students who have subscriptions to both English and French newspapers.\n-/", "vc-preamble": "def List.toFinset {α : Type} (l : List α) : Finset α :=\n  sorry\n\ndef count_dual_subscribers (eng: List Int) (fr: List Int) : Nat :=\n  sorry\n\ndef intersection_size {α : Type} (l1 l2 : List α) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def uniqueCount {α : Type} (l : List α) : Nat :=\n  sorry", "vc-theorems": "theorem count_dual_subscribers_bounded (eng fr: List Int) : \n  count_dual_subscribers eng fr ≤ eng.length ∧ \n  count_dual_subscribers eng fr ≤ fr.length :=\nsorry\n\ntheorem count_dual_subscribers_nonnegative (eng fr: List Int) :\n  count_dual_subscribers eng fr ≥ 0 :=\nsorry\n\ntheorem count_dual_subscribers_equals_intersection (eng fr: List Int) :\n  count_dual_subscribers eng fr = intersection_size eng fr :=\nsorry\n\ntheorem count_dual_subscribers_symmetric (eng fr: List Int) :\n  count_dual_subscribers eng fr = count_dual_subscribers fr eng :=\nsorry\n\ntheorem count_dual_subscribers_empty_list (eng fr: List Int) :\n  count_dual_subscribers [] fr = 0 ∧\n  count_dual_subscribers eng [] = 0 :=\nsorry\n\ntheorem count_dual_subscribers_same_list (xs: List Int) :\n  count_dual_subscribers xs xs = uniqueCount xs :=\nsorry\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval count_dual_subscribers [1, 2, 3, 4, 5, 6, 7, 8, 9] [10, 1, 2, 3, 11, 21, 55, 6, 8]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval count_dual_subscribers [1, 2, 3] [4, 5, 6]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval count_dual_subscribers [1, 2, 3] [1, 2, 3]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2496", "language": "lean", "source": "fvapps", "source-id": "fvapps_002496", "source-notes": "", "vc-description": "/-\n=====Problem Statement=====\nMr. Anant Asankhya is the manager at the INFINITE hotel. The hotel has an infinite amount of rooms.\n\nOne fine day, a finite number of tourists come to stay at the hotel.\nThe tourists consist of:\n→ A Captain.\n→ An unknown group of families consisting of K members per group where K ≠ 1.\n\nThe Captain was given a separate room, and the rest were given one room per group.\n\nMr. Anant has an unordered list of randomly arranged room entries. The list consists of the room numbers for all of the tourists. The room numbers will appear K times per group except for the Captain's room.\n\nMr. Anant needs you to help him find the Captain's room number.\nThe total number of tourists or the total number of groups of families is not known to you.\nYou only know the value of K and the room number list.\n\n=====Input Format=====\nThe first consists of an integer, K, the size of each group.\nThe second line contains the unordered elements of the room number list.\n\n=====Constraints=====\n1<K<1000\n\n=====Output Format=====\nOutput the Captain's room number.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_captains_room (k : Nat) (rooms : List Nat) : Nat := sorry\n\n-- Main property theorems", "vc-theorems": "theorem find_captains_room_properties \n  (k : Nat) (regular_rooms : List Nat) (captain_room : Nat)\n  (h1 : k ≥ 2) (h2 : k ≤ 20)\n  (h3 : ∀ r ∈ regular_rooms, r ≥ 1 ∧ r ≤ 50)\n  (h4 : captain_room ≥ 51) (h5 : captain_room ≤ 100)\n  (h6 : captain_room ∉ regular_rooms) :\n  let room_numbers := (regular_rooms.map (λ r => List.replicate k r)).join ++ [captain_room] \n  have result := find_captains_room k room_numbers\n  -- Main assertions\n  find_captains_room k room_numbers = captain_room ∧ \n  (room_numbers.filter (λ x => x = find_captains_room k room_numbers)).length = 1 ∧\n  -- k copies of regular rooms\n  ∀ room ∈ regular_rooms, \n    (room_numbers.filter (λ x => x = room)).length = k := sorry\n\n-- Minimal case theorem\n\ntheorem find_captains_room_minimal_case\n  (k : Nat) (h1 : k ≥ 2) (h2 : k ≤ 20) :\n  find_captains_room k (List.replicate k 1 ++ [2]) = 2 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2497", "language": "lean", "source": "fvapps", "source-id": "fvapps_002497", "source-notes": "", "vc-description": "/-\n=====Problem Statement=====\nThere is an array of n integers. There are also 2 disjoint sets, A and B, each containing m integers. You like all the integers in set A and dislike all the integers in set B. Your initial happiness is 0. For each integer i in the array, if i ∈ A, you add 1 to your happiness. If i ∈ B, you add -1 to your happiness. Otherwise, your happiness does not change. Output your final happiness at the end.\n\nNote: Since A and B are sets, they have no repeated elements. However, the array might contain duplicate elements.\n\n=====Constraints=====\n1≤n≤10^5\n1≤m≤10^5\n1≤Any integer in the input≤10^9\n\n=====Input Format=====\nThe first line contains integers n and m separated by a space.\nThe second line contains n integers, the elements of the array.\nThe third and fourth lines contain m integers, A and B, respectively.\n\n=====Output Format=====\nOutput a single integer, your total happiness.\n-/", "vc-preamble": "def SetInt.contains (s : SetInt) (x : Int) : Bool :=\n  match s with\n  | mk list => list.contains x", "vc-helpers": "", "vc-definitions": "def SetInt.empty : SetInt := SetInt.mk []\n\ndef calculate_happiness (arr : List Int) (setA setB : SetInt) : Int :=\n  sorry", "vc-theorems": "theorem happiness_count_property (arr : List Int) (setA setB : SetInt) \n    (h : arr.length > 0) :\n  calculate_happiness arr setA setB = \n    ((arr.filter (λ x => setA.contains x)).length - \n     (arr.filter (λ x => setB.contains x)).length) :=\n  sorry\n\ntheorem disjoint_set_no_effect (arr : List Int) (setA : SetInt) \n    (h : arr.length > 0) :\n  let disjointSet := SetInt.mk [arr.maximum?.get!.add 1]\n  (calculate_happiness arr setA disjointSet = calculate_happiness arr setA SetInt.empty) ∧ \n  (calculate_happiness arr disjointSet setA = calculate_happiness arr SetInt.empty setA) :=\n  sorry\n\ntheorem empty_sets_zero (arr : List Int) (h : arr.length > 0) :\n  calculate_happiness arr SetInt.empty SetInt.empty = 0 :=\n  sorry\n\ntheorem same_set_cancels (arr : List Int) (testSet : SetInt) \n    (h : arr.length > 0) :\n  calculate_happiness arr testSet testSet = 0 :=\n  sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval calculate_happiness [1, 5, 3] {3, 1} {5, 7}\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval calculate_happiness [1, 2, 3] {4, 5} {6, 7}\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval calculate_happiness [1, 1, 2, 2, 3] {1, 3} {2}", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2499", "language": "lean", "source": "fvapps", "source-id": "fvapps_002499", "source-notes": "", "vc-description": "/-\n=====Problem Statement=====\nA valid postal code P have to fullfil both below requirements:\n\n1. P must be a number in the range from 100000 to 999999 inclusive.\n2. P must not contain more than one alternating repetitive digit pair.\n\nAlternating repetitive digits are digits which repeat immediately after the next digit. In other words, an alternating repetitive digit pair is formed by two equal digits that have just a single digit between them.\n\nFor example:\n\n121426 # Here, 1 is an alternating repetitive digit.\n523563 # Here, NO digit is an alternating repetitive digit.\n552523 # Here, both 2 and 5 are alternating repetitive digits.\n\nYour task is to provide two regular expressions regex_integer_in_range and regex_alternating_repetitive_digit_pair. Where:\n\nregex_integer_in_range should match only integers range from 100000 to 999999 inclusive\n\nregex_alternating_repetitive_digit_pair should find alternating repetitive digits pairs in a given string.\n\nBoth these regular expressions will be used by the provided code template to check if the input string P is a valid postal code using the following expression:\n(bool(re.match(regex_integer_in_range, P)) \nand len(re.findall(regex_alternating_repetitive_digit_pair, P)) < 2)\n\n=====Input Format=====\nLocked stub code in the editor reads a single string denoting P from stdin and uses provided expression and your regular expressions to validate if P is a valid postal code.\n\n=====Output Format=====\nYou are not responsible for printing anything to stdout. Locked stub code in the editor does that.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def validate_postal_code (s : String) : Bool := sorry\n\ntheorem invalid_format_postal_code {s : String} :\n  (¬ s.all Char.isDigit) ∨ (s.length ≠ 6) ∨ (s.data[0]! = '0') →\n  validate_postal_code s = false := sorry", "vc-theorems": "theorem valid_format_postal_codes {s : String} \n  (h₁ : s.length = 6)\n  (h₂ : s.all Char.isDigit) \n  (h₃ : s.data[0]! ≠ '0') :\n  validate_postal_code s = \n    ¬ (∃ i : Fin 4, ∃ j : Fin 4, i ≠ j ∧ \n       s.data[i.val]! = s.data[(i.val + 2)]! ∧\n       s.data[j.val]! = s.data[(j.val + 2)]!) := sorry\n\nend PostalCode\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval validate_postal_code \"110000\"\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval validate_postal_code \"121426\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval validate_postal_code \"552523\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2501", "language": "lean", "source": "fvapps", "source-id": "fvapps_002501", "source-notes": "", "vc-description": "/-\n=====Problem Statement=====\nThe itertools module standardizes a core set of fast, memory efficient tools that are useful by themselves or in combination. Together, they form an iterator algebra making it possible to construct specialized tools succinctly and efficiently in pure Python.\n\nYou are given a list of N lowercase English letters. For a given integer K, you can select any K indices (assume 1-based indexing) with a uniform probability from the list.\nFind the probability that at least one of the K indices selected will contain the letter: ''.\n\n=====Input Format=====\nThe input consists of three lines. The first line contains the integer N, denoting the length of the list. The next line consists of N space-separated lowercase English letters, denoting the elements of the list.\nThe third and the last line of input contains the integer K, denoting the number of indices to be selected.\n\n=====Output Format=====\nOutput a single line consisting of the probability that at least one of the K indices selected contains the letter: 'a'.\nNote: The answer must be correct up to 3 decimal places. \n\n=====Constraints=====\n1≤N≤10\n1≤K≤N\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calc_probability_of_a (letters: List Letter) (k: Nat) : Float :=\n  sorry", "vc-theorems": "theorem prob_between_zero_and_one (letters: List Letter) (k: Nat) (h: k ≤ letters.length) :\n  let prob := calc_probability_of_a letters k\n  0 ≤ prob ∧ prob ≤ 1 := by\n  sorry\n\ntheorem no_a_prob_zero (letters: List Letter) (k: Nat) (h1: k ≤ letters.length)\n  (h2: ¬ (letters.contains Letter.a)) :\n  calc_probability_of_a letters k = 0 := by\n  sorry\n\ntheorem all_letters_k_prob_one (letters: List Letter) (k: Nat)\n  (h1: k = letters.length) (h2: letters.contains Letter.a) : \n  calc_probability_of_a letters k = 1 := by\n  sorry\n\ntheorem all_a_prob_one (letters: List Letter) (k: Nat) \n  (h1: k ≤ letters.length) (h2: ∀ l ∈ letters, l = Letter.a) :\n  calc_probability_of_a letters k = 1 := by\n  sorry\n\ntheorem only_a_letters_prob_one (letters: List Letter) (k: Nat)\n  (h1: k ≤ letters.length) (h2: ∀ l ∈ letters, l = Letter.a) :\n  calc_probability_of_a letters k = 1 := by\n  sorry\n\ntheorem no_a_letters_prob_zero (letters: List Letter) (k: Nat)\n  (h1: k ≤ letters.length) (h2: ∀ l ∈ letters, l ≠ Letter.a) :\n  calc_probability_of_a letters k = 0 := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2506", "language": "lean", "source": "fvapps", "source-id": "fvapps_002506", "source-notes": "", "vc-description": "/-\n=====Function Descriptions=====\nThe NumPy module also comes with a number of built-in routines for linear algebra calculations. These can be found in the sub-module linalg.\n\nlinalg.det\n\nThe linalg.det tool computes the determinant of an array.\n\nprint numpy.linalg.det([[1 , 2], [2, 1]])       #Output : -3.0\n\nlinalg.eig\n\nThe linalg.eig computes the eigenvalues and right eigenvectors of a square array.\n\nvals, vecs = numpy.linalg.eig([[1 , 2], [2, 1]])\nprint vals                                      #Output : [ 3. -1.]\nprint vecs                                      #Output : [[ 0.70710678 -0.70710678]\n                                                #          [ 0.70710678  0.70710678]]\n\nlinalg.inv\n\nThe linalg.inv tool computes the (multiplicative) inverse of a matrix.\n\nprint numpy.linalg.inv([[1 , 2], [2, 1]])       #Output : [[-0.33333333  0.66666667]\n                                                #          [ 0.66666667 -0.33333333]]\n\n=====Problem Statement=====\nYou are given a square matrix A with dimensions NXN. Your task is to find the determinant. Note: Round the answer to 2 places after the decimal.\n\n=====Input Format=====\nThe first line contains the integer N.\nThe next N lines contains the space separated elements of array A. \n\n=====Output Format=====\nPrint the determinant of A.\n-/", "vc-preamble": "def identityMatrix (n : Nat) : Matrix n Float := sorry\ndef zeroMatrix (n : Nat) : Matrix n Float := sorry", "vc-helpers": "", "vc-definitions": "def calculateMatrixDeterminant {n : Nat} (matrix : Matrix n Float) : Float := sorry\ndef transpose {n : Nat} (matrix : Matrix n Float) : Matrix n Float := sorry", "vc-theorems": "theorem identity_matrix_det {n : Nat} (h : n > 0) : \n  calculateMatrixDeterminant (identityMatrix n) = 1 := sorry\n\ntheorem zero_matrix_det {n : Nat} (h : n > 0) :\n  calculateMatrixDeterminant (zeroMatrix n) = 0 := sorry\n\ntheorem det_2x2_formula (matrix : Matrix 2 Float) (h : matrix.data.length = 2) :\n  calculateMatrixDeterminant matrix = \n    let rows := matrix.data\n    let r0 := rows[0]!\n    let r1 := rows[1]!\n    r0[0]! * r1[1]! - r0[1]! * r1[0]! := sorry\n\ntheorem det_transpose_eq {n : Nat} (matrix : Matrix n Float) :\n  calculateMatrixDeterminant (transpose matrix) = \n    calculateMatrixDeterminant matrix := sorry\n\n/-\ninfo: 0.0\n-/\n-- #guard_msgs in\n-- #eval calculate_matrix_determinant [[1.1, 1.1], [1.1, 1.1]]\n\n/-\ninfo: -3.0\n-/\n-- #guard_msgs in\n-- #eval calculate_matrix_determinant [[1, 2], [2, 1]]\n\n/-\ninfo: 0.0\n-/\n-- #guard_msgs in\n-- #eval calculate_matrix_determinant [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2512", "language": "lean", "source": "fvapps", "source-id": "fvapps_002512", "source-notes": "", "vc-description": "/-\n=====Problem Statement=====\nWhen users post an update on social media,such as a URL, image, status update etc., other users in their network are able to view this new post on their news feed. Users can also see exactly when the post was published, i.e, how many hours, minutes or seconds ago.\nSince sometimes posts are published and viewed in different time zones, this can be confusing. You are given two timestamps of one such post that a user can see on his newsfeed in the following format:\nDay dd Mon yyyy hh:mm:ss +xxxx\nHere +xxxx represents the time zone. Your task is to print the absolute difference (in seconds) between them.\n\n=====Input Format=====\nThe first line contains T, the number of tescases.\nEach testcase contains 2 lines, representing time t_1 and time t_2.\n-/", "vc-preamble": "def parseDateTime (s : String) : DateTime := sorry\n\ndef absTimeDiffInSeconds (t1 t2 : DateTime) : Nat := sorry", "vc-helpers": "", "vc-definitions": "def timeDifference (ts1 ts2 : String) : Nat := sorry\n\ntheorem timeDiff_nonneg (ts1 ts2 : String) :\n  timeDifference ts1 ts2 ≥ 0 := sorry", "vc-theorems": "theorem timeDiff_commutative (ts1 ts2 : String) :\n  timeDifference ts1 ts2 = timeDifference ts2 ts1 := sorry\n\ntheorem timeDiff_matches_datetime (ts1 ts2 : String) :\n  let dt1 := parseDateTime ts1\n  let dt2 := parseDateTime ts2\n  timeDifference ts1 ts2 = absTimeDiffInSeconds dt1 dt2 := sorry\n\ntheorem timeDiff_same_timestamp (ts : String) :\n  timeDifference ts ts = 0 := sorry\n\n/-\ninfo: 25200\n-/\n-- #guard_msgs in\n-- #eval time_difference \"Sun 10 May 2015 13:54:36 -0700\" \"Sun 10 May 2015 13:54:36 -0000\"\n\n/-\ninfo: 88200\n-/\n-- #guard_msgs in\n-- #eval time_difference \"Sat 02 May 2015 19:54:36 +0530\" \"Fri 01 May 2015 13:54:36 -0000\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2531", "language": "lean", "source": "fvapps", "source-id": "fvapps_002531", "source-notes": "", "vc-description": "/-\nPete and his mate Phil are out in the countryside shooting clay pigeons with a shotgun - amazing fun. \n\nThey decide to have a competition. 3 rounds, 2 shots each. Winner is the one with the most hits.\n\nSome of the clays have something attached to create lots of smoke when hit, guarenteed by the packaging to generate 'real excitement!' (genuinely this happened). None of the explosive things actually worked, but for this kata lets say they did.\n\nFor each round you will receive the following format:\n\n[{P1:'XX', P2:'XO'}, true]\n\nThat is an array containing an object and a boolean. Pl represents Pete, P2 represents Phil. X represents a hit and O represents a miss. If the boolean is true, any hit is worth 2. If it is false, any hit is worth 1.\n\nFind out who won. If it's Pete, return 'Pete Wins!'. If it is Phil, return 'Phil Wins!'. If the scores are equal, return 'Draw!'.\n\nNote that as there are three rounds, the actual input (x) will look something like this:\n\n[[{P1:'XX', P2:'XO'}, true], [{P1:'OX', P2:'OO'}, false], [{P1:'XX', P2:'OX'}, true]]\n-/", "vc-preamble": "def GameResults := List (RoundData × Bool)\n\ndef shoot : GameResults → String := sorry", "vc-helpers": "", "vc-definitions": "def calculateScore (shots : String) (double : Bool) : Nat :=\n  (shots.foldl (fun acc c => if c = 'X' then acc + 1 else acc) 0) * \n  (if double then 2 else 1)", "vc-theorems": "theorem shoot_returns_valid_result (results : GameResults) :\n  shoot results = \"Pete Wins!\" ∨ \n  shoot results = \"Phil Wins!\" ∨\n  shoot results = \"Draw!\" := sorry\n\ntheorem shoot_gives_correct_winner (results : GameResults) :\n  let peteScore := results.foldl \n    (fun acc (round, double) => acc + calculateScore round.P1 double) 0\n  let philScore := results.foldl \n    (fun acc (round, double) => acc + calculateScore round.P2 double) 0\n  (peteScore > philScore → shoot results = \"Pete Wins!\") ∧\n  (philScore > peteScore → shoot results = \"Phil Wins!\") ∧\n  (peteScore = philScore → shoot results = \"Draw!\") := sorry\n\ntheorem shoot_symmetrical_draw (results : GameResults) :\n  let symmetricalResults := results.map \n    (fun (round, double) => ({P1 := round.P1, P2 := round.P1}, double))\n  shoot symmetricalResults = \"Draw!\" := sorry\n\n/-\ninfo: 'Pete Wins!'\n-/\n-- #guard_msgs in\n-- #eval shoot [[{\"P1\": \"XX\", \"P2\": \"XO\"}, True], [{\"P1\": \"OX\", \"P2\": \"OO\"}, False], [{\"P1\": \"XX\", \"P2\": \"OX\"}, True]]\n\n/-\ninfo: 'Draw!'\n-/\n-- #guard_msgs in\n-- #eval shoot [[{\"P1\": \"XX\", \"P2\": \"XX\"}, True], [{\"P1\": \"OO\", \"P2\": \"OO\"}, False], [{\"P1\": \"XX\", \"P2\": \"XX\"}, True]]\n\n/-\ninfo: 'Phil Wins!'\n-/\n-- #guard_msgs in\n-- #eval shoot [[{\"P1\": \"XX\", \"P2\": \"XO\"}, False], [{\"P1\": \"OX\", \"P2\": \"XX\"}, False], [{\"P1\": \"OO\", \"P2\": \"XX\"}, True]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2542", "language": "lean", "source": "fvapps", "source-id": "fvapps_002542", "source-notes": "", "vc-description": "/-\nHelp a fruit packer sort out the bad apples. \n\nThere are 7 varieties of apples, all packaged as pairs and stacked in a fruit box. Some of the apples are spoiled. The fruit packer will have to make sure the spoiled apples are either removed from the fruit box or replaced. Below is the breakdown:\n\nApple varieties are represented with numbers, `1 to 7`\n\nA fruit package is represented with a 2 element array `[4,3]`\n\nA fruit package with one bad apple, or a bad package, is represented with `[2,0]` or `[0,2]`\n\nA fruit package with two bad apples, or a rotten package, is represented with `[0,0]`\n\nA fruit box is represented with:\n\n```\n[ [ 1, 3 ],\n  [ 7, 6 ],\n  [ 7, 2 ],\n  [ 1, 3 ],\n  [ 0, 2 ],\n  [ 4, 5 ],\n  [ 0, 3 ],\n  [ 7, 6 ] ]\n\n```\n\nWrite a program to clear the fruit box off bad apples. \n\nThe INPUT will be a fruit box represented with a 2D array: `[[1,3],[7,6],[7,2],[1,3],[0,2],[4,5],[0,3],[7,6]]`\n\nThe OUTPUT should be the fruit box void of bad apples: `[[1,3],[7,6],[7,2],[1,3],[2,3],[4,5],[7,6]]`\n\nConditions to be met:\n\n1.A bad package should have the bad apple replaced if there is another bad package with a good apple to spare. Else, the bad package should be discarded.\n\n2.The order of the packages in the fruit box should be preserved. Repackaging happens from the top of the fruit box `index = 0` to the bottom `nth index`. Also note how fruits in a package are ordered when repacking. Example shown in INPUT/OUPUT above.\n\n3.Rotten packages should be discarded. \n\n4.There can be packages with the same variety of apples, e.g `[1,1]`, this is not a problem.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bad_apples (apples : List (Nat × Nat)) : List (List Nat) :=\n  sorry", "vc-theorems": "theorem bad_apples_output_structure (apples : List (Nat × Nat)) :\n  let result := bad_apples apples\n  -- Output is list of lists with exactly 2 elements\n  ∀ sublist ∈ result, sublist.length = 2 := by\n  sorry\n\ntheorem bad_apples_no_zeros (apples : List (Nat × Nat)) :\n  let result := bad_apples apples\n  -- No zeros in output lists\n  ∀ sublist ∈ result, ∀ x ∈ sublist, x ≠ 0 := by\n  sorry\n\ntheorem bad_apples_values_subset (apples : List (Nat × Nat)) :\n  let result := bad_apples apples\n  let input_values := (apples.map (fun p => [p.1, p.2])).join.filter (fun n => n ≠ 0)\n  -- Output values come from input\n  ∀ sublist ∈ result, ∀ x ∈ sublist, x ∈ input_values := by\n  sorry\n\ntheorem bad_apples_length (apples : List (Nat × Nat)) :\n  let result := bad_apples apples\n  -- Output no longer than input\n  result.length ≤ apples.length := by\n  sorry\n\ntheorem bad_apples_all_zeros (apples : List (Nat × Nat)) :\n  (∀ p ∈ apples, p.1 = 0 ∧ p.2 = 0) →\n  -- All zero pairs give empty result  \n  bad_apples apples = [] := by\n  sorry\n\ntheorem bad_apples_value_counts (apples : List (Nat × Nat)) (x : Nat) :\n  let result := bad_apples apples\n  -- Output value counts don't exceed input counts\n  x ≠ 0 →\n  let input_count := (apples.map (fun p => [p.1, p.2])).join.filter (fun n => n = x) |>.length\n  let output_count := result.join.filter (fun n => n = x) |>.length\n  output_count ≤ input_count := by\n  sorry\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval bad_apples []\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval bad_apples [[1, 3], [7, 6], [7, 2], [1, 3], [0, 2], [4, 5], [0, 3], [7, 6]]\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval bad_apples [[0, 0], [0, 0]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2550", "language": "lean", "source": "fvapps", "source-id": "fvapps_002550", "source-notes": "", "vc-description": "/-\nIt's tricky keeping track of who is owed what when spending money in a group. Write a function to balance the books.\n\n* The function should take one parameter: an object/dict with two or more name-value pairs which represent the members of the group and the amount spent by each.\n* The function should return an object/dict with the same names, showing how much money the members should pay or receive.\n\n**Further points:**\n\n* The values should be positive numbers if the person should receive money from the group, negative numbers if they owe money to the group.\n* If value is a decimal, round to two decimal places.\n\nTranslations and comments (and upvotes!) welcome.\n\n### Example\n\n3 friends go out together: A spends £20, B spends £15, and C spends £10. The function should return an object/dict showing that A should receive £5, B should receive £0, and C should pay £5.\n-/", "vc-preamble": "def List.sum (xs : List Int) : Int :=\n  match xs with\n  | [] => 0\n  | x::xs => x + xs.sum\n\ndef Int.toFloat (i : Int) : Float :=\n  Float.ofInt i\n\nstructure BillDict where\n  keys : List String \n  values : List Int\n  size : Nat", "vc-helpers": "", "vc-definitions": "def split_the_bill (bill : BillDict) : BillDict :=\n  sorry", "vc-theorems": "theorem split_bill_preserves_keys (bill : BillDict) :\n  (split_the_bill bill).keys = bill.keys := by\n  sorry\n\ntheorem split_bill_preserves_differences (bill : BillDict) (k : String) :\n  k ∈ bill.keys →\n  let mean := (bill.values.sum.toFloat) / (Float.ofNat bill.size)\n  k ∈ (split_the_bill bill).keys →\n  let orig_val := bill.values[bill.keys.indexOf k]!\n  let new_val := (split_the_bill bill).values[bill.keys.indexOf k]!\n  new_val.toFloat = orig_val.toFloat - mean := by\n  sorry\n\ntheorem split_bill_input_size_bounds (bill : BillDict) :\n  2 ≤ bill.size ∧ bill.size ≤ 10 →\n  (∀ v ∈ bill.values, 0 ≤ v ∧ v ≤ 1000) →\n  (split_the_bill bill).size = bill.size := by\n  sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval split_the_bill {\"A\": 20, \"B\": 15, \"C\": 10}\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval split_the_bill {\"A\": 40, \"B\": 25, \"X\": 10}\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval split_the_bill {\"A\": 40, \"B\": 25, \"C\": 10, \"D\": 153, \"E\": 58}", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2558", "language": "lean", "source": "fvapps", "source-id": "fvapps_002558", "source-notes": "", "vc-description": "/-\nIn this Kata, you will be given a string that has lowercase letters and numbers. Your task is to compare the number groupings and return the largest number. Numbers will not have leading zeros. \n\nFor example, `solve(\"gh12cdy695m1\") = 695`, because this is the largest of all number groupings. \n\nGood luck!\n\nPlease also try [Simple remove duplicates](https://www.codewars.com/kata/5ba38ba180824a86850000f7)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem solve_returns_max_number (numbers : List Nat) :\n  let s := numbers.foldr (fun n acc => s!\"a{n}b\" ++ acc) \"\"\n  solve s = numbers.maximum?.getD 0\n  := by sorry\n\ntheorem solve_returns_nat (s : String) :\n  0 ≤ solve s\n  := by sorry\n\ntheorem solve_is_max_in_string (s : String) :\n  let digits := s.toList.filter Char.isDigit\n  let numbers := digits.map (λ c => c.toNat - '0'.toNat)\n  solve s = numbers.maximum?.getD 0\n  := by sorry\n\n/-\ninfo: 695\n-/\n-- #guard_msgs in\n-- #eval solve \"gh12cdy695m1\"\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval solve \"2ti9iei7qhr5\"\n\n/-\ninfo: 61\n-/\n-- #guard_msgs in\n-- #eval solve \"vih61w8oohj5\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2560", "language": "lean", "source": "fvapps", "source-id": "fvapps_002560", "source-notes": "", "vc-description": "/-\nIn this kata the function returns an array/list like the one passed to it but with its nth element removed (with `0 <= n <= array/list.length - 1`). The function is already written for you and the basic tests pass, but random tests fail. Your task is to figure out why and fix it.\n\nGood luck!\n\n~~~if:javascript\nSome good reading: [MDN Docs about arrays](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)\n~~~\n~~~if:python\nSome good reading: [Python Docs about lists](https://docs.python.org/3/tutorial/datastructures.html)\n~~~\n~~~if:coffeescript\nSome good reading: [CoffeeScript docs](http://coffeescript.org/)\n~~~\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def removeNthElement (arr : List α) (n : Nat) : List α :=\n  sorry\n\n/- Length decreases by 1 after removing element -/", "vc-theorems": "theorem removeNthElement_length_decreases {α : Type u} (arr : List α) (n : Nat) \n    (h : n < arr.length) :\n    (removeNthElement α arr n).length = arr.length - 1 :=\n  sorry\n\n/- Elements before n stay unchanged -/\n\ntheorem removeNthElement_prefix_unchanged {α : Type u} (arr : List α) (n : Nat)\n    (h : n < arr.length) :\n    (removeNthElement α arr n).take n = arr.take n :=\n  sorry\n\n/- Elements after n are unchanged but shifted -/\n\ntheorem removeNthElement_suffix_shifted {α : Type u} (arr : List α) (n : Nat)\n    (h : n < arr.length) :\n    (removeNthElement α arr n).drop n = arr.drop (n + 1) :=\n  sorry\n\n/- Removing first element gives tail -/\n\ntheorem removeNthElement_zero_is_tail {α : Type u} (arr : List α)\n    (h : arr ≠ []) :\n    removeNthElement α arr 0 = arr.tail :=\n  sorry\n\n/-\ninfo: [7, 6, 9]\n-/\n-- #guard_msgs in\n-- #eval remove_nth_element [9, 7, 6, 9] 0\n\n/-\ninfo: [1, 3]\n-/\n-- #guard_msgs in\n-- #eval remove_nth_element [1, 2, 3] 1\n\n/-\ninfo: ['a', 'b', 'c']\n-/\n-- #guard_msgs in\n-- #eval remove_nth_element [\"a\", \"b\", \"c\", \"d\"] 3", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2561", "language": "lean", "source": "fvapps", "source-id": "fvapps_002561", "source-notes": "", "vc-description": "/-\nPaul is an excellent coder and sits high on the CW leaderboard. He solves kata like a banshee but would also like to lead a normal life, with other activities. But he just can't stop solving all the kata!!\n\nGiven an array (x) you need to calculate the Paul Misery Score. The values are worth the following points:\n\nkata = 5\nPetes kata = 10\nlife = 0\neating = 1\n\nThe Misery Score is the total points gained from the array. Once you have the total, return as follows:\n\n<40        = 'Super happy!'<70   >=40 = 'Happy!'<100  >=70 = 'Sad!'\\>=100       = 'Miserable!'\n-/", "vc-preamble": "def points : Activity → Nat \n  | Activity.life => 0\n  | Activity.eating => 1\n  | Activity.kata => 5\n  | Activity.petes_kata => 10\n\ndef sumList : List Nat → Nat  \n  | [] => 0\n  | h :: t => h + sumList t", "vc-helpers": "", "vc-definitions": "def paul (activities: List Activity) : String := sorry\n\ntheorem paul_returns_valid_mood (activities : List Activity) (h : activities.length ≥ 1) : \n  paul activities = \"Miserable!\" ∨ \n  paul activities = \"Sad!\" ∨ \n  paul activities = \"Happy!\" ∨ \n  paul activities = \"Super happy!\" := sorry", "vc-theorems": "theorem paul_points_thresholds (activities : List Activity) (h : activities.length ≥ 1) :\n  let total := sumList (activities.map points)\n  if total ≥ 100 then\n    paul activities = \"Miserable!\"\n  else if total ≥ 70 then \n    paul activities = \"Sad!\"\n  else if total ≥ 40 then\n    paul activities = \"Happy!\"\n  else\n    paul activities = \"Super happy!\" := sorry\n\ntheorem paul_returns_string (activities : List Activity) :\n  ∃ s : String, paul activities = s := sorry\n\n/-\ninfo: 'Super happy!'\n-/\n-- #guard_msgs in\n-- #eval paul [\"life\", \"eating\", \"life\"]\n\n/-\ninfo: 'Super happy!'\n-/\n-- #guard_msgs in\n-- #eval paul [\"life\", \"Petes kata\", \"Petes kata\", \"Petes kata\", \"eating\"]\n\n/-\ninfo: 'Happy!'\n-/\n-- #guard_msgs in\n-- #eval paul [\"Petes kata\", \"Petes kata\", \"eating\", \"Petes kata\", \"Petes kata\", \"eating\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2567", "language": "lean", "source": "fvapps", "source-id": "fvapps_002567", "source-notes": "", "vc-description": "/-\n## Your Story\n\"A *piano* in the home meant something.\" - *Fried Green Tomatoes at the Whistle Stop Cafe*\n\nYou've just realized a childhood dream by getting a beautiful and beautiful-sounding upright piano from a friend who was leaving the country. You immediately started doing things like playing \"Heart and Soul\" over and over again, using one finger to pick out any melody that came into your head, requesting some sheet music books from the library, signing up for some MOOCs like Developing Your Musicianship, and wondering if you will think of any good ideas for writing piano-related katas and apps. \n\nNow you're doing an exercise where you play the very first (leftmost, lowest in pitch) key on the 88-key keyboard, which (as shown below) is white, with the little finger on your left hand, then the second key, which is black, with the ring finger on your left hand, then the third key, which is white, with the middle finger on your left hand, then the fourth key, also white, with your left index finger, and then the fifth key, which is black, with your left thumb. Then you play the sixth key, which is white, with your right thumb, and continue on playing the seventh, eighth, ninth, and tenth keys with the other four fingers of your right hand. Then for the eleventh key you go back to your left little finger, and so on. Once you get to the rightmost/highest, 88th, key, you start all over again with your left little finger on the first key. Your thought is that this will help you to learn to move smoothly and with uniform pressure on the keys from each finger to the next and back and forth between hands.\n\nYou're not saying the names of the notes while you're doing this, but instead just counting each key press out loud (not starting again at 1 after 88, but continuing on to 89 and so forth) to try to keep a steady rhythm going and to see how far you can get before messing up. You move gracefully and with flourishes, and between screwups you hear, see, and feel that you are part of some great repeating progression between low and high notes and black and white keys. \n\n## Your Function\nThe function you are going to write is not actually going to help you with your piano playing, but just explore one of the patterns you're experiencing: Given the number you stopped on, was it on a black key or a white key? For example, in the description of your piano exercise above, if you stopped at 5, your left thumb would be on the fifth key of the piano, which is black. Or if you stopped at 92, you would have gone all the way from keys 1 to 88 and then wrapped around, so that you would be on the fourth key, which is white.\n\nYour function will receive an integer between 1 and 10000 (maybe you think that in principle it would be cool to count up to, say, a billion, but considering how many years it would take it is just not possible) and return the string \"black\" or \"white\" -- here are a few more examples:\n```\n1     \"white\"\n12    \"black\"\n42    \"white\"\n100   \"black\"\n2017  \"white\"\n```\nHave fun! And if you enjoy this kata, check out the sequel: Piano Kata, Part 2\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def black_or_white_key (key : Int) : Color :=\n  sorry", "vc-theorems": "theorem returns_valid_color (key : Int) :\n  black_or_white_key key = Color.black ∨ black_or_white_key key = Color.white :=\nsorry\n\ntheorem pattern_repeats_88_keys (key : Int) :\n  black_or_white_key key = black_or_white_key (key + 88) :=\nsorry\n\ntheorem octave_pattern_correct (key : Int) :\n  let normalized := ((key - 1) % 88) % 12\n  (normalized = 1 ∨ normalized = 4 ∨ normalized = 6 ∨ normalized = 9 ∨ normalized = 11)\n    ↔ black_or_white_key key = Color.black :=\nsorry\n\n/-\ninfo: 'white'\n-/\n-- #guard_msgs in\n-- #eval black_or_white_key 1\n\n/-\ninfo: 'black'\n-/\n-- #guard_msgs in\n-- #eval black_or_white_key 5\n\n/-\ninfo: 'black'\n-/\n-- #guard_msgs in\n-- #eval black_or_white_key 12\n\n/-\ninfo: 'white'\n-/\n-- #guard_msgs in\n-- #eval black_or_white_key 89\n\n/-\ninfo: 'black'\n-/\n-- #guard_msgs in\n-- #eval black_or_white_key 100\n\n/-\ninfo: 'white'\n-/\n-- #guard_msgs in\n-- #eval black_or_white_key 2017", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2576", "language": "lean", "source": "fvapps", "source-id": "fvapps_002576", "source-notes": "", "vc-description": "/-\nWrite a function `take_umbrella()` that takes two arguments: a string representing the current weather and a float representing the chance of rain today.\n\nYour function should return `True` or `False` based on the following criteria.\n\n* You should take an umbrella if it's currently raining or if it's cloudy and the chance of rain is over `0.20`.\n* You shouldn't take an umbrella if it's sunny unless it's more likely to rain than not.\n\nThe options for the current weather are `sunny`, `cloudy`, and `rainy`.\n\nFor example, `take_umbrella('sunny', 0.40)` should return `False`.\n\nAs an additional challenge, consider solving this kata using only logical operaters and not using any `if` statements.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def take_umbrella (w: Weather) (rain_chance: Float): Bool :=\n  sorry", "vc-theorems": "theorem take_umbrella_rainy (rain_chance: Float):\n  rain_chance ≥ 0 ∧ rain_chance ≤ 1 →\n  take_umbrella Weather.Rainy rain_chance = true :=\n  sorry\n\ntheorem take_umbrella_sunny (rain_chance: Float):\n  rain_chance ≥ 0 ∧ rain_chance ≤ 1 →\n  take_umbrella Weather.Sunny rain_chance = (rain_chance > 0.5) :=\n  sorry\n\ntheorem take_umbrella_cloudy (rain_chance: Float):\n  rain_chance ≥ 0 ∧ rain_chance ≤ 1 →\n  take_umbrella Weather.Cloudy rain_chance = (rain_chance > 0.2) :=\n  sorry\n\ntheorem take_umbrella_returns_bool (w: Weather) (rain_chance: Float):\n  rain_chance ≥ 0 ∧ rain_chance ≤ 1 →\n  (take_umbrella w rain_chance = true ∨ take_umbrella w rain_chance = false) :=\n  sorry\n\ntheorem take_umbrella_rainy_edge_cases:\n  take_umbrella Weather.Rainy 0.0 = true ∧ \n  take_umbrella Weather.Rainy 1.0 = true :=\n  sorry\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval take_umbrella \"sunny\" 0.4\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval take_umbrella \"rainy\" 0.0\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval take_umbrella \"cloudy\" 0.2", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2582", "language": "lean", "source": "fvapps", "source-id": "fvapps_002582", "source-notes": "", "vc-description": "/-\n# Introduction\n\nYou are the developer working on a website which features a large counter on its homepage, proudly displaying the number of happy customers who have downloaded your companies software.\n\nYou have been tasked with adding an effect to this counter to make it more interesting.  \n\nInstead of just displaying the count value immediatley when the page loads, we want to create the effect of each digit cycling through its preceding numbers before stopping on the actual value.\n\n# Task\n\nAs a step towards achieving this; you have decided to create a function that will produce a multi-dimensional array out of the hit count value.  Each inner dimension of the array represents an individual digit in the hit count, and will include all numbers that come before it, going back to 0.\n\n## Rules\n* The function will take one argument which will be a four character `string` representing hit count\n* The function must return a multi-dimensional array containing four inner arrays\n* The final value in each inner array must be the actual value to be displayed\n* Values returned in the array must be of the type `number`\n\n**Examples**\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def counter_effect (digits : String) : List (List Nat) := sorry\n\ntheorem counter_effect_length {digits : String} \n  (h : digits.length = 4) :\n  (counter_effect digits).length = 4 := sorry", "vc-theorems": "theorem counter_effect_sublist_properties {digits : String} (h : digits.length = 4)\n  (i : Nat) (h2 : i < 4) : \n  let sublist := (counter_effect digits)[i]'(by sorry)\n  (sublist[0]? = some 0 ∧\n   (∀ j, j + 1 < sublist.length → \n      sublist[j+1]? = some ((sublist[j]'(by sorry)) + 1)) ∧\n   sublist.length = (digits.data[i]'(by sorry)).toUInt8.toNat - 48 + 1) := sorry\n\ntheorem counter_effect_bounded {digits : String} \n  (h : digits.length = 4) :\n  let result := counter_effect digits\n  (∀ sublist ∈ result, ∀ x ∈ sublist, x ≥ 0) ∧\n  (∀ sublist ∈ result, \n      sublist.maximum? = some (sublist.length - 1)) := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2603", "language": "lean", "source": "fvapps", "source-id": "fvapps_002603", "source-notes": "", "vc-description": "/-\nCreate a function that takes a list of one or more non-negative integers, and arranges them such that they form the largest possible number.\n\nExamples:\n\n`largestArrangement([4, 50, 8, 145])` returns 8504145 (8-50-4-145)\n\n`largestArrangement([4, 40, 7])` returns 7440 (7-4-40)\n\n`largestArrangement([4, 46, 7])` returns 7464 (7-46-4)\n\n`largestArrangement([5, 60, 299, 56])` returns 60565299 (60-56-5-299)\n\n`largestArrangement([5, 2, 1, 9, 50, 56])` returns 95655021 (9-56-5-50-21)\n-/", "vc-preamble": "def largest_arrangement (nums : List Nat) : Nat :=\n  sorry\n\n@[simp]\n\ndef numDigits (n : Nat) : Nat :=\n  sorry\n\n@[simp]\n\ndef getDigits (n : Nat) : List Nat :=\n  sorry\n\n@[simp]\n\ndef sumList (xs : List Nat) : Nat :=\n  sorry\n\n@[simp]", "vc-helpers": "", "vc-definitions": "def countDigits (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem largest_arrangement_length_preservation\n  (nums : List Nat)\n  (h : nums.length > 0)\n  (h2 : ∀ n ∈ nums, n ≤ 999) :\n  numDigits (largest_arrangement nums) = sumList (nums.map numDigits)\n  := sorry\n\ntheorem largest_arrangement_uses_same_digits\n  (nums : List Nat)\n  (h : nums.length > 0)\n  (h2 : ∀ n ∈ nums, n ≤ 999) :\n  ∀ d, countDigits d = countDigits d →\n  (d ∈ getDigits (largest_arrangement nums) ↔ d ∈ (nums.map getDigits).join)\n  := sorry\n\ntheorem largest_arrangement_is_nat\n  (nums : List Nat) \n  (h : nums.length > 0)\n  (h2 : ∀ n ∈ nums, n ≤ 999) :\n  largest_arrangement nums ≥ 0\n  := sorry\n\ntheorem largest_arrangement_greater_than_components\n  (nums : List Nat)\n  (h : nums.length > 1)\n  (h2 : ∀ n ∈ nums, 1 ≤ n ∧ n ≤ 999) :\n  ∀ n ∈ nums, largest_arrangement nums ≥ n\n  := sorry\n\n/-\ninfo: 8504145\n-/\n-- #guard_msgs in\n-- #eval largest_arrangement [4, 50, 8, 145]\n\n/-\ninfo: 7440\n-/\n-- #guard_msgs in\n-- #eval largest_arrangement [4, 40, 7]\n\n/-\ninfo: 95655021\n-/\n-- #guard_msgs in\n-- #eval largest_arrangement [5, 2, 1, 9, 50, 56]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2627", "language": "lean", "source": "fvapps", "source-id": "fvapps_002627", "source-notes": "", "vc-description": "/-\nHow many licks does it take to get to the tootsie roll center of a tootsie pop?\n\nA group of engineering students from Purdue University reported that its licking machine, modeled after a human tongue, took an average of 364 licks to get to the center of a Tootsie Pop. Twenty of the group's volunteers assumed the licking challenge-unassisted by machinery-and averaged 252 licks each to the center.\n\nYour task, if you choose to accept it, is to write a function that will return the number of licks it took to get to the tootsie roll center of a tootsie pop, given some environmental variables.\n\nEveryone knows it's harder to lick a tootsie pop in cold weather but it's easier if the sun is out. You will be given an object of environmental conditions for each trial paired with a value that will increase or decrease the number of licks. The environmental conditions all apply to the same trial.\n\nAssuming that it would normally take 252 licks to get to the tootsie roll center of a tootsie pop, return the new total of licks along with the condition that proved to be most challenging (causing the most added licks) in that trial.\n\nExample:\n```\ntotalLicks({ \"freezing temps\": 10, \"clear skies\": -2 });\n```\nShould return:\n```\n\"It took 260 licks to get to the tootsie roll center of a tootsie pop. The toughest challenge was freezing temps.\"\n```\nOther cases:\nIf there are no challenges, the toughest challenge sentence should be omitted. If there are multiple challenges with the highest toughest amount, the first one presented will be the toughest.\nIf an environment variable is present, it will be either a positive or negative integer. No need to validate.\n\nCheck out my other 80's Kids Katas:\n\n80's Kids #1: How Many Licks Does It Take\n80's Kids #2: Help Alf Find His Spaceship\n80's Kids #3: Punky Brewster's Socks\n80's Kids #4: Legends of the Hidden Temple\n80's Kids #5: You Can't Do That on Television\n80's Kids #6: Rock 'Em, Sock 'Em Robots\n80's Kids #7: She's a Small Wonder\n80's Kids #8: The Secret World of Alex Mack\n80's Kids #9: Down in Fraggle Rock \n80's Kids #10: Captain Planet\n-/", "vc-preamble": "def String.containsSubstr (s : String) (sub : String) : Bool := sorry\n\ndef List.sum (xs : List Int) : Int := \n  match xs with\n  | [] => 0\n  | x :: rest => x + rest.sum\n\nstructure Environment where\n  modifiers : List (String × Int)", "vc-helpers": "", "vc-definitions": "def total_licks (env : Environment) : String := sorry\n\ntheorem total_licks_base_text (env : Environment) :\n  let result := total_licks env\n  (result.startsWith \"It took\") ∧ \n  (result.containsSubstr \" licks to get to the tootsie roll center of a tootsie pop\") :=\nsorry", "vc-theorems": "theorem total_licks_contains_sum (env : Environment) :\n  let expected := 252 + (env.modifiers.map Prod.snd).sum\n  let result := total_licks env\n  result.containsSubstr (toString expected) :=\nsorry\n\ntheorem total_licks_toughest_challenge (env : Environment) :\n  let maxVal := (env.modifiers.map Prod.snd).maximum?.getD 0\n  let result := total_licks env\n  if maxVal > 0 then\n    (result.containsSubstr \"The toughest challenge was\") ∧\n    (env.modifiers.find? (fun p => p.2 = maxVal)).map (fun p => result.containsSubstr p.1) = some true\n  else\n    ¬(result.containsSubstr \"The toughest challenge was\") :=\nsorry\n\ntheorem total_licks_no_positive_challenges \n  (env : Environment)\n  (h : ∀ p ∈ env.modifiers, p.2 ≤ 0) :\n  ¬((total_licks env).containsSubstr \"The toughest challenge was\") :=\nsorry\n\ntheorem total_licks_always_has_toughest_challenge\n  (env : Environment)\n  (h1 : env.modifiers.length > 0)\n  (h2 : ∀ p ∈ env.modifiers, p.2 > 0) :\n  (total_licks env).containsSubstr \"The toughest challenge was\" :=\nsorry\n\n/-\ninfo: 'It took 260 licks to get to the tootsie roll center of a tootsie pop. The toughest challenge was freezing temps.'\n-/\n-- #guard_msgs in\n-- #eval total_licks {\"freezing temps\": 10, \"clear skies\": -2}\n\n/-\ninfo: 'It took 245 licks to get to the tootsie roll center of a tootsie pop.'\n-/\n-- #guard_msgs in\n-- #eval total_licks {\"happiness\": -5, \"clear skies\": -2}\n\n/-\ninfo: 'It took 512 licks to get to the tootsie roll center of a tootsie pop. The toughest challenge was evil wizards.'\n-/\n-- #guard_msgs in\n-- #eval total_licks {\"dragons\": 100, \"evil wizards\": 110, \"trolls\": 50}", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2649", "language": "lean", "source": "fvapps", "source-id": "fvapps_002649", "source-notes": "", "vc-description": "/-\nYour job is to create a calculator which evaluates expressions in [Reverse Polish notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).\n\nFor example expression `5 1 2 + 4 * + 3 -` (which is equivalent to `5 + ((1 + 2) * 4) - 3` in normal notation) should evaluate to `14`.\n\nFor your convenience, the input is formatted such that a space is provided between every token.\n\nEmpty expression should evaluate to `0`.\n\nValid operations are `+`, `-`, `*`, `/`.\n\nYou may assume that there won't be exceptional situations (like stack underflow or division by zero).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate (input : String) : CalcResult := sorry\n\ntheorem calculate_empty_expr : \n  calculate \"\" = CalcResult.Number 0 := sorry", "vc-theorems": "theorem calculate_returns_float (expr : String) :\n  ∃ (n : Float), calculate expr = CalcResult.Number n ∨ calculate expr = CalcResult.Error := sorry\n\ntheorem calculate_single_number (n : Float) (h : -1000 ≤ n ∧ n ≤ 1000) :\n  calculate (toString n) = CalcResult.Number n := sorry\n\ntheorem calculate_addition (a b : Float) (h : -1000 ≤ a ∧ a ≤ 1000 ∧ -1000 ≤ b ∧ b ≤ 1000) :\n  calculate (toString a ++ \" \" ++ toString b ++ \" +\") = CalcResult.Number (a + b) := sorry\n\ntheorem calculate_multiplication (a b : Float) (h : -1000 ≤ a ∧ a ≤ 1000 ∧ -1000 ≤ b ∧ b ≤ 1000) :\n  calculate (toString a ++ \" \" ++ toString b ++ \" *\") = CalcResult.Number (a * b) := sorry\n\ntheorem calculate_division (a b : Float) (h₁ : -1000 ≤ a ∧ a ≤ 1000 ∧ -1000 ≤ b ∧ b ≤ 1000) (h₂ : b ≠ 0) :\n  calculate (toString a ++ \" \" ++ toString b ++ \" /\") = CalcResult.Number (a / b) := sorry\n\ntheorem calculate_subtraction (a b : Float) (h : -1000 ≤ a ∧ a ≤ 1000 ∧ -1000 ≤ b ∧ b ≤ 1000) :\n  calculate (toString a ++ \" \" ++ toString b ++ \" -\") = CalcResult.Number (a - b) := sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval calc \"\"\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval calc \"1 3 +\"\n\n/-\ninfo: 14\n-/\n-- #guard_msgs in\n-- #eval calc \"5 1 2 + 4 * + 3 -\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2654", "language": "lean", "source": "fvapps", "source-id": "fvapps_002654", "source-notes": "", "vc-description": "/-\nWrite function bmi that calculates body mass index (bmi = weight / height ^ 2).\n\nif bmi <= 18.5 return \"Underweight\"\n\nif bmi <= 25.0 return \"Normal\"\n\nif bmi <= 30.0 return \"Overweight\"\n\nif bmi > 30 return \"Obese\"\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bmi (weight height : Float) : Category :=\n  sorry", "vc-theorems": "theorem bmi_returns_valid_category {weight height : Float} \n  (h1 : weight ≥ 1) (h2 : weight ≤ 500) \n  (h3 : height ≥ 0.5) (h4 : height ≤ 3.0) :\n  let result := bmi weight height\n  result = Category.Underweight ∨ \n  result = Category.Normal ∨\n  result = Category.Overweight ∨ \n  result = Category.Obese :=\n  sorry\n\ntheorem bmi_categories_are_monotonic {weight height : Float}\n  (h1 : weight ≥ 1) (h2 : weight ≤ 500)\n  (h3 : height ≥ 0.5) (h4 : height ≤ 3.0) :\n  let bmiValue := weight / (height * height)\n  (bmiValue ≤ 18.5 → bmi weight height = Category.Underweight) ∧\n  (18.5 < bmiValue ∧ bmiValue ≤ 25 → bmi weight height = Category.Normal) ∧\n  (25 < bmiValue ∧ bmiValue ≤ 30 → bmi weight height = Category.Overweight) ∧\n  (30 < bmiValue → bmi weight height = Category.Obese) :=\n  sorry\n\ntheorem bmi_zero_height_undefined {weight : Float} :\n  ¬∃(result : Category), bmi weight 0 = result :=\n  sorry\n\n/-\ninfo: 'Underweight'\n-/\n-- #guard_msgs in\n-- #eval bmi 50 1.8\n\n/-\ninfo: 'Normal'\n-/\n-- #guard_msgs in\n-- #eval bmi 80 1.8\n\n/-\ninfo: 'Obese'\n-/\n-- #guard_msgs in\n-- #eval bmi 110 1.8", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2659", "language": "lean", "source": "fvapps", "source-id": "fvapps_002659", "source-notes": "", "vc-description": "/-\nPhilip's just turned four and he wants to know how old he will be in various years in the future such as 2090 or 3044. His parents can't keep up calculating this so they've begged you to help them out by writing a programme that can answer Philip's endless questions.\n\nYour task is to write a function that takes two parameters: the year of birth and the year to count years in relation to. As Philip is getting more curious every day he may soon want to know how many years it was until he would be born, so your function needs to work with both dates in the future and in the past.\n\nProvide output in this format: For dates in the future: \"You are ... year(s) old.\" For dates in the past: \"You will be born in ... year(s).\" If the year of birth equals the year requested return: \"You were born this very year!\"\n\n\"...\" are to be replaced by the number, followed and proceeded by a single space. Mind that you need to account for both \"year\" and \"years\", depending on the result.\n\nGood Luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_age (birth_year : Int) (current_year : Int) : String := sorry\n\ntheorem calculate_age_output_is_string (birth_year current_year : Int) :\n  ∃ s : String, calculate_age birth_year current_year = s :=\nsorry", "vc-theorems": "theorem calculate_age_same_year (year : Int) :\n  calculate_age year year = \"You were born this very year!\" :=\nsorry\n\ntheorem calculate_age_future (birth_year current_year : Int) :\n  birth_year > current_year →\n  calculate_age birth_year current_year = \"You will be born in \" ++ toString (birth_year - current_year) ++ (if birth_year - current_year ≠ 1 then \"years.\" else \"year.\") :=\nsorry\n\ntheorem calculate_age_past (birth_year current_year : Int) :\n  birth_year < current_year →\n  calculate_age birth_year current_year = \"You are \" ++ toString (current_year - birth_year) ++ (if current_year - birth_year ≠ 1 then \" years old.\" else \" year old.\") :=\nsorry\n\ntheorem calculate_age_pluralization_single (birth_year current_year : Int) :\n  (current_year - birth_year).natAbs = 1 →\n  (calculate_age birth_year current_year).data.indexOf 's' = 0 ∧\n  (calculate_age birth_year current_year).data.contains 'r' :=\nsorry\n\ntheorem calculate_age_pluralization_multiple (birth_year current_year : Int) :\n  (current_year - birth_year).natAbs > 1 →\n  (calculate_age birth_year current_year).data.contains 's' :=\nsorry\n\n/-\ninfo: 'You are 4 years old.'\n-/\n-- #guard_msgs in\n-- #eval calculate_age 2012 2016\n\n/-\ninfo: 'You will be born in 10 years.'\n-/\n-- #guard_msgs in\n-- #eval calculate_age 2000 1990\n\n/-\ninfo: 'You were born this very year!'\n-/\n-- #guard_msgs in\n-- #eval calculate_age 2000 2000", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2678", "language": "lean", "source": "fvapps", "source-id": "fvapps_002678", "source-notes": "", "vc-description": "/-\nYour task is to make a program takes in a sentence (without puncuation), adds all words to a list and returns the sentence as a string which is the positions of the word in the list. Casing should not matter too.\n\nExample\n-----\n\n`\"Ask not what your COUNTRY can do for you ASK WHAT YOU CAN DO FOR YOUR country\"`\n\nbecomes\n\n`\"01234567802856734\"`\n\nAnother example\n-----\n\n`\"the one bumble bee one bumble the bee\"`\n\nbecomes\n\n`\"01231203\"`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def compress (s : String) : String := sorry\n\ntheorem compress_case_insensitive (s : String) : \n  compress s = compress s.toUpper ∧ compress s = compress s.toLower := by sorry", "vc-theorems": "theorem compress_only_digits (s : String) :\n  s ≠ \"\" → compress s ≠ \"\" → \n  (∀ c : Char, c ∈ (compress s).data → c.isDigit) := by sorry\n\ntheorem compress_maps_repeat_words (s : String) (i : Nat) :\n  s ≠ \"\" →\n  let words := s.toLower.split (· = ' ')\n  i < words.length →\n  let result := compress s\n  String.toNat! ((result.data.get! i).toString) = words.indexOf (words.get! i) := by sorry\n\n/-\ninfo: '012'\n-/\n-- #guard_msgs in\n-- #eval compress \"The bumble bee\"\n\n/-\ninfo: '012012'\n-/\n-- #guard_msgs in\n-- #eval compress \"SILLY LITTLE BOYS silly little boys\"\n\n/-\ninfo: '01234567802856734'\n-/\n-- #guard_msgs in\n-- #eval compress \"Ask not what your COUNTRY can do for you ASK WHAT YOU CAN DO FOR YOUR country\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2680", "language": "lean", "source": "fvapps", "source-id": "fvapps_002680", "source-notes": "", "vc-description": "/-\nDeoxyribonucleic acid (DNA) is a chemical found in the nucleus of cells and carries the \"instructions\" for the development and functioning of living organisms.\n\nIf you want to know more http://en.wikipedia.org/wiki/DNA\n\nIn DNA strings, symbols \"A\" and \"T\" are complements of each other, as \"C\" and \"G\". \nYou have function with one side of the DNA (string, except for Haskell); you need to get the other complementary side. DNA strand is never empty or there is no DNA at all (again, except for Haskell).\n\nMore similar exercise are found here http://rosalind.info/problems/list-view/ (source)\n\n```python\nDNA_strand (\"ATTGC\") # return \"TAACG\"\n\nDNA_strand (\"GTAT\") # return \"CATA\"\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def DNA_strand : List Base → List Base\n  | xs => sorry", "vc-theorems": "theorem dna_complement_length {xs : List Base} :\n  (DNA_strand xs).length = xs.length := by sorry\n\ntheorem dna_complement_involution {xs : List Base} :\n  DNA_strand (DNA_strand xs) = xs := by sorry\n\ntheorem dna_complement_maps_correctly {xs : List Base} {i : Nat} (h : i < xs.length) :\n  match xs.get ⟨i, h⟩ with\n  | Base.A => (DNA_strand xs).get ⟨i, by {rw [dna_complement_length]; exact h}⟩ = Base.T\n  | Base.T => (DNA_strand xs).get ⟨i, by {rw [dna_complement_length]; exact h}⟩ = Base.A\n  | Base.C => (DNA_strand xs).get ⟨i, by {rw [dna_complement_length]; exact h}⟩ = Base.G\n  | Base.G => (DNA_strand xs).get ⟨i, by {rw [dna_complement_length]; exact h}⟩ = Base.C\n  := by sorry\n\n/-\ninfo: 'TTTT'\n-/\n-- #guard_msgs in\n-- #eval DNA_strand \"AAAA\"\n\n/-\ninfo: 'TAACG'\n-/\n-- #guard_msgs in\n-- #eval DNA_strand \"ATTGC\"\n\n/-\ninfo: 'CATA'\n-/\n-- #guard_msgs in\n-- #eval DNA_strand \"GTAT\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2687", "language": "lean", "source": "fvapps", "source-id": "fvapps_002687", "source-notes": "", "vc-description": "/-\nA Magic Square contains the integers 1 to n^(2), arranged in an n by n array such that the columns, rows and both main diagonals add up to the same number.For doubly even positive integers (multiples of 4) the following method can be used to create a magic square.\nFill an array with the numbers 1 to n^(2) in succession. Then, for each 4 by 4 subarray, replace the entries on the blue and red diagonals by n^(2)+1-aij.\nSo, in the following example, a11 (row 1, column 1) was initially 1 and is replaced by 8^(2)+1-1 = 64\n\n    tab1 { padding-left: 2em; }\n    fc1  { font color=\"blue\"}\n\nn=8\n642 3 61606 7 57 \n9 55541213515016\n1747462021434224\n4026273736303133\n3234352928383925\n4123224445191848\n4915145253111056\n8 58595 4 62631 \n\nThe function even_magic() should return a 2D array as follows:-\nExample:\nn=4: Output: [[16,2,3,13],[5,11,10,8],[9,7,6,12],[4,14,15,1]]\n\n162 3 13\n5 11108 \n9 7 6 12\n4 14151 \n\nOnly doubly even numbers will be passed to the function in the tests.\n\nSee mathworld.wolfram.com for further details.\n-/", "vc-preamble": "def even_magic (n : Nat) : Array (Array Nat) := sorry\n\ntheorem even_magic_dimensions {n : Nat} (h : n ≥ 4) (h2 : n % 2 = 0) :\n  let result := even_magic n\n  result.size = n ∧ \n  ∀ i, i < n → (result.get ⟨i, by sorry⟩).size = n := sorry", "vc-helpers": "", "vc-definitions": "def check_position_pattern (matrix : Array (Array Nat)) (x y : Nat) (hx : x < matrix.size) (hy : y < matrix.size) : Prop := \n  let val := (matrix.get ⟨y, hy⟩).get ⟨x, by sorry⟩\n  if x % 4 = y % 4 ∨ (x % 4 + y % 4) % 4 = 3\n  then val = matrix.size * matrix.size - (y * matrix.size + x)\n  else val = y * matrix.size + x + 1", "vc-theorems": "theorem even_magic_contains_all_numbers {n : Nat} (h : n ≥ 4) (h2 : n % 2 = 0) :\n  let result := even_magic n\n  let flattened := result.flatten\n  ∀ k, 1 ≤ k → k ≤ n*n → k ∈ flattened.toList := sorry\n\ntheorem even_magic_pattern {n : Nat} (h : n ≥ 4) (h2 : n % 2 = 0) :\n  let result := even_magic n\n  ∀ x y (hx : x < n) (hy : y < n), \n    check_position_pattern result x y (by sorry) (by sorry) := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2693", "language": "lean", "source": "fvapps", "source-id": "fvapps_002693", "source-notes": "", "vc-description": "/-\nGiven a sequence of numbers, find the largest pair sum in the sequence.\n\nFor example\n```\n[10, 14, 2, 23, 19] -->  42 (= 23 + 19)\n[99, 2, 2, 23, 19]  --> 122 (= 99 + 23)\n```\n\nInput sequence contains minimum two elements and every element is an integer.\n-/", "vc-preamble": "def largest_pair_sum (l : List Int) : Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def isSorted (l : List Int) : Bool :=\n  sorry", "vc-theorems": "theorem output_greater_than_min_pair\n  {l : List Int} (h : l.length ≥ 2) :\n  largest_pair_sum l ≥ 2 * (l.minimum?.getD 0) :=\nsorry\n\ntheorem output_less_than_max_pair \n  {l : List Int} (h : l.length ≥ 2) :\n  largest_pair_sum l ≤ 2 * (l.maximum?.getD 0) :=\nsorry\n\ntheorem sorted_input_same_output \n  {l : List Int} (h : l.length ≥ 2) (sorted : List Int) (h₂ : isSorted sorted) :\n  largest_pair_sum l = largest_pair_sum sorted :=\nsorry\n\ntheorem reversed_input_same_output\n  {l : List Int} (h : l.length ≥ 2) :\n  largest_pair_sum l = largest_pair_sum l.reverse :=\nsorry\n\ntheorem non_negative_sum_non_negative\n  {l : List Int} (h : l.length ≥ 2) (h₂ : ∀ x ∈ l, x ≥ 0) :\n  largest_pair_sum l ≥ 0 :=\nsorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval largest_pair_sum [10, 14, 2, 23, 19]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval largest_pair_sum [-100, -29, -24, -19, 19]\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval largest_pair_sum [-10, -8, -16, -18, -19]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2703", "language": "lean", "source": "fvapps", "source-id": "fvapps_002703", "source-notes": "", "vc-description": "/-\nTaking into consideration the [3.5 edition rules](http://www.dandwiki.com/wiki/SRD:Ability_Scores#Table:_Ability_Modifiers_and_Bonus_Spells), your goal is to build a function that takes an ability score (worry not about validation: it is always going to be a non negative integer), will return:\n\n* attribute modifier, as indicated on the table of the above link;\n* maximum spell level for the spells you can cast (-1 for no spells at all) with that score;\n* the eventual extra spells you might get (as an array/list, with elements representing extra spells for 1st, 2nd,... spell level in order; empty array for no extra spells).\n\nThe result needs to be an object (associative array in PHP), as shown in the examples:\n\n```python\nchar_attribute(0) == {\"modifier\": 0, \"maximum_spell_level\": -1, \"extra_spells\": []}\nchar_attribute(1) == {\"modifier\": -5, \"maximum_spell_level\": -1, \"extra_spells\": []}\nchar_attribute(5) == {\"modifier\": -3, \"maximum_spell_level\": -1, \"extra_spells\": []}\nchar_attribute(10) == {\"modifier\": 0, \"maximum_spell_level\": 0, \"extra_spells\": []}\nchar_attribute(20) == {\"modifier\": +5, \"maximum_spell_level\": 9, \"extra_spells\": [2,1,1,1,1]}\n```\n\n*Note: I didn't explain things in detail and just pointed out to the table on purpose, as my goal is also to train the pattern recognition skills of whoever is going to take this challenges, so do not complain about a summary description. Thanks :)*\n\nIn the same series:\n\n* [D&D Character generator #1: attribute modifiers and spells](https://www.codewars.com/kata/d-and-d-character-generator-number-1-attribute-modifiers-and-spells/)\n* [D&D Character generator #2: psion power points](https://www.codewars.com/kata/d-and-d-character-generator-number-2-psion-power-points/)\n* [D&D Character generator #3: carrying capacity](https://www.codewars.com/kata/d-and-d-character-generator-number-3-carrying-capacity/)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def char_attribute : Int → CharAttribute := sorry\n\ntheorem char_attribute_types (score : Int) :\n  let result := char_attribute score\n  0 ≤ score → score ≤ 100 →\n  True := sorry", "vc-theorems": "theorem max_spell_level_constraints (score : Int) :\n  let result := char_attribute score\n  0 ≤ score → score ≤ 100 →\n  (score = 0 → result.maximum_spell_level = -1) ∧\n  (score ≠ 0 → \n    let modifier := score / 2 - 5\n    result.maximum_spell_level ≤ 9 ∧\n    (modifier < 0 → result.maximum_spell_level = -1) ∧\n    (score ≥ 10 → result.maximum_spell_level ≤ score - 10)) := sorry\n\ntheorem extra_spells_properties (score : Int) :\n  let result := char_attribute score \n  0 ≤ score → score ≤ 100 →\n  result.extra_spells.length ≤ 9 ∧\n  (∀ x ∈ result.extra_spells, x > 0) ∧\n  (∀ i j, i < j → j < result.extra_spells.length → \n    match result.extra_spells.get? i, result.extra_spells.get? j with\n    | some x, some y => x ≥ y\n    | _, _ => true) := sorry\n\n/-\ninfo: {'modifier': 0, 'maximum_spell_level': -1, 'extra_spells': []}\n-/\n-- #guard_msgs in\n-- #eval char_attribute 0\n\n/-\ninfo: {'modifier': 0, 'maximum_spell_level': 0, 'extra_spells': []}\n-/\n-- #guard_msgs in\n-- #eval char_attribute 10\n\n/-\ninfo: {'modifier': 5, 'maximum_spell_level': 9, 'extra_spells': [2, 1, 1, 1, 1]}\n-/\n-- #guard_msgs in\n-- #eval char_attribute 20", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2705", "language": "lean", "source": "fvapps", "source-id": "fvapps_002705", "source-notes": "", "vc-description": "/-\nYou're about to go on a trip around the world! On this trip you're bringing your trusted backpack, that anything fits into. The bad news is that the airline has informed you, that your luggage cannot exceed a certain amount of weight.\n\nTo make sure you're bringing your most valuable items on this journey you've decided to give all your items a score that represents how valuable this item is to you. It's your job to pack you bag so that you get the most value out of the items that you decide to bring.\n\nYour input will consist of two arrays, one for the scores and one for the weights. You input will always be valid lists of equal length, so you don't have to worry about verifying your input.\n\nYou'll also be given a maximum weight. This is the weight that your backpack cannot exceed.\n\nFor instance, given these inputs:\n\n    scores = [15, 10, 9, 5]\n    weights = [1, 5, 3, 4]\n    capacity = 8\n\nThe maximum score will be ``29``. This number comes from bringing items ``1, 3 and 4``.\n\nNote: Your solution will have to be efficient as the running time of your algorithm will be put to a test.\n-/", "vc-preamble": "def List.sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum xs\n\ndef List.minimum : List Nat → Nat\n  | [] => 0 \n  | [x] => x\n  | x::xs => Nat.min x (minimum xs)\n\ndef pack_bagpack (scores weights : List Nat) (capacity : Nat) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def max_valid_score (scores weights : List Nat) (capacity : Nat) : Nat :=\n  let pairs := List.zip scores weights\n  let valid := List.filter (fun p => p.snd ≤ capacity) pairs\n  let scores := List.map Prod.fst valid\n  match scores with\n  | [] => 0\n  | x::xs => List.foldl Nat.max x xs", "vc-theorems": "theorem pack_backpack_non_negative (scores weights : List Nat) (capacity : Nat) :\n  pack_bagpack scores weights capacity ≥ 0 := sorry\n\ntheorem pack_backpack_at_most_sum_scores (scores weights : List Nat) (capacity : Nat) :\n  pack_bagpack scores weights capacity ≤ List.sum scores := sorry\n\ntheorem pack_backpack_zero_if_capacity_too_small \n  (scores weights : List Nat) (capacity : Nat)\n  (h : capacity < List.minimum weights) :\n  pack_bagpack scores weights capacity = 0 := sorry\n\ntheorem pack_backpack_at_least_max_valid_score \n  (scores weights : List Nat) (capacity : Nat)\n  (h : scores.length = weights.length)\n  (h2 : scores.length > 0) :\n  pack_bagpack scores weights capacity ≥ max_valid_score scores weights capacity := sorry\n\n/-\ninfo: 29\n-/\n-- #guard_msgs in\n-- #eval pack_bagpack [15, 10, 9, 5] [1, 5, 3, 4] 8\n\n/-\ninfo: 60\n-/\n-- #guard_msgs in\n-- #eval pack_bagpack [20, 5, 10, 40, 15, 25] [1, 2, 3, 8, 7, 4] 10\n\n/-\ninfo: 39\n-/\n-- #guard_msgs in\n-- #eval pack_bagpack [100, 5, 16, 18, 50] [25, 1, 3, 2, 15] 14", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2723", "language": "lean", "source": "fvapps", "source-id": "fvapps_002723", "source-notes": "", "vc-description": "/-\nFor a given 2D vector described by cartesian coordinates of its initial point and terminal point in the following format:\n\n```python\n[[x1, y1], [x2, y2]]\n```\n\nYour function must return this vector's length represented as a floating point number.\n\nError must be within 1e-7.\n\nCoordinates can be integers or floating point numbers.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def vectorLength (p1 p2 : Point) : Float := \n  sorry", "vc-theorems": "theorem vectorLength_nonnegative (p1 p2 : Point) :\n  vectorLength p1 p2 ≥ 0 := by\n  sorry\n\ntheorem vectorLength_symmetric (p1 p2 : Point) :\n  vectorLength p1 p2 = vectorLength p2 p1 := by\n  sorry\n\ntheorem vectorLength_same_point (p : Point) :\n  vectorLength p p = 0 := by\n  sorry\n\ntheorem vectorLength_triangle_inequality (a b c : Point) :\n  vectorLength a c ≤ vectorLength a b + vectorLength b c := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2726", "language": "lean", "source": "fvapps", "source-id": "fvapps_002726", "source-notes": "", "vc-description": "/-\n# Task\n You have two sorted arrays `a` and `b`, merge them to form new array of unique items.\n\n If an item is present in both arrays, it should be part of the resulting array if and only if it appears in both arrays the same number of times.\n\n# Example\n\n  For `a = [1, 3, 40, 40, 50, 60, 60, 60]` and `b = [2, 40, 40, 50, 50, 65]`, the result should be `[1, 2, 3, 40, 60, 65]`.\n```\nNumber 40 appears 2 times in both arrays, \nthus it is in the resulting array.\nNumber 50 appears once in array a and twice in array b, \ntherefore it is not part of the resulting array.```\n\n# Input/Output\n\n - `[input]` integer array `a`\n\n A sorted array.\n\n 1 ≤ a.length ≤ 500000\n\n - `[input]` integer array `b`\n\n A sorted array.\n\n `1 ≤ b.length ≤ 500000`\n\n- `[output]` an integer array\n\n  The resulting sorted array.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def merge_arrays (a b : List Int) : List Int := sorry\n\ntheorem merge_arrays_sorted_property\n  (a b : List Int) :\n  let result := merge_arrays a b\n  ∀ i j, i < j → j < result.length → result[i]! ≤ result[j]! := sorry", "vc-theorems": "theorem merge_arrays_elements_from_inputs\n  (a b : List Int) (x : Int) :\n  x ∈ merge_arrays a b →\n  x ∈ a ∨ x ∈ b := sorry\n\ntheorem merge_arrays_no_duplicates\n  (a b : List Int) :\n  let result := merge_arrays a b\n  ∀ x ∈ result, ∀ y ∈ result, x = y → result.indexOf x = result.indexOf y := sorry\n\ntheorem merge_arrays_different_counts_excluded\n  (a b : List Int) (x : Int) :\n  x ∈ a ∧ x ∈ b →\n  (List.countP (· = x) a ≠ List.countP (· = x) b) →\n  x ∉ merge_arrays a b := sorry\n\ntheorem merge_arrays_unique_elements_included\n  (a b : List Int) (x : Int) :\n  (x ∈ a ∧ x ∉ b) ∨ (x ∉ a ∧ x ∈ b) →\n  x ∈ merge_arrays a b := sorry\n\ntheorem merge_arrays_same_count_included\n  (a b : List Int) (x : Int) :\n  x ∈ a ∧ x ∈ b →\n  List.countP (· = x) a = List.countP (· = x) b →\n  x ∈ merge_arrays a b := sorry\n\ntheorem merge_arrays_idempotent\n  (a : List Int) :\n  let result := merge_arrays a a\n  ∀ x, x ∈ result ↔ x ∈ a := sorry\n\ntheorem merge_arrays_symmetric\n  (a b : List Int) :\n  merge_arrays a b = merge_arrays b a := sorry\n\n/-\ninfo: [15, 20, 25, 27, 30, 7000, 7200]\n-/\n-- #guard_msgs in\n-- #eval merge_arrays [10, 10, 10, 15, 20, 20, 25, 25, 30, 7000] [10, 15, 20, 20, 27, 7200]\n\n/-\ninfo: [2, 3, 500, 550, 1000, 1400, 1500, 3500]\n-/\n-- #guard_msgs in\n-- #eval merge_arrays [500, 550, 1000, 1000, 1400, 3500] [2, 2, 2, 2, 3, 1500]\n\n/-\ninfo: [7]\n-/\n-- #guard_msgs in\n-- #eval merge_arrays [5] [5, 5, 7]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2745", "language": "lean", "source": "fvapps", "source-id": "fvapps_002745", "source-notes": "", "vc-description": "/-\n# Convert a linked list to a string\n\n## Related Kata\n\nAlthough this Kata is not part of an official Series, you may also want to try out [Parse a linked list from a string](https://www.codewars.com/kata/582c5382f000e535100001a7) if you enjoyed this Kata.\n\n## Preloaded\n\nPreloaded for you is a class, struct or derived data type `Node` (depending on the language) used to construct linked lists in this Kata:\n\n```python\nclass Node():\n    def __init__(self, data, next = None):\n        self.data = data\n        self.next = next\n```\n\n~~~if:objc\n*NOTE: In Objective-C, the* `Node` *struct is placed on top of your main solution because there is a \"double-import\" bug in the Preloaded section at the time of writing (which cannot be fixed on my end).  Attempts to modify it (e.g. to cheat the tests in some way) will likely result in a test crash so it is not recommended for you to modify that section ;)*\n~~~\n\n~~~if:c\n*NOTE: In C, the* `Node` *struct is placed on top of your main solution (and the [Sample] Test Cases) because the compiler complains about not recognizing the* `Node` *datatype even after adding it to the Preloaded section.  Attempts to modify it (e.g. to cheat the tests in some way) will likely result in a test crash so it is not recommended for you to modify that section ;)*\n~~~\n\nIf you are attempting this Kata in NASM then note that the code example shown directly above may not be relevant; please refer to the Sample Tests (written in C) for the exact definition of the `Node` structure.\n\n## Prerequisites\n\nThis Kata assumes that you are already familiar with the idea of a linked list.  If you do not know what that is, you may want to read up on [this article on Wikipedia](https://en.wikipedia.org/wiki/Linked_list).  Specifically, the linked lists this Kata is referring to are **singly linked lists**, where the value of a specific node is stored in its `data`/`$data`/`Data` property, the reference to the next node is stored in its `next`/`$next`/`Next`/`next_node` property and the terminator for a list is `null`/`NULL`/`None`/`nil`/`nullptr`/`null()`.\n\n## Task\n\n*If you are attempting this Kata in NASM, the code examples shown below may not be relevant at all - please refer to the Sample Tests (written in C) for the exact requirements.*\n\nCreate a function `stringify` which accepts an argument `list`/`$list` and returns a string representation of the list.  The string representation of the list starts with the value of the current `Node`, specified by its `data`/`$data`/`Data` property, followed by a whitespace character, an arrow and another whitespace character (`\" -> \"`), followed by the rest of the list.  The end of the string representation of a list must always end with `null`/`NULL`/`None`/`nil`/`nullptr`/`null()` (all caps or all lowercase depending on the language you are undertaking this Kata in).  For example, given the following list:\n\n```python\nNode(1, Node(2, Node(3)))\n```\n\n... its string representation would be:\n\n```python\n\"1 -> 2 -> 3 -> None\"\n```\n\nAnd given the following linked list:\n\n```python\nNode(0, Node(1, Node(4, Node(9, Node(16)))))\n```\n\n... its string representation would be:\n\n```python\n\"0 -> 1 -> 4 -> 9 -> 16 -> None\"\n```\n\nNote that `null`/`NULL`/`None`/`nil`/`nullptr`/`null()` itself is also considered a valid linked list.  In that case, its string representation would simply be `\"null\"`/`\"NULL\"`/`\"None\"`/`\"nil\"`/`\"nullptr\"`/`@\"NULL\"`/`\"null()\"` (again, depending on the language).\n\nFor the simplicity of this Kata, you may assume that any `Node` in this Kata may only contain **non-negative integer** values.  For example, you will not encounter a `Node` whose `data`/`$data`/`Data` property is `\"Hello World\"`.\n\nEnjoy, and don't forget to check out my other Kata Series :D\n\n~~~if:fortran\n*NOTE: In Fortran, your returned string is* **not** *permitted to contain any leading and/or trailing whitespace.*\n~~~\n-/", "vc-preamble": "def stringify {α : Type} [ToString α] : Node α → String :=\n  sorry\n\ndef make_linked_list {α : Type} : List α → Node α :=\n  sorry", "vc-helpers": "", "vc-definitions": "def splitOnStr (s : String) (sep : String) : List String :=\n  sorry", "vc-theorems": "theorem stringify_matches_list_structure {α : Type} [ToString α] (items : List α) :\n  let ll := make_linked_list items\n  let result := stringify ll\n  let parts := splitOnStr result \" -> \"\n  if items.isEmpty then\n    result = \"None\"\n  else\n    parts.getLast! = \"None\" ∧\n    parts.length - 1 = items.length ∧\n    parts.take items.length = items.map ToString.toString :=\n  sorry\n\ntheorem stringify_outputs_well_formed {α : Type} [ToString α] (items : List α) :\n  let ll := make_linked_list items\n  let result := stringify ll\n  let parts := splitOnStr result \" -> \"\n  result.endsWith \"None\" ∧\n  parts.all (·.trim ≠ \"\") ∧\n  (if items.isEmpty then\n    parts.length = 1\n  else\n    parts.length = items.length + 1) :=\n  sorry\n\n/-\ninfo: 'None'\n-/\n-- #guard_msgs in\n-- #eval stringify None\n\n/-\ninfo: '1 -> None'\n-/\n-- #guard_msgs in\n-- #eval stringify Node(1)\n\n/-\ninfo: '1 -> 2 -> 3 -> None'\n-/\n-- #guard_msgs in\n-- #eval stringify Node(1, Node(2, Node(3)))", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2759", "language": "lean", "source": "fvapps", "source-id": "fvapps_002759", "source-notes": "", "vc-description": "/-\n# Task\n You are given a binary string (a string consisting of only '1' and '0'). The only operation that can be performed on it is a Flip operation. \n\n It flips any binary character ( '0' to '1' and vice versa) and all characters to the `right` of it.\n\n For example, applying the Flip operation to the 4th character of string \"1001010\" produces the \"1000101\" string, since all characters from the 4th to the 7th are flipped.\n\n Your task is to find the minimum number of flips required to convert the binary string to string consisting of all '0'.\n\n# Example\n\n For `s = \"0101\"`, the output should be `3`.\n\n It's possible to convert the string in three steps:\n\n ```\n \"0101\" -> \"0010\"\n    ^^^\n \"0010\" -> \"0001\"\n     ^^\n \"0001\" -> \"0000\"\n      ^\n ```\n\n# Input/Output\n\n - `[input]` string `s`\n\n  A binary string.\n\n - `[output]` an integer\n\n  The minimum number of flips required.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bin_str (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem bin_str_nonnegative (s : String) (h : s.length > 0) :\n  bin_str s ≥ 0 := sorry\n\ntheorem bin_str_ends_zero (s : String) (h : s.length > 0) (h2 : s.data.getLast! = '0') :\n  bin_str s % 2 = 0 := sorry\n\ntheorem bin_str_ends_one (s : String) (h : s.length > 0) (h2 : s.data.getLast! = '1') :\n  bin_str s % 2 = 1 := sorry\n\ntheorem bin_str_upper_bound (s : String) (h : s.length > 0) :\n  bin_str s ≤ 2 * s.length - 1 := sorry\n\ntheorem bin_str_n_zeros (n : Nat) (h : n > 0) :\n  bin_str (String.mk (List.replicate n '0')) = 0 := sorry\n\ntheorem bin_str_alternating (n : Nat) (h : n > 0) :\n  bin_str (String.mk (List.join (List.replicate n ['1', '0']))) = 2 * n := sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval bin_str \"0101\"\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval bin_str \"10000\"\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval bin_str \"0000000000\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2768", "language": "lean", "source": "fvapps", "source-id": "fvapps_002768", "source-notes": "", "vc-description": "/-\n###Story\nSometimes we are faced with problems when we have a big nested dictionary with which it's hard to work. Now, we need to solve this problem by writing a function that will flatten a given dictionary.\n\n###Info\nPython dictionaries are a convenient data type to store and process configurations. They allow you to store data by keys to create nested structures. You are given a dictionary where the keys are strings and the values are strings or dictionaries. The goal is flatten the dictionary, but save the structures in the keys. The result should be a dictionary without the nested dictionaries. The keys should contain paths that contain the parent keys from the original dictionary. The keys in the path are separated by a `/`. If a value is an empty dictionary, then it should be replaced by an empty string `\"\"`.\n\n###Examples\n```python\n{\n    \"name\": {\n        \"first\": \"One\",\n        \"last\": \"Drone\"\n    },\n    \"job\": \"scout\",\n    \"recent\": {},\n    \"additional\": {\n        \"place\": {\n            \"zone\": \"1\",\n            \"cell\": \"2\"\n        }\n    }\n}\n```\nThe result will be:\n```python\n{\"name/first\": \"One\",           #one parent\n \"name/last\": \"Drone\",\n \"job\": \"scout\",                #root key\n \"recent\": \"\",                  #empty dict\n \"additional/place/zone\": \"1\",  #third level\n \"additional/place/cell\": \"2\"}\n```\n\n***`Input: An original dictionary as a dict.`***\n***`Output: The flattened dictionary as a dict.`***\n***`Precondition:\nKeys in a dictionary are non-empty strings.\nValues in a dictionary are strings or dicts.\nroot_dictionary != {}`***\n\n```python\nflatten({\"key\": \"value\"}) == {\"key\": \"value\"}\nflatten({\"key\": {\"deeper\": {\"more\": {\"enough\": \"value\"}}}}) == {\"key/deeper/more/enough\": \"value\"}\nflatten({\"empty\": {}}) == {\"empty\": \"\"}\n```\n-/", "vc-preamble": "def flatten {α : Type} [ToString α] (d : Dict α (Dict α String)) : Dict α String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def appendPath (s1 s2 : String) : String :=\n  s1 ++ \"/\" ++ s2\n\nstructure isFlat (d : Dict String String) : Prop where\n  flat : ∀ k v, d.get k = some v → ¬∃ k' v', k = appendPath k' v'", "vc-theorems": "theorem flatten_flat_dict_unchanged {d : Dict String String} :\n  isFlat d → d = Dict.mk (λ s => d.get s) :=\n  sorry\n\ntheorem flatten_nested_dict (d : Dict String (Dict String String))\n    (outer inner : String) (value : String) :\n  (d.get outer >>= (λ innerDict => innerDict.get inner)) = some value →\n  (flatten d).get (appendPath outer inner) = some value :=\n  sorry\n\ntheorem flatten_empty_dict :\n  flatten (Dict.mk (λ (_ : String) => none)) = Dict.mk (λ (_ : String) => none) :=\n  sorry\n\ntheorem flatten_empty_nested_dict :\n  flatten (Dict.mk (λ s => if s = \"key\" \n    then some (Dict.mk (λ (_ : String) => none)) \n    else none)) =\n  Dict.mk (λ s => if s = \"key\" then some \"\" else none) :=\n  sorry\n\n/-\ninfo: {'key': 'value'}\n-/\n-- #guard_msgs in\n-- #eval flatten {\"key\": \"value\"}\n\n/-\ninfo: {'key/deeper/more/enough': 'value'}\n-/\n-- #guard_msgs in\n-- #eval flatten {\"key\": {\"deeper\": {\"more\": {\"enough\": \"value\"}}}}\n\n/-\ninfo: {'empty': ''}\n-/\n-- #guard_msgs in\n-- #eval flatten {\"empty\": {}}\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval flatten {\"name\": {\"first\": \"One\", \"last\": \"Drone\"}, \"job\": \"scout\", \"recent\": {}, \"additional\": {\"place\": {\"zone\": \"1\", \"cell\": \"2\"}}}", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2780", "language": "lean", "source": "fvapps", "source-id": "fvapps_002780", "source-notes": "", "vc-description": "/-\nJust another day in the world of Minecraft, Steve is working on his new project -- building a beacon pyramid in front of his house.\n\n![Beacon pyramid](http://www.minecraft101.net/reference/images/beacon_pyramid_thb.jpg)\n\nSteve has already obtained the beacon (the glass wrapped blue thingy on the top), he just needs to build the pyramid. Each level of the pyramid is built using one of the following four kinds of block: gold, diamond, emerald, and iron. Since these four kinds of blocks are relatively hard to collect, Steve needs to know exactly how many of each kind is required to build a pyramid of level N.\n\nAssume that the top level of the pyramid uses gold blocks, the second level uses diamond blocks, the third level uses emerald blocks, the fourth level uses iron blocks, and the fifth level uses gold blocks, etc. (if you are a Minecraft player, you know it's not neccessary the right way to build the pyramid. Let's just assume it is for the sake of this kata ;-))\n\nImplement a function that takes one argument which is the number of levels of the pyramid, and returns an object of the form: `{total: 9, gold: 9, diamond: 0, emerald: 0, iron: 0}`.\n\n---\n\nTo all the Minecraft players out there: \nfeel free to expand this series or let me know if you have any ideas related to Minecraft that can be turned into codewars puzzles. Some ideas I have that might potentially be turned into katas:\n\n* distance traveled in real world vs. in Nether\n* shortest path problems related to mining diamonds/gold/goodies that appears in different levels under ground\n* growth of animal population from breeding\n* redstone stuff?!\n\nIf you do end up expanding this series, please send me a link of your kata so I can check it out and include a link to your kata here :-)\n\n* [Minecraft Series #2: Minimum amount of fuel needed to get some iron ingots](https://www.codewars.com/kata/minecraft-series-number-2-minimum-amount-of-fuel-needed-to-get-some-iron-ingots/ruby)\n* [Minecraft Series #3: Lava is amazing! ](https://www.codewars.com/kata/583a23d40cf946ec380002c2)\n* [Minecraft Series #4: Lava is amazing, however...](https://www.codewars.com/kata/583a6b0b171f3a3c3f0003e3)\n-/", "vc-preamble": "def blocks_to_collect (level : Nat) : BlockCount :=\n  sorry", "vc-helpers": "", "vc-definitions": "def square (n : Nat) : Nat := n * n\n\ndef goldCalc (level : Nat) : Nat := \n  match level with\n  | 0 => 0\n  | n + 1 => \n    if (n % 4 = 0) then\n      square (n + n + 3) + goldCalc n\n    else\n      goldCalc n", "vc-theorems": "theorem blocks_total_is_sum_of_others (level : Nat) :\n  let result := blocks_to_collect level\n  result.total = result.gold + result.diamond + result.emerald + result.iron :=\nsorry\n\ntheorem values_are_nonnegative (level : Nat) :\n  let result := blocks_to_collect level\n  result.total ≥ 0 ∧ result.gold ≥ 0 ∧ result.diamond ≥ 0 ∧ result.emerald ≥ 0 ∧ result.iron ≥ 0 :=\nsorry\n\ntheorem gold_blocks_pattern (level : Nat) :\n  let result := blocks_to_collect level\n  result.gold = goldCalc level :=\nsorry\n\n/-\ninfo: {'total': 9, 'gold': 9, 'diamond': 0, 'emerald': 0, 'iron': 0}\n-/\n-- #guard_msgs in\n-- #eval blocks_to_collect 1\n\n/-\ninfo: {'total': 34, 'gold': 9, 'diamond': 25, 'emerald': 0, 'iron': 0}\n-/\n-- #guard_msgs in\n-- #eval blocks_to_collect 2\n\n/-\ninfo: {'total': 83, 'gold': 9, 'diamond': 25, 'emerald': 49, 'iron': 0}\n-/\n-- #guard_msgs in\n-- #eval blocks_to_collect 3", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2781", "language": "lean", "source": "fvapps", "source-id": "fvapps_002781", "source-notes": "", "vc-description": "/-\nYou have stumbled across the divine pleasure that is owning a dog and a garden. Now time to pick up all the cr@p! :D\n\nGiven a 2D array to represent your garden, you must find and collect all of the dog cr@p - represented by '@'.\n\nYou will also be given the number of bags you have access to (bags), and the capactity of a bag (cap). If there are no bags then you can't pick anything up, so you can ignore cap.\n\nYou need to find out if you have enough capacity to collect all the cr@p and make your garden clean again. \n\nIf you do, return 'Clean', else return 'Cr@p'.\n\nWatch out though - if your dog is out there ('D'), he gets very touchy about being watched. If he is there you need to return 'Dog!!'.\n\nFor example:\n\nx=\n[[\\_,\\_,\\_,\\_,\\_,\\_]\n [\\_,\\_,\\_,\\_,@,\\_]\n [@,\\_,\\_,\\_,\\_,\\_]]\n\nbags = 2, cap = 2\n\nreturn  --> 'Clean'\n-/", "vc-preamble": "def crap (garden : List (List Cell)) (bags : Nat) (cap : Nat) : GardenResult :=\n  sorry\n\ndef countCrap (garden : List (List Cell)) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def hasDog (garden : List (List Cell)) : Bool :=\n  sorry", "vc-theorems": "theorem crap_result_always_valid (garden : List (List Cell)) (bags cap : Nat) :\n  let result := crap garden bags cap\n  result = GardenResult.Clean ∨ result = GardenResult.Crap ∨ result = GardenResult.Dog :=\n  sorry\n\ntheorem dog_implies_dog_result (garden : List (List Cell)) (bags cap : Nat) :\n  hasDog garden → crap garden bags cap = GardenResult.Dog :=\n  sorry\n\ntheorem clean_implies_sufficient_capacity (garden : List (List Cell)) (bags cap : Nat) :\n  crap garden bags cap = GardenResult.Clean →\n  countCrap garden ≤ bags * cap :=\n  sorry\n\ntheorem crap_implies_insufficient_capacity (garden : List (List Cell)) (bags cap : Nat) :\n  crap garden bags cap = GardenResult.Crap →\n  countCrap garden > bags * cap :=\n  sorry\n\ntheorem zero_capacity_behavior (garden : List (List Cell)) :\n  ¬hasDog garden →\n  (crap garden 0 0 = GardenResult.Clean ↔ countCrap garden = 0) ∧\n  (crap garden 0 0 = GardenResult.Crap ↔ countCrap garden > 0) :=\n  sorry\n\n/-\ninfo: 'Clean'\n-/\n-- #guard_msgs in\n-- #eval crap [[\"_\", \"_\", \"_\", \"_\"], [\"_\", \"_\", \"_\", \"@\"], [\"_\", \"_\", \"@\", \"_\"]] 2 2\n\n/-\ninfo: 'Dog!!'\n-/\n-- #guard_msgs in\n-- #eval crap [[\"_\", \"_\"], [\"_\", \"@\"], [\"D\", \"_\"]] 2 2\n\n/-\ninfo: 'Clean'\n-/\n-- #guard_msgs in\n-- #eval crap [[\"@\", \"@\"], [\"@\", \"@\"], [\"@\", \"@\"]] 3 2", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2791", "language": "lean", "source": "fvapps", "source-id": "fvapps_002791", "source-notes": "", "vc-description": "/-\nColour plays an important role in our lifes. Most of us like this colour better then another. User experience specialists believe that certain colours have certain psychological meanings for us.\n\nYou are given a 2D array, composed of a colour and its 'common' association in each array element. The function you will write needs to return the colour as 'key' and association as its 'value'.\n\nFor example:\n```python\nvar array = [[\"white\", \"goodness\"], ...] returns [{'white': 'goodness'}, ...]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def colourAssociation {α β : Type} (pairs : List (α × β)) : List (Dict α β) :=\n  sorry", "vc-theorems": "theorem colourAssociation_length_eq\n  {α β : Type} [Inhabited α] [Inhabited β]\n  (pairs : List (α × β))\n  (h : pairs.length > 0) :\n  (colourAssociation pairs).length = pairs.length :=\nsorry\n\ntheorem colourAssociation_valid_structure\n  {α β : Type} [Inhabited α] [Inhabited β]\n  (pairs : List (α × β))\n  (h : pairs.length > 0)\n  (i : Nat)\n  (hi : i < pairs.length) :\n  let result := colourAssociation pairs\n  have hi' : i < result.length := by\n    rw [colourAssociation_length_eq pairs h]\n    exact hi\n  (result[i]'hi').keys.length = 1 ∧ \n  (result[i]'hi').values.length = 1 ∧\n  (result[i]'hi').keys[0]! = (pairs[i]'hi).1 ∧\n  (result[i]'hi').values[0]! = (pairs[i]'hi).2 :=\nsorry\n\ntheorem colourAssociation_maintains_order\n  {α β : Type} [Inhabited α] [Inhabited β]\n  (pairs : List (α × β))\n  (h : pairs.length > 0)\n  (i : Nat)\n  (hi : i < pairs.length) :\n  let result := colourAssociation pairs\n  have hi' : i < result.length := by\n    rw [colourAssociation_length_eq pairs h]\n    exact hi\n  (result[i]'hi').keys[0]! = (pairs[i]'hi).1 :=\nsorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval colour_association [[\"white\", \"goodness\"], [\"blue\", \"tranquility\"]]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval colour_association [[\"red\", \"energy\"], [\"yellow\", \"creativity\"]]\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval colour_association [[\"gray\", \"intelligence\"], [\"black\", \"classy\"]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2799", "language": "lean", "source": "fvapps", "source-id": "fvapps_002799", "source-notes": "", "vc-description": "/-\nThis kata is all about adding numbers.\n\nYou will create a function named add. It will return the sum of all the arguments. Sounds easy, doesn't it?\n\nWell Here's the Twist. The inputs will gradually decrease with their index as parameter to the function.\n\n```python\n  add(3,4,6) #returns (3/1)+(4/2)+(6/3)=7\n```\n\nRemember the function will return 0 if no arguments are passed and it must round the result if sum is a float.\n\nExample\n```python\n  add() #=> 0\n  add(1,2,3) #=> 3\n  add(1,4,-6,20) #=> 6\n```\n\nCheck my another kata here!! http://www.codewars.com/kata/555b73a81a6285b6ce000047\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def add (nums : List Float) : Int := sorry\n\ntheorem add_returns_int (nums : List Float) :\n  add nums = add nums := sorry", "vc-theorems": "theorem add_empty_list :\n  add [] = 0 := sorry\n\ntheorem add_single_number (x : Float) :\n  add [x] = Int.ofNat (x.toUInt64.toNat) := sorry \n\ntheorem add_weighted_sum (nums : List Float) (h : nums ≠ []) :\n  ∃ w : Float, w = (nums.enum.foldl (fun acc p => acc + p.2/(Float.ofNat (p.1 + 1))) 0) ∧ \n  (w - Float.ofInt (add nums)).abs < 0.01 := sorry\n\n/-\ninfo: 300\n-/\n-- #guard_msgs in\n-- #eval add 100 200 300\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval add 2\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval add 4 -3 -2", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2802", "language": "lean", "source": "fvapps", "source-id": "fvapps_002802", "source-notes": "", "vc-description": "/-\n## Introduction\n\nEach chemical element in its neutral state has a specific number of electrons associated with it. This is represented by the **atomic number** which is noted by an integer number next to or above each element of the periodic table (as highlighted in the image above).\n\nAs we move from left to right, starting from the top row of the periodic table, each element differs from its predecessor by 1 unit (electron). Electrons fill in different orbitals sets according to a specific order. Each set of orbitals, when full, contains an even number of electrons.\n\nThe orbital sets are:\n* The _**s** orbital_ - a single orbital that can hold a maximum of 2 electrons.\n* The _**p** orbital set_ - can hold 6 electrons.\n* The _**d** orbital set_ - can hold 10 electrons.\n* The _**f** orbital set_ - can hold 14 electrons.\n\nThe order in which electrons are filling the different set of orbitals is shown in the picture above. First electrons will occupy the **1s** orbital, then the **2s**, then the **2p** set, **3s** and so on.\n\nElectron configurations show how the number of electrons of an element is distributed across each orbital set. Each orbital is written as a sequence that follows the order in the picture, joined by the number of electrons contained in that orbital set. The final electron configuration is a single string of orbital names and number of electrons per orbital set where the first 2 digits of each substring represent the orbital name followed by a number that states the number of electrons that the orbital set contains.\n\nFor example, a string that demonstrates an electron configuration of a chemical element that contains 10 electrons is: `1s2 2s2 2p6`. This configuration shows that there are two electrons in the `1s` orbital set, two electrons in the `2s` orbital set, and six electrons in the `2p` orbital set. `2 + 2 + 6 = 10` electrons total.\n\n___\n\n# Task\n\nYour task is to write a function that displays the electron configuration built according to the Madelung rule of all chemical elements of the periodic table. The argument will be the symbol of a chemical element, as displayed in the periodic table.\n\n**Note**: There will be a preloaded array called `ELEMENTS` with chemical elements sorted by their atomic number.\n\nFor example, when the element \"O\" is fed into the function the output should look like: \n\n`\"O -> 1s2 2s2 2p4\"`\n\nHowever, there are some exceptions! The electron configurations of the elements below should end as:\n\n```\nCr -> ...3d5 4s1\nCu -> ...3d10 4s1\nNb -> ...4d4 5s1\nMo -> ...4d5 5s1\nRu -> ...4d7 5s1\nRh -> ...4d8 5s1\nPd -> ...4d10 5s0\nAg -> ...4d10 5s1\nLa -> ...4f0 5d1\nCe -> ...4f1 5d1\nGd -> ...4f7 5d1 6s2\nPt -> ...4f14 5d9 6s1\nAu -> ...4f14 5d10 6s1\nAc -> ...5f0 6d1 7s2\nTh -> ...5f0 6d2 7s2\nPa -> ...5f2 6d1 7s2\nU  -> ...5f3 6d1 7s2\nNp -> ...5f4 6d1 7s2\nCm -> ...5f7 6d1 7s2\n```\n\n**Note**: for `Ni` the electron configuration should be `3d8 4s2` instead of `3d9 4s1`.\n-/", "vc-preamble": "def Element.toNat : Element → Nat \n| H => 1 | He => 2 | Li => 3 | Be => 4 | B => 5 | C => 6 | N => 7 | O => 8\n| F => 9 | Ne => 10 | Na => 11 | Mg => 12 | Al => 13 | Si => 14 | P => 15\n| S => 16 | Cl => 17 | Ar => 18 | K => 19 | Ca => 20 | Sc => 21 | Ti => 22\n| V => 23 | Cr => 24 | Mn => 25 | Fe => 26 | Co => 27 | Ni => 28 | Cu => 29\n| Zn => 30 | Ga => 31 | Ge => 32 | As => 33 | Se => 34 | Br => 35 | Kr => 36\n| Rb => 37 | Sr => 38 | Y => 39 | Zr => 40 | Nb => 41 | Mo => 42 | Tc => 43\n| Ru => 44 | Rh => 45 | Pd => 46 | Ag => 47 | Cd => 48 | In => 49 | Sn => 50\n| Sb => 51 | Te => 52 | I => 53 | Xe => 54 | Cs => 55 | Ba => 56 | La => 57\n| Ce => 58 | Pr => 59 | Nd => 60 | Pm => 61 | Sm => 62 | Eu => 63 | Gd => 64\n| Tb => 65 | Dy => 66 | Ho => 67 | Er => 68 | Tm => 69 | Yb => 70 | Lu => 71\n| Hf => 72 | Ta => 73 | W => 74 | Re => 75 | Os => 76 | Ir => 77 | Pt => 78\n| Au => 79 | Hg => 80 | Tl => 81 | Pb => 82 | Bi => 83 | Po => 84 | At => 85\n| Rn => 86 | Fr => 87 | Ra => 88 | Ac => 89 | Th => 90 | Pa => 91 | U => 92\n| Np => 93 | Pu => 94 | Am => 95 | Cm => 96 | Bk => 97 | Cf => 98 | Es => 99\n| Fm => 100 | Md => 101 | No => 102 | Lr => 103 | Rf => 104 | Db => 105\n| Sg => 106 | Bh => 107 | Hs => 108 | Mt => 109 | Ds => 110 | Rg => 111\n| Cn => 112 | Nh => 113 | Fl => 114 | Mc => 115 | Lv => 116 | Ts => 117\n| Og => 118\n\ninductive Orbital \n| s | p | d | f | g\nderiving Repr\n\nstructure OrbitalConfig where\n  n: Nat \n  l: Orbital\n  electrons: Nat\n\ndef get_electron_configuration (e: Element) : List OrbitalConfig :=\n  sorry", "vc-helpers": "", "vc-definitions": "def sumElectrons (config: List OrbitalConfig) : Nat :=\n  match config with\n  | [] => 0\n  | x :: xs => x.electrons + sumElectrons xs", "vc-theorems": "theorem electron_config_format (e: Element) (config: List OrbitalConfig):\n  get_electron_configuration e = config →\n  ∀ oc ∈ config, \n    oc.n > 0 ∧ \n    match oc.l with\n    | Orbital.s => oc.electrons ≤ 2\n    | Orbital.p => oc.electrons ≤ 6\n    | Orbital.d => oc.electrons ≤ 10  \n    | Orbital.f => oc.electrons ≤ 14\n    | Orbital.g => oc.electrons ≤ 18\n:= sorry\n\ntheorem electron_count_conservation (e: Element):\n  let config := get_electron_configuration e\n  sumElectrons config = Element.toNat e := sorry\n\ntheorem orbital_order (e: Element):\n  let config := get_electron_configuration e\n  ∀ i j, i ≤ j → i < config.length → j < config.length →\n  (config.get ⟨i, sorry⟩).n ≤ (config.get ⟨j, sorry⟩).n := sorry\n\ntheorem first_period (e: Element) :\n  (e = Element.H ∨ e = Element.He) →\n  let config := get_electron_configuration e\n  ∀ oc ∈ config, oc.n = 1 ∧ oc.l = Orbital.s := sorry\n\n/-\ninfo: 'H -> 1s1'\n-/\n-- #guard_msgs in\n-- #eval get_electron_configuration \"H\"\n\n/-\ninfo: 'Cr -> 1s2 2s2 2p6 3s2 3p6 3d5 4s1'\n-/\n-- #guard_msgs in\n-- #eval get_electron_configuration \"Cr\"\n\n/-\ninfo: 'C -> 1s2 2s2 2p2'\n-/\n-- #guard_msgs in\n-- #eval get_electron_configuration \"C\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2816", "language": "lean", "source": "fvapps", "source-id": "fvapps_002816", "source-notes": "", "vc-description": "/-\nIn this kata you need to create a function that takes a 2D array/list of non-negative integer pairs and returns the sum of all the \"saving\" that you can have getting the [LCM](https://en.wikipedia.org/wiki/Least_common_multiple) of each couple of number compared to their simple product.\n\nFor example, if you are given:\n```\n[[15,18], [4,5], [12,60]]\n```\nTheir product would be:\n```\n[270, 20, 720]\n```\nWhile their respective LCM would be:\n```\n[90, 20, 60]\n```\nThus the result should be:\n```\n(270-90)+(20-20)+(720-60)==840\n```\nThis is a kata that I made, among other things, to let some of my trainees familiarize with the [euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm), a really neat tool to have on your belt ;)\n-/", "vc-preamble": "def sumDifferencesBetweenProductsAndLCMs (pairs : List (Nat × Nat)) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def List.sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => h + List.sum t", "vc-theorems": "theorem empty_list_gives_zero :\n  sumDifferencesBetweenProductsAndLCMs [] = 0 :=\nsorry\n\ntheorem zero_pairs_give_zero (n : Nat) :\n  sumDifferencesBetweenProductsAndLCMs (List.replicate n (0, 0)) = 0 :=\nsorry\n\ntheorem result_leq_sum_products (pairs : List (Nat × Nat)) :\n  pairs ≠ [] →\n  sumDifferencesBetweenProductsAndLCMs pairs ≤ \n    List.sum (pairs.map (fun p => p.fst * p.snd)) :=\nsorry\n\ntheorem commutative (pairs : List (Nat × Nat)) :\n  sumDifferencesBetweenProductsAndLCMs pairs = \n  sumDifferencesBetweenProductsAndLCMs (pairs.map fun p => (p.snd, p.fst)) :=\nsorry\n\n/-\ninfo: 840\n-/\n-- #guard_msgs in\n-- #eval sum_differences_between_products_and_LCMs [[15, 18], [4, 5], [12, 60]]\n\n/-\ninfo: 1092\n-/\n-- #guard_msgs in\n-- #eval sum_differences_between_products_and_LCMs [[1, 1], [0, 0], [13, 91]]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval sum_differences_between_products_and_LCMs []", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2817", "language": "lean", "source": "fvapps", "source-id": "fvapps_002817", "source-notes": "", "vc-description": "/-\nYou are given an array of non-negative integers, your task is to complete the series from 0 to the highest number in the array.\n\nIf the numbers in the sequence provided are not in order you should order them, but if a value repeats, then you must return a sequence with only one item, and the value of that item must be 0. like this:\n```\ninputs        outputs\n[2,1]     ->  [0,1,2]\n[1,4,4,6] ->  [0]\n```\nNotes: all numbers are positive integers.\n\nThis is set of example outputs based on the input sequence.\n```\ninputs        outputs\n[0,1]   ->    [0,1]\n[1,4,6] ->    [0,1,2,3,4,5,6]\n[3,4,5] ->    [0,1,2,3,4,5]\n[0,1,0] ->    [0]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def complete_series (arr : List Nat) : List Nat := sorry\n\ntheorem complete_series_returns_list (arr : List Nat) :\n  ∃ l, complete_series arr = l := by sorry", "vc-theorems": "theorem complete_series_main_property (arr : List Nat) :\n  (∃ x ∈ arr, ∃ y ∈ arr, x = y ∧ arr.indexOf x ≠ arr.indexOf y) →\n  complete_series arr = [0] := by sorry\n\ntheorem complete_series_complete_sequence (arr : List Nat) :\n  (∀ x ∈ arr, ∀ y ∈ arr, x = y → arr.indexOf x = arr.indexOf y) →\n  let maxVal := arr.maximum?.getD 0\n  complete_series arr = List.range (maxVal + 1) := by sorry \n\ntheorem complete_series_length (arr : List Nat) :\n  (∀ x ∈ arr, ∀ y ∈ arr, x = y → arr.indexOf x = arr.indexOf y) →\n  let maxVal := arr.maximum?.getD 0\n  (complete_series arr).length = maxVal + 1 := by sorry\n\ntheorem complete_series_contains_all_elements (arr : List Nat) : \n  (∀ x ∈ arr, ∀ y ∈ arr, x = y → arr.indexOf x = arr.indexOf y) →\n  let maxVal := arr.maximum?.getD 0\n  ∀ i, i ≤ maxVal → i ∈ complete_series arr := by sorry\n\ntheorem complete_series_monotone (arr : List Nat) :\n  (∀ x ∈ arr, ∀ y ∈ arr, x = y → arr.indexOf x = arr.indexOf y) →\n  ∀ i j, i < j → i < (complete_series arr).length → j < (complete_series arr).length →\n  (complete_series arr).get ⟨i, by sorry⟩ ≤ (complete_series arr).get ⟨j, by sorry⟩ := by sorry\n\n/-\ninfo: [0, 1]\n-/\n-- #guard_msgs in\n-- #eval complete_series [0, 1]\n\n/-\ninfo: [0, 1, 2, 3, 4, 5, 6]\n-/\n-- #guard_msgs in\n-- #eval complete_series [1, 4, 6]\n\n/-\ninfo: [0]\n-/\n-- #guard_msgs in\n-- #eval complete_series [1, 4, 4, 6]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2820", "language": "lean", "source": "fvapps", "source-id": "fvapps_002820", "source-notes": "", "vc-description": "/-\nCreate a function that returns the sum of the two lowest positive numbers given an array of minimum 4 positive integers. No floats or non-positive integers will be passed.\n\nFor example, when an array is passed like `[19, 5, 42, 2, 77]`, the output should be `7`.\n\n`[10, 343445353, 3453445, 3453545353453]` should return `3453455`.\n-/", "vc-preamble": "def sum_two_smallest_numbers (numbers : List Nat) : Nat :=\n  sorry\n\ndef List.sum : List Nat → Nat\n  | [] => 0\n  | x :: xs => x + List.sum xs", "vc-helpers": "", "vc-definitions": "def List.minimum (l : List Nat) : Option Nat :=\n  match l with\n  | [] => none\n  | x :: xs => some (List.foldl min x xs)", "vc-theorems": "theorem sum_two_smallest_numbers_properties {numbers : List Nat} (h : numbers.length ≥ 2) :\n  let result := sum_two_smallest_numbers numbers\n  let sorted := numbers.toArray.qsort (·≤·)\n  (result ≥ 0) ∧\n  (match numbers.minimum with\n   | none => true\n   | some m => result ≥ 2 * m) ∧\n  (result ≤ List.sum numbers) :=\n  sorry\n\ntheorem sum_two_smallest_numbers_minimal {numbers : List Nat} (h : numbers.length ≥ 2) :\n  let result := sum_two_smallest_numbers numbers\n  ∀ i j, i < numbers.length → j < numbers.length → i ≠ j →\n    result ≤ numbers[i]! + numbers[j]! :=\n  sorry\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval sum_two_smallest_numbers #[19, 5, 42, 2, 77]\n\n/-\ninfo: 3453455\n-/\n-- #guard_msgs in\n-- #eval sum_two_smallest_numbers #[10, 343445353, 3453445, 3453545353453]\n\n/-\ninfo: 13\n-/\n-- #guard_msgs in\n-- #eval sum_two_smallest_numbers #[5, 8, 12, 18, 22]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2825", "language": "lean", "source": "fvapps", "source-id": "fvapps_002825", "source-notes": "", "vc-description": "/-\nLaura Bassi was the first female professor at a European university.  \nDespite her immense intellect, she was not always allowed to lecture publicly.\n\nOne day a professor with very strong beliefs against women in academia sent some `agents` to find Bassi and end her career.\n\nHelp her escape by telling her the safest places in town!\n\nTask\n\n```if:python,javascript\nImplement the function `advice(agents, n)` where\n```\n```if:haskell\nImplement the function `advice agents n :: [(Int,Int)] -> Int -> [(Int,Int)]` where\n```\n```if:swift\nImplement the function `advice(agents: [[Int]], n: Int) -> [[Int]]` where\n```\n\n- `agents` is an array of agent coordinates.\n- `n` defines the size of the city that Bassi needs to hide in, in other words the side length of the square grid. \n\nThe function should return a list of coordinates that are the furthest away (by Manhattan distance) from all agents.\n\nAs an example, say you have a 6x6 map, and agents at locations\n\n```python\n[(0, 0), (1, 5), (5, 1)]\n```\n\nThe distances to the nearest agent look like this.\n\nThe safest spaces are the ones with distance `4`, marked in bright red. So the function should return\n\n```python\n[(2, 2), (3, 3), (4, 4), (5, 5)]\n```\n\nin any order.\n\nEdge cases:\n- If there is an agent on every grid cell, there is no safe space, so return an empty list.\n- If there are no agents, then every cell is a safe spaces, so return all coordinates.\n- if `n` is `0`, return an empty list.\n- If agent coordinates are outside of the map, they are simply not considered.\n- There are no duplicate agents on the same square.\n\nPerformance\n\nAll reference solutions run in around 6 seconds.\nYou might not pass the tests if you use a brute-force solution.\n\n```if-not:swift,javascript\nThere are `200` random tests with `n <= 50`. Inefficient solutions might time out.\n```\n```if:javascript\nThere are `300` random tests with `n <= 70`. Inefficient solutions might time out.\n```\n```if:swift\nThere are `200` random tests with `n <= 70`. Inefficient solutions might time out.\n```\n\nThis kata is inspired by ThoughtWorks' coding challenge\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def advice (agents : List Pos) (n : Nat) : List Pos :=\n  sorry", "vc-theorems": "theorem advice_empty_grid (n : Nat) :\n  let result := advice [] n\n  n = 0 → result = [] ∧\n  n > 0 → (\n    result.length = n * n ∧\n    result.all (fun (x,y) => x < n ∧ y < n)\n  ) := sorry\n\ntheorem advice_result_properties (n : Nat) (agents : List Pos) :\n  n > 0 →\n  let result := advice agents n\n  result.all (fun (x,y) => x < n ∧ y < n) ∧\n  let validAgents := agents.filter (fun (x,y) => x < n ∧ y < n)\n  ∀ p, p ∈ validAgents → p ∉ result\n  := sorry\n\ntheorem advice_connected_safe_spaces (n : Nat) (agents : List Pos) :\n  n > 0 →\n  let result := advice agents n\n  result.isEmpty ∨\n  ∀ x y, (x,y) ∈ result →\n    let adjacent := [(x,y+1), (x,y), (x+1,y), (x,y)].filter (fun (nx,ny) => nx < n ∧ ny < n)\n    let safeAdj := adjacent.filter (fun p => p ∈ result)\n    safeAdj.isEmpty ∨ ∃ p, p ∈ safeAdj\n  := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2844", "language": "lean", "source": "fvapps", "source-id": "fvapps_002844", "source-notes": "", "vc-description": "/-\n# Task\n You are a magician. You're going to perform a trick.\n\n You have `b` black marbles and `w` white marbles in your magic hat, and an infinite supply of black and white marbles that you can pull out of nowhere. \n\n You ask your audience to repeatedly remove a pair of marbles from your hat and, for each pair removed, you add one marble to the hat according to the following rule until there is only 1 marble left. \n\n If the marbles of the pair that is removed are of the same color, you add a white marble to the hat. Otherwise, if one is black and one is white, you add a black marble.\n\n Given the initial number of black and white marbles in your hat, your trick is to predict the color of the last marble.\n\n Note: A magician may confuse your eyes, but not your mind ;-)\n\n# Input/Output\n\n - `[input]` integer `b`\n\n  Initial number of black marbles in the hat. \n\n  `1 <= b <= 10^9`\n\n - `[input]` integer `w`\n\n  Initial number of white marbles in the hat. \n\n  `1 <= w <= 10^9`\n\n - `[output]` a string\n\n  `\"Black\"` or `\"White\"` if you can safely predict the color of the last marble. If not, return `\"Unsure\"`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def not_so_random (b w : Nat) : Color :=\n  sorry", "vc-theorems": "theorem output_is_valid (b w : Nat) :\n  not_so_random b w = Color.Black ∨ not_so_random b w = Color.White :=\n  sorry\n\ntheorem odd_black_returns_black (b w : Nat) :\n  b % 2 = 1 → not_so_random b w = Color.Black :=\n  sorry\n\ntheorem even_black_returns_white (b w : Nat) :\n  b % 2 = 0 → not_so_random b w = Color.White :=\n  sorry\n\ntheorem white_count_irrelevant (b w₁ w₂ : Nat) :\n  not_so_random b w₁ = not_so_random b w₂ :=\n  sorry\n\n/-\ninfo: 'Black'\n-/\n-- #guard_msgs in\n-- #eval not_so_random 1 1\n\n/-\ninfo: 'White'\n-/\n-- #guard_msgs in\n-- #eval not_so_random 2 1\n\n/-\ninfo: 'Black'\n-/\n-- #guard_msgs in\n-- #eval not_so_random 11111 22222", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2858", "language": "lean", "source": "fvapps", "source-id": "fvapps_002858", "source-notes": "", "vc-description": "/-\nReducing Problems - Bug Fixing #8\n\nOh no! Timmy's reduce is causing problems, Timmy's goal is to calculate the two teams scores and return the winner but timmy has gotten confused and sometimes teams don't enter their scores, total the scores out of 3! Help timmy fix his program!\n\nReturn true if team 1 wins or false if team 2 wins!\n-/", "vc-preamble": "def List.sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => h + List.sum t", "vc-helpers": "", "vc-definitions": "def calculate_total (team1 team2 : List Nat) : Bool :=\n  sorry", "vc-theorems": "theorem calculate_total_sum_comparison {team1 team2 : List Nat} \n  (h1 : team1.length = 3 ∨ team1 = []) \n  (h2 : team2.length = 3 ∨ team2 = []) :\n  calculate_total team1 team2 = (List.sum (if team1 = [] then [0,0,0] else team1) > \n                                List.sum (if team2 = [] then [0,0,0] else team2)) :=\nsorry\n\ntheorem calculate_total_self {team : List Nat} \n  (h : team.length = 3 ∨ team = []) :\n  calculate_total team team = false :=\nsorry\n\ntheorem calculate_total_empty {team : List Nat} \n  (h : team.length = 3) :\n  (List.sum team > 0 → calculate_total team [] = true) ∧ \n  (List.sum team > 0 → calculate_total [] team = false) ∧\n  calculate_total [] [] = false :=\nsorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval calculate_total [1, 2, 2] [1, 0, 0]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval calculate_total [6, 45, 1] [1, 55, 0]\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval calculate_total [57, 2, 1] []", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2862", "language": "lean", "source": "fvapps", "source-id": "fvapps_002862", "source-notes": "", "vc-description": "/-\nComplete the solution so that it takes the object (JavaScript/CoffeeScript) or hash (ruby) passed in and generates a human readable string from its key/value pairs. \n\nThe format should be \"KEY = VALUE\". Each key/value pair should be separated by a comma except for the last pair.\n\n**Example:**\n```python\nsolution({\"a\": 1, \"b\": '2'}) # should return \"a = 1,b = 2\"\n```\n-/", "vc-preamble": "def Dict := List (String × (String ⊕ Int))\n\ndef solution (d : Dict) : String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def isSorted (xs : List String) : Prop :=\n  ∀ i j, i < j → j < xs.length → xs[i]! ≤ xs[j]!", "vc-theorems": "theorem solution_output_sorted (d : Dict) (h : d.length > 0) : \n  let result := solution d\n  let pairs := result.splitOn \",\"\n  isSorted pairs := by\n  sorry\n\ntheorem solution_contains_all_pairs (d : Dict) (h : d.length > 0) : \n  let result := solution d\n  let pairs := result.splitOn \",\"  \n  ∀ p ∈ d, ∃ pair ∈ pairs, \n    match p.2 with\n    | Sum.inl s => pair = s!\"{p.1} = {s}\"\n    | Sum.inr n => pair = s!\"{p.1} = {n}\" := by\n  sorry \n\ntheorem solution_empty (d : Dict) (h : d = []) :\n  solution d = \"\" := by\n  sorry\n\n/-\ninfo: 'a = 1,b = 2'\n-/\n-- #guard_msgs in\n-- #eval solution {\"a\": 1, \"b\": 2}\n\n/-\ninfo: 'a = b,b = a'\n-/\n-- #guard_msgs in\n-- #eval solution {\"a\": \"b\", \"b\": \"a\"}\n\n/-\ninfo: ''\n-/\n-- #guard_msgs in\n-- #eval solution {}", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2863", "language": "lean", "source": "fvapps", "source-id": "fvapps_002863", "source-notes": "", "vc-description": "/-\n# Task\n You have some people who are betting money, and they all start with the same amount of money (this number>0). \n\n Find out if the given end-state of amounts is possible after the betting is over and money is redistributed.\n\n# Input/Output\n\n - `[input]` integer array arr\n\n  the proposed end-state showing final amounts for each player\n\n - `[output]` a boolean value\n\n  `true` if this is a possible end-state and `false` otherwise\n\n# Examples\n\n- For `arr = [0, 56, 100]`, the output should be `true`.\n\nThree players start with the same amount of money 52.\n\nAt the end of game, player 1 lose `52`, player2 win `4`, and  player3 win `48`.\n\n- For `arr = [0, 0, 0]`, the output should be `false`.\n\nPlayers should start with a positive number of of money.\n\n- For `arr = [11]`, the output should be `true`.\n\nOne player always keep his money at the end of game.\n\n- For `arr = [100, 100, 100, 90, 1, 0, 0]`, the output should be `false`.\n\nThese players can not start with the same amount of money.\n-/", "vc-preamble": "def List.sum (xs : List Int) : Int := \n  xs.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def learn_charitable_game (arr : List Int) : Bool := sorry\n\ntheorem single_element_validity {n : Int} :\n  learn_charitable_game [n] = (n > 0) := sorry", "vc-theorems": "theorem non_positive_sum_invalid {arr : List Int} (h : arr.sum ≤ 0) :\n  learn_charitable_game arr = false := sorry\n\ntheorem divisible_sum_valid {arr : List Int} (h₁ : arr.sum > 0) :\n  learn_charitable_game arr = (arr.sum % arr.length == 0) := sorry\n\ntheorem all_zeros_invalid {arr : List Int} \n  (h₁ : arr.length ≥ 2)\n  (h₂ : ∀ x ∈ arr, x = 0) :\n  learn_charitable_game arr = false := sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval learn_charitable_game [0, 56, 100]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval learn_charitable_game [0, 0, 0]\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval learn_charitable_game [11]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2876", "language": "lean", "source": "fvapps", "source-id": "fvapps_002876", "source-notes": "", "vc-description": "/-\nWrite a function that gets a sequence and value and returns `true/false` depending on whether the variable exists in a multidimentional sequence.\n\nExample:\n```\nlocate(['a','b',['c','d',['e']]],'e'); // should return true\nlocate(['a','b',['c','d',['e']]],'a'); // should return true\nlocate(['a','b',['c','d',['e']]],'f'); // should return false\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def locate {α : Type u} [BEq α] : NestedList α → α → Bool := \n  sorry", "vc-theorems": "theorem locate_returns_bool {α : Type u} [BEq α] (seq : NestedList α) (value : α) :\n  locate seq value = true ∨ locate seq value = false :=\nsorry\n\ntheorem locate_finds_root_value {α : Type u} [BEq α] (seq : List (NestedList α)) (value : α) :\n  locate (NestedList.list (seq ++ [NestedList.elem value])) value = true :=\nsorry\n\ntheorem locate_handles_missing_value {α : Type u} [BEq α] (seq : List (NestedList α)) (value : α)\n  (h : ∀ x ∈ seq, ¬∃ inner, x = NestedList.list inner) : \n  (∀ x ∈ seq, x ≠ NestedList.elem value) → locate (NestedList.list seq) value = false :=\nsorry\n\ntheorem locate_finds_nested_value {α : Type u} [BEq α] (seq : NestedList α) (value : α) :\n  locate (NestedList.list [seq, NestedList.list [NestedList.elem value]]) value = true := \nsorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval locate [\"a\", \"b\", [\"c\", \"d\", [\"e\"]]] \"a\"\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval locate [\"a\", \"b\", [\"c\", \"d\", [\"e\"]]] \"e\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval locate [\"a\", \"b\", [\"c\", \"d\", [\"e\"]]] \"f\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2890", "language": "lean", "source": "fvapps", "source-id": "fvapps_002890", "source-notes": "", "vc-description": "/-\n# Description\n\"It's the end of trick-or-treating and we have a list/array representing how much candy each child in our group has made out with. We don't want the kids to start arguing, and using our parental intuition we know trouble is brewing as many of the children in the group have received different amounts of candy from each home. \n\nSo we want each child to have the same amount of candies, only we can't exactly take any candy away from the kids, that would be even worse. Instead we decide to give each child extra candy until they all have the same amount.\n# Task\nYour job is to find out how much candy each child has, and give them each additional candy until they too have as much as the child(ren) with the most candy. You also want to keep a total of how much candy you've handed out because reasons.\"\n\nYour job is to give all the kids the same amount of candies as the kid with the most candies and then return the total number candies that have been given out. If there are no kids, or only one, return -1. \n\nIn the first case (look below) the most candies are given to second kid (i.e second place in list/array), 8. Because of that we will give the first kid 3 so he can have 8 and the third kid 2 and the fourth kid 4, so all kids will have 8 candies.So we end up handing out 3 + 2 + 4 = 9.\n\n```python\ncandies ([5,8,6,4]) # return 9\n\ncandies ([1,2,4,6]) # return 11\n\ncandies ([1,6]) # return 5\n\ncandies ([]) # return -1\n\ncandies ([6]) # return -1 (because only one kid)\n```\n```cs\nCandyProblem.GetMissingCandies(new [] {5, 6, 8, 4}) // return 9\n\nCandyProblem.GetMissingCandies(new [] {1, 2, 4, 6}) // return 11\n\nCandyProblem.GetMissingCandies(new [] { }) // return -1\n\nCandyProblem.GetMissingCandies(new [] {1, 6}) // return 5\n\n```\n```haskell \ncandies [5,8,6,4] -- return 9\n\ncandies [1,2,4,6] -- return 11\n\ncandies [] -- return -1\n\ncandies [1,6] -- return 5\n```\n-/", "vc-preamble": "def List.sum (l : List Nat) : Nat := sorry \n\ndef List.maximum (l : List Nat) : Nat := sorry", "vc-helpers": "", "vc-definitions": "def candies (arr : List Nat) : Int := sorry\n\ntheorem candies_valid_input {arr : List Nat} (h : arr.length ≥ 2) :\n  candies arr ≥ 0 ∧ candies arr = arr.length * (List.maximum arr) - arr.sum := sorry", "vc-theorems": "theorem candies_invalid_input {arr : List Nat} (h : arr.length ≤ 1) :\n  candies arr = -1 := sorry\n\ntheorem candies_minimum_list :\n  candies [1, 1] = 0 := sorry\n\ntheorem candies_result_formula {arr : List Nat} (h : arr.length ≥ 2) :\n  candies arr = arr.length * (List.maximum arr) - arr.sum := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2907", "language": "lean", "source": "fvapps", "source-id": "fvapps_002907", "source-notes": "", "vc-description": "/-\nIn the board game Talisman, when two players enter combat the outcome is decided by a combat score, equal to the players power plus any modifiers plus the roll of a standard 1-6 dice. The player with the highest combat score wins and the opposing player loses a life. In the case of a tie combat ends with neither player losing a life.\n\nFor example:\n```\nPlayer 1: 5 Power, 0 Modifier\nPlayer 2: 3 Power, 2 Modifier\n\nPlayer 1 rolls a 4, Player 2 rolls a 2.\n\n(5 + 0 + 4) -> (3 + 2 + 2)\nPlayer 1 wins (9 > 7)\n```\n\nYour task is to write a method that calculates the required roll for the player to win.\n\nThe player and enemy stats are given as an array in the format:\n```python\n[power, modifier]\n```\n\nFor example for the examples used above the stats would be given as:\n```python\nget_required([5, 0], [3, 2]) # returns 'Random'\n```\n\nIf the player has at least 6 more power (including modifiers) than the enemy they automatically wins the fight, as the enemy's combat score couldn't possibly exceed the player's. In this instance the method should return \"Auto-win\".\n\nFor example:\n```python\nget_required([9, 0], [2, 1]) # returns 'Auto-win' as the enemy can't possibly win\n```\n\nIf the enemy has at least 6 more power (including modifiers) than the player they automatically wins the fight, as the player's combat score couldn't possibly exceed the enemy's. In this instance the method should return \"Auto-lose\".\n\nFor example:\n```python\nget_required([2, 1], [9, 0]) # returns 'Auto-lose' as the player can't possibly win\n```\n\nIf the player and enemy have the same power (including modifiers) the outcome is purely down to the dice roll, and hence would be considered completely random. In this instance the method should return \"Random\".\n\nFor example (as above):\n```python\nget_required([5, 0], [3, 2]) # returns 'Random' as it is purely down to the dice roll\n```\n\nIf the player has greater power than the enemy (including modifiers) the player could guarantee a win by rolling a high enough number on the dice. In this instance the method should return a range equal to the numbers which would guarantee victory for the player.\n\n```python\nget_required([6, 0], [2, 2]) # returns '(5..6)' as rolling a 5 or 6 would mean the enemy could not win\nget_required([7, 1], [2, 2]) # returns '(3..6)' as rolling anything 3 through 6 would mean the enemy could not win\n```\n\nIf the player has less power than the enemy (including modifiers) the player can only win if the enemy rolls a low enough number, providing they then roll a high enough number. In this instance the method should return a range equal to the numbers which would allow the player a chance to win.\n\n```python\nget_required([4, 0], [6, 0]) # returns '(1..3)' as this would be the only outcome for which the player could still win\nget_required([1, 1], [6, 0]) # returns '(1..1)' as this would be the only outcome for which the player could still win\n```\n\nIf the better case scenario for the player is to hope for a tie, then return `\"Pray for a tie!\"`.\n\n```python\nget_required([7, 2], [6, 8]) # returns \"Pray for a tie!\"\n```\n-/", "vc-preamble": "def List.sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + (sum xs)", "vc-helpers": "", "vc-definitions": "def get_required (player enemy : List Nat) : String :=\n  sorry", "vc-theorems": "theorem get_required_diff_cases {player enemy : List Nat} \n  (h : player.length ≥ 1 ∧ enemy.length ≥ 1) :\n  let diff : Int := Int.ofNat player.sum - Int.ofNat enemy.sum\n  match diff with\n  | 0 => get_required player enemy = \"Random\" \n  | d => \n    if d > 5 then get_required player enemy = \"Auto-win\"\n    else if d < -5 then get_required player enemy = \"Auto-lose\" \n    else if d = -5 then get_required player enemy = \"Pray for a tie!\"\n    else if d < 0 then get_required player enemy = s!\"(1..{6-d.toNat-1})\"\n    else get_required player enemy = s!\"({6-d+1}..6)\" :=\n  sorry\n\ntheorem same_arrays_random {xs : List Nat} (h : xs.length ≥ 1) :\n  get_required xs xs = \"Random\" :=\n  sorry\n\ntheorem get_required_symmetry {xs ys : List Nat}\n  (h : xs.length ≥ 1 ∧ ys.length ≥ 1) :\n  (get_required xs ys = \"Auto-win\" → get_required ys xs = \"Auto-lose\") ∧\n  (get_required xs ys = \"Auto-lose\" → get_required ys xs = \"Auto-win\") :=\n  sorry\n\n/-\ninfo: 'Auto-win'\n-/\n-- #guard_msgs in\n-- #eval get_required [8, 1] [3, 0]\n\n/-\ninfo: 'Random'\n-/\n-- #guard_msgs in\n-- #eval get_required [4, 0] [4, 0]\n\n/-\ninfo: 'Pray for a tie!'\n-/\n-- #guard_msgs in\n-- #eval get_required [7, 2] [6, 8]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2923", "language": "lean", "source": "fvapps", "source-id": "fvapps_002923", "source-notes": "", "vc-description": "/-\nIn this Kata, you will be given directions and your task will be to find your way back. \n```Perl\nsolve([\"Begin on Road A\",\"Right on Road B\",\"Right on Road C\",\"Left on Road D\"]) = ['Begin on Road D', 'Right on Road C', 'Left on Road B', 'Left on Road A']\nsolve(['Begin on Lua Pkwy', 'Right on Sixth Alley', 'Right on 1st Cr']) =  ['Begin on 1st Cr', 'Left on Sixth Alley', 'Left on Lua Pkwy']\n```\n\nMore examples in test cases. \n\nGood luck!\n\nPlease also try [Simple remove duplicates](https://www.codewars.com/kata/5ba38ba180824a86850000f7)\n-/", "vc-preamble": "def solve : List String → List String := sorry\n\ndef extractDirections (commands : List String) : List Direction := sorry\n\ndef extractRoads (commands : List String) : List String := sorry\n\ndef isLeftOrRight (d : Direction) : Bool :=\n  match d with\n  | Direction.Left => true\n  | Direction.Right => true\n  | _ => false", "vc-helpers": "", "vc-definitions": "def allLeftOrRight (directions : List Direction) : Bool := \n  directions.all isLeftOrRight", "vc-theorems": "theorem solution_preserves_length (commands : List String) :\n  List.length (solve commands) = List.length commands := sorry\n\ntheorem solution_preserves_roads (commands : List String) :\n  extractRoads (solve commands) = extractRoads commands := sorry\n\ntheorem first_direction_valid (commands : List String) :\n  commands ≠ [] →\n  let result := solve commands\n  let firstDir := extractDirections result |>.head!\n  firstDir = Direction.Begin ∨ firstDir = Direction.Left ∨ firstDir = Direction.Right := sorry\n\ntheorem directions_alternate (commands : List String) :\n  List.length commands > 1 →\n  allLeftOrRight (List.tail! (extractDirections (solve commands))) := sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval solve [\"Begin on 3rd Blvd\", \"Right on First Road\", \"Left on 9th Dr\"]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval solve [\"Begin on Road A\", \"Right on Road B\", \"Right on Road C\", \"Left on Road D\"]\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval solve [\"Begin on Road A\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2941", "language": "lean", "source": "fvapps", "source-id": "fvapps_002941", "source-notes": "", "vc-description": "/-\nYou like the way the Python `+` operator easily handles adding different numeric types, but you need a tool to do that kind of addition without killing your program with a `TypeError` exception whenever you accidentally try adding incompatible types like strings and lists to numbers.\n\nYou decide to write a function `my_add()` that takes two arguments. If the arguments can be added together it returns the sum. If adding the arguments together would raise an error the function should return `None` instead.\n\nFor example, `my_add(1, 3.414)` would return `4.414`, but `my_add(42, \" is the answer.\")` would return `None`.\n\nHint: using a `try` / `except` statement may simplify this kata.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def my_add : Input → Input → Option Input := sorry\n\ntheorem add_numbers (a b : Int) :\n  my_add (Input.number a) (Input.number b) = some (Input.number (a + b)) := sorry", "vc-theorems": "theorem add_number_and_string (a : Int) (b : String) :\n  my_add (Input.number a) (Input.text b) = none := sorry\n\ntheorem add_non_numbers {a b : Input} \n  (h1 : ¬∃ n : Int, a = Input.number n) \n  (h2 : ¬∃ n : Int, b = Input.number n) :\n  my_add a b = none ∨ \n  (∃ s : String, my_add a b = some (Input.text s)) ∨\n  (∃ bs : ByteArray, my_add a b = some (Input.binary bs)) ∨\n  (∃ l : List Int, my_add a b = some (Input.list l)) := sorry\n\ntheorem add_none_left (x : Input) :\n  my_add Input.none x = none := sorry\n\ntheorem add_none_right (x : Input) :\n  my_add x Input.none = none := sorry\n\ntheorem add_none_both :\n  my_add Input.none Input.none = none := sorry\n\n/-\ninfo: 4.414\n-/\n-- #guard_msgs in\n-- #eval my_add 1 3.414\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval my_add 42 \" is the answer.\"\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval my_add 10 \"2\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2945", "language": "lean", "source": "fvapps", "source-id": "fvapps_002945", "source-notes": "", "vc-description": "/-\nBased on [this kata, Connect Four.](https://www.codewars.com/kata/connect-four-1)\n\nIn this kata we play a modified game of connect four. It's connect X, and there can be multiple players.\n\nWrite the function ```whoIsWinner(moves,connect,size)```.\n\n```2 <= connect <= 10```\n\n```2 <= size <= 52```\n\nEach column is identified by a character, A-Z a-z:  \n``` ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ```\n\nMoves come in the form:\n\n```\n['C_R','p_Y','s_S','I_R','Z_Y','d_S']\n```\n* Player R puts on C\n* Player Y puts on p\n* Player S puts on s\n* Player R puts on I\n* ...\n\nThe moves are in the order that they are played. \n\nThe first player who connect ``` connect ``` items in same color is the winner. \n\nNote that a player can win before all moves are done. You should return the first winner.\n\nIf no winner is found, return \"Draw\".\n\nA board with size 7, where yellow has connected 4:\n\nAll inputs are valid, no illegal moves are made.\n\n![alt text](https://i.imgur.com/xnJEsIx.png)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def whoIsWinner (moves : List Move) (con sz : Nat) : Color :=\n  sorry", "vc-theorems": "theorem winner_result_valid (moves : List Move) (con sz : Nat) :\n  whoIsWinner moves con sz = Color.Red ∨ \n  whoIsWinner moves con sz = Color.Yellow ∨\n  whoIsWinner moves con sz = Color.Draw := \n  sorry\n\ntheorem empty_board_is_draw (con sz : Nat) : \n  con ≥ 2 → sz ≥ 2 →\n  whoIsWinner [] con sz = Color.Draw := \n  sorry\n\ntheorem single_column_valid (moves : List Move) (col : Nat) (sz : Nat) :\n  moves.length ≤ sz →\n  (∀ m ∈ moves, m.col = col) →\n  whoIsWinner moves 2 sz = Color.Red ∨\n  whoIsWinner moves 2 sz = Color.Yellow ∨ \n  whoIsWinner moves 2 sz = Color.Draw := \n  sorry\n\ntheorem valid_board_yields_valid_result (moves : List Move) (con sz : Nat) :\n  sz ≥ con →\n  moves.length ≥ con →\n  (∀ m ∈ moves, m.col < sz) →\n  (∀ col, (moves.filter (λ m => m.col = col)).length ≤ sz) →\n  whoIsWinner moves con sz = Color.Red ∨\n  whoIsWinner moves con sz = Color.Yellow ∨\n  whoIsWinner moves con sz = Color.Draw := \n  sorry\n\n/-\ninfo: 'R'\n-/\n-- #guard_msgs in\n-- #eval whoIsWinner [\"A_R\", \"B_Y\", \"A_R\"] 2 2\n\n/-\ninfo: 'Y'\n-/\n-- #guard_msgs in\n-- #eval whoIsWinner [\"A_R\", \"C_Y\", \"C_R\", \"B_Y\", \"A_R\", \"C_Y\", \"B_R\", \"B_Y\", \"D_R\", \"A_Y\", \"D_R\", \"A_Y\"] 2 4\n\n/-\ninfo: 'R'\n-/\n-- #guard_msgs in\n-- #eval whoIsWinner [\"E_R\", \"E_Y\", \"E_R\", \"A_Y\", \"B_R\", \"C_Y\", \"B_R\", \"F_Y\", \"F_R\", \"C_Y\", \"B_R\", \"D_Y\", \"D_R\", \"A_Y\", \"C_R\", \"E_Y\", \"B_R\", \"D_Y\", \"D_R\", \"A_Y\", \"A_R\", \"D_Y\", \"D_R\"] 3 6", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2949", "language": "lean", "source": "fvapps", "source-id": "fvapps_002949", "source-notes": "", "vc-description": "/-\n# Remove Duplicates\n\nYou are to write a function called `unique` that takes an array of integers and returns the array with duplicates removed. It must return the values in the same order as first seen in the given array. Thus no sorting should be done, if 52 appears before 10 in the given array then it should also be that 52 appears before 10 in the returned array.\n\n## Assumptions\n\n* All values given are integers (they can be positive or negative).\n* You are given an array but it may be empty.\n* They array may have duplicates or it may not.\n\n## Example\n\n```python\nprint unique([1, 5, 2, 0, 2, -3, 1, 10])\n[1, 5, 2, 0, -3, 10]\n\nprint unique([])\n[]\n\nprint unique([5, 2, 1, 3])\n[5, 2, 1, 3]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def unique (α : Type) [BEq α] : List α → List α := sorry\n\ntheorem unique_order (α : Type) [BEq α] (l : List α) :\n  let r := unique α l\n  (∀ x ∈ r, x ∈ l) ∧ \n  (List.Nodup r) ∧\n  (∀ x y, List.indexOf r x < List.indexOf r y → List.indexOf l x < List.indexOf l y) :=\nsorry", "vc-theorems": "theorem unique_properties (α : Type) [BEq α] (l : List α) :\n  let r := unique α l\n  (∀ x ∈ r, x ∈ l) ∧ \n  (∀ x ∈ l, (x ∈ r)) ∧ \n  (r.length ≤ l.length) :=\nsorry \n\ntheorem unique_empty (α : Type) [BEq α] : unique α [] = [] := sorry\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval unique []\n\n/-\ninfo: [5, 2, 1, 3]\n-/\n-- #guard_msgs in\n-- #eval unique [5, 2, 1, 3]\n\n/-\ninfo: [1, 5, 2, 0, -3, 10]\n-/\n-- #guard_msgs in\n-- #eval unique [1, 5, 2, 0, 2, -3, 1, 10]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2961", "language": "lean", "source": "fvapps", "source-id": "fvapps_002961", "source-notes": "", "vc-description": "/-\nGiven a square matrix (i.e. an array of subarrays), find the sum of values from the first value of the first array, the second value of the second array, the third value of the third array, and so on...\n\n## Examples\n\n```\narray = [[1, 2],\n         [3, 4]]\n\ndiagonal sum: 1 + 4 = 5\n```\n\n```\narray = [[5, 9, 1, 0],\n         [8, 7, 2, 3],\n         [1, 4, 1, 9],\n         [2, 3, 8, 2]]\n\ndiagonal sum: 5 + 7 + 1 + 2 = 15\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum (xs : List Int) : Int := xs.foldl (· + ·) 0\n\ndef diagonal_sum (matrix : List (List Int)) : Int := sorry", "vc-theorems": "theorem diagonal_sum_square_matrix (matrix : List (List Int)) : \n  let size := min (matrix.length) (matrix.map List.length |>.minimum?.getD 0)\n  let square_matrix := matrix.take size |>.map (List.take size)\n  diagonal_sum square_matrix = \n  sum ((List.range size).map (fun i => (square_matrix.get! i).get! i)) := sorry\n\ntheorem diagonal_sum_uniform_matrix (size : Nat) (value : Int) : \n  diagonal_sum (List.replicate size (List.replicate size value)) = \n  value * size := sorry\n\ntheorem diagonal_sum_bounds (matrix : List (List Int)) :\n  !matrix.isEmpty →\n  let size := min matrix.length (matrix.map List.length |>.minimum?.getD 0)\n  let square_matrix := matrix.take size |>.map (List.take size)\n  let min_val := (square_matrix.map (λ row => (row.minimum?.getD 0))).minimum?.getD 0\n  let max_val := (square_matrix.map (λ row => (row.maximum?.getD 0))).maximum?.getD 0\n  min_val * size ≤ diagonal_sum square_matrix ∧ \n  diagonal_sum square_matrix ≤ max_val * size := sorry\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval diagonal_sum [[1, 2], [3, 4]]\n\n/-\ninfo: 15\n-/\n-- #guard_msgs in\n-- #eval diagonal_sum [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n/-\ninfo: 34\n-/\n-- #guard_msgs in\n-- #eval diagonal_sum [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2979", "language": "lean", "source": "fvapps", "source-id": "fvapps_002979", "source-notes": "", "vc-description": "/-\n### Vaccinations for children under 5\nYou have been put in charge of administrating vaccinations for children in your local area. Write a function that will generate a list of vaccines for each child presented for vaccination, based on the child's age and vaccination history, and the month of the year.\n#### The function takes three parameters: age, status and month\n- The parameter 'age' will be given in weeks up to 16 weeks, and thereafter in months. You can assume that children presented will be scheduled for vaccination (eg '16 weeks', '12 months' etc).\n- The parameter 'status' indicates if the child has missed a scheduled vaccination, and the argument will be a string that says 'up-to-date', or a scheduled stage (eg '8 weeks') that has been missed, in which case you need to add any missing shots to the list. Only one missed vaccination stage will be passed in per function call.\n- If the month is 'september', 'october' or 'november' add 'offer fluVaccine' to the list.\n- Make sure there are no duplicates in the returned list, and sort it alphabetically.\n\n#### Example input and output\n~~~~\ninput     ('12 weeks', 'up-to-date', 'december')\noutput    ['fiveInOne', 'rotavirus']\n\ninput     ('12 months', '16 weeks', 'june')\noutput     ['fiveInOne', 'hibMenC', 'measlesMumpsRubella', 'meningitisB', 'pneumococcal']\n\ninput     ('40 months', '12 months', 'october') \noutput    ['hibMenC', 'measlesMumpsRubella', 'meningitisB', 'offer fluVaccine', 'preSchoolBooster']\n~~~~\n\n#### To save you typing it up, here is the vaccinations list\n~~~~\nfiveInOne : ['8 weeks', '12 weeks', '16 weeks'],\n//Protects against: diphtheria, tetanus, whooping cough, polio and Hib (Haemophilus influenzae type b)\npneumococcal : ['8 weeks', '16 weeks'],\n//Protects against: some types of pneumococcal infection\nrotavirus : ['8 weeks', '12 weeks'],\n//Protects against: rotavirus infection, a common cause of childhood diarrhoea and sickness\nmeningitisB : ['8 weeks', '16 weeks', '12 months'],\n//Protects against: meningitis caused by meningococcal type B bacteria\nhibMenC : ['12 months'],\n//Protects against: Haemophilus influenzae type b (Hib), meningitis caused by meningococcal group C bacteria    \nmeaslesMumpsRubella : ['12 months', '40 months'],\n//Protects against: measles, mumps and rubella\nfluVaccine : ['september','october','november'],\n//Given at: annually in Sept/Oct\npreSchoolBooster : ['40 months']\n//Protects against: diphtheria, tetanus, whooping cough and polio\n~~~~\n-/", "vc-preamble": "def TOME : List (String × List Vaccine) :=\n  sorry", "vc-helpers": "", "vc-definitions": "def vaccine_list (age status month : String) : List Vaccine :=\n  sorry", "vc-theorems": "theorem vaccine_list_ordered (age status month : String) :\n  let l := vaccine_list age status month\n  ∀ i v₁ v₂, i < l.length - 1 → \n  v₁ = l[i]! → v₂ = l[i+1]! → \n  v₁ ≤ v₂ := by\n  sorry\n\ntheorem vaccine_list_unique (age status month : String) :\n  let l := vaccine_list age status month\n  ∀ i j, i < l.length → j < l.length → i ≠ j →\n  l[i]! ≠ l[j]! := by\n  sorry\n\ntheorem vaccine_list_subset_of_valid_vaccines (age status month : String) (v : Vaccine) :\n  v ∈ vaccine_list age status month →\n  ∃ p : String × List Vaccine, p ∈ TOME ∧ v ∈ p.2 := by\n  sorry\n\ntheorem vaccine_list_contains_required (age status month : String) :\n  ∀ k : String, k ∈ [age, status, month] →\n  ∀ p : String × List Vaccine, p ∈ TOME →\n  ∀ v : Vaccine, v ∈ p.2 → v ∈ vaccine_list age status month := by\n  sorry\n\ntheorem vaccine_list_invalid_empty (age status month : String) :\n  (∀ p : String × List Vaccine, p ∈ TOME → p.1 ≠ age ∧ p.1 ≠ status ∧ p.1 ≠ month) →\n  vaccine_list age status month = [] := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2980", "language": "lean", "source": "fvapps", "source-id": "fvapps_002980", "source-notes": "", "vc-description": "/-\nGiven a string, determine if it's a valid identifier.\n\n## Here is the syntax for valid identifiers:\n* Each identifier must have at least one character.\n* The first character must be picked from: alpha, underscore, or dollar sign. The first character cannot be a digit.\n* The rest of the characters (besides the first) can be from: alpha, digit, underscore, or dollar sign. In other words, it can be any valid identifier character.\n\n### Examples of valid identifiers:\n* i\n* wo_rd\n* b2h\n\n### Examples of invalid identifiers:\n* 1i\n* wo rd \n* !b2h\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isValid (s : String) : Bool := sorry\n\n-- All strings consisting of letters/underscores/$ followed by letters/numbers/underscores/$ are valid", "vc-theorems": "theorem valid_identifier (s : String)\n  (h : s.data = x::xs ∧ (x = '_' ∨ x = '$' ∨ ('A' ≤ x ∧ x ≤ 'Z') ∨ ('a' ≤ x ∧ x ≤ 'z')) ∧ \n   ∀ c ∈ xs, (('0' ≤ c ∧ c ≤ '9') ∨ ('A' ≤ c ∧ c ≤ 'Z') ∨ ('a' ≤ c ∧ c ≤ 'z') ∨ c = '_' ∨ c = '$')) :\n  isValid s = true := sorry\n\n-- Edge cases\n\ntheorem empty_invalid : isValid \"\" = false := sorry\n\ntheorem underscore_valid : isValid \"_\" = true := sorry\n\ntheorem dollar_valid : isValid \"$\" = true := sorry\n\ntheorem space_invalid : isValid \" \" = false := sorry\n\ntheorem leading_number_invalid : isValid \"1abc\" = false := sorry\n\ntheorem whitespace_invalid : isValid \"abc def\" = false := sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval is_valid \"okay_ok1\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval is_valid \"\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval is_valid \"no no\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2987", "language": "lean", "source": "fvapps", "source-id": "fvapps_002987", "source-notes": "", "vc-description": "/-\n# Task\nJohn is an orchard worker. \n\nThere are `n` piles of fruits waiting to be transported. Each pile of fruit has a corresponding weight. John's job is to combine the fruits into a pile and wait for the truck to take them away.\n\nEvery time, John can combine any two piles(`may be adjacent piles, or not`), and the energy he costs is equal to the weight of the two piles of fruit.\n\nFor example, if there are two piles, pile1's weight is `1` and pile2's weight is `2`. After merging, the new pile's weight is `3`, and he consumed 3 units of energy.\n\nJohn wants to combine all the fruits into 1 pile with the least energy.\n\nYour task is to help John, calculate the minimum energy he costs.\n\n# Input\n\n- `fruits`: An array of positive integers. Each element represents the weight of a pile of fruit.\n\n  Javascript:\n  - 1 <= fruits.length <= 10000\n  - 1 <= fruits[i] <= 10000\n\n  Python:\n  - 1 <= len(fruits) <= 5000\n  - 1 <= fruits[i] <= 10000\n\n# Output\n\nAn integer. the minimum energy John costs.\n\n# Examples\n\nFor `fruits = [1,2,9]`, the output should be `15`.\n\n```\n3 piles:  1  2  9\ncombine 1 and 2 to 3, cost 3 units of energy.\n2 piles:  3  9\ncombine 3 and 9 to 12, cost 12 units of energy.\n1 pile:  12\n\nThe total units of energy is 3 + 12 = 15 units\n```\n\nFor `fruits = [100]`, the output should be `0`.\n\nThere's only 1 pile. So no need combine it.\n-/", "vc-preamble": "def List.minimum (l : List Nat) : Option Nat :=\n  sorry\n\ndef List.maximum (l : List Nat) : Option Nat :=\n  sorry\n\ndef List.sum (l : List Nat) : Nat :=\n  sorry\n\ndef List.log2 (n : Nat) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def combine_fruits (fruits : List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem combine_fruits_empty_singleton {fruits : List Nat} \n  (h : fruits.length ≤ 1) : combine_fruits fruits = 0 := by\n  sorry\n\ntheorem combine_fruits_nonneg {fruits : List Nat} :\n  combine_fruits fruits ≥ 0 := by\n  sorry\n\ntheorem combine_fruits_lower_bound {fruits : List Nat} {min1 min2 : Nat}\n  (h : fruits.length ≥ 2)\n  (h1 : fruits.minimum = some min1)\n  (h2 : (fruits.tail).minimum = some min2) :\n  combine_fruits fruits ≥ min1 + min2 := by\n  sorry\n\ntheorem combine_fruits_upper_bound {fruits : List Nat} \n  (h : fruits ≠ []) :\n  combine_fruits fruits ≤ fruits.sum * (fruits.length.log2) := by\n  sorry\n\ntheorem combine_fruits_monotone {fruits : List Nat} {x maxVal : Nat}\n  (h : fruits.length ≥ 2)\n  (h2 : fruits.maximum = some maxVal)\n  (h3 : x > maxVal) :\n  combine_fruits (fruits ++ [x]) ≥ combine_fruits fruits := by\n  sorry\n\n/-\ninfo: 15\n-/\n-- #guard_msgs in\n-- #eval combine_fruits [1, 2, 9]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval combine_fruits [100]\n\n/-\ninfo: 111\n-/\n-- #guard_msgs in\n-- #eval combine_fruits [4, 3, 5, 6, 10, 20]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF2993", "language": "lean", "source": "fvapps", "source-id": "fvapps_002993", "source-notes": "", "vc-description": "/-\n# Story\n\nJohn found a path to a treasure, and while searching for its precise location he wrote a list of directions using symbols `\"^\"`, `\"v\"`, `\"<\"`, `\">\"` which mean `north`, `east`, `west`, and `east` accordingly. On his way John had to try many different paths, sometimes walking in circles, and even missing the treasure completely before finally noticing it.\n\n___\n\n## Task\n\nSimplify the list of directions written by John by eliminating any loops.\n\n**Note**: a loop is any sublist of directions which leads John to the coordinate he had already visited.\n\n___\n\n## Examples\n\n```\nsimplify(\"<>>\")        ==  \">\"\nsimplify(\"<^^>v<^^^\")  ==  \"<^^^^\"\nsimplify(\"\")           ==  \"\"\nsimplify(\"^< > v\n    ^   v\n> > C > D > >\n^   ^   v\n^ < B < <\n    ^\n    A\n```\n\nJohn visits points `A -> B -> C -> D -> B -> C -> D`, realizes that `-> C -> D -> B` steps are meaningless and removes them, getting this path: `A -> B -> (*removed*) -> C -> D`.\n\n```\n    ∙ ∙ ∙\n    ∙   ∙\n> > C > D > >\n^   ∙   ∙\n^ < B ∙ ∙\n    ^\n    A\n```\n\nFollowing the final, simplified route John visits points `C` and `D`, but for the first time, not the second (because we ignore the steps made on a hypothetical path), and he doesn't need to alter the directions list anymore.\n-/", "vc-preamble": "def dirList := List Dir\n\ndef getEndpoint (path : dirList) : Int × Int := sorry\n\ndef simplify (path : dirList) : dirList := sorry \n\ntheorem simplify_same_endpoint (path : dirList) : \n  getEndpoint path = getEndpoint (simplify path) := sorry", "vc-helpers": "", "vc-definitions": "def isValidDir (d : Dir) : Bool := sorry\n\ntheorem simplify_valid_chars (path : dirList) (d : Dir) :\n  List.elem d (simplify path) → isValidDir d := sorry", "vc-theorems": "theorem simplify_shorter (path : dirList) :\n  (simplify path).length ≤ path.length := sorry\n\ntheorem simplify_empty (path : dirList) :\n  path = [] → simplify path = [] := sorry\n\ntheorem simplify_idempotent (path : dirList) :\n  simplify (simplify path) = simplify path := sorry\n\n/-\ninfo: '>'\n-/\n-- #guard_msgs in\n-- #eval simplify \"<>>\"\n\n/-\ninfo: '<^^^^'\n-/\n-- #guard_msgs in\n-- #eval simplify \"<^^>v<^^^\"\n\n/-\ninfo: ''\n-/\n-- #guard_msgs in\n-- #eval simplify \"\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3001", "language": "lean", "source": "fvapps", "source-id": "fvapps_003001", "source-notes": "", "vc-description": "/-\n## Number of people in the bus\nThere is a bus moving in the city, and it takes and drop some people in each bus stop.\n\nYou are provided with a list (or array) of integer arrays (or tuples). Each integer array has two items which represent number of people get into bus (The first item) and number of people get off the bus (The second item) in a bus stop.\n\nYour task is to return number of people who are still in the bus after the last bus station (after the last array). Even though it is the last bus stop, the bus is not empty and some people are still in the bus, and they are probably sleeping there :D \n\nTake a look on the test cases.\n\nPlease keep in mind that the test cases ensure that the number of people in the bus is always >= 0. So the return integer can't be negative.\n\nThe second value in the first integer array is 0, since the bus is empty in the first bus stop.\n-/", "vc-preamble": "def List.sum : List Int → Int\n| [] => 0\n| (x :: xs) => x + sum xs", "vc-helpers": "", "vc-definitions": "def number (stops : List (Int × Int)) : Int :=\n  sorry", "vc-theorems": "theorem bus_stops_non_negative (stops : List (Int × Int)) \n  (h : ∀ s ∈ stops, s.1 ≥ 0 ∧ s.2 ≥ 0 ∧ s.1 ≥ s.2) : \n  number stops ≥ 0 :=\n  sorry\n\ntheorem zero_passengers (stops : List (Int × Int))\n  (h : ∀ s ∈ stops, s.1 = 0 ∧ s.2 = 0) :\n  number stops = 0 :=\n  sorry\n\ntheorem sum_equals_difference (stops : List (Int × Int))\n  (h : ∀ s ∈ stops, s.1 ≥ 0 ∧ s.2 ≥ 0 ∧ s.1 ≥ s.2) :\n  number stops = List.sum (stops.map (fun s => s.1 - s.2)) :=\n  sorry\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval number [[10, 0], [3, 5], [5, 8]]\n\n/-\ninfo: 17\n-/\n-- #guard_msgs in\n-- #eval number [[3, 0], [9, 1], [4, 10], [12, 2], [6, 1], [7, 10]]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval number [[0, 0]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3005", "language": "lean", "source": "fvapps", "source-id": "fvapps_003005", "source-notes": "", "vc-description": "/-\nCompare two strings by comparing the sum of their values (ASCII character code).\n\n* For comparing treat all letters as UpperCase\n* `null/NULL/Nil/None` should be treated as empty strings\n* If the string contains other characters than letters, treat the whole string as it would be empty\n\nYour method should return `true`, if the strings are equal and `false` if they are not equal.\n\n## Examples:\n```\n\"AD\", \"BC\"  -> equal\n\"AD\", \"DD\"  -> not equal\n\"gf\", \"FG\"  -> equal\n\"zz1\", \"\"   -> equal (both are considered empty)\n\"ZzZz\", \"ffPFF\" -> equal\n\"kl\", \"lz\"  -> not equal\nnull, \"\"    -> equal\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def compare (s1 s2 : String) : Bool := sorry\n\n/-\nThe comparison of strings is case-insensitive.\nIn other words, comparing lowercase versions equals comparing uppercase versions.\n-/", "vc-theorems": "theorem compare_case_insensitive (s1 s2 : String) : \n  MyCompare.compare s1.toLower s2.toLower = MyCompare.compare s1.toUpper s2.toUpper := sorry\n\n/-\nThe comparison is reflexive: a string equals itself.\n-/\n\ntheorem compare_reflexive (s : String) :\n  MyCompare.compare s s = true := sorry\n\n/-\nThe comparison is symmetric: order of comparison doesn't matter.\n-/\n\ntheorem compare_symmetric (s1 s2 : String) :\n  MyCompare.compare s1 s2 = MyCompare.compare s2 s1 := sorry\n\n/-\nInvalid inputs compared with valid strings return false, but equal invalid inputs return true.\n-/\n\ntheorem compare_invalid_input (s : String) (h : ¬s.all Char.isAlpha) :\n  MyCompare.compare s \"abc\" = false ∧ \n  MyCompare.compare \"abc\" s = false ∧ \n  MyCompare.compare s s = true := sorry\n\nend MyCompare\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval compare \"AD\" \"BC\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval compare \"AD\" \"DD\"\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval compare \"gf\" \"FG\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3011", "language": "lean", "source": "fvapps", "source-id": "fvapps_003011", "source-notes": "", "vc-description": "/-\nPirates have notorious difficulty with enunciating. They tend to blur all the letters together and scream at people.\n\nAt long last, we need a way to unscramble what these pirates are saying.\n\nWrite a function that will accept a jumble of letters as well as a dictionary, and output a list of words that the pirate might have meant.\n\nFor example:\n```\ngrabscrab( \"ortsp\", [\"sport\", \"parrot\", \"ports\", \"matey\"] )\n```\n\nShould return `[\"sport\", \"ports\"]`.\n\nReturn matches in the same order as in the dictionary. Return an empty array if there are no matches.\n\nGood luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isAnagram (s1 s2 : String) : Bool := sorry\n\ndef grabscrab (said : String) (possibleWords : List String) : List String := sorry", "vc-theorems": "theorem grabscrab_words_in_list (said : String) (possibleWords : List String) :\n  ∀ w ∈ grabscrab said possibleWords, w ∈ possibleWords := sorry\n\ntheorem grabscrab_words_are_anagrams (said : String) (possibleWords : List String) :\n  ∀ w ∈ grabscrab said possibleWords, isAnagram w said = true := sorry\n\ntheorem grabscrab_contains_all_anagrams (said : String) (possibleWords : List String) :\n  ∀ w ∈ possibleWords, isAnagram w said = true → w ∈ grabscrab said possibleWords := sorry\n\ntheorem grabscrab_preserves_order (said : String) (possibleWords : List String) :\n  ∀ (i j : Nat), i < j →\n    let result := grabscrab said possibleWords\n    ∀ (wi wj : String), \n      wi ∈ result → wj ∈ result →\n      List.indexOf wi possibleWords < List.indexOf wj possibleWords → \n      List.indexOf wi result < List.indexOf wj result := sorry\n\ntheorem grabscrab_empty_list (said : String) :\n  grabscrab said [] = [] := sorry\n\ntheorem grabscrab_result_unique (said : String) (possibleWords : List String) :\n  let result := grabscrab said possibleWords\n  result.length = (result.eraseDups).length := sorry\n\n/-\ninfo: ['first']\n-/\n-- #guard_msgs in\n-- #eval grabscrab \"trisf\" [\"first\"]\n\n/-\ninfo: ['sport', 'ports']\n-/\n-- #guard_msgs in\n-- #eval grabscrab \"ortsp\" [\"sport\", \"parrot\", \"ports\", \"matey\"]\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval grabscrab \"ourf\" [\"one\", \"two\", \"three\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3038", "language": "lean", "source": "fvapps", "source-id": "fvapps_003038", "source-notes": "", "vc-description": "/-\nIn Spanish, the conjugated verb changes by adding suffixes and according to the person we're talking about. There's something similar in English when we talk about \"She\", \"He\"or \"It\" (3rd person singular):\n\nWith the verb \"run\":\n\n**He / She / It runS**\n\nAs you can see, the rule (at least with regular verbs) is to add the suffix  \"-s\" in the 3rd person singular. In Spanish it works the same way but we need to remove the **infinitive suffix** and add a specific suffix to all the others persons (I, You, He/She/It, We, You, They).\n\nVerbs in Spanish and the infinitive suffix.\n--\n\nIn Spanish we assume a verb is on its infitive form when it has one of the infinitives suffixes (**AR**, **ER** or **IR**) at the end:\n\n- Com**er** -> to eat\n\n- Camin**ar** -> to walk\n\n- Viv**ir** -> to live\n\n## How to conjugate\n\nFor conjugating in Spanish, we need to remove the infinitive suffix (**ar**, **er** *or* **ir**) and add the personal suffixes corresponding to the person we're talking to. In this kata we'll conjugate the verbs to its **presente indicativo** (simple present) form.\n\nPersonal suffixes\n--\nThe personal suffixes changes depending of the **Infinitive suffix**.\n\nIf the infinitive suffix is **AR** the personal suffixes are:\n\n- first person singular (Yo / I): -**o**\n- second person singular (Tú / You): -**as**\n- third person singular (Él, Ella / He, She): -**a**\n- first person plural (Nosotros / We): -**amos**\n- second person plural (Vosotros / You): -**áis**\n- third person plural (Ellos / They): -**an**\n\nIf the infinitive suffix is **ER**:\n- first person singular (Yo / I): -**o**\n- second person singular (Tú / You): -**es**\n- third person singular (Él, Ella / He, She): -**e**\n- first person plural (Nosotros / We): -**emos**\n- second person plural (Vosotros / You): -**éis**\n- third person plural (Ellos / They): -**en**\n\nIf the infinitive suffix is **IR**:\n- first person singular (Yo / I): -**o**\n- second person singular (Tú / You): -**es**\n- third person singular (Él, Ella / He, She): -**e**\n- first person plural (Nosotros / We): -**imos**\n- second person plural (Vosotros / You): -**ís**\n- third person plural (Ellos / They): -**en**\n\n## Conjugating \nSteps for conjugating:\n1. Remove the infinitive suffix (ar, er, ir)\n2. And add the personal suffixes\n- Example: verb **Caminar** (to walk)\n  - Camin**o** (I walk)\n  - Camin**as** (You walk)\n  - Camin**a** (He walks)\n  - Camin**amos** (We walk)\n  - Camin**áis** (You guys walk)\n  - Camin**an** (They walk)\n- Example: verb **Comer** (to eat):\n  - Com**o** (I eat)\n  - Com**es** (You eat)\n  - Com**e** (He, She eats)\n  - Com**emos** (We eat)\n  - Com**éis** (You guys eat)\n  - Com**en** (They eat)\n- Example: verb **Vivir** (to live):\n  - Viv**o** (I live)\n  - Viv**es** (You live)\n  - Viv**e** (He, She lives)\n  - Viv**imos** (We live)\n  - Viv**ís** (You guys live)\n  - Viv**en** (They live)\n\n## Your Task\n\nYou need to write a function called **conjugate** which will return an object with a spanish verb conjugated. The object must look like this:\n\n```\n{\n  \"comer\": [\n    \"como\",\n    \"comes\",\n    \"come\",\n    \"comemos\",\n    \"coméis\",\n    \"comen\"\n  ]\n}\n\n```\n\nWhere the key is the verb in its original form (infinitive form) and its value will be an array with the conjugations.\n\nAnother example:\n```\n{\n  \"vivir\": [\n    \"vivo\",\n    \"vives\",\n    \"vive\",\n    \"vivimos\",\n    \"vivís\",\n    \"viven\"\n  ]\n}\n\n```\n\n## Notes:\n1. The conjugations must be in this order:\n```\n{\n    verb: [\n      \"first person singular\",\n      \"second person singular\",\n      \"third person singular\",\n      \"first person plural\",\n      \"second person plural\",\n      \"third person plural\"\n    ]\n}\n```\n2.Don't use `JSON.stringify(obj, null, 2)` because the \"presentation\" of the object isn't important.\n\n3.Don't use accents in Python version\n\n **Buena suerte!**\n---\n-/", "vc-preamble": "def conjugate (verb : String) : String × Conjugations :=\n  sorry", "vc-helpers": "", "vc-definitions": "def SUFFIXES : Char × List String :=\n  sorry\n\n-- Properties:", "vc-theorems": "theorem conjugate_returns_single_entry (verb : String) \n  (h : ∃ stem suffix, verb = stem ++ suffix ∧ String.length suffix = 2) :\n  let (key, result) := conjugate verb\n  key = verb := sorry\n\ntheorem conjugate_returns_six_forms (verb : String)\n  (h : ∃ stem suffix, verb = stem ++ suffix ∧ String.length suffix = 2) :\n  let (_, result) := conjugate verb\n  List.length result.forms = 6 := sorry\n\ntheorem conjugations_use_stem (verb : String)\n  (h : ∃ stem suffix, verb = stem ++ suffix ∧ String.length suffix = 2) :\n  let stem := String.dropRight verb 2\n  let (_, result) := conjugate verb\n  ∀ conj ∈ result.forms, String.isPrefixOf stem conj := sorry\n\ntheorem conjugations_match_suffixes (verb : String)\n  (h : ∃ stem suffix, verb = stem ++ suffix ∧ String.length suffix = 2) :\n  let stem := String.dropRight verb 2\n  let (_, result) := conjugate verb\n  let suffixes := List.map (fun conj => String.drop conj (String.length stem)) result.forms \n  suffixes = SUFFIXES.2 := sorry\n\ntheorem suffix_patterns_properties (ending : Char) \n  (h : ending = 'a' ∨ ending = 'e' ∨ ending = 'i') :\n  List.length SUFFIXES.2 = 6 ∧ \n  String.endsWith (List.getLast SUFFIXES.2 sorry) \"n\" := sorry\n\n/-\ninfo: {'caminar': ['camino', 'caminas', 'camina', 'caminamos', 'caminais', 'caminan']}\n-/\n-- #guard_msgs in\n-- #eval conjugate \"caminar\"\n\n/-\ninfo: {'comer': ['como', 'comes', 'come', 'comemos', 'comeis', 'comen']}\n-/\n-- #guard_msgs in\n-- #eval conjugate \"comer\"\n\n/-\ninfo: {'vivir': ['vivo', 'vives', 'vive', 'vivimos', 'vivis', 'viven']}\n-/\n-- #guard_msgs in\n-- #eval conjugate \"vivir\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3044", "language": "lean", "source": "fvapps", "source-id": "fvapps_003044", "source-notes": "", "vc-description": "/-\nImplement `String#parse_mana_cost`, which parses [Magic: the Gathering mana costs](http://mtgsalvation.gamepedia.com/Mana_cost) expressed as a string and returns a `Hash` with keys being kinds of mana, and values being the numbers.\n\nDon't include any mana types equal to zero.\n\nFormat is:\n\n* optionally natural number representing total amount of generic mana (use key `*`)\n* optionally followed by any combination of `w`, `u`, `b`, `r`, `g` (case insensitive in input, return lower case in output), each representing one mana of specific color.\n\nIf case of Strings not following specified format, return `nil/null/None`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ManaMap.empty : ManaMap := ⟨0,0,0,0,0,0⟩\n\ndef parse_mana_cost (s : String) : Option ManaMap := sorry", "vc-theorems": "theorem parse_mana_cost_valid_keys (s : String) (result : ManaMap) :\n  parse_mana_cost s = some result →\n  result.white ≥ 0 ∧ result.blue ≥ 0 ∧ result.black ≥ 0 ∧ \n  result.red ≥ 0 ∧ result.green ≥ 0 ∧ result.generic ≥ 0 := sorry\n\ntheorem parse_mana_cost_positive_values (s : String) (result : ManaMap) : \n  parse_mana_cost s = some result →\n  (result.white > 0 → result.white > 0) ∧\n  (result.blue > 0 → result.blue > 0) ∧\n  (result.black > 0 → result.black > 0) ∧\n  (result.red > 0 → result.red > 0) ∧\n  (result.green > 0 → result.green > 0) ∧\n  (result.generic > 0 → result.generic > 0) := sorry\n\ntheorem parse_mana_cost_length (s : String) (result : ManaMap) :\n  parse_mana_cost s = some result →\n  result.white + result.blue + result.black + result.red + result.green +\n  (if result.generic > 0 then toString result.generic |>.length else 0) = s.length := sorry\n\ntheorem parse_mana_cost_invalid (s : String) :\n  (∃ c ∈ s.data, ¬(c.toLower ∈ ['w', 'u', 'b', 'r', 'g'] ∨ c.isDigit)) →\n  parse_mana_cost s = none := sorry\n\ntheorem parse_mana_cost_constructed (generic : Nat) (colors : List Char) :\n  let mana := (if generic > 0 then toString generic else \"\") ++ String.mk colors\n  let result := parse_mana_cost mana\n  match result with\n  | some m => \n    (generic > 0 → m.generic = generic) ∧\n    (colors.countP (· = 'w') > 0 → m.white = colors.countP (· = 'w')) ∧\n    (colors.countP (· = 'u') > 0 → m.blue = colors.countP (· = 'u')) ∧\n    (colors.countP (· = 'b') > 0 → m.black = colors.countP (· = 'b')) ∧\n    (colors.countP (· = 'r') > 0 → m.red = colors.countP (· = 'r')) ∧\n    (colors.countP (· = 'g') > 0 → m.green = colors.countP (· = 'g'))\n  | none => True := sorry\n\n/-\ninfo: {'*': 2, 'r': 2}\n-/\n-- #guard_msgs in\n-- #eval parse_mana_cost \"2rr\"\n\n/-\ninfo: {'*': 1, 'w': 2, 'u': 1}\n-/\n-- #guard_msgs in\n-- #eval parse_mana_cost \"1wwu\"\n\n/-\ninfo: {'w': 1, 'u': 1, 'b': 1, 'r': 1, 'g': 1}\n-/\n-- #guard_msgs in\n-- #eval parse_mana_cost \"wubrg\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3049", "language": "lean", "source": "fvapps", "source-id": "fvapps_003049", "source-notes": "", "vc-description": "/-\nThere is a queue for the self-checkout tills at the supermarket. Your task is write a function to calculate the total time required for all the customers to check out!\n\n### input\n```if-not:c\n* customers: an array of positive integers representing the queue. Each integer represents a customer, and its value is the amount of time they require to check out.\n* n: a positive integer, the number of checkout tills.\n```\n```if:c\n* customers: a pointer to an array of positive integers representing the queue. Each integer represents a customer, and its value is the amount of time they require to check out.\n* customers_length: the length of the array that `customers` points to.\n* n: a positive integer, the number of checkout tills.\n```\n\n### output\nThe function should return an integer, the total time required.\n\n-------------------------------------------\n\n## Important\n**Please look at the examples and clarifications below, to ensure you understand the task correctly :)**\n\n-------\n\n### Examples\n\n```python\nqueue_time([5,3,4], 1)\n# should return 12\n# because when n=1, the total time is just the sum of the times\n\nqueue_time([10,2,3,3], 2)\n# should return 10\n# because here n=2 and the 2nd, 3rd, and 4th people in the \n# queue finish before the 1st person has finished.\n\nqueue_time([2,3,10], 2)\n# should return 12\n```\n\n### Clarifications\n\n * There is only ONE queue serving many tills, and\n * The order of the queue NEVER changes, and\n * The front person in the queue (i.e. the first element in the array/list) proceeds to a till as soon as it becomes free.\n\nN.B. You should assume that all the test input will be valid, as specified above.\n\nP.S. The situation in this kata can be likened to the more-computer-science-related idea of a thread pool, with relation to running multiple processes at the same time: https://en.wikipedia.org/wiki/Thread_pool\n-/", "vc-preamble": "def List.maximum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => List.foldl Nat.max h t\n\ndef List.sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => h + List.sum t", "vc-helpers": "", "vc-definitions": "def queue_time (customers : List Nat) (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem queue_time_non_negative (customers : List Nat) (n : Nat) (h : n > 0) :\n  queue_time customers n ≥ 0 :=\n  sorry \n\ntheorem queue_time_empty_list (n : Nat) (h : n > 0) :\n  queue_time [] n = 0 :=\n  sorry\n\ntheorem queue_time_monotonic (customers : List Nat) (n : Nat) (h : n > 0) :\n  queue_time customers (n + 1) ≤ queue_time customers n :=\n  sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval queue_time [] 1\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval queue_time [2] 5\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval queue_time [2, 2, 3, 3, 4, 4] 2", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3058", "language": "lean", "source": "fvapps", "source-id": "fvapps_003058", "source-notes": "", "vc-description": "/-\nYou will have a list of rationals in the form\n\n```\nlst = [ [numer_1, denom_1] , ... , [numer_n, denom_n] ]\n```\nor\n```\nlst = [ (numer_1, denom_1) , ... , (numer_n, denom_n) ]\n```\n\nwhere all numbers are positive integers. You have to produce their sum `N / D` in an irreducible form: this means that `N` and `D` have only `1` as a common divisor.\n\nReturn the result in the form:\n\n- `[N, D]` in Ruby, Crystal, Python, Clojure, JS, CS, PHP, Julia\n- `Just \"N D\"` in Haskell, PureScript\n- `\"[N, D]\"` in Java, CSharp, TS, Scala, PowerShell, Kotlin\n- `\"N/D\"` in Go, Nim\n- `{N, D}` in C++, Elixir\n- `{N, D}` in C\n- `Some((N, D))` in Rust\n- `Some \"N D\"` in F#, Ocaml\n- `c(N, D)` in R\n- `(N, D)` in Swift\n- `'(N D)` in Racket\n\nIf the result is an integer (`D` evenly divides `N`) return:\n\n- an integer in Ruby, Crystal, Elixir, Clojure, Python, JS, CS, PHP, R, Julia\n- `Just \"n\"` (Haskell, PureScript)\n- `\"n\"` Java, CSharp, TS, Scala, PowerShell, Go, Nim, Kotlin\n- `{n, 1}` in C++\n- `{n, 1}` in C\n- `Some((n, 1))` in Rust\n- `Some \"n\"` in F#, Ocaml,\n- `(n, 1)` in Swift\n- `n` in Racket \n\nIf the input list is empty, return \n\n- `nil/None/null/Nothing` \n- `{0, 1}` in C++\n- `{0, 1}` in C\n- `\"0\"` in Scala, PowerShell, Go, Nim\n- `O` in Racket\n- `\"\"` in Kotlin\n\n### Example:\n\n```\n[ [1, 2], [1, 3], [1, 4] ]  -->  [13, 12]\n\n    1/2  +  1/3  +  1/4     =      13/12\n```\n\n### Note\nSee sample tests for more examples and the form of results.\n-/", "vc-preamble": "def sumFracts (lst : List (Int × Nat)) : Option (Int ⊕ (Int × Nat)) := sorry\n\ntheorem sum_fracts_empty : \n  sumFracts [] = none := sorry", "vc-helpers": "", "vc-definitions": "def addFractions (f1 f2 : Fraction) : Fraction := sorry\n\ntheorem sum_fracts_preserves_value (lst : List (Int × Nat)) (h : ∀ p : Int × Nat, p ∈ lst → p.2 > 0) :\n  match sumFracts lst with\n  | none => lst = []\n  | some (Sum.inl n) => Fraction.mk n 1 = lst.foldr (fun p acc => addFractions acc (Fraction.mk p.1 p.2)) (Fraction.mk 0 1)\n  | some (Sum.inr (n,d)) => Fraction.mk n d = lst.foldr (fun p acc => addFractions acc (Fraction.mk p.1 p.2)) (Fraction.mk 0 1)\n  := sorry", "vc-theorems": "theorem sum_fracts_single (n : Int) (d : Nat) (h : d > 0) :\n  sumFracts [(n,d)] = if d = 1 \n    then some (Sum.inl n)\n    else some (Sum.inr (n,d)) := sorry\n\ntheorem sum_fracts_result_form (lst : List (Int × Nat)) (h : ∀ p : Int × Nat, p ∈ lst → p.2 > 0) :\n  match lst with\n  | [] => sumFracts lst = none\n  | _ => ∃ n d, (sumFracts lst = some (Sum.inl n) ∧ d = 1) ∨ \n                (sumFracts lst = some (Sum.inr (n,d)) ∧ d > 1)\n  := sorry\n\n/-\ninfo: [13, 12]\n-/\n-- #guard_msgs in\n-- #eval sum_fracts [[1, 2], [1, 3], [1, 4]]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval sum_fracts [[1, 3], [5, 3]]\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval sum_fracts []", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3076", "language": "lean", "source": "fvapps", "source-id": "fvapps_003076", "source-notes": "", "vc-description": "/-\n```if-not:sql\nCreate a function (or write a script in Shell) that takes an integer as an argument and returns \"Even\" for even numbers or \"Odd\" for odd numbers.\n```\n\n```if:sql\n## SQL Notes:\nYou will be given a table, `numbers`, with one column `number`.\n\nReturn a table with a column `is_even` containing \"Even\" or \"Odd\" depending on `number` column values.\n\n### numbers table schema\n* number INT\n\n### output table schema\n* is_even STRING\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def even_or_odd (n : Int) : EvenOdd := sorry\n\ntheorem even_or_odd_valid (x : Int) : \n  even_or_odd x = (if x % 2 = 0 then EvenOdd.Even else EvenOdd.Odd) := sorry", "vc-theorems": "theorem even_or_odd_consistent_add2 (x : Int) :\n  even_or_odd x = even_or_odd (x + 2) := sorry \n\ntheorem even_or_odd_alternates (x : Int) :\n  even_or_odd x ≠ even_or_odd (x + 1) := sorry\n\ntheorem even_or_odd_negation (x : Int) :\n  even_or_odd x = even_or_odd (-x) := sorry\n\n/-\ninfo: 'Even'\n-/\n-- #guard_msgs in\n-- #eval even_or_odd 2\n\n/-\ninfo: 'Odd'\n-/\n-- #guard_msgs in\n-- #eval even_or_odd 1\n\n/-\ninfo: 'Even'\n-/\n-- #guard_msgs in\n-- #eval even_or_odd 0\n\n/-\ninfo: 'Even'\n-/\n-- #guard_msgs in\n-- #eval even_or_odd 1545452\n\n/-\ninfo: 'Odd'\n-/\n-- #guard_msgs in\n-- #eval even_or_odd 74156741\n\n/-\ninfo: 'Odd'\n-/\n-- #guard_msgs in\n-- #eval even_or_odd -123\n\n/-\ninfo: 'Even'\n-/\n-- #guard_msgs in\n-- #eval even_or_odd -456", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3078", "language": "lean", "source": "fvapps", "source-id": "fvapps_003078", "source-notes": "", "vc-description": "/-\n# Task\n Four men, `a, b, c and d` are standing in a line, one behind another. \n\n There's a wall between the first three people (a, b and c) and the last one (d).\n\n a, b and c are lined up in order of height, so that person a can see the backs of b and c, person b can see the back of c, and c can see just the wall.\n\n There are 4 hats, 2 black and 2 white. Each person is given a hat. None of them can see their own hat, but person a can see the hats of b and c, while person b can see the hat of person c. Neither c nor d can see any hats.\n\n Once a person figures out their hat's color, they shouts it. \n\n ![](http://stuffbox.in/wp-content/uploads/2016/08/Guess-hat-colour-604x270.png)\n\n Your task is to return the person who will guess their hat first. You can assume that they will speak only when they reach a correct conclusion.\n\n# Input/Output\n\n - `[input]` string `a`\n\n  a's hat color (\"white\" or \"black\").\n\n - `[input]` string `b`\n\n  b's hat color (\"white\" or \"black\").\n\n - `[input]` string `c`\n\n  c's hat color (\"white\" or \"black\").\n\n - `[input]` string `d`\n\n  d's hat color (\"white\" or \"black\").\n\n - `[output]` an integer\n\n The person to guess his hat's color first, `1 for a, 2 for b, 3 for c and 4 for d`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def guess_hat_color : Color → Color → Color → Color → Nat :=\n  fun _ _ _ _ => sorry", "vc-theorems": "theorem guess_hat_result_valid {a b c d : Color} :\n  (guess_hat_color a b c d = 1) ∨ (guess_hat_color a b c d = 2) := \n  sorry\n\ntheorem guess_hat_equal_gives_one {a b c d : Color} :\n  (guess_hat_color a b c d = 1) = (b = c) :=\n  sorry \n\ntheorem guess_hat_unequal_gives_two {a b c d : Color} :\n  (guess_hat_color a b c d = 2) = (b ≠ c) :=\n  sorry\n\ntheorem guess_hat_preserves_colors (a b c d : Color) :\n  (a = Color.black ∨ a = Color.white) ∧\n  (b = Color.black ∨ b = Color.white) ∧\n  (c = Color.black ∨ c = Color.white) ∧\n  (d = Color.black ∨ d = Color.white) :=\n  sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval guess_hat_color \"white\" \"black\" \"white\" \"black\"\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval guess_hat_color \"white\" \"black\" \"black\" \"white\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3082", "language": "lean", "source": "fvapps", "source-id": "fvapps_003082", "source-notes": "", "vc-description": "/-\nIt's been a tough week at work and you are stuggling to get out of bed in the morning.\n\nWhile waiting at the bus stop you realise that if you could time your arrival to the nearest minute you could get valuable extra minutes in bed.\n\nThere is a bus that goes to your office every 15 minute, the first bus is at `06:00`, and the last bus is at `00:00`.\n\nGiven that it takes 5 minutes to walk from your front door to the bus stop, implement a function that when given the curent time will tell you much time is left, before you must leave to catch the next bus.\n\n## Examples\n\n```\n\"05:00\"  =>  55\n\"10:00\"  =>  10\n\"12:10\"  =>  0\n\"12:11\"  =>  14\n```\n\n### Notes\n\n1. Return the number of minutes till the next bus\n2. Input will be formatted as `HH:MM` (24-hour clock)\n3. The input time might be after the buses have stopped running, i.e. after `00:00`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def busTimer (t : Time) : Nat := sorry\n\ntheorem bus_timer_range_bounds (t : Time) :\n  0 ≤ busTimer t ∧ busTimer t ≤ 600 := sorry", "vc-theorems": "theorem exact_hours_normal_hours (t : Time)\n  (h : 6 ≤ t.hours ∧ t.hours < 23) (m : t.minutes = 0) :\n  busTimer t ≤ 10 := sorry\n\ntheorem normal_schedule (t : Time)\n  (h : 6 ≤ t.hours ∧ t.hours ≤ 22) :\n  busTimer t ≤ 10 := sorry\n\ntheorem early_morning_bound (t : Time)\n  (h : t.hours ≤ 5) (m : t.minutes = 30) :\n  busTimer t ≥ (5 - t.hours) * 60 - 35 := sorry\n\ntheorem specific_late_night_values (t : Time) :\n  (t.hours = 23 ∧ t.minutes = 56 → busTimer t = 359) ∧\n  (t.hours = 23 ∧ t.minutes = 59 → busTimer t = 356) := sorry\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval bus_timer \"10:00\"\n\n/-\ninfo: 45\n-/\n-- #guard_msgs in\n-- #eval bus_timer \"05:10\"\n\n/-\ninfo: 358\n-/\n-- #guard_msgs in\n-- #eval bus_timer \"23:57\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3085", "language": "lean", "source": "fvapps", "source-id": "fvapps_003085", "source-notes": "", "vc-description": "/-\nGoal\nGiven a list of elements [a1, a2, ..., an], with each ai being a string, write a function **majority** that returns the value that appears the most in the list. \n\nIf there's no winner, the function should return None, NULL, nil, etc, based on the programming language.\n\nExample\nmajority([\"A\", \"B\", \"A\"]) returns \"A\"\nmajority([\"A\", \"B\", \"B\", \"A\"]) returns None\n-/", "vc-preamble": "def count (xs : List α) (a : α) : Nat :=\n  xs.foldl (fun acc x => if x = a then acc + 1 else acc) 0", "vc-helpers": "", "vc-definitions": "def majority : List α → Option α := sorry\n\ntheorem majority_exists {arr : List α} {x : α}\n  (h : count arr x > arr.length / 2) :\n  majority arr = some x := sorry", "vc-theorems": "theorem majority_empty :\n  majority ([] : List α) = none := sorry\n\ntheorem majority_single_element {arr : List α} {x : α}\n  (h_nonempty : arr ≠ [])\n  (h_all_same : ∀ i, arr.get ⟨i, sorry⟩ = x) :\n  majority arr = some x := sorry\n\n/-\ninfo: 'A'\n-/\n-- #guard_msgs in\n-- #eval majority [\"A\", \"B\", \"A\"]\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval majority [\"A\", \"B\", \"C\"]\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval majority []", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3097", "language": "lean", "source": "fvapps", "source-id": "fvapps_003097", "source-notes": "", "vc-description": "/-\nYou are to write a function to transpose a guitar tab up or down a number of semitones. The amount to transpose is a number, positive or negative. The tab is given as an array, with six elements for each guitar string (fittingly passed as strings). Output your tab in a similar form.\n\nGuitar tablature (or 'tab') is an alternative to sheet music, where notes are replaced by fret numbers and the five lines of the staff are replaced by six lines to represent each of the guitar's strings. It is still read from left to right like sheet music, and notes written directly above each other are played at the same time.\n\nFor example, Led Zeppelin's Stairway to Heaven begins:\n```\ne|-------5-7-----7-|-8-----8-2-----2-|-0---------0-----|-----------------|\nB|-----5-----5-----|---5-------3-----|---1---1-----1---|-0-1-1-----------|\nG|---5---------5---|-----5-------2---|-----2---------2-|-0-2-2-----------|\nD|-7-------6-------|-5-------4-------|-3---------------|-----------------|\nA|-----------------|-----------------|-----------------|-2-0-0---0--/8-7-|\nE|-----------------|-----------------|-----------------|-----------------|\n```\nTransposed up two semitones, it would look like this:\n```\ne|-------7-9-----9-|-10-----10-4-----4-|-2---------2-----|------------------|\nB|-----7-----7-----|----7--------5-----|---3---3-----3---|-2-3-3------------|\nG|---7---------7---|------7--------4---|-----4---------4-|-2-4-4------------|\nD|-9-------8-------|-7---------6-------|-5---------------|------------------|\nA|-----------------|-------------------|-----------------|-4-2-2---2--/10-9-|\nE|-----------------|-------------------|-----------------|------------------|\n```\nNote how when the 8th fret note on the top string in bar 2 gets transposed to the 10th fret, extra '-' are added on the other strings below so as to retain the single '-' that originally separated that beat (i.e. column) from the following note – fret 7 on the B string.\n\nEach beat must retain at least one '-' separator before the next, to keep the tab legible. The inputted test tabs all obey this convention.\n\nElectric guitars usually have 22 frets, with the 0th fret being an open string. If your fret numbers transpose to either negative values or values over 22, you should return 'Out of frets!' (and probably detune your guitar).\n\nTests include some randomly generated guitar tabs, which come with no guarantee of musical quality and/or playability...!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def transpose (amount : Int) (tab : List String) : List String := sorry\n\ndef Nat.toString (n : Nat) : String := sorry", "vc-theorems": "theorem transpose_basic_format \n  (tab : List String)\n  (amount : Int)\n  (h1 : -5 ≤ amount)\n  (h2 : amount ≤ 5) :\n  let result := transpose amount tab\n  if result ≠ [\"Out of frets!\"] then\n    (∀ r ∈ result, \n      r.length > 0 ∧ \n      ((r.data.get? 0).isSome ∧\n       ((r.data.get? 0).getD '_' = 'e' ∨ \n        (r.data.get? 0).getD '_' = 'E' ∨\n        (r.data.get? 0).getD '_' = 'B' ∨\n        (r.data.get? 0).getD '_' = 'G' ∨\n        (r.data.get? 0).getD '_' = 'D' ∨\n        (r.data.get? 0).getD '_' = 'A')) ∧\n      (r.data.get? 1).isSome ∧\n      (r.data.get? 1).getD '_' = '|') ∧\n    result.length = 6 ∧\n    (∀ line ∈ result,\n      ∀ n : Nat,\n      (n ≥ 0 ∧ n ≤ 22))\n  else True :=\nsorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval transpose 2 [\"e|-------5-7-----7-|-8-----8-2-----2-|-0---------0-----|-----------------|\", \"B|-----5-----5-----|---5-------3-----|---1---1-----1---|-0-1-1-----------|\", \"G|---5---------5---|-----5-------2---|-----2---------2-|-0-2-2-----------|\", \"D|-7-------6-------|-5-------4-------|-3---------------|-----------------|\", \"A|-----------------|-----------------|-----------------|-2-0-0---0--/8-7-|\", \"E|-----------------|-----------------|-----------------|-----------------|\"]\n\n/-\ninfo: 'Out of frets!'\n-/\n-- #guard_msgs in\n-- #eval transpose -1 [\"e|-----------------|---------------|----------------|------------------|\", \"B|-----------------|---------------|----------------|------------------|\", \"G|--0---3---5----0-|---3---6-5-----|-0---3---5----3-|---0----(0)-------|\", \"D|--0---3---5----0-|---3---6-5-----|-0---3---5----3-|---0----(0)-------|\", \"A|-----------------|---------------|----------------|------------------|\", \"E|-----------------|---------------|----------------|------------------|\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3102", "language": "lean", "source": "fvapps", "source-id": "fvapps_003102", "source-notes": "", "vc-description": "/-\nIn this Kata, you will be given a series of times at which an alarm goes off. Your task will be to determine the maximum time interval between alarms. Each alarm starts ringing at the beginning of the corresponding minute and rings for exactly one minute. The times in the array are not in chronological order. Ignore duplicate times, if any.\n\n```Haskell\nFor example:\nsolve([\"14:51\"]) = \"23:59\". If the alarm goes off now, it will not go off for another 23 hours and 59 minutes.\nsolve([\"23:00\",\"04:22\",\"18:05\",\"06:24\"]) == \"11:40\". The max interval that the alarm will not go off is 11 hours and 40 minutes.\n```\nIn the second example, the alarm goes off `4` times in a day.\n\nMore examples in test cases. Good luck!\n-/", "vc-preamble": "def Time.toString (t : Time) : String := sorry\n\ndef parseTime (s : String) : Option Time := sorry", "vc-helpers": "", "vc-definitions": "def solve (times : List String) : String := sorry\n\ndef toMinutes (t : Time) : Nat :=\n  t.hour * 60 + t.minute", "vc-theorems": "theorem solve_valid_format (times : List String) :\n  let result := solve times\n  let hrs := result.take 2\n  let mins := result.drop 3\n  result.length = 5 ∧ \n  result.data.get? 2 = some ':' ∧\n  (parseTime result).isSome := sorry\n\ntheorem solve_under_24h (times : List String) :\n  let result := solve times\n  let t := Option.get! (parseTime result)\n  toMinutes t < 24 * 60 := sorry\n\ntheorem solve_single_time (t : Time) :\n  solve [t.toString] = \"23:59\" := sorry\n\ntheorem solve_unique_times (times : List String) :\n  solve times = solve (times ++ times) := sorry\n\n/-\ninfo: '23:59'\n-/\n-- #guard_msgs in\n-- #eval solve [\"14:51\"]\n\n/-\ninfo: '11:40'\n-/\n-- #guard_msgs in\n-- #eval solve [\"23:00\", \"04:22\", \"18:05\", \"06:24\"]\n\n/-\ninfo: '09:10'\n-/\n-- #guard_msgs in\n-- #eval solve [\"21:14\", \"15:34\", \"14:51\", \"06:25\", \"15:30\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3108", "language": "lean", "source": "fvapps", "source-id": "fvapps_003108", "source-notes": "", "vc-description": "/-\nYou are the best freelancer in the city. Everybody knows you, but what they don't know, is that you are actually offloading your work to other freelancers and and you rarely need to do any work. You're living the life!\n\nTo make this process easier you need to write a method called workNeeded to figure out how much time you need to contribute to a project. \n\nGiving the amount of time in `minutes` needed to complete the project and an array of pair values representing other freelancers' time in `[Hours, Minutes]` format ie. `[[2, 33], [3, 44]]` calculate how much time **you** will need to contribute to the project (if at all) and return a string depending on the case.\n\n* If we need to contribute time to the project then return `\"I need to work x hour(s) and y minute(s)\"`\n* If we don't have to contribute any time to the project then return `\"Easy Money!\"`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def work_needed (project_minutes : Nat) (freelancers : List Time) : String :=\n  sorry", "vc-theorems": "theorem work_needed_output_valid (project_minutes : Nat) (freelancers : List Time) :\n  let result := work_needed project_minutes freelancers\n  (result = \"Easy Money!\" ∨ result.startsWith \"I need to work\") :=\n  sorry\n\ntheorem work_needed_enough_help (project_minutes : Nat) (freelancers : List Time) :\n  let total_available := freelancers.foldl (fun acc t => acc + t.hours * 60 + t.minutes) 0\n  total_available ≥ project_minutes → \n  work_needed project_minutes freelancers = \"Easy Money!\" :=\n  sorry\n\ntheorem work_needed_not_enough_help (project_minutes : Nat) (freelancers : List Time) :\n  let total_available := freelancers.foldl (fun acc t => acc + t.hours * 60 + t.minutes) 0\n  let deficit := project_minutes - total_available\n  let deficit_hours := deficit / 60\n  let deficit_minutes := deficit % 60\n  total_available < project_minutes →\n  work_needed project_minutes freelancers = s!\"I need to work {deficit_hours} hour(s) and {deficit_minutes} minute(s)\" :=\n  sorry\n\ntheorem work_needed_zero_project (freelancers : List Time) :\n  work_needed 0 freelancers = \"Easy Money!\" :=\n  sorry\n\ntheorem work_needed_no_freelancers (project_minutes : Nat) :\n  let hours := project_minutes / 60\n  let minutes := project_minutes % 60\n  work_needed project_minutes [] = s!\"I need to work {hours} hour(s) and {minutes} minute(s)\" :=\n  sorry\n\n/-\ninfo: 'Easy Money!'\n-/\n-- #guard_msgs in\n-- #eval work_needed 60 [[1, 0]]\n\n/-\ninfo: 'I need to work 1 hour(s) and 0 minute(s)'\n-/\n-- #guard_msgs in\n-- #eval work_needed 60 [[0, 0]]\n\n/-\ninfo: 'I need to work 1 hour(s) and 0 minute(s)'\n-/\n-- #guard_msgs in\n-- #eval work_needed 90 [[0, 30]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3130", "language": "lean", "source": "fvapps", "source-id": "fvapps_003130", "source-notes": "", "vc-description": "/-\nGiven a string, turn each letter into its ASCII character code and join them together to create a number - let's call this number `total1`:\n\n```\n'ABC' --> 'A' = 65, 'B' = 66, 'C' = 67 --> 656667\n```\n\nThen replace any incidence of the number `7` with the number `1`, and call this number 'total2':\n```\ntotal1 = 656667\n              ^\ntotal2 = 656661\n              ^\n```\n\nThen return the difference between the sum of the digits in `total1` and `total2`:\n\n```\n  (6 + 5 + 6 + 6 + 6 + 7)\n- (6 + 5 + 6 + 6 + 6 + 1)\n-------------------------\n                       6\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calc' (s : String) : Nat :=\nmatch s with\n| _ => sorry", "vc-theorems": "theorem calc_non_negative (s : String) : \n  calc' s ≥ 0 := by\n  sorry\n\ntheorem calc_empty_string :\n  calc' \"\" = 0 := by\n  sorry \n\ntheorem calc_is_sum_of_seven_differences (s : String) :\n  calc' s = ((String.join (List.map toString (List.map Char.toNat (String.toList s)))).toList.filter (· = '7')).length * 6 := by\n  sorry\n\ntheorem calc_bounded_by_string_length (s : String) (h : s ≠ \"\") :\n  calc' s ≤ (String.join (List.map toString (List.map Char.toNat (String.toList s)))).length * 6 := by\n  sorry\n\nend Example\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval calc \"ABC\"\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval calc \"jaam\"\n\n/-\ninfo: 30\n-/\n-- #guard_msgs in\n-- #eval calc \"aaaaaddddr\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3140", "language": "lean", "source": "fvapps", "source-id": "fvapps_003140", "source-notes": "", "vc-description": "/-\nGiven a mixed array of number and string representations of integers, add up the string integers and subtract this from the total of the non-string integers. \n\nReturn as a number.\n-/", "vc-preamble": "def List.sum (l : List Int) : Int := \n  l.foldl (· + ·) 0\n\ndef div_con (lst : List Item) : Int := sorry\n\ndef string_is_numeric (s : String) : Bool := sorry", "vc-helpers": "", "vc-definitions": "def string_to_int (s : String) : Int := sorry\n\ntheorem div_con_main_property (lst : List Item)\n  (h : ∀ s, s ∈ lst → match s with | Item.Str s => string_is_numeric s | _ => true) :\n  div_con lst = \n    (lst.filterMap (fun x => match x with\n      | Item.Int n => some n\n      | _ => none)).sum -\n    (lst.filterMap (fun x => match x with\n      | Item.Str s => if string_is_numeric s then some (string_to_int s) else none\n      | _ => none)).sum := sorry", "vc-theorems": "theorem div_con_all_ints (lst : List Int) :\n  div_con (lst.map Item.Int) = lst.sum := sorry\n\ntheorem div_con_all_strings (lst : List String)\n  (h : ∀ s, s ∈ lst → string_is_numeric s) :\n  div_con (lst.map Item.Str) = -(lst.map string_to_int).sum := sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval div_con [9, 3, \"7\", \"3\"]\n\n/-\ninfo: 14\n-/\n-- #guard_msgs in\n-- #eval div_con [\"5\", \"0\", 9, 3, 2, 1, \"9\", 6, 7]\n\n/-\ninfo: 13\n-/\n-- #guard_msgs in\n-- #eval div_con [\"3\", 6, 6, 0, \"5\", 8, 5, \"6\", 2, \"0\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3142", "language": "lean", "source": "fvapps", "source-id": "fvapps_003142", "source-notes": "", "vc-description": "/-\n## TL;DR\n\nGiven a number of vertices `N` and a list of weighted directed edges in a directed acyclic graph (each edge is written as `[start, end, weight]` where `from < to`), compute the weight of the shortest path from vertex `0` to vertex `N - 1`.  If there is no such path, return `-1`.\n\n## Background\n\nA weighted DAG is a directed acyclic graph where each edge has a weight associated with it:\n\n1\n5\n3\n1\n5\n\nA\nB\nC\nD\n\nIn this example, the shortest path from A to D is given by A -> B -> D, which has a total weight of 4.\n\nFinding shortest distances in DAGs is made easier by the fact that the nodes can be _linearized:_ they can be given an order `A1, A2, ..., An` such that edges only point forward (that is, there are no edges from `Aj` to `Ai` when `j > i`).  In the example above, the two possible linear orderings are `A, B, C, D` and `A, C, B, D.`\n\n1\n\n1\n5\n5\n3\n\nA\nB\nC\nD\n\n## Your Task\n\nGiven a number `N` (indicating a graph with vertices `0, 1, ..., N-1`) and a list of weighted edges `[start, end, weight]` for a DAG, where `start < end` for each edge, find the weight (a.k.a. length) of the shortest path from node `0` to node `N-1`.\n\nFor example, if the input is\n\n```\nN = 4\nedgeList = [\n  [0, 1, 1], [0, 2, 5], [0, 3, 5], [1, 3, 3], [2, 3, 1]\n]\n```\n\nthen we have the graph depicted above (with `0 = A`, `1 = B`, etc.) and the answer is `4`.\n\nIf there is no path from node `0` to node `N-1`, return `-1`.\n\n## Notes and Warnings\n\n**Precondition:** `N` will always be greater than 1, and edge weights will always be positive integers.  There may be multiple edges going between two nodes.\n\n**Warning:** You will probably need to use a dynamic programming solution if you want your solution to run fast enough not to time out--that's the whole point of this kata!\n\nHowever, a well-written general shortest-path algorithm such as Dijkstra's Algorithm may also be fast enough to past the soak tests.  (The reason is that the dividing line between linear and linearithmic time is hard to define and depends on a variety of external factors, so the kata's tests err on the safe side.)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def shortest (n : Int) (edges : List Edge) : Int :=\n  sorry", "vc-theorems": "theorem shortest_basic_properties (n : Int) (edges : List Edge)\n  (h1 : n ≥ 2) (h2 : n ≤ 10) (h3 : edges.length ≥ 1) (h4 : edges.length ≤ 20)\n  (h5 : ∀ e ∈ edges, e.src ≥ 0 ∧ e.src < n ∧ \n                     e.dst ≥ 0 ∧ e.dst < n ∧ \n                     e.weight ≥ 1 ∧ e.weight ≤ 100 ∧\n                     e.src ≠ e.dst) :\n  let result := shortest n edges\n  (result = -1 ∨ result > 0) ∧\n  (∀ e ∈ edges, e.src = 0 ∧ e.dst = n-1 → result ≤ e.weight) :=\nsorry\n\ntheorem shortest_empty_graph (n : Int)\n  (h1 : n ≥ 2) (h2 : n ≤ 10) :\n  shortest n [] = -1 :=\nsorry\n\ntheorem shortest_single_direct_edge (n : Int) (w : Int)\n  (h1 : n ≥ 2) (h2 : n ≤ 10) (h3 : w ≥ 1) (h4 : w ≤ 100) :\n  shortest n [{ src := 0, dst := n-1, weight := w }] = w :=\nsorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval shortest 4 [[0, 1, 1], [0, 2, 5], [0, 3, 5], [1, 3, 3], [2, 3, 1]]\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval shortest 3 [[0, 1, 7], [1, 2, 5], [0, 2, 12]]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval shortest 5 [[0, 2, 1], [1, 2, 1], [0, 3, 1], [1, 4, 1]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3146", "language": "lean", "source": "fvapps", "source-id": "fvapps_003146", "source-notes": "", "vc-description": "/-\nYour task is to determine the top 3 place finishes in a pole vault competition involving several different competitors. This is isn't always so simple, and it is often a source of confusion for people who don't know the actual rules.\n\nHere's what you need to know:\n\nAs input, you will receive an array of objects. Each object contains the respective competitor's name (as a string) and his/her results at the various bar heights (as an array of strings):\n\n[{name: \"Sergey\", results: [\"\", \"O\", \"XO\", \"O\", \"XXO\", \"XXX\", \"\", \"\"]}{name: \"Jan\", results: [\"\", \"\", \"\", \"O\", \"O\", \"XO\", \"XXO\", \"XXX\"]}{name: \"Bruce\", results: [\"\", \"XO\", \"XXO\", \"XXX\", \"\", \"\", \"\", \"\"]}{name: \"HerrWert\", results: [\"XXX\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]}]\n\nIn the array of strings described above, each string represents the vaulter's performance at a given height. The possible values are based on commonly used written notations on a pole vault scoresheet:\nAn empty string indicates that the vaulter did not jump at this height for a variety of possible reasons (\"passed\" at this height, was temporarily called away to a different track and field event, was already eliminated from competition, or withdrew due to injury, for example).An upper-case X in the string represents an unsuccessful attempt at the height. (As you may know, the vaulter is eliminated from the competition after three consecutive failed attempts.)An upper-case O represents a successful attempt. If present at all, this will be the final character in the string, because it indicates that the vaulter has now successfully completed this height and is ready to move on.\n\nAll vaulters will have a result string (though possibly empty) for every height involved in the competition, making it possible to match up the results of different vaulters with less confusion.\n\nObviously, your first task is to determine who cleared the greatest height successfully. In other words, who has a \"O\" mark at a higher array element than any other competitor? You might want to work through the arrays from right to left to determine this. In the most straightforward case, you would first determine the winner, then second place, and finally third place by this simple logic.\n\nBut what if there's a tie for one of these finishing places? Proceed as follows (according to American high school rules, at least):\nFirst trace backwards to find the greatest height that both vaulters cleared successfully. Then determine who had the fewest unsuccessful attempts at this height (i.e., the fewest X's in the string for this height). This person wins the tie-break.But what if they're still tied with one another?  Do NOT continue to trace backwards through the heights! Instead, compare their total numbers of unsuccessful attempts at all heights in the competition. The vaulter with the fewest total misses wins the tie-break.But what if they're still tied? It depends on the finishing place:If it's for second or third place, the tie stands (i.e., is not broken).But if it's for first place, there must be a jump-off (like overtime or penalty kicks in other sports) to break the tie and determine the winner. (This jump-off occurs - hypothetically - after your code runs and is thus not a part of this kata.)\n\nReturn a single object as your result. Each place-finish that is included in the results (including at least first place as property \"1st\" and possibly second and third places as properties \"2nd\" and \"3rd\") should have as its value the respective vaulter's name. In the event of a tie, the value of the property is the names of all tied vaulters, in alphabetical order, separated by commas, and followed by the notation \"(jump-off)\" if the tie is for first place or \"(tie)\" if it's for second or third place.\n\nHere are some possible outcomes to show you what I mean:\n{1st: \"Jan\", 2nd: \"Sergey\"; 3rd: \"Bruce\"} (These results correspond to the sample input data given above.){1st: \"Julia\", 2nd: \"Madi, Emily (tie)}\"{1st: \"Caleb, Dustin (jump-off)\", 3rd: \"Sam\"}{1st: \"Meredith\", 2nd: \"Maddy\", 3rd: \"Cierra, Sara (tie)\"}{1st: \"Alex, Basti, Max (jump-off)\"}\n\nIf you are familiar with the awarding of place finishes in sporting events or team standings in a league, then you know that there won't necessarily be a 2nd or 3rd place, because ties in higher places \"bump\"  all lower places downward accordingly.\n\nOne more thing: You really shouldn't change the array of objects that you receive as input. This represents the physical scoresheet. We need this \"original document\" to be intact, so that we can refer back to it to resolve a disputed result!\n\nHave fun with this!\n\n- - - - -\n\nNotes for the Python version:\n\nThe rules for the Python version are the same as the original JavaScript version. \n\nThe input and output will look the same as the JavaScript version. But, the JavaScript objects will be replaced by Python dictionaries. The JavaScript arrays will be replaced by Python lists. The Python function name was changed to include underscores as is customary with Python names. The example below should help clarify all of this.\n\nThe input for the Python version will be a list containing dictionaries with the competitors' names and results. The names in the dictionaries are strings. The results are lists with a list of strings. And example follows.\n\nscore_pole_vault([\n        {\"name\": \"Linda\", \"results\": [\"XXO\", \"O\",\"XXO\", \"O\"]},\n        {\"name\": \"Vickie\", \"results\": [\"O\",\"X\", \"\", \"\"]},\n        {\"name\": \"Debbie\", \"results\": [\"XXO\", \"O\",\"XO\", \"XXX\"]},\n        {\"name\": \"Michelle\", \"results\": [\"XO\",\"XO\",\"XXX\",\"\"]},\n        {\"name\": \"Carol\", \"results\": [\"XXX\", \"\",\"\",\"\"]}\n])\n\nThe returned results should be in a dictionary with one to three elements. \n\nExamples of possible returned results:\n\n  {'1st': 'Linda', '2nd': 'Debbie', '3rd': 'Michelle'}\n\n  {'1st': 'Green, Hayes (jump-off)', '3rd': 'Garcia'}           \n  Note: Since first place was tied in this case, there is no 2nd place awarded.\n\n  {'1st': 'Wilson', '2nd': 'Laurie', '3rd': 'Joyce, Moore (tie)'}\n\nI have tried to create test cases that have every concievable tie situation.\n\nHave fun with this version, as well!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def score_pole_vault (vaulters : List Vaulter) : List (String × String) :=\n  sorry\n\n-- Properties about valid placements", "vc-theorems": "theorem score_pole_vault_valid_places (vaulters : List Vaulter) :\n  let result := score_pole_vault vaulters\n  ∀ p ∈ result, p.1 ∈ [\"1st\", \"2nd\", \"3rd\"] :=\nsorry\n\ntheorem score_pole_vault_max_places (vaulters : List Vaulter) :\n  let result := score_pole_vault vaulters\n  result.length ≤ 3 :=\nsorry\n\n-- Properties about tie/jump-off formatting\n\ntheorem score_pole_vault_tie_format (vaulters : List Vaulter) :\n  let result := score_pole_vault vaulters\n  ∀ p ∈ result,\n    p.2.contains '(' → (p.2.splitOn \",\").length > 1 :=\nsorry\n\ntheorem score_pole_vault_jumpoff_format (vaulters : List Vaulter) :\n  let result := score_pole_vault vaulters\n  ∀ p ∈ result,\n    p.2.contains 'j' →\n      (p.2.splitOn \",\").length > 1 ∧ p.1 = \"1st\" :=\nsorry\n\n-- Property about names in result appearing in original vaulters \n\ntheorem score_pole_vault_valid_names (vaulters : List Vaulter) :\n  let result := score_pole_vault vaulters\n  let processName (s : String) := s.trim\n  ∀ p ∈ result, ∀ name ∈ p.2.splitOn \",\",\n    ∃ v ∈ vaulters, v.name = processName name :=\nsorry\n\n-- Property about ordering of places\n\ntheorem score_pole_vault_ordered_places (vaulters : List Vaulter) :\n  let result := score_pole_vault vaulters\n  result.length > 1 →\n    ∀ i j, i < j → j < result.length →\n      (result[i]!.1.front.toNat) ≤ (result[j]!.1.front.toNat) :=\nsorry\n\n/-\ninfo: {'1st': 'Linda', '2nd': 'Debbie', '3rd': 'Michelle'}\n-/\n-- #guard_msgs in\n-- #eval score_pole_vault [{\"name\": \"Linda\", \"results\": [\"XXO\", \"O\", \"XXO\", \"O\"]}, {\"name\": \"Vickie\", \"results\": [\"O\", \"X\", \"\", \"\"]}, {\"name\": \"Debbie\", \"results\": [\"XXO\", \"O\", \"XO\", \"XXX\"]}, {\"name\": \"Michelle\", \"results\": [\"XO\", \"XO\", \"XXX\", \"\"]}, {\"name\": \"Carol\", \"results\": [\"XXX\", \"\", \"\", \"\"]}]\n\n/-\ninfo: {'1st': 'Onyx', '2nd': 'Lana', '3rd': 'Alexandria, Molly, Rebecca (tie)'}\n-/\n-- #guard_msgs in\n-- #eval score_pole_vault [{\"name\": \"Lana\", \"results\": [\"XO\", \"O\", \"O\", \"XXO\", \"XXX\"]}, {\"name\": \"Onyx\", \"results\": [\"XXO\", \"XXO\", \"XO\", \"O\", \"XXX\"]}, {\"name\": \"Molly\", \"results\": [\"XO\", \"XO\", \"O\", \"XXX\", \"\"]}, {\"name\": \"Alexandria\", \"results\": [\"XO\", \"XO\", \"O\", \"XXX\", \"\"]}, {\"name\": \"Rebecca\", \"results\": [\"XXO\", \"O\", \"O\", \"XXX\", \"\"]}]\n\n/-\ninfo: {'1st': 'Brett, Laura (jump-off)', '3rd': 'Sarah, Sharon (tie)'}\n-/\n-- #guard_msgs in\n-- #eval score_pole_vault [{\"name\": \"Sarah\", \"results\": [\"O\", \"X\", \"\", \"\"]}, {\"name\": \"Brett\", \"results\": [\"XO\", \"O\", \"XO\", \"XXO\"]}, {\"name\": \"Sharon\", \"results\": [\"O\", \"X\", \"\", \"\"]}, {\"name\": \"Laura\", \"results\": [\"O\", \"XO\", \"XO\", \"XXO\"]}]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3156", "language": "lean", "source": "fvapps", "source-id": "fvapps_003156", "source-notes": "", "vc-description": "/-\n###Introduction\n\nThe [I Ching](https://en.wikipedia.org/wiki/I_Ching) (Yijing, or Book of Changes) is an ancient Chinese book of sixty-four hexagrams. \nA hexagram is a figure composed of six stacked horizontal lines, where each line is either Yang (an unbroken line) or Yin (a broken line):\n```\n---------    ---- ----    ---------    \n---- ----    ---- ----    ---------    \n---- ----    ---- ----    ---------    \n---------    ---- ----    ---- ----    \n---------    ---------    ---- ----    \n---- ----    ---- ----    ---------    \n```\nThe book is commonly used as an oracle. After asking it a question about one's present scenario,\neach line is determined by random methods to be Yang or Yin. The resulting hexagram is then interpreted by the querent as a symbol of their current situation, and how it might unfold.\n\nThis kata will consult the I Ching using the three coin method.\n\n###Instructions\n\nA coin is flipped three times and lands heads\nor tails. The three results are used to\ndetermine a line as being either:\n```\n3 tails          ----x----  Yin (Moving Line*)\n2 tails 1 heads  ---------  Yang\n1 tails 2 heads  ---- ----  Yin \n3 heads          ----o----  Yang (Moving Line*)\n\n*See bottom of description if curious.\n```\nThis process is repeated six times to determine\neach line of the hexagram. The results of these\noperations are then stored in a 2D Array like so:\nIn each array the first index will always be the number of the line ('one' is the bottom line, and 'six' the top), and the other three values will be the results of the coin flips that belong to that line as heads ('h') and tails ('t').\n\nWrite a function that will take a 2D Array like the above as argument and return its hexagram as a string. Each line of the hexagram should begin on a new line.\n\nshould return:\n```\n---------\n---------\n----x----\n----o----\n---- ----\n---- ----\n```\nYou are welcome to consult your new oracle program with a question before pressing submit. You can compare your result [here](http://www.ichingfortune.com/hexagrams.php). The last test case is random and can be used for your query.\n\n*[1] A Moving Line is a Yang line that will change\nto Yin or vice versa. The hexagram made by the coin\nthrows represents the querent's current situation,\nand the hexagram that results from changing its\nmoving lines represents their upcoming situation.*\n-/", "vc-preamble": "def oracle (input : List (LineName × CoinFlip × CoinFlip × CoinFlip)) : List LineOutput :=\n  sorry\n\ndef getOutput (output : List LineOutput) (line : LineName × CoinFlip × CoinFlip × CoinFlip) : LineOutput :=\n  sorry", "vc-helpers": "", "vc-definitions": "def sortFlips (f1 f2 f3 : CoinFlip) : CoinFlip × CoinFlip × CoinFlip :=\n  sorry", "vc-theorems": "theorem oracle_output_length {input : List (LineName × CoinFlip × CoinFlip × CoinFlip)} \n  (h1 : input.length = 6)\n  (h2 : ∀ x y, x ∈ input → y ∈ input → x.1 = y.1 → x = y) :\n  (oracle input).length = 6 := \n  sorry\n\ntheorem line_positions_valid {input : List (LineName × CoinFlip × CoinFlip × CoinFlip)}\n  (h1 : input.length = 6)\n  (h2 : ∀ x y, x ∈ input → y ∈ input → x.1 = y.1 → x = y) :\n  ∀ line, line ∈ input → ∃ pos, pos < 6 :=\n  sorry\n\ntheorem oracle_flip_mapping {input : List (LineName × CoinFlip × CoinFlip × CoinFlip)}\n  (h1 : input.length = 6)\n  (h2 : ∀ x y, x ∈ input → y ∈ input → x.1 = y.1 → x = y)\n  (line : LineName × CoinFlip × CoinFlip × CoinFlip) \n  (h3 : line ∈ input) :\n  let (name, f1, f2, f3) := line\n  let (s1, s2, s3) := sortFlips f1 f2 f3\n  if s1 = CoinFlip.H ∧ s2 = CoinFlip.H ∧ s3 = CoinFlip.H then\n    getOutput (oracle input) line = LineOutput.Circle\n  else if s1 = CoinFlip.T ∧ s2 = CoinFlip.T ∧ s3 = CoinFlip.T then\n    getOutput (oracle input) line = LineOutput.X\n  else if s1 = CoinFlip.H ∧ s2 = CoinFlip.H ∧ s3 = CoinFlip.T then\n    getOutput (oracle input) line = LineOutput.Space\n  else if s1 = CoinFlip.H ∧ s2 = CoinFlip.T ∧ s3 = CoinFlip.T then\n    getOutput (oracle input) line = LineOutput.Empty\n  else\n    True :=\n  sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval oracle [[\"two\", \"h\", \"h\", \"t\"], [\"six\", \"t\", \"h\", \"t\"], [\"four\", \"t\", \"t\", \"t\"], [\"one\", \"h\", \"t\", \"h\"], [\"three\", \"h\", \"h\", \"h\"], [\"five\", \"t\", \"t\", \"h\"]]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval oracle [[\"six\", \"t\", \"t\", \"h\"], [\"one\", \"h\", \"h\", \"t\"], [\"three\", \"t\", \"h\", \"h\"], [\"two\", \"t\", \"t\", \"t\"], [\"five\", \"h\", \"h\", \"t\"], [\"four\", \"t\", \"t\", \"h\"]]\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval oracle [[\"five\", \"h\", \"h\", \"h\"], [\"four\", \"t\", \"t\", \"h\"], [\"two\", \"h\", \"t\", \"h\"], [\"one\", \"h\", \"h\", \"t\"], [\"six\", \"t\", \"h\", \"t\"], [\"three\", \"h\", \"h\", \"h\"]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3178", "language": "lean", "source": "fvapps", "source-id": "fvapps_003178", "source-notes": "", "vc-description": "/-\nThere is an array of strings. All strings contains similar _letters_ except one. Try to find it!\n\n```python\nfind_uniq([ 'Aa', 'aaa', 'aaaaa', 'BbBb', 'Aaaa', 'AaAaAa', 'a' ]) # => 'BbBb'\nfind_uniq([ 'abc', 'acb', 'bac', 'foo', 'bca', 'cab', 'cba' ]) # => 'foo'\n```\n\nStrings may contain spaces. Spaces is not significant, only non-spaces symbols matters. E.g. string that contains only spaces is like empty string.\n\nIt’s guaranteed that array contains more than 3 strings.\n\nThis is the second kata in series:\n\n1. [Find the unique number](https://www.codewars.com/kata/585d7d5adb20cf33cb000235)\n2. Find the unique string (this kata)\n3. [Find The Unique](https://www.codewars.com/kata/5862e0db4f7ab47bed0000e5)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_uniq (arr : List String) : String := sorry\n\ndef String.title (s : String) : String := sorry", "vc-theorems": "theorem find_uniq_returns_unique_string \n  {base_str unique_str : String} {copies : Nat}\n  (h_copies : copies ≥ 2) \n  (h_base_alph : ∀ c ∈ base_str.toList, c ∈ ['a', 'b', 'c'])\n  (h_unique_alph : ∀ c ∈ unique_str.toList, c ∈ ['d', 'e', 'f'])\n  : let test_arr := List.replicate copies base_str ++ [unique_str]\n    let result := find_uniq test_arr \n    (∀ c ∈ result.toLower.toList, c ∉ base_str.toLower.toList) ∧ \n    result = unique_str := sorry\n\ntheorem find_uniq_case_insensitive\n  {base_str : String} {copies : Nat}\n  (h_copies : copies ≥ 2)\n  (h_base_alph : ∀ c ∈ base_str.toList, c ∈ ['a', 'b'])\n  : let variations := [base_str, base_str.toUpper, base_str.toLower, base_str.title]\n    let unique := String.mk (List.replicate base_str.length 'c')\n    let test_arr := List.join (List.replicate copies variations) ++ [unique]\n    find_uniq test_arr = unique := sorry\n\ntheorem find_uniq_ignores_whitespace\n  {base_str : String}\n  (h_base_alph : ∀ c ∈ base_str.toList, c.toNat ≥ 65 ∧ c.toNat ≤ 90)\n  : let test_arr := [s!\" {base_str} \", base_str, s!\"{base_str} \", \"unique\"]\n    find_uniq test_arr = \"unique\" := sorry\n\n/-\ninfo: 'BbBb'\n-/\n-- #guard_msgs in\n-- #eval find_uniq [\"Aa\", \"aaa\", \"aaaaa\", \"BbBb\", \"Aaaa\", \"AaAaAa\", \"a\"]\n\n/-\ninfo: 'foo'\n-/\n-- #guard_msgs in\n-- #eval find_uniq [\"abc\", \"acb\", \"bac\", \"foo\", \"bca\", \"cab\", \"cba\"]\n\n/-\ninfo: 'victor'\n-/\n-- #guard_msgs in\n-- #eval find_uniq [\"silvia\", \"vasili\", \"victor\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3183", "language": "lean", "source": "fvapps", "source-id": "fvapps_003183", "source-notes": "", "vc-description": "/-\nWhen working with color values it can sometimes be useful to extract the individual red, green, and blue (RGB) component values for a color. Implement a function that meets these requirements:\n\n+ Accepts a case-insensitive hexadecimal color string as its parameter (ex. `\"#FF9933\"` or `\"#ff9933\"`)\n+ Returns an object with the structure `{r: 255, g: 153, b: 51}` where *r*, *g*, and *b* range from 0 through 255\n\n**Note:** your implementation does not need to support the shorthand form of hexadecimal notation (ie `\"#FFF\"`)\n\n## Example\n\n```\n\"#FF9933\" --> {r: 255, g: 153, b: 51}\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hexStringToRGB (s : String) : Option RGB := sorry\n\ntheorem hex_string_to_RGB_valid {r g b : Nat} \n  (hr : r ≤ 255) (hg : g ≤ 255) (hb : b ≤ 255) :\n  ∀ (hex : String),\n  match hexStringToRGB hex with\n  | none => True\n  | some rgb => \n    rgb.r ≤ 255 ∧ \n    rgb.g ≤ 255 ∧ \n    rgb.b ≤ 255 := sorry", "vc-theorems": "theorem hex_string_to_RGB_correct {r g b : Nat}\n  (hr : r ≤ 255) (hg : g ≤ 255) (hb : b ≤ 255) :\n  ∀ (hex : String),\n  match hexStringToRGB hex with\n  | none => True\n  | some rgb =>\n    rgb.r = r ∧\n    rgb.g = g ∧\n    rgb.b = b := sorry\n\n/-\ninfo: {'r': 255, 'g': 153, 'b': 51}\n-/\n-- #guard_msgs in\n-- #eval hex_string_to_RGB \"#FF9933\"\n\n/-\ninfo: {'r': 190, 'g': 173, 'b': 237}\n-/\n-- #guard_msgs in\n-- #eval hex_string_to_RGB \"#beaded\"\n\n/-\ninfo: {'r': 0, 'g': 0, 'b': 0}\n-/\n-- #guard_msgs in\n-- #eval hex_string_to_RGB \"#000000\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3193", "language": "lean", "source": "fvapps", "source-id": "fvapps_003193", "source-notes": "", "vc-description": "/-\n~~~if:csharp,javascript,cfml,php\nGiven a 2D array of size `m * n`. Your task is to find the sum of minimum value in each row.\n~~~\n~~~if:cpp\nGiven a 2D vector of size `m * n`. Your task is to find the sum of minimum value in each row.\n~~~\n~~~if:python,ruby\nGiven a 2D list of size `m * n`. Your task is to find the sum of minimum value in each row.\n~~~\n\nFor Example:\n```python\n[\n  [1, 2, 3, 4, 5],       # minimum value of row is 1\n  [5, 6, 7, 8, 9],       # minimum value of row is 5\n  [20, 21, 34, 56, 100]  # minimum value of row is 20\n]\n```\nSo, the function should return `26` because sum of minimums is as `1 + 5 + 20 = 26`\n\n~~~if:javascript,php\nNote: You will be always given non-empty array containing Positive values.\n~~~\n~~~if:python\nNote: You will be always given non-empty list containing Positive values.\n~~~\n~~~if:cpp\nNote: You will be always given non-empty vector containing Positive values.\n~~~\n~~~if:c#\nNote: You will be always given non-empty vector containing Positive values.\n~~~\n~~~if:cfml\nNote: You will be always given non-empty array containing Positive values.\n~~~\n\nENJOY CODING :)\n-/", "vc-preamble": "def List.minimums (l : List (List Int)) : Int := sorry \n\ndef List.sum (l : List Int) : Int := sorry", "vc-helpers": "", "vc-definitions": "def List.minimum (l : List Int) : Int := sorry\n\ntheorem minimums_eq_sum_of_mins (numbers : List (List Int))\n  (h : ∀ l ∈ numbers, l.length > 0) :\n  numbers.minimums = (numbers.map List.minimum).sum := sorry", "vc-theorems": "theorem single_element_minimums (numbers : List (List Int))\n  (h1 : ∀ l ∈ numbers, l.length = 1) :\n  numbers.minimums = numbers.join.sum := sorry\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval sum_of_minimums [[7, 9, 8, 6, 2], [6, 3, 5, 4, 3], [5, 8, 7, 4, 5]]\n\n/-\ninfo: 76\n-/\n-- #guard_msgs in\n-- #eval sum_of_minimums [[11, 12, 14, 54], [67, 89, 90, 56], [7, 9, 4, 3], [9, 8, 6, 7]]\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval sum_of_minimums [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3194", "language": "lean", "source": "fvapps", "source-id": "fvapps_003194", "source-notes": "", "vc-description": "/-\nGiven an array of integers as strings and numbers, return the sum of the array values as if all were numbers.\n\nReturn your answer as a number.\n-/", "vc-preamble": "def sum_mix (arr : List (String ⊕ Int)) : Int :=\n  sorry\n\ndef List.sum (xs : List Int) : Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def List.perm {α : Type} (xs ys : List α) : Prop :=\n  sorry", "vc-theorems": "theorem sum_mix_equals_int_conversion {arr : List (String ⊕ Int)} :\n  sum_mix arr = arr.foldl (fun acc x => acc + match x with \n                                            | Sum.inl s => s.toInt!\n                                            | Sum.inr n => n) 0 := by\n  sorry\n\ntheorem sum_mix_order_independent {arr₁ arr₂ : List (String ⊕ Int)} :\n  List.perm arr₁ arr₂ → sum_mix arr₁ = sum_mix arr₂ := by\n  sorry\n\ntheorem sum_mix_all_ints {arr : List Int} :\n  sum_mix (arr.map Sum.inr) = List.sum arr := by\n  sorry\n\ntheorem sum_mix_all_strings {arr : List String} :\n  sum_mix (arr.map Sum.inl) = List.sum (arr.map String.toInt!) := by\n  sorry\n\n/-\ninfo: 22\n-/\n-- #guard_msgs in\n-- #eval sum_mix [9, 3, \"7\", \"3\"]\n\n/-\ninfo: 42\n-/\n-- #guard_msgs in\n-- #eval sum_mix [\"5\", \"0\", 9, 3, 2, 1, \"9\", 6, 7]\n\n/-\ninfo: 41\n-/\n-- #guard_msgs in\n-- #eval sum_mix [\"3\", 6, 6, 0, \"5\", 8, 5, \"6\", 2, \"0\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3205", "language": "lean", "source": "fvapps", "source-id": "fvapps_003205", "source-notes": "", "vc-description": "/-\nWrite a function that accepts two square (`NxN`) matrices (two dimensional arrays), and returns the product of the two. Only square matrices will be given.\n\nHow to multiply two square matrices: \n\nWe are given two matrices, A and B, of size 2x2 (note: tests are not limited to 2x2). Matrix C, the solution, will be equal to the product of A and B. To fill in cell `[0][0]` of matrix C, you need to compute: `A[0][0] * B[0][0] + A[0][1] * B[1][0]`.\n\nMore general: To fill in cell `[n][m]` of matrix C, you need to first multiply the elements in the nth row of matrix A by the elements in the mth column of matrix B, then take the sum of all those products. This will give you the value for cell `[m][n]` in matrix C. \n\n## Example\n```\n  A         B          C\n|1 2|  x  |3 2|  =  | 5 4|\n|3 2|     |1 1|     |11 8|\n```\n\nDetailed calculation:\n```\nC[0][0] = A[0][0] * B[0][0] + A[0][1] * B[1][0] = 1*3 + 2*1 =  5\nC[0][1] = A[0][0] * B[0][1] + A[0][1] * B[1][1] = 1*2 + 2*1 =  4\nC[1][0] = A[1][0] * B[0][0] + A[1][1] * B[1][0] = 3*3 + 2*1 = 11\nC[1][1] = A[1][0] * B[0][1] + A[1][1] * B[1][1] = 3*2 + 2*1 =  8\n```\nLink to Wikipedia explaining matrix multiplication (look at the square matrix example): \nhttp://en.wikipedia.org/wiki/Matrix_multiplication\n\nA more visual explanation of matrix multiplication: http://matrixmultiplication.xyz\n\n~~~if:c\n**Note:** In **C**, the dimensions of both square matrices `n` will be passed into your function.  However, since the dimensions of your returned \"matrix\" is expected to be the same as that of the inputs, you will not need to keep track of the dimensions of your matrix in another variable.\n~~~\n-/", "vc-preamble": "def matrix_mult {n : Nat} (A B : Matrix Int n) : Matrix Int n where\n  data := sorry\n  dim_rows := sorry\n  dim_cols := sorry\n\ndef numpy_matmul {n : Nat} (A B : Matrix Int n) : Matrix Int n where\n  data := sorry\n  dim_rows := sorry\n  dim_cols := sorry", "vc-helpers": "", "vc-definitions": "def identity_matrix (n : Nat) : Matrix Int n where\n  data := sorry\n  dim_rows := sorry\n  dim_cols := sorry", "vc-theorems": "theorem matrix_mult_matches_numpy {n : Nat} (A B : Matrix Int n) :\n  matrix_mult A B = numpy_matmul A B := by sorry\n\ntheorem matrix_mult_identity {n : Nat} (A : Matrix Int n) :\n  matrix_mult A (identity_matrix n) = A := by sorry\n\ntheorem matrix_mult_associative {n : Nat} (A B C : Matrix Int n) :\n  matrix_mult (matrix_mult A B) C = matrix_mult A (matrix_mult B C) := by sorry\n\ntheorem matrix_mult_dimensions {n : Nat} (A B : Matrix Int n) :\n  let C := matrix_mult A B\n  C.data.size = n ∧ ∀ i < n, (C.data.get! i).size = n := by sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval matrix_mult #[[1, 2], [3, 2]] #[[3, 2], [1, 1]]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval matrix_mult #[[9, 7], [0, 1]] #[[1, 1], [4, 12]]\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval matrix_mult #[[1, 2, 3], [3, 2, 1], [2, 1, 3]] #[[4, 5, 6], [6, 5, 4], [4, 6, 5]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3226", "language": "lean", "source": "fvapps", "source-id": "fvapps_003226", "source-notes": "", "vc-description": "/-\nYour task is to remove all duplicate words from a string, leaving only single (first) words entries.\n\nExample:\n\nInput:\n\n'alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma delta'\n\nOutput:\n\n'alpha beta gamma delta'\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def removeDuplicateWords (s : String) : String := sorry\n\n/- The output of removeDuplicateWords contains no duplicate words -/", "vc-theorems": "theorem no_duplicates {s : String} :\n  let result := removeDuplicateWords s\n  let resultWords := (result.splitOn \" \")\n  List.Nodup resultWords := by sorry\n\n/- Words in the output appear in the same order as their first occurrence in the input -/\n\ntheorem preserves_order {s : String} :\n  let inputWords := (s.splitOn \" \")\n  let outputWords := (removeDuplicateWords s).splitOn \" \" \n  ∀ w ∈ outputWords, \n    List.indexOf w inputWords = List.indexOf w inputWords := by sorry\n\n/- All words in the output appear in the input -/\n\ntheorem output_subset_input {s : String} :\n  let inputWords := (s.splitOn \" \")\n  let outputWords := (removeDuplicateWords s).splitOn \" \"\n  ∀ w ∈ outputWords, w ∈ inputWords := by sorry\n\n/-\ninfo: 'alpha beta gamma delta'\n-/\n-- #guard_msgs in\n-- #eval remove_duplicate_words \"alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma delta\"\n\n/-\ninfo: 'my cat is fat'\n-/\n-- #guard_msgs in\n-- #eval remove_duplicate_words test2", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3227", "language": "lean", "source": "fvapps", "source-id": "fvapps_003227", "source-notes": "", "vc-description": "/-\nWrite a function that accepts two square matrices (`N x N` two dimensional arrays), and return the sum of the two. Both matrices being passed into the function will be of size `N x N` (square), containing only integers.\n\nHow to sum two matrices:\n\nTake each cell `[n][m]` from the first matrix, and add it with the same `[n][m]` cell from the second matrix. This will be cell `[n][m]` of the solution matrix.\n\nVisualization: \n```\n|1 2 3|     |2 2 1|     |1+2 2+2 3+1|     |3 4 4|\n|3 2 1|  +  |3 2 3|  =  |3+3 2+2 1+3|  =  |6 4 4|\n|1 1 1|     |1 1 3|     |1+1 1+1 1+3|     |2 2 4|\n```\n\n## Example\n-/", "vc-preamble": "def matrixAddition {n : Nat} (A B : Matrix Int n) : Matrix Int n :=\n  sorry", "vc-helpers": "", "vc-definitions": "def zeroMatrix (n : Nat) : Matrix Int n :=\n  sorry", "vc-theorems": "theorem matrixAddition_commutativity {n : Nat} (A B : Matrix Int n) :\n  ∀ i j, i < n → j < n →\n    (matrixAddition A B).data[i]!.get! j = (matrixAddition B A).data[i]!.get! j := by\n  sorry\n\ntheorem matrixAddition_correctness {n : Nat} (A B : Matrix Int n) :\n  ∀ i j, i < n → j < n →\n    (matrixAddition A B).data[i]!.get! j = A.data[i]!.get! j + B.data[i]!.get! j := by\n  sorry\n\ntheorem matrixAddition_identity {n : Nat} (A : Matrix Int n) :\n  matrixAddition A (zeroMatrix n) = A := by\n  sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval matrix_addition #[[1, 2, 3], [3, 2, 1], [1, 1, 1]] #[[2, 2, 1], [3, 2, 3], [1, 1, 3]]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval matrix_addition #[[1, 2], [1, 2]] #[[2, 3], [2, 3]]\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval matrix_addition #[[1]] #[[2]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3239", "language": "lean", "source": "fvapps", "source-id": "fvapps_003239", "source-notes": "", "vc-description": "/-\n## Check Digits\n\nSome numbers are more important to get right during data entry than others: a common example is product codes.\n\nTo reduce the possibility of mistakes, product codes can be crafted in such a way that simple errors are detected. This is done by calculating a single-digit value based on the product number, and then appending that digit to the product number to arrive at the product code.\n\nWhen the product code is checked, the check digit value is stripped off and recalculated. If the supplied value does not match the recalculated value, the product code is rejected.\n\nA simple scheme for generating self-check digits, described here, is called Modulus 11 Self-Check.\n\n## Calculation method\n\nEach digit in the product number is assigned a multiplication factor. The factors are assigned ***from right to left***, starting at `2` and counting up. For numbers longer than six digits, the factors restart at `2` after `7` is reached. The product of each digit and its factor is calculated, and the products summed. For example:\n\n```python\ndigit     :  1    6    7    7    0    3    6    2    5\nfactor    :  4    3    2    7    6    5    4    3    2\n           ---  ---  ---  ---  ---  ---  ---  ---  ---\n             4 + 18 + 14 + 49 +  0 + 15 + 24 +  6 + 10 = 140\n```\n\nThen the sum of the products is divided by the prime number `11`. The remainder is inspected, and:\n\n* if the remainder is `0`, the check digit is also `0`\n* if the remainder is `1`, the check digit is replaced by an uppercase `X`\n* for all others, the remainder is subtracted from `11`\n\nThe result is the **check digit**.\n\n## Your task\n\nYour task is to implement this algorithm and return the input number with the correct check digit appended.\n\n## Examples\n\n```python\ninput: \"036532\"\n\nproduct sum = 2*2 + 3*3 + 5*4 + 6*5 + 3*6 + 0*7 = 81\nremainder   = 81 mod 11 = 4\ncheck digit = 11 - 4 = 7\n\noutput: \"0365327\"\n```\n-/", "vc-preamble": "def add_check_digit (num : String) : String := sorry\n\n-- Length property: result is one char longer and preserves input", "vc-helpers": "", "vc-definitions": "def mkFactors (n : Nat) : List Nat :=\n  let base := [2,3,4,5,6,7]\n  let repeats := n / 6 + 1\n  List.join (List.replicate repeats base)\n\n-- Calculation property: check digit follows formula", "vc-theorems": "theorem check_digit_length\n  (num : String)\n  (h : num.all (fun c => '0' ≤ c ∧ c ≤ '9')) :\n  let result := add_check_digit num\n  (result.length = num.length + 1) ∧\n  (result.dropRight 1 = num) := sorry\n\n-- Format property: last char is digit or X\n\ntheorem check_digit_format\n  (num : String)\n  (h : num.all (fun c => '0' ≤ c ∧ c ≤ '9')) :\n  let result := add_check_digit num\n  let last := result.back\n  (('0' ≤ last ∧ last ≤ '9') ∨ last = 'X') := sorry\n\ntheorem check_digit_calculation\n  (num : String)\n  (h : num.all (fun c => '0' ≤ c ∧ c ≤ '9')) :\n  let result := add_check_digit num\n  let factors := mkFactors num.length\n  let nums := num.toList.reverse.map (fun c => c.toNat - '0'.toNat)\n  let products := List.zipWith (· * ·) nums factors\n  let total := products.foldl (· + ·) 0\n  let remainder := total % 11\n  ((remainder = 0 → result.back = '0') ∧\n   (remainder = 1 → result.back = 'X') ∧\n   (remainder > 1 → result.back = (Char.ofNat ('0'.toNat + (11 - remainder))))) := sorry\n\n/-\ninfo: '0365327'\n-/\n-- #guard_msgs in\n-- #eval add_check_digit \"036532\"\n\n/-\ninfo: '123888782'\n-/\n-- #guard_msgs in\n-- #eval add_check_digit \"12388878\"\n\n/-\ninfo: '6789X'\n-/\n-- #guard_msgs in\n-- #eval add_check_digit \"6789\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3251", "language": "lean", "source": "fvapps", "source-id": "fvapps_003251", "source-notes": "", "vc-description": "/-\nIn this Kata, you will be given an array of numbers and a number `n`, and your task will be to determine if `any` array elements, when summed (or taken individually), are divisible by `n`. \n\nFor example:\n\n  * `solve([1,3,4,7,6],9) == true`, because `3 + 6` is divisible by `9`\n  * `solve([1,2,3,4,5],10) == true` for similar reasons.\n  * `solve([8,5,3,9],7) == true`, because `7` evenly divides `5 + 9`\n  * but `solve([8,5,3],7) == false`.\n\nAll numbers in the array will be greater than `0`. \n\nMore examples in the test cases.\n\nGood luck!\n\nIf you like this Kata, please try:\n\n[Simple division](https://www.codewars.com/kata/59ec2d112332430ce9000005)\n\n[Divisor harmony](https://www.codewars.com/kata/59bf97cd4f98a8b1cd00007e)\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat :=\nmatch xs with\n| [] => 0\n| x::xs => x + xs.sum", "vc-helpers": "", "vc-definitions": "def solve (numbers : List Nat) (n : Nat) : Bool :=\nsorry", "vc-theorems": "theorem solve_sum_divisible_by_n {numbers : List Nat} {n : Nat} \n  (h1: 0 < n) (h2: ∀ x ∈ numbers, 0 < x) :\n  (numbers.sum % n = 0) → solve numbers n = true :=\nsorry\n\ntheorem solve_single_divisible_by_n {numbers : List Nat} {n : Nat}\n  (h1: 0 < n) (h2: ∀ x ∈ numbers, 0 < x) :\n  (∃ x ∈ numbers, x % n = 0) → solve numbers n = true :=\nsorry\n\ntheorem solve_multiply_by_n {numbers : List Nat} {n : Nat}\n  (h1: 0 < n) (h2: ∀ x ∈ numbers, 0 < x) :\n  solve (List.map (· * n) numbers) n = true :=\nsorry\n\ntheorem solve_with_sum_as_n {numbers : List Nat}\n  (h: ∀ x ∈ numbers, 0 < x) :\n  solve numbers numbers.sum = true :=\nsorry\n\ntheorem solve_single_element {x n : Nat} (h1: 0 < x) (h2: 0 < n) :\n  solve [x] n = (x % n = 0) :=\nsorry\n\ntheorem solve_all_larger_than_n {numbers : List Nat} {n : Nat}\n  (h1: 0 < n) (h2: ∀ x ∈ numbers, n < x) :\n  solve numbers n = true :=\nsorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval solve [1, 2, 3, 4, 5] 10\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval solve [8, 5, 3] 7\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval solve [8, 5, 3, 9] 7", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3257", "language": "lean", "source": "fvapps", "source-id": "fvapps_003257", "source-notes": "", "vc-description": "/-\nYou were given a string of integer temperature values. Create a function `lowest_temp(t)` and return the lowest value or `None/null/Nothing` if the string is empty.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def lowest_temp (s : String) : Option Int := sorry \n\ntheorem lowest_temp_empty: lowest_temp \"\" = none := sorry", "vc-theorems": "theorem lowest_temp_single (n : Int) (h : -100 ≤ n ∧ n ≤ 100) :\n  lowest_temp (toString n) = some n := sorry\n\ntheorem lowest_temp_properties (s : String) :\n  match lowest_temp s with\n  | none => s = \"\"\n  | some result =>\n    ∃ nums : List Int,\n      (∀ n ∈ nums, -100 ≤ n ∧ n ≤ 100) ∧\n      result = nums.minimum?.get! ∧\n      nums ≠ []\n  := sorry\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval lowest_temp \"\"\n\n/-\ninfo: -8\n-/\n-- #guard_msgs in\n-- #eval lowest_temp \"-1 50 -4 20 22 -7 0 10 -8\"\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval lowest_temp \"5\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3258", "language": "lean", "source": "fvapps", "source-id": "fvapps_003258", "source-notes": "", "vc-description": "/-\n# A wolf in sheep's clothing\n\nWolves have been reintroduced to Great Britain. You are a sheep farmer, and are now plagued by wolves which pretend to be sheep. Fortunately, you are good at spotting them. \n\nWarn the sheep in front of the wolf that it is about to be eaten. Remember that you are standing **at the front of the queue** which is at the end of the array:\n\n```\n[sheep, sheep, sheep, sheep, sheep, wolf, sheep, sheep]      (YOU ARE HERE AT THE FRONT OF THE QUEUE)\n   7      6      5      4      3            2      1\n```\n\nIf the wolf is the closest animal to you, return `\"Pls go away and stop eating my sheep\"`. Otherwise, return `\"Oi! Sheep number N! You are about to be eaten by a wolf!\"` where `N` is the sheep's position in the queue.\n\n**Note:** there will always be exactly one wolf in the array.\n\n## Examples\n\n```python\nwarn_the_sheep([\"sheep\", \"sheep\", \"sheep\", \"wolf\", \"sheep\"]) == 'Oi! Sheep number 1! You are about to be eaten by a wolf!'\n\nwarn_the_sheep(['sheep', 'sheep', 'wolf']) == 'Pls go away and stop eating my sheep'\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def warn_the_sheep (queue : List String) : String := sorry\n\ntheorem wolf_at_end_gives_warning_message {queue : List String} \n  (h : queue = queue.dropLast ++ [(\"wolf\" : String)]) :\n  warn_the_sheep queue = \"Pls go away and stop eating my sheep\" := sorry", "vc-theorems": "theorem wolf_with_sheep_after_gives_warning {queue : List String}\n  (h1 : ∃ i, queue.get? i = some \"wolf\")\n  (h2 : ∃ n, n > 0 ∧ queue.length = (queue.indexOf \"wolf\" + 1 + n)) :\n  let sheep_after := queue.length - queue.indexOf \"wolf\" - 1\n  warn_the_sheep queue = s!\"Oi! Sheep number {sheep_after}! You are about to be eaten by a wolf!\" := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3276", "language": "lean", "source": "fvapps", "source-id": "fvapps_003276", "source-notes": "", "vc-description": "/-\nIf you finish this kata, you can try [Insane Coloured Triangles](http://www.codewars.com/kata/insane-coloured-triangles) by Bubbler, which is a ***much*** harder version of this one.\n\nA coloured triangle is created from a row of colours, each of which is red, green or blue. Successive rows, each containing one fewer colour than the last, are generated by considering the two touching colours in the previous row. If these colours are identical, the same colour is used in the new row. If they are different, the missing colour is used in the new row. This is continued until the final row, with only a single colour, is generated.\n\nThe different possibilities are:\n```\nColour here:        G G        B G        R G        B R\nBecomes colour:      G          R          B          G\n```\n\nWith a bigger example:\n```\nR R G B R G B B\n R B R G B R B\n  G G B R G G\n   G R G B G\n    B B R R\n     B G R\n      R B\n       G\n```\n\nYou will be given the first row of the triangle as a string and its your job to return the final colour which would appear in the bottom row as a string. In the case of the example above, you would the given `RRGBRGBB` you should return `G`.\n\n* The input string will only contain the uppercase letters `R, G, B` and there will be at least one letter so you do not have to test for invalid input.\n* If you are only given one colour as the input, return that colour. \n\n*Adapted from the 2017 British Informatics Olympiad*\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def triangle (s : String) : String := sorry\n\ntheorem triangle_returns_single_char {s : String} \n  (h : ∀ c ∈ s.data, c = 'R' ∨ c = 'G' ∨ c = 'B') :\n  (triangle s).length = 1 ∧ \n  (triangle s).data.head? = some 'R' ∨ \n  (triangle s).data.head? = some 'G' ∨ \n  (triangle s).data.head? = some 'B' := sorry", "vc-theorems": "theorem triangle_single_char_identity {s : String}\n  (h : s.length = 1)\n  (h2 : ∀ c ∈ s.data, c = 'R' ∨ c = 'G' ∨ c = 'B') :\n  triangle s = s := sorry \n\ntheorem triangle_deterministic {s : String}\n  (h : s.length ≥ 2)\n  (h2 : ∀ c ∈ s.data, c = 'R' ∨ c = 'G' ∨ c = 'B') :\n  triangle s = triangle s := sorry\n\ntheorem triangle_concatenation {s1 s2 : String}\n  (h1 : s1.length > 0)\n  (h2 : s2.length > 0)\n  (h3 : ∀ c ∈ s1.data, c = 'R' ∨ c = 'G' ∨ c = 'B')\n  (h4 : ∀ c ∈ s2.data, c = 'R' ∨ c = 'G' ∨ c = 'B') :\n  (triangle (s1 ++ s2)).data.head? = some 'R' ∨\n  (triangle (s1 ++ s2)).data.head? = some 'G' ∨\n  (triangle (s1 ++ s2)).data.head? = some 'B' := sorry\n\nend Property\n\n/-\ninfo: 'R'\n-/\n-- #guard_msgs in\n-- #eval triangle \"GB\"\n\n/-\ninfo: 'B'\n-/\n-- #guard_msgs in\n-- #eval triangle \"B\"\n\n/-\ninfo: 'G'\n-/\n-- #guard_msgs in\n-- #eval triangle \"RBRGBRB\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3301", "language": "lean", "source": "fvapps", "source-id": "fvapps_003301", "source-notes": "", "vc-description": "/-\nDefine a method that accepts 2 strings as parameters. The method returns the first string sorted by the second.\n\n```python\nsort_string(\"foos\", \"of\")       == \"oofs\"\nsort_string(\"string\", \"gnirts\") == \"gnirts\"\nsort_string(\"banana\", \"abn\")    == \"aaabnn\"\n```\n\nTo elaborate, the second string defines the ordering. It is possible that in the second string characters repeat, so you should remove repeating characters, leaving only the first occurrence.\n\nAny character in the first string that does not appear in the second string should be sorted to the end of the result in original order.\n-/", "vc-preamble": "def sort_string (s : String) (ordering : String) : String :=\n  sorry\n\n/- Helper function to count occurrences of a character in a string -/\n\ndef String.countChar (s : String) (c : Char) : Nat :=\n  s.data.filter (· = c) |>.length\n\n/- Helper function to find first index of character in string -/", "vc-helpers": "", "vc-definitions": "def String.findFirstIndex (s : String) (c : Char) : Nat :=\n  s.data.indexOf? c |>.getD s.length", "vc-theorems": "theorem sort_string_length_preservation (s ordering : String) :\n  (sort_string s ordering).length = s.length :=\nsorry\n\ntheorem sort_string_char_preservation (s ordering : String) (c : Char) :\n  c ∈ (sort_string s ordering).data → c ∈ s.data :=\nsorry\n\ntheorem sort_string_frequency_preservation (s ordering : String) (c : Char) :\n  (sort_string s ordering).countChar c = s.countChar c :=\nsorry\n\ntheorem sort_string_ordering_property (s ordering : String) (i j : Char) :\n  i ∈ s.data → j ∈ s.data → i ∈ ordering.data → j ∈ ordering.data → \n  ordering.findFirstIndex i < ordering.findFirstIndex j →\n  (sort_string s ordering).findFirstIndex i < (sort_string s ordering).findFirstIndex j :=\nsorry\n\ntheorem sort_string_empty_string (ordering : String) :\n  sort_string \"\" ordering = \"\" :=\nsorry\n\ntheorem sort_string_empty_ordering (s : String) :\n  sort_string s \"\" = s :=\nsorry\n\ntheorem sort_string_idempotent (s ordering : String) :\n  sort_string (sort_string s ordering) ordering = sort_string s ordering :=\nsorry\n\n/-\ninfo: 'oofs'\n-/\n-- #guard_msgs in\n-- #eval sort_string \"foos\" \"of\"\n\n/-\ninfo: 'gnirts'\n-/\n-- #guard_msgs in\n-- #eval sort_string \"string\" \"gnirts\"\n\n/-\ninfo: 'aaabnn'\n-/\n-- #guard_msgs in\n-- #eval sort_string \"banana\" \"abn\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3308", "language": "lean", "source": "fvapps", "source-id": "fvapps_003308", "source-notes": "", "vc-description": "/-\nDon't Drink the Water\n\nGiven a two-dimensional array representation of a glass of mixed liquids, sort the array such that the liquids appear in the glass based on their density. (Lower density floats to the top) The width of the glass will not change from top to bottom.\n\n```\n======================\n|   Density Chart    |\n======================\n| Honey   | H | 1.36 |\n| Water   | W | 1.00 |\n| Alcohol | A | 0.87 |\n| Oil     | O | 0.80 |\n----------------------\n\n[                            [\n ['H', 'H', 'W', 'O'],        ['O','O','O','O']\n ['W', 'W', 'O', 'W'],  =>    ['W','W','W','W']\n ['H', 'H', 'O', 'O']         ['H','H','H','H']\n ]                           ]\n\n ```\n\n The glass representation may be larger or smaller. If a liquid doesn't fill a row, it floats to the top and to the left.\n-/", "vc-preamble": "def liquidDensity (l: Liquid) : Float :=\n  match l with\n  | Liquid.H => 1.36\n  | Liquid.W => 1.0\n  | Liquid.A => 0.87\n  | Liquid.O => 0.8", "vc-helpers": "", "vc-definitions": "def separate_liquids (glass: List (List Liquid)) : List (List Liquid) := sorry\n\ntheorem count_preserving (glass: List (List Liquid)) : \n  let input_counts := ((glass.join.filter (fun x => x == Liquid.H)).length,\n                      (glass.join.filter (fun x => x == Liquid.W)).length,\n                      (glass.join.filter (fun x => x == Liquid.A)).length,\n                      (glass.join.filter (fun x => x == Liquid.O)).length);\n  let output := separate_liquids glass;\n  let output_counts := ((output.join.filter (fun x => x == Liquid.H)).length,\n                       (output.join.filter (fun x => x == Liquid.W)).length,\n                       (output.join.filter (fun x => x == Liquid.A)).length, \n                       (output.join.filter (fun x => x == Liquid.O)).length);\n  input_counts = output_counts := sorry", "vc-theorems": "theorem density_layering (glass: List (List Liquid)) :\n  let result := separate_liquids glass\n  ∀ i j, i < j → j < result.length →\n  ∀ k, k < (result.get! i).length →\n  liquidDensity ((result.get! i).get! k) ≤ liquidDensity ((result.get! j).get! k) := sorry\n\ntheorem empty_glass :\n  separate_liquids [] = [] := sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval separate_liquids [[\"H\", \"H\", \"W\", \"O\"], [\"W\", \"W\", \"O\", \"W\"], [\"H\", \"H\", \"O\", \"O\"]]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval separate_liquids [[\"A\", \"H\", \"W\", \"O\"]]\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval separate_liquids []", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3317", "language": "lean", "source": "fvapps", "source-id": "fvapps_003317", "source-notes": "", "vc-description": "/-\nIn this kata you will be given a sequence of the dimensions of rectangles ( sequence with width and length ) and circles ( radius - just a number ).  \nYour task is to return a new sequence of dimensions, sorted ascending by area.\n\nFor example,\n\n```python\nseq = [ (4.23, 6.43), 1.23, 3.444, (1.342, 3.212) ] # [ rectangle, circle, circle, rectangle ]\nsort_by_area(seq) => [ ( 1.342, 3.212 ), 1.23, ( 4.23, 6.43 ), 3.444 ]\n```\n\nThis kata inspired by [Sort rectangles and circles by area](https://www.codewars.com/kata/sort-rectangles-and-circles-by-area/).\n-/", "vc-preamble": "def get_area (x : AreaElement) : Nat :=\n  match x with\n  | .circle r => 314159 * r * r / 100000  -- π approximation times r^2\n  | .rect (w, h) => w * h", "vc-helpers": "", "vc-definitions": "def sort_by_area (seq : List AreaElement) : List AreaElement :=\n  sorry", "vc-theorems": "theorem sort_by_area_preserves_length {seq : List AreaElement} :\n  (sort_by_area seq).length = seq.length :=\n  sorry\n\ntheorem sort_by_area_preserves_elements {seq : List AreaElement} (x : AreaElement) :\n  (seq.count x) = ((sort_by_area seq).count x) :=\n  sorry\n\ntheorem sort_by_area_ascending {seq : List AreaElement} :\n  ∀ i j, i < j → j < (sort_by_area seq).length →\n    let sorted := sort_by_area seq\n    ∀ (hi : i < sorted.length) (hj : j < sorted.length),\n    get_area (sorted.get ⟨i, hi⟩) ≤ get_area (sorted.get ⟨j, hj⟩) :=\n  sorry\n\ntheorem sort_by_area_empty :\n  sort_by_area [] = [] :=\n  sorry\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval sort_by_area []\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval sort_by_area [(4.23, 6.43), 1.23, 3.444, (1.342, 3.212)]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval sort_by_area [1.0, 2.0, 3.0]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3338", "language": "lean", "source": "fvapps", "source-id": "fvapps_003338", "source-notes": "", "vc-description": "/-\nOn Unix system type files can be identified with the ls -l command which displays the type of the file in the first alphabetic letter of the file system permissions field. You can find more information about file type on Unix system on the [wikipedia page](https://en.wikipedia.org/wiki/Unix_file_types).\n\n- '-' A regular file ==> `file`.\n- 'd' A directory ==> `directory`.\n- 'l' A symbolic link ==> `symlink`.\n- 'c' A character special file. It refers to a device that handles data as a stream of bytes (e.g: a terminal/modem) ==> `character_file`.\n- 'b' A block special file. It refers to a device that handles data in blocks (e.g: such as a hard drive or CD-ROM drive) ==> `block_file`.\n- 'p' a named pipe ==> `pipe`.\n- 's' a socket ==> `socket`.\n- 'D' a door ==> `door`.\n\nIn this kata you should complete a function that return the `filetype` as a string regarding the `file_attribute` given by the `ls -l` command. \n\nFor example if the function receive `-rwxr-xr-x` it should return `file`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def linux_type (full_attr: String) : FileType := sorry\n\ntheorem linux_type_first_char_determines_type (file_type: Char) (permissions: String) \n  (h1: file_type = '-' ∨ file_type = 'd' ∨ file_type = 'l' ∨ \n       file_type = 'c' ∨ file_type = 'b' ∨ file_type = 'p' ∨\n       file_type = 's' ∨ file_type = 'D')\n  (h2: permissions.length = 9)\n  (h3: ∀ c ∈ permissions.data, c = 'r' ∨ c = 'w' ∨ c = 'x' ∨ c = '-') :\n  let full_attr := String.mk (file_type :: permissions.data)\n  match file_type with\n  | '-' => linux_type full_attr = FileType.file\n  | 'd' => linux_type full_attr = FileType.directory\n  | 'l' => linux_type full_attr = FileType.symlink\n  | 'c' => linux_type full_attr = FileType.character_file\n  | 'b' => linux_type full_attr = FileType.block_file\n  | 'p' => linux_type full_attr = FileType.pipe\n  | 's' => linux_type full_attr = FileType.socket\n  | 'D' => linux_type full_attr = FileType.door\n  | _ => True := sorry", "vc-theorems": "theorem linux_type_invalid_first_char (c: Char) (permissions: String)\n  (h1: c ≠ '-' ∧ c ≠ 'd' ∧ c ≠ 'l' ∧ c ≠ 'c' ∧ c ≠ 'b' ∧ c ≠ 'p' ∧ c ≠ 's' ∧ c ≠ 'D')\n  (h2: permissions.length = 9)\n  (h3: ∀ c ∈ permissions.data, c = 'r' ∨ c = 'w' ∨ c = 'x' ∨ c = '-') :\n  ∀ ft: FileType, linux_type (String.mk (c :: permissions.data)) ≠ ft := sorry\n\n/-\ninfo: 'file'\n-/\n-- #guard_msgs in\n-- #eval linux_type \"-rwxrwxrwx\"\n\n/-\ninfo: 'door'\n-/\n-- #guard_msgs in\n-- #eval linux_type \"Drwxr-xr-x\"\n\n/-\ninfo: 'symlink'\n-/\n-- #guard_msgs in\n-- #eval linux_type \"lrwxrw-rw-\"\n\n/-\ninfo: 'socket'\n-/\n-- #guard_msgs in\n-- #eval linux_type \"srwxrwxrwx\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3346", "language": "lean", "source": "fvapps", "source-id": "fvapps_003346", "source-notes": "", "vc-description": "/-\nCheck your arrows\nYou have a quiver of arrows, but some have been damaged. The quiver contains arrows with an optional range information (different types of targets are positioned at different ranges), so each item is an arrow.\n\nYou need to verify that you have some good ones left, in order to prepare for battle:\n```python\nanyArrows([{'range': 5}, {'range': 10, 'damaged': True}, {'damaged': True}])\n```\n\nIf an arrow in the quiver does not have a damaged status, it means it's new.\n\nThe expected result is a boolean, indicating whether you have any good arrows left.\n\nReference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def any_arrows (arrows : List Arrow) : Bool := sorry\n\ntheorem any_arrows_all_damaged \n  (arrows : List Arrow)\n  (h : ∀ a ∈ arrows, (a.damaged = some true)) :\n  any_arrows arrows = false := sorry", "vc-theorems": "theorem any_arrows_exists_undamaged\n  (arrows : List Arrow)\n  (h : ∃ a ∈ arrows, (a.damaged = some false) ∨ (a.damaged = none)) :\n  any_arrows arrows = true := sorry\n\ntheorem any_arrows_empty :\n  any_arrows [] = false := sorry\n\ntheorem any_arrows_undamaged_only\n  (arrows : List Arrow)\n  (h : ∀ a ∈ arrows, a.damaged = none) :\n  any_arrows arrows = (arrows ≠ []) := sorry\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval any_arrows []\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval any_arrows [{\"range\": 5}]\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval any_arrows [{\"range\": 5}, {\"range\": 10, \"damaged\": True}, {\"damaged\": True}]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3353", "language": "lean", "source": "fvapps", "source-id": "fvapps_003353", "source-notes": "", "vc-description": "/-\nBit Vectors/Bitmaps\nA bitmap is one way of efficiently representing sets of unique integers using single bits.\nTo see how this works, we can represent a set of unique integers between `0` and `< 20` using a vector/array of 20 bits:\n```\nvar set = [3, 14, 2, 11, 16, 4, 6];```\n```\nvar bitmap = [0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0];\n```\nAs you can see, with a bitmap, the length of the vector represents the range of unique values in the set (in this case `0-20`), and the `0/1` represents whether or not the current index is equal to a value in the set.\n\nTask:\nYour task is to write a function `toBits` that will take in a set of uniqe integers and output a bit vector/bitmap (an array in javascript) using `1`s and `0`s to represent present and non-present values.\nInput:\nThe function will be passed a set of unique integers in string form, in a random order, separated by line breaks.\nEach integer can be expected to have a unique value `>= 0` and `< 5000`.\nThe input will look like this:\n`let exampleInput = '3\\n14\\n5\\n19\\n18\\n1\\n8\\n11\\n2...'`\nOutput:\nThe function will be expected to output a 5000 bit vector (array) of bits, either `0` or `1`, for example:\n`let exampleOutput = [0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0,...]`\nMore in-depth bitmap kata coming very soon, happy coding!\nTo learn more about bitmapping and to see the inspiration for making these kata, checkout the book Programming Pearls by Jon Bently.  It's a powerful resource for any programmer!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def to_bits (s : String) : List Nat := sorry\n\ntheorem to_bits_length (s : String) (h : ∃ nums : List Nat, \n    (∀ n ∈ nums, n < 5000) ∧ \n    (s = String.intercalate \"\\n\" (nums.map toString))) : \n  (to_bits s).length = 5000 := sorry", "vc-theorems": "theorem to_bits_binary (s : String) (h : ∃ nums : List Nat, \n    (∀ n ∈ nums, n < 5000) ∧ \n    (s = String.intercalate \"\\n\" (nums.map toString))) :\n  ∀ x ∈ to_bits s, x = 0 ∨ x = 1 := sorry\n\ntheorem to_bits_indices {nums : List Nat} (s : String) (h : \n    (∀ n ∈ nums, n < 5000) ∧ \n    (s = String.intercalate \"\\n\" (nums.map toString))) :\n  ((List.enum (to_bits s)).filter (fun p => p.2 = 1)).map Prod.fst = nums := sorry\n\ntheorem to_bits_invalid_chars (s : String) :\n  (∃ c ∈ s.data, ¬(c = '\\n' ∨ ('0' ≤ c ∧ c ≤ '9'))) →\n  to_bits s = [] := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3354", "language": "lean", "source": "fvapps", "source-id": "fvapps_003354", "source-notes": "", "vc-description": "/-\nSome new cashiers started to work at your restaurant. \n\nThey are good at taking orders, but they don't know how to capitalize words, or use a space bar! \n\nAll the orders they create look something like this:\n\n`\"milkshakepizzachickenfriescokeburgerpizzasandwichmilkshakepizza\"`\n\nThe kitchen staff are threatening to quit, because of how difficult it is to read the orders. \n\nTheir preference is to get the orders as a nice clean string with spaces and capitals like so:\n\n`\"Burger Fries Chicken Pizza Pizza Pizza Sandwich Milkshake Milkshake Coke\"`\n\nThe kitchen staff expect the items to be in the same order as they appear in the menu. \n\nThe menu items are fairly simple, there is no overlap in the names of the items:\n```\n1. Burger\n2. Fries\n3. Chicken\n4. Pizza\n5. Sandwich\n6. Onionrings\n7. Milkshake\n8. Coke\n```\n-/", "vc-preamble": "def get_order (order: String) : String := sorry\n\ndef to_lower (s: String) : String := sorry\n\ndef to_capital (s: String) : String := sorry\ndef string_split (s: String) : List String := sorry\n\ndef menu_item_to_nat (m: MenuItem) : Nat :=\n  match m with\n  | .burger => 0\n  | .fries => 1\n  | .chicken => 2\n  | .pizza => 3\n  | .sandwich => 4\n  | .onionrings => 5\n  | .milkshake => 6\n  | .coke => 7", "vc-helpers": "", "vc-definitions": "def string_to_menu_item? (s: String) : Option MenuItem := sorry\n\ndef string_eq_dec (s1 s2: String) : Decidable (s1 = s2) := inferInstance", "vc-theorems": "theorem get_order_preserves_items (items: List MenuItem) (order: String) :\n  let result := string_split (get_order order)\n  ∀ item, items.contains item → result.contains (to_capital (toString item)) := sorry\n\ntheorem get_order_maintains_menu_order (items: List MenuItem) (order: String) : \n  let result := string_split (get_order order)\n  ∀ s1 s2, result.contains s1 → result.contains s2 → ∀ m1 m2,\n    string_to_menu_item? s1 = some m1 → \n    string_to_menu_item? s2 = some m2 →\n    result.indexOf s1 ≤ result.indexOf s2 → \n    menu_item_to_nat m1 ≤ menu_item_to_nat m2 := sorry\n\ntheorem get_order_counts_match (items: List MenuItem) (order: String) :\n  let result := string_split (get_order order)\n  ∀ item: MenuItem, \n    (items.filter (fun x => x = item)).length = \n    (result.filter (fun x => to_lower x = toString item)).length := sorry\n\ntheorem get_order_only_valid_items (s: String) :\n  let result := string_split (get_order s)\n  ∀ item, result.contains item → ∃ m: MenuItem, to_lower item = toString m := sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval get_order \"burgerfriesfriesfriesfriesfriespizzasandwichcokefriesburger\"\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval get_order \"milkshakepizzachickenfriescokeburgerpizzasandwichmilkshakepizza\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3357", "language": "lean", "source": "fvapps", "source-id": "fvapps_003357", "source-notes": "", "vc-description": "/-\nImplement a function that normalizes out of range sequence indexes (converts them to 'in range' indexes) by making them repeatedly 'loop' around the array. The function should then return the value at that index. Indexes that are not out of range should be handled normally and indexes to empty sequences should return undefined/None depending on the language.\n\nFor positive numbers that are out of range, they loop around starting at the beginning, so \n\n```python\nnorm_index_test(seq, len(seq))     # Returns first element\nnorm_index_test(seq, len(seq) + 1) # Returns second element\nnorm_index_test(seq, len(seq) + 2) # Returns third element\n# And so on...\nnorm_index_test(seq, len(seq) * 2) # Returns first element\n```\n\nFor negative numbers, they loop starting from the end, so\n\n```python norm_index_test(seq, len(seq))\nnorm_index_test(seq, -1)        # Returns last element\nnorm_index_test(seq, -2)        # Returns second to last element\nnorm_index_test(seq, -3)        # Returns third to last element\n# And so on...\nnorm_index_test(seq, -len(seq)) # Returns first element\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def norm_index_test {α : Type} [Inhabited α] (s : List α) (i : Int) : Option α := sorry \n\ntheorem norm_index_empty_sequence {α : Type} [Inhabited α] (i : Int) :\n  @norm_index_test α _ [] i = none := sorry", "vc-theorems": "theorem norm_index_nonempty_sequence {α : Type} [Inhabited α] (s : List α) (i : Int) :\n  s ≠ [] → @norm_index_test α _ s i = some (s.get! (Int.toNat (Int.mod i s.length))) := sorry\n\ntheorem norm_index_wrapping {α : Type} [Inhabited α] (s : List α) (i : Int) :\n  s ≠ [] → \n  @norm_index_test α _ s i = @norm_index_test α _ s (i + s.length) ∧ \n  @norm_index_test α _ s i = @norm_index_test α _ s (i - s.length) := sorry\n\ntheorem norm_index_identity {α : Type} [Inhabited α] (s : List α) :\n  s ≠ [] →\n  ∀ i : Nat, i < s.length → @norm_index_test α _ s i = some (s.get! i) := sorry\n\ntheorem norm_index_negative {α : Type} [Inhabited α] (s : List α) :\n  s ≠ [] →\n  ∀ i : Nat, i < s.length → \n  @norm_index_test α _ s (-i-1) = some (s.get! (s.length - i - 1)) := sorry\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval norm_index_test [] 10\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval norm_index_test [1, 2, 3] 3\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval norm_index_test test_seq 4\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval norm_index_test test_seq 6\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval norm_index_test test_seq -1\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval norm_index_test test_seq -4\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval norm_index_test test_seq -6", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3362", "language": "lean", "source": "fvapps", "source-id": "fvapps_003362", "source-notes": "", "vc-description": "/-\nFor every good kata idea there seem to be quite a few bad ones!\n\nIn this kata you need to check the provided 2 dimensional array (x) for good ideas 'good' and bad ideas 'bad'. If there are one or two good ideas, return 'Publish!', if there are more than 2 return 'I smell a series!'. If there are no good ideas, as is often the case, return 'Fail!'.\n\nThe sub arrays may not be the same length.\n\nThe solution should be case insensitive (ie good, GOOD and gOOd all count as a good idea). All inputs may not be strings.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def well (arr: List (List String)) : String := sorry\n\ntheorem well_output_is_valid (arr: List (List String)) : \n  well arr = \"Fail!\" ∨ well arr = \"Publish!\" ∨ well arr = \"I smell a series!\" := sorry", "vc-theorems": "theorem well_count_good_matches (arr: List (List String)) :\n  let goodCount := (arr.join.filter (fun x => x.toLower = \"good\")).length\n  well arr = (if goodCount > 2 then \"I smell a series!\"\n             else if goodCount > 0 then \"Publish!\"\n             else \"Fail!\") := sorry\n\ntheorem well_all_bad (arr: List (List String))\n  (h: ∀ l ∈ arr, ∀ s ∈ l, s = \"bad\") : \n  well arr = \"Fail!\" := sorry\n\ntheorem well_all_good (arr: List (List String))\n  (h: ∀ l ∈ arr, ∀ s ∈ l, s = \"good\") :\n  let totalGood := arr.join.length\n  well arr = (if totalGood > 2 then \"I smell a series!\" else \"Publish!\") := sorry\n\n/-\ninfo: 'Fail!'\n-/\n-- #guard_msgs in\n-- #eval well [[\"bad\", \"bAd\", \"bad\"], [\"bad\", \"bAd\", \"bad\"], [\"bad\", \"bAd\", \"bad\"]]\n\n/-\ninfo: 'Publish!'\n-/\n-- #guard_msgs in\n-- #eval well [[\"gOOd\", \"bad\", \"BAD\", \"bad\", \"bad\"], [\"bad\", \"bAd\", \"bad\"], [\"GOOD\", \"bad\", \"bad\", \"bAd\"]]\n\n/-\ninfo: 'I smell a series!'\n-/\n-- #guard_msgs in\n-- #eval well [[\"gOOd\", \"bAd\", \"BAD\", \"bad\", \"bad\", \"GOOD\"], [\"bad\"], [\"gOOd\", \"BAD\"]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3363", "language": "lean", "source": "fvapps", "source-id": "fvapps_003363", "source-notes": "", "vc-description": "/-\nA lot of goods have an  International Article Number (formerly known as \"European Article Number\") abbreviated \"EAN\". EAN is a 13-digits barcode consisting of 12-digits data followed by a single-digit checksum (EAN-8 is not considered in this kata).\n\nThe single-digit checksum is calculated as followed (based upon the 12-digit data):\n\nThe digit at the first, third, fifth, etc. position (i.e. at the odd position) has to be multiplied with \"1\". \nThe digit at the second, fourth, sixth, etc. position (i.e. at the even position) has to be multiplied with \"3\".\nSum these results. \n\nIf this sum is dividable by 10, the checksum is 0. Otherwise the checksum has the following formula:\n\n  checksum = 10 - (sum mod 10)\n\nFor example, calculate the checksum for \"400330101839\" (= 12-digits data):\n\n4·1 + 0·3 + 0·1 + 3·3 + 3·1 + 0·3 + 1·1 + 0·3 + 1·1 + 8·3 + 3·1 + 9·3\n= 4 + 0 + 0 + 9 + 3 + 0 + 1 + 0 + 1 + 24 + 3 + 27 \n= 72\n10 - (72 mod 10) = 8 ⇒ Checksum: 8\n\nThus, the EAN-Code is 4003301018398 (= 12-digits data followed by single-digit checksum).\n\nYour Task\nValidate a given EAN-Code. Return true if the given EAN-Code is valid, otherwise false.\n\nAssumption\nYou can assume the given code is syntactically valid, i.e. it only consists of numbers and it exactly has a length of 13 characters.\n\nExamples\n\n```python\nvalidate_ean(\"4003301018398\") # => True\nvalidate_ean(\"4003301018392\") # => False\n```\n\nGood Luck and have fun.\n-/", "vc-preamble": "def calculateCheckDigit (code : String) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def validateEAN (code : String) : Bool :=\n  sorry", "vc-theorems": "theorem valid_ean_with_check_digit {code : String} (h1 : code.length = 12) (h2 : ∀ c ∈ code.data, '0' ≤ c ∧ c ≤ '9') : \n  validateEAN (code ++ toString (calculateCheckDigit code)) = true :=\nsorry\n\ntheorem invalid_ean_check {code : String} (h1 : code.length = 13) (h2 : ∀ c ∈ code.data, '0' ≤ c ∧ c ≤ '9') :\n  ¬(validateEAN code) →\n  let digits := code.data.map (fun c => c.toNat - '0'.toNat)\n  ((digits.enum.foldl (fun acc (i, d) => acc + if i % 2 = 0 then d else d * 3) 0) % 10 ≠ 0) :=\nsorry\n\ntheorem ean_length_requirement {code : String} :\n  validateEAN code → code.length = 13 :=\nsorry\n\ntheorem ean_digits_only {code : String} (h : ∃ c ∈ code.data, ¬('0' ≤ c ∧ c ≤ '9')) :\n  ¬(validateEAN code) :=\nsorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval validate_ean \"4003301018398\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval validate_ean \"4003301018392\"\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval validate_ean \"9783815820865\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3367", "language": "lean", "source": "fvapps", "source-id": "fvapps_003367", "source-notes": "", "vc-description": "/-\nIn this Kata, you're to complete the function `sum_square_even_root_odd`.\n\nYou will be given a list of numbers, `nums`, as the only argument to the function. Take each number in the list and *square* it if it is even, or *square root* the number if it is odd. Take this new list and find the *sum*, rounding to two decimal places.\n\nThe list will never be empty and will only contain values that are greater than or equal to zero.\n\nGood luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sum_square_even_root_odd (nums : List Nat) : Float := sorry\n\ntheorem sum_square_even_root_odd_nonneg (nums : List Nat) :\n  sum_square_even_root_odd nums ≥ 0 := sorry", "vc-theorems": "theorem sum_square_even_root_odd_equals_sum (nums : List Nat) :\n  let expected := nums.foldr (fun n acc => \n    acc + if n % 2 = 0 \n      then Float.ofNat (n * n)\n      else Float.sqrt (Float.ofNat n)) (0 : Float);\n  Float.abs (sum_square_even_root_odd nums - expected) < 0.1 := sorry\n\ntheorem large_evens_dominate (nums : List Nat) (max_even : Nat) :\n  max_even = (nums.filter (fun n => n % 2 = 0)).maximum?.getD 0 →\n  max_even > 10 → \n  sum_square_even_root_odd nums ≥ Float.ofNat max_even := sorry\n\n/-\ninfo: 91.61\n-/\n-- #guard_msgs in\n-- #eval sum_square_even_root_odd [4, 5, 7, 8, 1, 2, 3, 0]\n\n/-\ninfo: 272.71\n-/\n-- #guard_msgs in\n-- #eval sum_square_even_root_odd [1, 14, 9, 8, 17, 21]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3371", "language": "lean", "source": "fvapps", "source-id": "fvapps_003371", "source-notes": "", "vc-description": "/-\nGiven the number n, return a string which shows the minimum number of moves to complete the tower of Hanoi consisting of n layers.\nTower of Hanoi : https://en.wikipedia.org/wiki/Tower_of_Hanoi\n\nExample - 2 layered Tower of Hanoi \n\nInput: n=2\n\nStart\n[[2, 1], [], []]\n\nGoal\n[[], [], [2, 1]]\n\nExpected Output : '[[2, 1], [], []]\\n[[2], [1], []]\\n[[], [1], [2]]\\n[[], [], [2, 1]]'\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def hanoi_array (n : Nat) : String :=\n  sorry\n\n-- A valid tower has elements in strictly decreasing order", "vc-theorems": "theorem tower_ordering {n : Nat} (tower : List Nat) : \n  tower.length ≥ 2 → ∀ i, i + 1 < tower.length → \n  tower.get! i > tower.get! (i+1) :=\n  sorry\n\n-- Each state has exactly 3 towers\n\ntheorem three_towers {n : Nat} (state : List (List Nat)) :\n  state.length = 3 :=\n  sorry\n\n-- All numbers from 1 to n appear exactly once across all towers\n\ntheorem numbers_complete {n : Nat} (state : List (List Nat)) :\n  (∀ x ∈ state.join, x ≤ n) ∧\n  ∀ k, k ≤ n → k > 0 → k ∈ state.join :=\n  sorry\n\n-- There are exactly 2^n states in the solution\n\ntheorem states_count {n : Nat} (states : List (List (List Nat))) :\n  states.length = 2^n :=\n  sorry\n\n-- Initial state has all discs on first pole\n\ntheorem initial_state {n : Nat} (states : List (List (List Nat))) :\n  states.head!.get! 0 = List.range' n n ∧\n  states.head!.get! 1 = [] ∧ \n  states.head!.get! 2 = [] :=\n  sorry\n\n-- Final state has all discs on last pole\n\ntheorem final_state {n : Nat} (states : List (List (List Nat))) :\n  states.getLast!.get! 0 = [] ∧\n  states.getLast!.get! 1 = [] ∧\n  states.getLast!.get! 2 = List.range' n n :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3382", "language": "lean", "source": "fvapps", "source-id": "fvapps_003382", "source-notes": "", "vc-description": "/-\nGiven two integer arrays where the second array is a shuffled duplicate of the first array with one element missing, find the missing element.\n\nPlease note, there may be duplicates in the arrays, so checking if a numerical value exists in one and not the other is not a valid solution.\n\n```\nfind_missing([1, 2, 2, 3], [1, 2, 3]) => 2\n```\n```\nfind_missing([6, 1, 3, 6, 8, 2], [3, 6, 6, 1, 2]) => 8\n```\n\nThe first array will always have at least one element.\n-/", "vc-preamble": "def List.sum : List Int → Int  \n  | [] => 0\n  | (x::xs) => x + List.sum xs", "vc-helpers": "", "vc-definitions": "def List.sort : List Int → List Int := sorry\n\ndef find_missing (arr1 : List Int) (arr2 : List Int) : Int := sorry", "vc-theorems": "theorem removing_element_gives_correct_difference \n  (arr : List Int) (elem : Int) :\n  find_missing (arr ++ [elem]) arr = elem := sorry\n\ntheorem identical_arrays_difference_is_zero\n  (arr : List Int) (h : arr ≠ []) :\n  find_missing arr arr = 0 := sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval find_missing [1, 2, 3] [1, 3]\n\n/-\ninfo: 8\n-/\n-- #guard_msgs in\n-- #eval find_missing [6, 1, 3, 6, 8, 2] [3, 6, 6, 1, 2]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval find_missing [0, 0, 0, 0, 0] [0, 0, 0, 0]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3388", "language": "lean", "source": "fvapps", "source-id": "fvapps_003388", "source-notes": "", "vc-description": "/-\n### Task\n King Arthur and his knights are having a New Years party. Last year Lancelot was jealous of Arthur, because Arthur had a date and Lancelot did not, and they started a duel.\n\n To prevent this from happening again, Arthur wants to make sure that there are at least as many women as men at this year's party. He gave you a list of integers of all the party goers. \n\n Arthur needs you to return true if he needs to invite more women or false if he is all set.\n\n### Input/Output\n\n - `[input]` integer array `L` (`$a` in PHP)\n\n  An array (guaranteed non-associative in PHP) representing the genders of the attendees, where `-1` represents `women` and `1` represents `men`.\n\n  `2 <= L.length <= 50`\n\n- `[output]` a boolean value\n\n  `true` if Arthur need to invite more women, `false` otherwise.\n-/", "vc-preamble": "def List.sum : List Int → Int \n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def invite_more_women (arr : List Int) : Bool := sorry\n\ntheorem invite_more_women_sum_property (arr : List Int) \n  (h : arr.length > 0)\n  (h₁ : ∀ x ∈ arr, x = 1 ∨ x = -1) :\n  invite_more_women arr = (List.sum arr > 0) := sorry", "vc-theorems": "theorem party_balance_monotonicity (arr : List Int)\n  (h : arr.length > 0)\n  (h₁ : ∀ x ∈ arr, x = 1 ∨ x = -1) :\n  invite_more_women (arr ++ [-1]) ≤ invite_more_women arr ∧ \n  invite_more_women arr ≤ invite_more_women (arr ++ [1]) := sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval invite_more_women [1, -1, 1]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval invite_more_women [-1, -1, -1]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval invite_more_women [1, -1]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3392", "language": "lean", "source": "fvapps", "source-id": "fvapps_003392", "source-notes": "", "vc-description": "/-\nComplete the function that takes one argument, a list of words, and returns the length of the longest word in the list.\n\nFor example: \n\n```python\n['simple', 'is', 'better', 'than', 'complex'] ==> 7\n```\n\nDo not modify the input list.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longest (words : List String) : Nat :=\n  sorry\n\n@[simp]", "vc-theorems": "theorem longest_equals_max_length (words : List String) (h : words ≠ []) :\n  longest words = (words.map String.length).maximum?.getD 0\n  := by sorry\n\ntheorem longest_min_length_5 (words : List String) (h₁ : words ≠ []) \n  (h₂ : ∀ w ∈ words, String.length w ≥ 5) :\n  longest words ≥ 5\n  := by sorry\n\ntheorem longest_max_length_10 (words : List String) (h₁ : words ≠ []) \n  (h₂ : ∀ w ∈ words, String.length w ≤ 10) :\n  longest words ≤ 10\n  := by sorry\n\ntheorem longest_empty_list :\n  longest [] = 0 ∧ longest [] ≠ longest [\"a\"]\n  := by sorry\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval longest [\"simple\", \"is\", \"better\", \"than\", \"complex\"]\n\n/-\ninfo: 8\n-/\n-- #guard_msgs in\n-- #eval longest [\"explicit\", \"is\", \"better\", \"than\", \"implicit\"]\n\n/-\ninfo: 9\n-/\n-- #guard_msgs in\n-- #eval longest [\"beautiful\", \"is\", \"better\", \"than\", \"ugly\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3420", "language": "lean", "source": "fvapps", "source-id": "fvapps_003420", "source-notes": "", "vc-description": "/-\nIn this kata, your task is to identify the pattern underlying a sequence of numbers. For example, if the sequence is [1, 2, 3, 4, 5], then the pattern is [1], since each number in the sequence is equal to the number preceding it, plus 1. See the test cases for more examples.\n\nA few more rules :\n\npattern may contain negative numbers.\nsequence will always be made of a whole number of repetitions of the pattern.\nYour answer must correspond to the shortest form of the pattern, e.g. if the pattern is [1], then [1, 1, 1, 1] will not be considered a correct answer.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def findPattern (sequence : List Int) : Option (List Int) := sorry\n\ndef differencesSeq (sequence : List Int) : List Int :=\n  (sequence.zip (sequence.drop 1)).map (fun (x, y) => y - x)", "vc-theorems": "theorem valid_differences_pattern (sequence : List Int) (h : sequence.length ≥ 2) : \n  match findPattern sequence with\n  | none => True \n  | some pattern =>\n    let diffs := differencesSeq sequence\n    -- Pattern length divides sequence length\n    diffs.length % pattern.length = 0 ∧\n    -- Pattern matches when repeated\n    let repeatedPattern := List.replicate (diffs.length / pattern.length) pattern |>.join\n    List.zip diffs repeatedPattern |>.all (fun (a, b) => a = b)\n  := sorry\n\ntheorem minimal_pattern (sequence : List Int) (h : sequence.length ≥ 2) :\n  match findPattern sequence with\n  | none => True\n  | some pattern =>\n    let diffs := differencesSeq sequence\n    ∀ i : Nat, 1 ≤ i → i < pattern.length → diffs.length % i = 0 →\n      let shortPattern := diffs.take i\n      let repeatedShortPattern := List.replicate (diffs.length / i) shortPattern |>.join\n      ¬(List.zip diffs repeatedShortPattern |>.all (fun (a, b) => a = b))\n  := sorry\n\ntheorem arithmetic_sequence_pattern (d : Int) (len : Nat) (h₁ : 1 ≤ d ∧ d ≤ 9) (h₂ : 2 ≤ len ∧ len ≤ 100) :\n  let arithmetic := List.range len |>.map (fun n => Int.ofNat n * d)\n  match findPattern arithmetic with\n  | none => False\n  | some pattern =>\n    pattern.length = 1 ∧ pattern.head! = d\n  := sorry\n\n/-\ninfo: [1]\n-/\n-- #guard_msgs in\n-- #eval find_pattern [1, 2, 3, 4, 5]\n\n/-\ninfo: [1, 1, 1, 1, -1, -1, -1, -1]\n-/\n-- #guard_msgs in\n-- #eval find_pattern [1, 2, 3, 4, 5, 4, 3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]\n\n/-\ninfo: [1, 2, -1, -2, -2, 1, 2, -1, -2]\n-/\n-- #guard_msgs in\n-- #eval find_pattern [4, 5, 7, 6, 4, 2, 3, 5, 4, 2, 3, 5, 4, 2, 0, 1, 3, 2, 0, 1, 3, 2, 0, -2, -1, 1, 0, -2]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3425", "language": "lean", "source": "fvapps", "source-id": "fvapps_003425", "source-notes": "", "vc-description": "/-\nIn some ranking people collects points. The challenge is sort by points and calulate position for every person. But remember if two or more persons have same number of points, they should have same position number and sorted by name (name is unique).\n\nFor example:\nInput structure:\n\nOutput should be:\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ranking (players : List Player) : List Player :=\n  sorry", "vc-theorems": "theorem ranking_length_preservation (players : List Player) :\n  (ranking players).length = players.length :=\n  sorry\n\ntheorem ranking_min_position (players : List Player) :\n  players ≠ [] → \n  (List.map Player.position (ranking players)).head! > 0 ∧\n  (List.map Player.position (ranking players)).head! ≤ 1 :=\n  sorry\n\ntheorem ranking_equal_points_equal_position (players : List Player) :\n  ∀ i : Nat, i + 1 < (ranking players).length →\n    let result := ranking players\n    (result[i]!.points = result[i+1]!.points) →\n    (result[i]!.position = result[i+1]!.position) :=\n  sorry\n\ntheorem ranking_points_position_relation (players : List Player) :\n  ∀ i : Nat, i + 1 < (ranking players).length →\n    let result := ranking players\n    (result[i]!.points > result[i+1]!.points) →\n    (result[i]!.position < result[i+1]!.position) :=\n  sorry\n\ntheorem ranking_points_descending (players : List Player) :\n  ∀ i : Nat, i + 1 < (ranking players).length →\n    let result := ranking players\n    result[i]!.points ≥ result[i+1]!.points :=\n  sorry\n\ntheorem ranking_names_ascending_same_points (players : List Player) :\n  ∀ i : Nat, i + 1 < (ranking players).length →\n    let result := ranking players\n    result[i]!.points = result[i+1]!.points →\n    result[i]!.name ≤ result[i+1]!.name :=\n  sorry\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval ranking []", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3428", "language": "lean", "source": "fvapps", "source-id": "fvapps_003428", "source-notes": "", "vc-description": "/-\nA group of friends (n >= 2) have reunited for a get-together after \na very long time. \n\nThey agree that they will make presentations on holiday destinations \nor expeditions they have been to only if it satisfies **one simple rule**: \n> the holiday/journey being presented must have been visited _only_ by the presenter and no one else from the audience.\n\nWrite a program to output the presentation agenda, including the\npresenter and their respective presentation titles. \n\n---\n### EXAMPLES\n\n```python\npresentation_agenda([\n    {'person': 'Abe', 'dest': ['London', 'Dubai']},\n    {'person': 'Bond', 'dest': ['Melbourne', 'Dubai']}\n]) == [{'person': 'Abe', 'dest': ['London']},\n       {'person': 'Bond', 'dest': ['Melbourne']}]\n\npresentation_agenda([\n    {'person': 'Abe', 'dest': ['Dubai']},\n    {'person': 'Brad', 'dest': ['Dubai']}\n]) == []\n\npresentation_agenda([\n    {'person': 'Abe', 'dest': ['London', 'Dubai']},\n    {'person': 'Bond', 'dest': ['Melbourne', 'Dubai']},\n    {'person': 'Carrie', 'dest': ['Melbourne']},\n    {'person': 'Damu', 'dest': ['Melbourne', 'Dubai', 'Paris']}\n]) == [{'person': 'Abe',  'dest': ['London']},\n       {'person': 'Damu', 'dest': ['Paris']}]\n\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def presentation_agenda (friend_list : List Person) : List Person :=\n  sorry", "vc-theorems": "theorem presentation_agenda_structure (friend_list : List Person) :\n  let result := presentation_agenda friend_list\n  -- Result destinations should be subset of input destinations \n  ∀ p, p ∈ result → ∀ d, d ∈ p.dest → ∃ p', p' ∈ friend_list ∧ d ∈ p'.dest :=\n  sorry\n\ntheorem presentation_agenda_unique_dests (friend_list : List Person) :\n  let result := presentation_agenda friend_list\n  -- Each destination appears exactly once in result\n  ∀ d : String, (∃ p, p ∈ result ∧ d ∈ p.dest) → \n    ∀ p₁ p₂, p₁ ∈ result → p₂ ∈ result → d ∈ p₁.dest → d ∈ p₂.dest → p₁ = p₂ :=\n  sorry\n\ntheorem presentation_agenda_valid_people (friend_list : List Person) :\n  let result := presentation_agenda friend_list\n  -- All people in result come from input\n  ∀ p, p ∈ result → ∃ p', p' ∈ friend_list ∧ p.person = p'.person :=\n  sorry\n\ntheorem presentation_agenda_nonempty_dests (friend_list : List Person) :\n  let result := presentation_agenda friend_list\n  -- Everyone has at least one destination\n  ∀ p, p ∈ result → p.dest.length > 0 :=\n  sorry\n\ntheorem presentation_agenda_unique_input_dests (friend_list : List Person) :\n  let result := presentation_agenda friend_list\n  -- Destinations in result appeared exactly once in input\n  ∀ p, p ∈ result → ∀ d, d ∈ p.dest →\n    (friend_list.filter (fun p' => d ∈ p'.dest)).length = 1 :=\n  sorry\n\ntheorem presentation_agenda_shared_empty (friend_list : List Person) (d : String) :\n  friend_list.length ≥ 2 →\n  (∀ p, p ∈ friend_list → p.dest = [d]) →\n  presentation_agenda friend_list = [] :=\n  sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval presentation_agenda [{\"person\": \"Abe\", \"dest\": [\"London\", \"Dubai\"]}, {\"person\": \"Bond\", \"dest\": [\"Melbourne\", \"Dubai\"]}]\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval presentation_agenda [{\"person\": \"Abe\", \"dest\": [\"Dubai\"]}, {\"person\": \"Brad\", \"dest\": [\"Dubai\"]}]\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval presentation_agenda [{\"person\": \"Abe\", \"dest\": [\"London\", \"Dubai\"]}, {\"person\": \"Bond\", \"dest\": [\"Melbourne\", \"Dubai\"]}, {\"person\": \"Carrie\", \"dest\": [\"Melbourne\"]}, {\"person\": \"Damu\", \"dest\": [\"Melbourne\", \"Dubai\", \"Paris\"]}]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3430", "language": "lean", "source": "fvapps", "source-id": "fvapps_003430", "source-notes": "", "vc-description": "/-\nAn array is called `zero-balanced` if its elements sum to `0` and for each positive element `n`, there exists another element that is the negative of `n`. Write a function named `ìsZeroBalanced` that returns `true` if its argument is `zero-balanced` array, else return `false`. Note that an `empty array` will not sum to `zero`.\n-/", "vc-preamble": "def List.sum : List Int → Int \n  | [] => 0\n  | x::xs => x + xs.sum", "vc-helpers": "", "vc-definitions": "def isZeroBalanced (arr : List Int) : Bool := sorry\n\ntheorem empty_array_not_balanced {arr : List Int} :\n  arr = [] → ¬(isZeroBalanced arr) := sorry", "vc-theorems": "theorem balanced_implies_sum_zero {arr : List Int} :\n  isZeroBalanced arr → (arr.sum = 0) := sorry\n\ntheorem balanced_implies_equal_frequencies {arr : List Int} :\n  isZeroBalanced arr → ∀ x, (List.countP (· = x) arr) = (List.countP (· = -x) arr) := sorry \n\ntheorem all_zeros_array_balanced {arr : List Int} :\n  arr ≠ [] → (∀ x ∈ arr, x = 0) → isZeroBalanced arr := sorry\n\ntheorem reverse_preserves_balance {arr : List Int} :\n  isZeroBalanced arr → isZeroBalanced arr.reverse := sorry\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval is_zero_balanced []\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval is_zero_balanced [0, 1, -1]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval is_zero_balanced [3, -2, -1]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3431", "language": "lean", "source": "fvapps", "source-id": "fvapps_003431", "source-notes": "", "vc-description": "/-\nA core idea of several left-wing ideologies is that the wealthiest should *support* the poorest, no matter what and that is exactly what you are called to do using this kata (which, on a side note, was born out of the necessity to redistribute the width of `div`s into a given container).\n\nYou will be given two parameters, `population` and `minimum`: your goal is to give to each one according to his own needs (which we assume to be equal to `minimum` for everyone, no matter what), taking from the richest (bigger numbers) first.\n\nFor example, assuming a population `[2,3,5,15,75]` and `5` as a minimum, the expected result should be `[5,5,5,15,70]`. Let's punish those filthy capitalists, as we all know that being rich has to be somehow a fault and a shame!\n\nIf you happen to have few people as the richest, just take from the ones with the lowest index (the closest to the left, in few words) in the array first, on a 1:1 based heroic proletarian redistribution, until everyone is satisfied.\n\nTo clarify this rule, assuming a population `[2,3,5,45,45]` and `5` as `minimum`, the expected result should be `[5,5,5,42,43]`.\n\nIf you want to see it in steps, consider removing `minimum` from every member of the population, then iteratively (or recursively) adding 1 to the poorest while removing 1 from the richest. Pick the element most at left if more elements exist with the same level of minimal poverty, as they are certainly even more aligned with the party will than other poor people; similarly, it is ok to take from the richest one on the left first, so they can learn their lesson and be more kind, possibly giving more *gifts* to the inspectors of the State!\n\nIn steps:\n```\n[ 2, 3, 5,45,45] becomes\n[-3,-2, 0,40,40] that then becomes\n[-2,-2, 0,39,40] that then becomes\n[-1,-2, 0,39,39] that then becomes\n[-1,-1, 0,38,39] that then becomes\n[ 0,-1, 0,38,38] that then becomes\n[ 0, 0, 0,37,38] that then finally becomes (adding the minimum again, as no value is no longer under the poverty threshold\n[ 5, 5, 5,42,43]\n```\n\nIf giving `minimum` is unfeasable with the current resources (as it often comes to be the case in socialist communities...), for example if the above starting population had set a goal of giving anyone at least `30`, just return an empty array `[]`.\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | x :: xs => x + List.sum xs\n\ndef List.modifyNth (xs : List α) (n : Nat) (v : α) : List α :=\n  match n, xs with\n  | _, [] => []\n  | 0, x :: xs => v :: xs\n  | n + 1, x :: xs => x :: modifyNth xs n v", "vc-helpers": "", "vc-definitions": "def Nat.abs (n : Nat) : Nat := n\n\ndef socialist_distribution (population : List Nat) (minimum : Nat) : Option (List Nat) :=\n  sorry", "vc-theorems": "theorem socialist_distribution_properties {population : List Nat} {minimum : Nat}\n  (h : population ≠ []) :\n  match socialist_distribution population minimum with\n  | none => minimum > List.sum population / List.length population\n  | some result => \n      (List.length result = List.length population) ∧ \n      (List.sum result = List.sum population) ∧\n      (∀ x ∈ result, x ≥ minimum) ∧\n      (∀ x ∈ result, x ≥ 0) ∧\n      (∀ i j, i < List.length result → j < List.length result → i ≠ j →\n        let swapped := result.modifyNth i (result.get! j) |>.modifyNth j (result.get! i)\n        (∀ x ∈ swapped, x ≥ minimum) →\n        List.sum (List.zipWith (·-·) population result |>.map Nat.abs) ≤ \n        List.sum (List.zipWith (·-·) population swapped |>.map Nat.abs))\n  := by sorry\n\ntheorem minimum_zero_returns_original {population : List Nat} (h : population ≠ []) :\n  socialist_distribution population 0 = some population := by sorry\n\n/-\ninfo: [5, 5, 5, 15, 70]\n-/\n-- #guard_msgs in\n-- #eval socialist_distribution [2, 3, 5, 15, 75] 5\n\n/-\ninfo: [5, 5, 5, 42, 43]\n-/\n-- #guard_msgs in\n-- #eval socialist_distribution [2, 3, 5, 45, 45] 5\n\n/-\ninfo: [20, 20, 20, 20, 20]\n-/\n-- #guard_msgs in\n-- #eval socialist_distribution [2, 3, 5, 15, 75] 20", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3433", "language": "lean", "source": "fvapps", "source-id": "fvapps_003433", "source-notes": "", "vc-description": "/-\nYour task is to get Zodiac Sign using input ```day``` and ```month```.\n\nFor exapmle: \n\n```python\nget_zodiac_sign(1,5) => 'Taurus'\nget_zodiac_sign(10,10) => 'Libra'\n```\n\nCorrect answers are (preloaded): \n```python\nSIGNS = ['Capricorn', 'Aquarius', 'Pisces', 'Aries', 'Taurus', 'Gemini', 'Cancer', 'Leo', 'Virgo', 'Libra', 'Scorpio', 'Sagittarius']\n```\n\nP.S. Each argument is correct integer number.\n\nWESTERN ASTROLOGY STAR SIGN DATES\n\n* Aries (March 21-April 19)\n* Taurus (April 20-May 20)\n* Gemini (May 21-June 20)\n* Cancer (June 21-July 22)\n* Leo (July 23-August 22)\n* Virgo (August 23-September 22)\n* Libra (September 23-October 22)\n* Scorpio (October 23-November 21)\n* Sagittarius (November 22-December 21)\n* Capricorn (December 22-January 19)\n* Aquarius (January 20 to February 18)\n* Pisces (February 19 to March 20)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_zodiac_sign (day : Nat) (month : Nat) : ZodiacSign := sorry\n\ntheorem zodiac_sign_january_ranges (day : Nat) (h1 : 1 ≤ day) (h2 : day ≤ 31) :\n  day ≤ 19 → get_zodiac_sign day 1 = ZodiacSign.Capricorn ∧\n  day ≥ 20 → get_zodiac_sign day 1 = ZodiacSign.Aquarius := sorry", "vc-theorems": "theorem zodiac_sign_year_boundaries :\n  get_zodiac_sign 1 1 = ZodiacSign.Capricorn ∧ \n  get_zodiac_sign 31 12 = ZodiacSign.Capricorn := sorry\n\ntheorem zodiac_sign_february_special :\n  get_zodiac_sign 19 2 = ZodiacSign.Pisces := sorry\n\ntheorem zodiac_sign_valid_days (month : Nat) (day : Nat)\n  (h1 : 1 ≤ month) (h2 : month ≤ 12) (h3 : 1 ≤ day) :\n  (month ∈ [4,6,9,11] → day ≤ 30) →\n  (month = 2 → day ≤ 29) →\n  (month ∉ [2,4,6,9,11] → day ≤ 31) → \n  ∃ sign : ZodiacSign, get_zodiac_sign day month = sign := sorry\n\n/-\ninfo: 'Libra'\n-/\n-- #guard_msgs in\n-- #eval get_zodiac_sign 10 10\n\n/-\ninfo: 'Taurus'\n-/\n-- #guard_msgs in\n-- #eval get_zodiac_sign 1 5\n\n/-\ninfo: 'Sagittarius'\n-/\n-- #guard_msgs in\n-- #eval get_zodiac_sign 25 11", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3441", "language": "lean", "source": "fvapps", "source-id": "fvapps_003441", "source-notes": "", "vc-description": "/-\n> \n**Note**: This kata is a translation of this (Java) one: http://www.codewars.com/kata/rotate-array. I have not translated this first one as usual because I did not solved it, and I fear not being able to solve it (Java is **not** my cup of... tea). @cjmcgraw, if you want to use my translation on your kata feel free to use it.\n\nCreate a function named \"rotate\" that takes an array and returns a new one with the elements inside rotated n spaces.\n\nIf n is greater than 0 it should rotate the array to the right. If n is less than 0 it should rotate the array to the left. If n is 0, then it should return the array unchanged.\n\nExample:\n```python\ndata = [1, 2, 3, 4, 5];\n\nrotate(data, 1) # => [5, 1, 2, 3, 4]\nrotate(data, 2) # => [4, 5, 1, 2, 3]\nrotate(data, 3) # => [3, 4, 5, 1, 2]\nrotate(data, 4) # => [2, 3, 4, 5, 1]\nrotate(data, 5) # => [1, 2, 3, 4, 5]\n\nrotate(data, 0) # => [1, 2, 3, 4, 5]\n\nrotate(data, -1) # => [2, 3, 4, 5, 1]\nrotate(data, -2) # => [3, 4, 5, 1, 2]\nrotate(data, -3) # => [4, 5, 1, 2, 3]\nrotate(data, -4) # => [5, 1, 2, 3, 4]\nrotate(data, -5) # => [1, 2, 3, 4, 5]\n```\n\nFurthermore the method should take ANY array of objects and perform this operation on them:\n```python\nrotate(['a', 'b', 'c'], 1)     # => ['c', 'a', 'b']\nrotate([1.0, 2.0, 3.0], 1)     # => [3.0, 1.0, 2.0]\nrotate([True, True, False], 1) # => [False, True, True]\n```\n\nFinally the rotation shouldn't be limited by the indices available in the array. Meaning that if we exceed the indices of the array it keeps rotating.\n\nExample:\n```python\ndata = [1, 2, 3, 4, 5]\n\nrotate(data, 7)     # => [4, 5, 1, 2, 3]\nrotate(data, 11)    # => [5, 1, 2, 3, 4]\nrotate(data, 12478) # => [3, 4, 5, 1, 2]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def rotate {α : Type u} (arr : List α) (n : Int) : List α :=\n  sorry", "vc-theorems": "theorem rotate_empty {α : Type u} (n : Int) :\n  rotate ([] : List α) n = ([] : List α) :=\n  sorry\n\ntheorem rotate_length {α : Type u} (arr : List α) (n : Int) :\n  arr ≠ [] → List.length (rotate arr n) = List.length arr :=\n  sorry\n\ntheorem rotate_elements_same {α : Type u} (arr : List α) (n : Int) (x : α) :\n  arr ≠ [] → (x ∈ arr ↔ x ∈ rotate arr n) :=\n  sorry\n\ntheorem rotate_period {α : Type u} (arr : List α) :\n  arr ≠ [] → rotate arr (List.length arr) = arr :=\n  sorry\n\ntheorem rotate_split {α : Type u} (arr : List α) (n : Int) :\n  arr ≠ [] →\n  let normalized := Int.mod n (List.length arr)\n  rotate arr n = arr.drop (List.length arr - normalized.toNat) ++ arr.take (List.length arr - normalized.toNat) :=\n  sorry\n\ntheorem rotate_compose {α : Type u} (arr : List α) (n1 n2 : Int) :\n  arr ≠ [] →\n  rotate (rotate arr n1) n2 = rotate arr (Int.mod (n1 + n2) (List.length arr)) :=\n  sorry\n\ntheorem rotate_inverse {α : Type u} (arr : List α) (n : Int) :\n  arr ≠ [] →\n  rotate (rotate arr n) (-n) = arr :=\n  sorry\n\n/-\ninfo: ['c', 'a', 'b']\n-/\n-- #guard_msgs in\n-- #eval rotate [\"a\", \"b\", \"c\"] 1\n\n/-\ninfo: [3.0, 1.0, 2.0]\n-/\n-- #guard_msgs in\n-- #eval rotate [1.0, 2.0, 3.0] 1\n\n/-\ninfo: [False, True, True]\n-/\n-- #guard_msgs in\n-- #eval rotate [True, True, False] 1\n\n/-\ninfo: [4, 5, 1, 2, 3]\n-/\n-- #guard_msgs in\n-- #eval rotate [1, 2, 3, 4, 5] 7", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3443", "language": "lean", "source": "fvapps", "source-id": "fvapps_003443", "source-notes": "", "vc-description": "/-\nGiven two numbers and an arithmetic operator (the name of it, as a string), return the result of the two numbers having that operator used on them. \n\n```a``` and ```b``` will both be positive integers, and ```a``` will always be the first number in the operation, and ```b``` always the second.\n\nThe four operators are \"add\", \"subtract\", \"divide\", \"multiply\". \n\nA few examples: \n\n``` javascript\nArithmeticFunction.arithmetic(5, 2, \"add\")      => returns 7\nArithmeticFunction.arithmetic(5, 2, \"subtract\") => returns 3\nArithmeticFunction.arithmetic(5, 2, \"multiply\") => returns 10\nArithmeticFunction.arithmetic(5, 2, \"divide\")   => returns 2\n```\n\nTry to do it without using if statements!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def arithmetic (a b : Int) (op : Op) : Int :=\n  sorry", "vc-theorems": "theorem arithmetic_add (a b : Int) : \n  arithmetic a b Op.add = a + b := sorry\n\ntheorem arithmetic_subtract (a b : Int) :\n  arithmetic a b Op.subtract = a - b := sorry\n\ntheorem arithmetic_multiply (a b : Int) :\n  arithmetic a b Op.multiply = a * b := sorry\n\ntheorem arithmetic_divide (a b : Int) (h : b ≠ 0) :\n  arithmetic a b Op.divide = a / b := sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval arithmetic 1 2 \"add\"\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval arithmetic 8 2 \"subtract\"\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval arithmetic 5 2 \"multiply\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3453", "language": "lean", "source": "fvapps", "source-id": "fvapps_003453", "source-notes": "", "vc-description": "/-\nImagine a funnel filled with letters. The bottom letter drops out of the funnel and onto a conveyor belt:\n\n```\n  \\b,c/  -->   \\b,c/\n   \\a/   -->    \\ /\n                 a\n-------     -------\n```\nIf there are two letters above a gap, the smaller letter falls into the gap.\n```\n  \\b,c/   -->   \\  c/ \n   \\ /    -->    \\b/   \na            a         \n-------      -------\n```\nOf course, this can create a new gap, which must also be filled in the same way:\n```\n  \\f,e,d/  -->  \\f, ,d/\n   \\  c/   -->   \\e,c/ \n    \\b/           \\b/   \n   a            a         \n  -------      -------\n```\nOnce all the gaps above it have been filled, the bottom letter drops out of the funnel and onto the conveyorbelt. The process continues until all letters have fallen onto the conveyor. (New letters fall onto the end of the existing string)\n\n**KATA GOAL: Return the string on the conveyorbelt after all letters have fallen**.\n```\n\\f, ,d/      \\f, ,d/   --> etc -->    \\     /\n \\e,c/        \\e,c/    --> etc -->     \\   /\n  \\b/    -->   \\ /     --> etc -->      \\ /\na           a   b                   abcdef\n-------     -------                 -------\n```\nAll letters in the funnel will be unique i.e. in every comparison one letter will be strictly smaller than the other. The funnel will be presented as a nested list, e.g:\n```\n[[\"d\",\"a\",\"c\"],\n   [\"b\",\"e\"],\n     [\"f\"]]\n```\nThe value of a letter is defined by its codepoint. Note: this means all capital letters are defined as smaller than all lower-case letters, but your language's comparison operator will probably treat it that way automatically.\n\nThe funnels will always be \"nice\" -- every layer will have 1 item more than the layer below, and every layer will be full, and generally there's no funny business or surprises to consider. The only characters used are standard uppercase and lowercase letters A-Z and a-z. The tests go up to 9 layer funnel.\n\n### Fully Worked Example\n```\n\\d,a,c/      \\d,a,c/      \\d,a,c/ -->  \\d   c/     \n \\b,e/        \\b,e/  -->   \\  e/  -->   \\a,e/\n  \\f/   -->    \\ /   -->    \\b/          \\b/  --> \n                f        f            f\n------      -------      -------      -------\n\n\\d   c/      \\d   c/ -->  \\    c/      \\    c/     \n \\a,e/  -->   \\  e/  -->   \\d,e/        \\d,e/  -->\n  \\ /   -->    \\a/          \\a/   -->    \\ /   -->\nf  b        fb           fb           fb  a\n------      -------      -------      -------\n\n \\    c/      \\    c/      \\    c/ -->  \\     /     \n  \\  e/        \\  e/  -->   \\   /  -->   \\  c/   \n   \\d/   -->    \\ /   -->    \\e/          \\e/  -->\nfba          fba d       fbad          fbad\n-------      -------     --------      -------\n\n  \\     /      \\     /      \\     /\n   \\  c/  -->   \\   /        \\   / \n    \\ /          \\c/   -->    \\ /   \nfbad e       fbade        fbadec         \n-------      -------      -------\n\nDONE. Return \"fbadec\".\n\n```\n\n**For a bigger funneling challenge, check out [this kata](https://www.codewars.com/kata/create-a-funnel) by @myjinxin2015.**\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Funnel := List (List Char)\n\ndef funnel_out (f : Funnel) : List Char := sorry", "vc-theorems": "theorem funnel_structure_preserved (f : Funnel) :\n  let f' := f\n  f = f' := sorry\n\ntheorem all_letters_output (f : Funnel) :\n  let input_letters := f.join\n  List.length (funnel_out f) = List.length input_letters := sorry\n\ntheorem funnel_fills_bottom (f : Funnel) :\n  let total_letters := f.join.length \n  (funnel_out f).length = total_letters := sorry\n\ntheorem simple_cases :\n  funnel_out [['a']] = ['a'] ∧  \n  funnel_out [['a', 'b'], ['c']] = ['c', 'a', 'b'] := sorry\n\n/-\ninfo: 'q'\n-/\n-- #guard_msgs in\n-- #eval funnel_out [[\"q\"]]\n\n/-\ninfo: 'abc'\n-/\n-- #guard_msgs in\n-- #eval funnel_out [[\"b\", \"c\"], [\"a\"]]\n\n/-\ninfo: 'fbadec'\n-/\n-- #guard_msgs in\n-- #eval funnel_out [[\"d\", \"a\", \"c\"], [\"b\", \"e\"], [\"f\"]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3469", "language": "lean", "source": "fvapps", "source-id": "fvapps_003469", "source-notes": "", "vc-description": "/-\nGiven a rational number n\n\n``` n >= 0, with denominator strictly positive```  \n\n- as a string (example: \"2/3\" in Ruby, Python, Clojure, JS, CS, Go) \n- or as two strings (example: \"2\" \"3\" in Haskell, Java, CSharp, C++, Swift) \n- or as a rational or decimal number (example: 3/4, 0.67 in R) \n- or two integers (Fortran)\n\ndecompose \nthis number as a sum of rationals with numerators equal to one and without repetitions\n(2/3 = 1/2 + 1/6 is correct but not 2/3 = 1/3 + 1/3, 1/3 is repeated).\n\nThe algorithm must be \"greedy\", so at each stage the new rational obtained in the decomposition must have a denominator as small as possible. \nIn this manner the sum of a few fractions in the decomposition gives a rather good approximation of the rational to decompose.\n\n2/3 = 1/3 + 1/3 doesn't fit because of the repetition but also because the first 1/3 has a denominator bigger than the one in 1/2 \nin the decomposition 2/3 = 1/2 + 1/6.\n\n### Example: \n(You can see other examples in \"Sample Tests:\")\n```\ndecompose(\"21/23\") or \"21\" \"23\" or 21/23 should return \n\n[\"1/2\", \"1/3\", \"1/13\", \"1/359\", \"1/644046\"] in Ruby, Python, Clojure, JS, CS, Haskell, Go\n\n\"[1/2, 1/3, 1/13, 1/359, 1/644046]\" in Java, CSharp, C++\n\n\"1/2,1/3,1/13,1/359,1/644046\" in C, Swift, R\n```  \n\n### Notes\n1) The decomposition of 21/23 as\n```\n21/23 = 1/2 + 1/3 + 1/13 + 1/598 + 1/897\n```\nis exact but don't fulfill our requirement because 598 is bigger than 359.\nSame for \n```\n21/23 = 1/2 + 1/3 + 1/23 + 1/46 + 1/69 (23 is bigger than 13)\nor \n21/23 = 1/2 + 1/3 + 1/15 + 1/110 + 1/253 (15 is bigger than 13).\n```\n\n2) The rational given to decompose could be greater than one or equal to one, in which case the first \"fraction\" will be an integer \n(with an implicit denominator of 1). \n\n3) If the numerator parses to zero the function \"decompose\" returns [] (or \"\".\n\n4) The number could also be a decimal which can be expressed as a rational. \n\nexamples:\n\n`0.6` in Ruby, Python, Clojure,JS, CS, Julia, Go\n\n`\"66\" \"100\"` in Haskell, Java, CSharp, C++, C, Swift, Scala, Kotlin\n\n`0.67` in R.\n\n**Ref:**\nhttp://en.wikipedia.org/wiki/Egyptian_fraction\n-/", "vc-preamble": "def Rat.add (a b : Rat) : Rat := sorry\ndef Rat.sub (a b : Rat) : Rat := sorry\n\ndef Rat.le (a b : Rat) : Prop := sorry\ndef Rat.abs (a : Rat) : Rat := sorry\n\ndef Int.toRat (n : Int) : Rat := sorry\ndef Nat.toRat (n : Nat) : Rat := sorry\n\ndef Float.toRat (f : Float) : Rat := sorry\n\ninstance : Add Rat where\n  add := Rat.add\n\ninstance : Sub Rat where\n  sub := Rat.sub\n\ninstance : LE Rat where\n  le := Rat.le", "vc-helpers": "", "vc-definitions": "def decompose (f : Rat) : List Rat := sorry\n\n/- The sum of decomposed unit fractions equals the input rational number -/", "vc-theorems": "theorem decompose_sum_equals_input (f : Rat) (h : Rat.le ⟨0, 1, by simp⟩ f) (h2 : Rat.le f ⟨10, 1, by simp⟩) :\n  let parts := decompose f\n  let sum_parts := parts.foldl Rat.add ⟨0, 1, by simp⟩\n  Rat.le (Rat.abs (Rat.sub sum_parts f)) ⟨1, 100000, by simp⟩ := sorry\n\n/- For non-whole numbers, decomposition yields unique descending unit fractions -/\n\ntheorem decompose_unique_unit_fractions (f : Rat) (h : Rat.le ⟨0, 1, by simp⟩ f) (h2 : Rat.le f ⟨10, 1, by simp⟩) :\n  let parts := decompose f\n  (parts.length > 1) →\n  let unit_fracs := parts.tail\n  (∀ x ∈ unit_fracs, ∃ (n : Nat) (h : n > 0), x = ⟨1, n, h⟩) ∧ \n  List.Pairwise (fun x y => Rat.le y x) unit_fracs ∧\n  List.Nodup unit_fracs := sorry\n\n/- Decomposition of whole numbers returns singleton list -/\n\ntheorem decompose_whole_numbers (n : Nat) (h : n > 0) (h2 : n ≤ 100) :\n  decompose (Nat.toRat n) = [Nat.toRat n] := sorry\n\n/- Decimal inputs are handled properly -/\n\ntheorem decompose_decimals (d : Float) (h : d ≥ 0) (h2 : d ≤ 10) :\n  let result := decompose (Float.toRat d)\n  let sum_parts := result.foldl Rat.add ⟨0, 1, by simp⟩\n  Rat.le (Rat.abs (Rat.sub sum_parts (Float.toRat d))) ⟨1, 100000, by simp⟩ := sorry\n\n/-\ninfo: ['1/2', '1/4']\n-/\n-- #guard_msgs in\n-- #eval decompose \"3/4\"\n\n/-\ninfo: ['1/2', '1/7', '1/59', '1/5163', '1/53307975']\n-/\n-- #guard_msgs in\n-- #eval decompose \"0.66\"\n\n/-\ninfo: ['1/2', '1/4', '1/20']\n-/\n-- #guard_msgs in\n-- #eval decompose \"4/5\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3485", "language": "lean", "source": "fvapps", "source-id": "fvapps_003485", "source-notes": "", "vc-description": "/-\nGiven a string of integers, return the number of odd-numbered substrings that can be formed. \n\nFor example, in the case of `\"1341\"`, they are `1, 1, 3, 13, 41, 341, 1341`, a total of `7` numbers. \n\n`solve(\"1341\") = 7`.  See test cases for more examples.\n\nGood luck!\n\nIf you like substring Katas, please try \n\n[Longest vowel chain](https://www.codewars.com/kata/59c5f4e9d751df43cf000035)\n\n[Alphabet symmetry](https://www.codewars.com/kata/59d9ff9f7905dfeed50000b0)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem solve_bounds {s : String} (h : s.length > 0) :\n  solve s ≥ 0 ∧ solve s ≤ (s.length * (s.length + 1)) / 2 :=\n  sorry\n\ntheorem solve_expected {s : String} (h : s.length > 0) :\n  solve s = s.data.enum.foldl (fun acc (i, c) => \n    if c.toNat % 2 = 1 then \n      acc + (i + 1)\n    else acc) 0 :=\n  sorry\n\ntheorem solve_even_only {s : String} (h : s.length > 0)\n  (h_even : ∀ c ∈ s.data, c.toNat % 2 = 0) :\n  solve s = 0 :=\n  sorry\n\ntheorem solve_odd_only {s : String} (h : s.length > 0)\n  (h_odd : ∀ c ∈ s.data, c.toNat % 2 = 1) :\n  solve s = (s.length * (s.length + 1)) / 2 :=\n  sorry\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval solve \"1341\"\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval solve \"1357\"\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval solve \"13471\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3505", "language": "lean", "source": "fvapps", "source-id": "fvapps_003505", "source-notes": "", "vc-description": "/-\nDescription:\n\nThe mean (or average) is the most popular measure of central tendency; however it does not behave very well when the data is skewed (i.e. wages distribution). In such cases, it's better to use the median.\n\nYour task for this kata is to find the median of an array consisting of n elements.\n\nYou can assume that all inputs are arrays of numbers in integer format. For the empty array your code should return `NaN` (false in JavaScript/`NULL` in PHP/`nil` in Ruby).\n\nExamples:\n\nInput `[1, 2, 3, 4]` --> Median `2.5`\n\nInput `[3, 4, 1, 2, 5]` --> Median `3`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def median (lst: List Int) : Float := sorry\n\nnamespace MedianTheorems", "vc-theorems": "theorem median_nonempty_returns_number (lst: List Int) (h: lst ≠ []) : \n  let result := median lst\n  ∃ n: Float, result = n := sorry\n\ntheorem median_empty_is_nan : \n  let result := median []\n  Float.isNaN result := sorry\n\ntheorem median_same_elements {lst: List Int} (h: lst ≠ []) \n  (head: lst.head? = some (lst.head!)) :\n  (∀ x ∈ lst, x = lst.head!) → \n  median lst = Float.ofInt lst.head! := sorry\n\ntheorem median_sort_invariant {lst: List Int} (h: lst ≠ []) :\n  median lst = median (List.mergeSort (· ≤ ·) lst) := sorry\n\nend MedianTheorems\n\n/-\ninfo: 2.5\n-/\n-- #guard_msgs in\n-- #eval median [1, 2, 3, 4]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval median [3, 4, 1, 2, 5]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval median [1]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3509", "language": "lean", "source": "fvapps", "source-id": "fvapps_003509", "source-notes": "", "vc-description": "/-\nMake a function **\"add\"** that will be able to sum elements of **list** continuously and return a new list of sums.\n\nFor example: \n\n```\nadd [1,2,3,4,5] == [1, 3, 6, 10, 15], because it's calculated like \nthis : [1, 1 + 2, 1 + 2 + 3, 1 + 2 + 3 + 4, 1 + 2 + 3 + 4 + 5]\n```\n\nIf you want to learn more see https://en.wikipedia.org/wiki/Prefix_sum\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def add (nums: List Int) : List Int :=\n  sorry\n\n@[simp]", "vc-theorems": "theorem add_length_preservation: \n  ∀ (nums: List Int), \n  List.length (add nums) = List.length nums := \n  sorry\n\n@[simp]\n\ntheorem add_cumulative_property:\n  ∀ (nums: List Int),\n  nums ≠ [] →\n  let result := add nums\n  (List.get! result 0 = List.get! nums 0) ∧ \n  ∀ (i: Nat), 0 < i → i < nums.length → \n    List.get! result i = List.get! result (i-1) + List.get! nums i :=\n  sorry\n\n@[simp]\n\ntheorem add_monotonic_for_nonnegative:\n  ∀ (nums: List Int),\n  (∀ x, x ∈ nums → 0 ≤ x) →\n  let result := add nums\n  ∀ (i j: Nat), i < j → j < result.length → \n    List.get! result i ≤ List.get! result j :=\n  sorry\n\n@[simp]\n\ntheorem add_invalid_input:\n  ∀ (s: String), add [] = [] :=\n  sorry\n\nend AddSpec\n\n/-\ninfo: [1, 3, 6, 10, 15]\n-/\n-- #guard_msgs in\n-- #eval add [1, 2, 3, 4, 5]\n\n/-\ninfo: [5, 15, 30, 50]\n-/\n-- #guard_msgs in\n-- #eval add [5, 10, 15, 20]\n\n/-\ninfo: [2, 6, 12]\n-/\n-- #guard_msgs in\n-- #eval add [2, 4, 6]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3510", "language": "lean", "source": "fvapps", "source-id": "fvapps_003510", "source-notes": "", "vc-description": "/-\nA nested list (or *array* in JavaScript) is a list that apears as a value inside another list, \n```python\n[item, item, [item, item], item]\n```\nin the above list, [item, item] is a nested list.  \n\nYour goal is to write a function that determines the depth of the deepest nested list within a given list.  \nreturn 1 if there are no nested lists.\nThe list passed to your function can contain any data types.  \n\nA few examples:\n\n```python\nlist_depth([True])\nreturn 1\n\nlist_depth([])\nreturn 1\n\nlist_depth([2, \"yes\", [True, False]])\nreturn 2\n\nlist_depth([1, [2, [3, [4, [5, [6], 5], 4], 3], 2], 1])\nreturn 6\n\nlist_depth([2.0, [2, 0], 3.7, [3, 7], 6.7, [6, 7]])\nreturn 2\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def NestedList.depth {α : Type} : NestedList α → Nat\n  | elem _ => sorry\n  | list _ => sorry", "vc-theorems": "theorem flat_list_depth {α : Type} (l : List α) : \n  NestedList.depth (NestedList.list (l.map NestedList.elem)) = 1 := sorry\n\ntheorem list_depth_lower_bound {α : Type} (nl : NestedList α) :\n  NestedList.depth nl ≥ 1 := sorry\n\ntheorem nested_list_depth_greater {α : Type} (outer : NestedList α) (inner : NestedList α)\n  (h : inner ≠ outer) : \n  NestedList.depth outer > NestedList.depth inner := sorry\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval list_depth [1, [2, [3, [4, [5, [6], 5], 4], 3], 2], 1]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval list_depth [2, \"yes\", [True, False]]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval list_depth [2.0, [2, 0], 3.7, [3, 7], 6.7, [6, 7]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3543", "language": "lean", "source": "fvapps", "source-id": "fvapps_003543", "source-notes": "", "vc-description": "/-\nA Madhav array has the following property:\n\n```a[0] = a[1] + a[2] = a[3] + a[4] + a[5] = a[6] + a[7] + a[8] + a[9] = ...```\n\nComplete the function/method that returns `true` if the given array is a Madhav array, otherwise it returns `false`.\n\n*Edge cases: An array of length* `0` *or* `1` *should not be considered a Madhav array as there is nothing to compare.*\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_valid_madhav_length (n : Nat) : Bool := sorry\n\ndef is_madhav_array (arr : List Int) : Bool := sorry", "vc-theorems": "theorem single_element_array_is_false (x : Int) :\n  is_madhav_array [x] = false := sorry\n\ntheorem invalid_length_arrays_are_false (arr : List Int) :\n  ¬ is_valid_madhav_length arr.length →\n  is_madhav_array arr = false := sorry\n\ntheorem valid_madhav_arrays (k : Nat) (h : k ≥ 2) :\n  let total_len := k * (k + 1) / 2\n  let zeros := List.replicate (k * (k + 1) / 2 - k) 0\n  let ks := List.replicate k k\n  let arr := zeros.map Int.ofNat ++ ks.map Int.ofNat\n  is_madhav_array arr = true := sorry\n\ntheorem invalid_madhav_arrays_different_sums (k : Nat) (h : k ≥ 2) :\n  let make_arr : Nat → List Int := λ i => \n    if i = 0 then [Int.ofNat (k + i)]\n    else List.replicate i (Int.ofNat 0) ++ [Int.ofNat (k + i)]\n  let arr := List.join (List.map make_arr (List.range k))\n  is_madhav_array arr = false := sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval is_madhav_array [6, 2, 4, 2, 2, 2, 1, 5, 0, 0]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval is_madhav_array [5, 2, 4, 1, 0, 3]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval is_madhav_array [1]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3548", "language": "lean", "source": "fvapps", "source-id": "fvapps_003548", "source-notes": "", "vc-description": "/-\n**Steps**\n1. Square the numbers that are greater than zero.\n2. Multiply by 3 every third number.\n3. Multiply by -1 every fifth number.\n4. Return the sum of the sequence.\n\n**Example**   \n`{ -2, -1, 0, 1, 2 }` returns `-6`\n```\n1. { -2, -1, 0, 1 * 1, 2 * 2 }\n2. { -2, -1, 0 * 3, 1, 4 }\n3. { -2, -1, 0, 1, -1 * 4 }\n4. -6\n```\n\nP.S.: The sequence consists only of integers. And try not to use \"for\", \"while\" or \"loop\" statements.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem operation_type_nonempty {sequence : List Int} (h : sequence ≠ []) :\n  ∃ (result : Int), operation sequence = result :=\n  sorry\n\ntheorem operation_empty_case :\n  operation [] = 0 :=\n  operation_empty operation\n\ntheorem operation_type_bounded_length {sequence : List Int} (h : sequence.length ≤ 100) :\n  ∃ (result : Int), operation sequence = result :=\n  sorry\n\ntheorem operation_type_repeated (x : Int) (length : Nat) (h : 0 < length ∧ length ≤ 10) :\n  ∃ (result : Int), operation (List.replicate length x) = result :=\n  sorry\n\ntheorem operation_type_alternating_signs {sequence : List Int} (h : sequence ≠ []) :\n  ∃ (result : Int), operation sequence = result :=\n  sorry\n\ntheorem operation_type_small_ints {sequence : List Int}\n    (h1 : sequence ≠ [])\n    (h2 : sequence.length ≤ 10)\n    (h3 : ∀ x ∈ sequence, -100 ≤ x ∧ x ≤ 100) :\n  ∃ (result : Int), operation sequence = result :=\n  sorry\n\n/-\ninfo: -6\n-/\n-- #guard_msgs in\n-- #eval calc [-2, -1, 0, 1, 2]\n\n/-\ninfo: 31\n-/\n-- #guard_msgs in\n-- #eval calc [0, 2, 1, -6, -3, 3]\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval calc [1, 1, 1, 1, 1]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3550", "language": "lean", "source": "fvapps", "source-id": "fvapps_003550", "source-notes": "", "vc-description": "/-\n###Instructions\n\nA time period starting from ```'hh:mm'``` lasting until ```'hh:mm'``` is stored in an array:\n```\n['08:14', '11:34']\n```\nA set of different time periods is then stored in a 2D Array like so, each in its own sub-array:\n```\n[['08:14','11:34'], ['08:16','08:18'], ['22:18','01:14'], ['09:30','10:32'], ['04:23','05:11'], ['11:48','13:48'], ['01:12','01:14'], ['01:13','08:15']]\n```\nWrite a function that will take a 2D Array like the above as argument and return a 2D Array of the argument's sub-arrays sorted in ascending order.\n\nTake note of the following:\n\n* The first time period starts at the earliest time  possible ```('00:00'+)```.\n* The next time period is the one that starts the soonest **after** the prior time period finishes. If several time periods begin at the same hour, pick the first one showing up in the original array.\n* The next time period can start the same time the last one finishes.\n\nThis:\n```\n[['08:14','11:34'], ['08:16','08:18'], ['13:48','01:14'], ['09:30','10:32'], ['04:23','05:11'], ['11:48','13:48'], ['01:12','01:14'], ['01:13','08:15']]\n```\nShould return:\n```\n[['01:12','01:14'], ['04:23','05:11'], ['08:14','11:34'], ['11:48','13:48'], ['13:48','01:14'], ['08:16','08:18'], ['09:30','10:32'], ['01:13','08:15']]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sort_time (pairs : List TimePair) : List TimePair :=\n  sorry", "vc-theorems": "theorem sort_time_length_preserving\n  (pairs : List TimePair) :\n  List.length (sort_time pairs) = List.length pairs :=\n  sorry\n\ntheorem sort_time_elements_same\n  (pairs : List TimePair) :\n  ∀ x, x ∈ sort_time pairs ↔ x ∈ pairs :=\n  sorry\n\ntheorem sort_time_valid_ordering\n  (pairs : List TimePair) \n  (i : Nat)\n  (h₁ : i < List.length (sort_time pairs) - 1)\n  (h₂ : i < List.length (sort_time pairs))\n  (h₃ : i + 1 < List.length (sort_time pairs)) :\n  let result := sort_time pairs\n  let curr := result[i]'h₂\n  let next := result[i+1]'h₃\n  next.start < curr.end_ → curr.end_ > next.start :=\n  sorry\n\ntheorem sort_time_idempotent\n  (pairs : List TimePair) :\n  sort_time (sort_time pairs) = sort_time pairs :=\n  sorry\n\ntheorem sort_time_concatenation\n  (lists : List (List TimePair))\n  (h : lists ≠ []) :\n  let flattened := List.join lists\n  sort_time flattened = sort_time (sort_time flattened) :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3554", "language": "lean", "source": "fvapps", "source-id": "fvapps_003554", "source-notes": "", "vc-description": "/-\nIntegral numbers can be even or odd.\n\nEven numbers satisfy `n = 2m` ( with `m` also integral ) and we will ( completely arbitrarily ) think of odd numbers as `n = 2m + 1`.  \nNow, some odd numbers can be more odd than others: when for some `n`, `m` is more odd than for another's. Recursively. :]  \nEven numbers are just not odd.\n\n# Task\n\nGiven a finite list of integral ( not necessarily non-negative ) numbers, determine the number that is _odder than the rest_.  \nIf there is no single such number, no number is odder than the rest; return `Nothing`, `null` or a similar empty value.\n\n# Examples\n\n```python\noddest([1,2]) => 1\noddest([1,3]) => 3\noddest([1,5]) => None\n```\n\n# Hint\n\nDo you _really_ want one? Point or tap here.\n-/", "vc-preamble": "def get_oddity (n : Int) : Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def oddest (nums : List Int) : Option Int :=\n  sorry", "vc-theorems": "theorem oddest_empty (nums : List Int) :\n  nums = [] → oddest nums = none :=\n  sorry\n\ntheorem oddest_in_list {nums : List Int} {result : Int} :\n  oddest nums = some result → result ∈ nums :=\n  sorry\n\ntheorem oddest_null_tie_or_even {nums : List Int} :\n  nums ≠ [] →\n  oddest nums = none →\n  let oddities := nums.map get_oddity\n  let max_odd := oddities.maximum?\n  match max_odd with\n  | none => True \n  | some m => \n    (oddities.filter (·= m)).length > 1 ∨ m = 0 :=\n  sorry\n\ntheorem oddest_output_type (nums : List Int) :\n  oddest nums = none ∨ (∃ x, oddest nums = some x) :=\n  sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval oddest [1, 2]\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval oddest [1, 3]\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval oddest [1, 3, 5, 7]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3558", "language": "lean", "source": "fvapps", "source-id": "fvapps_003558", "source-notes": "", "vc-description": "/-\n# Task\n A common way for prisoners to communicate secret messages with each other is to encrypt them. One such encryption algorithm goes as follows.\n\n You take the message and place it inside an `nx6` matrix (adjust the number of rows depending on the message length) going from top left to bottom right (one row at a time) while replacing spaces with dots (.) and adding dots at the end of the last row (if necessary) to complete the matrix.\n\n Once the message is in the matrix you read again from top left to bottom right but this time going one column at a time and treating each column as one word.\n\n# Example\n\n The following message `\"Attack at noon or we are done for\"` is placed in a `6 * 6` matrix :\n```\nAttack\n.at.no\non.or.\nwe.are\n.done.\nfor...```\nReading it one column at a time we get:\n\n `A.ow.f tanedo tt..or a.oan. cnrre. ko.e..`\n\n# Input/Output\n\n - `[input]` string `msg`\n\n  a regular english sentance representing the original message\n\n - `[output]` a string\n\n  encrypted message\n-/", "vc-preamble": "def String.splitColumns (s : String) : List String := sorry\n\ndef List.sum (l : List Nat) : Nat := l.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def six_column_encryption (msg : String) : String := sorry\n\ntheorem encryption_correct_columns (msg : String) : \n  (six_column_encryption msg).splitColumns.length = 6\n  := sorry", "vc-theorems": "theorem encryption_length_divisible_by_six (msg : String) :\n  let columns := (six_column_encryption msg).splitColumns\n  let total_chars := (columns.map String.length).sum\n  total_chars % 6 = 0\n  := sorry\n\ntheorem encryption_preserves_length (msg : String) :\n  let result := six_column_encryption msg\n  let result_chars := result.splitColumns.foldl (· ++ ·) \"\"\n  let padded_len := msg.length + ((6 - msg.length % 6) % 6)\n  result_chars.length = padded_len\n  := sorry \n\ntheorem encryption_balanced_columns (msg : String) :\n  let result := six_column_encryption msg\n  let lengths := result.splitColumns.map String.length\n  match lengths.maximum?, lengths.minimum? with\n  | some max, some min => max - min ≤ 1\n  | _, _ => True\n  := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3570", "language": "lean", "source": "fvapps", "source-id": "fvapps_003570", "source-notes": "", "vc-description": "/-\nScheduling is how the processor decides which jobs (processes) get to use the processor and for how long. This can cause a lot of problems. Like a really long process taking the entire CPU and freezing all the other processes. One solution is Round-Robin, which today you will be implementing.\n\nRound-Robin works by queuing jobs in a First In First Out fashion, but the processes are only given a short slice of time. If a processes is not finished in that time slice, it yields the proccessor and goes to the back of the queue.\n\nFor this Kata you will be implementing the \n```python\n  def roundRobin(jobs, slice, index):\n```\n\nIt takes in:\n\n    1. \"jobs\" a non-empty positive integer array. It represents the queue and clock-cycles(cc) remaining till the job[i] is finished.\n\n    2. \"slice\" a positive integer. It is the amount of clock-cycles that each job is given till the job yields to the next job in the queue.\n\n    3. \"index\" a positive integer. Which is the index of the job we're interested in.\n\nroundRobin returns:\n\n    1. the number of cc till the job at index is finished.\n\nHere's an example:\n```\nroundRobin([10,20,1], 5, 0) \nat 0cc [10,20,1] jobs[0] starts\nafter 5cc [5,20,1] jobs[0] yields, jobs[1] starts\nafter 10cc [5,15,1] jobs[1] yields, jobs[2] starts\nafter 11cc [5,15,0] jobs[2] finishes, jobs[0] starts\nafter 16cc [0,15,0] jobs[0] finishes\n```\n\nso:\n```\nroundRobin([10,20,1], 5, 0) == 16\n```\n\n**You can assume that the processor can switch jobs between cc so it does not add to the total time.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def roundRobin (jobs : List Nat) (slice : Nat) (target : Nat) : Nat := sorry\n\ndef List.sum : List Nat → Nat\n  | [] => 0\n  | x :: xs => x + List.sum xs", "vc-theorems": "theorem roundRobin_lower_bound {jobs : List Nat} {slice : Nat} (h : jobs.length > 0) :\n  roundRobin jobs slice 0 ≥ jobs.get! 0 := by sorry\n\ntheorem roundRobin_upper_bound {jobs : List Nat} {slice : Nat} (h : jobs.length > 0) :\n  roundRobin jobs slice 0 ≤ List.sum jobs := by sorry\n\ntheorem roundRobin_single_job {job : Nat} {slice : Nat} :\n  roundRobin [job] slice 0 = job := by sorry\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval roundRobin [10] 4 0\n\n/-\ninfo: 15\n-/\n-- #guard_msgs in\n-- #eval roundRobin [10, 20] 5 0\n\n/-\ninfo: 11\n-/\n-- #guard_msgs in\n-- #eval roundRobin [10, 20, 1, 2, 3] 5 2", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3575", "language": "lean", "source": "fvapps", "source-id": "fvapps_003575", "source-notes": "", "vc-description": "/-\nAlgorithmic predicament - Bug Fixing #9\n\nOh no! Timmy's algorithim has gone wrong! help Timmy fix his algorithim! \n\nTask\nYour task is to fix timmy's algorithim so it returns the group name with the highest total age. \n\nYou will receive two groups of `people` objects, with two properties `name` and `age`. The name property is a string and the age property is a number.  \nYour goal is to make the total the age of all people having the same name through both groups and return the name of the one with the highest age. If two names have the same total age return the first alphabetical name.\n-/", "vc-preamble": "def highest_age (persons1 persons2 : List Person) : Option String := sorry\n\ntheorem highest_age_empty_lists : \n  highest_age [] [] = none := sorry", "vc-helpers": "", "vc-definitions": "def total_age_for_name (persons : List Person) (name : String) : Nat :=\n  (persons.filter (fun p => p.name = name)).foldl (fun acc p => acc + p.age) 0", "vc-theorems": "theorem highest_age_in_input (persons1 persons2 : List Person) (result : String) :\n  highest_age persons1 persons2 = some result →\n  ∃ p, p ∈ persons1 ++ persons2 ∧ p.name = result := sorry\n\ntheorem highest_age_has_max_total (persons1 persons2 : List Person) (result : String) :\n  highest_age persons1 persons2 = some result →\n  ∀ p ∈ persons1 ++ persons2,\n    total_age_for_name (persons1 ++ persons2) p.name ≤ \n    total_age_for_name (persons1 ++ persons2) result := sorry\n\ntheorem highest_age_lexicographically_first (persons1 persons2 : List Person) (result : String) :\n  highest_age persons1 persons2 = some result →\n  let persons := persons1 ++ persons2\n  ∀ p ∈ persons,\n    (total_age_for_name persons p.name = total_age_for_name persons result → result ≤ p.name) := sorry\n\ntheorem highest_age_deterministic (persons1 persons2 : List Person) :\n  highest_age persons1 persons2 = highest_age persons1 persons2 := sorry\n\ntheorem highest_age_order_independent (persons1 persons2 p1 p2 : List Person) :\n  persons1.length = p1.length →\n  persons2.length = p2.length →\n  (∀ p, p ∈ persons1 ↔ p ∈ p1) →\n  (∀ p, p ∈ persons2 ↔ p ∈ p2) →\n  highest_age persons1 persons2 = highest_age p1 p2 := sorry\n\n/-\ninfo: 'alice'\n-/\n-- #guard_msgs in\n-- #eval highest_age [{\"name\": \"kay\", \"age\": 1}, {\"name\": \"john\", \"age\": 13}, {\"name\": \"kay\", \"age\": 76}] [{\"name\": \"john\", \"age\": 1}, {\"name\": \"alice\", \"age\": 77}]\n\n/-\ninfo: 'kay'\n-/\n-- #guard_msgs in\n-- #eval highest_age [{\"name\": \"kay\", \"age\": 1}, {\"name\": \"john\", \"age\": 13}, {\"name\": \"kay\", \"age\": 76}] [{\"name\": \"john\", \"age\": 1}, {\"name\": \"alice\", \"age\": 76}]\n\n/-\ninfo: 'kay'\n-/\n-- #guard_msgs in\n-- #eval highest_age [{\"name\": \"kay\", \"age\": 2}, {\"name\": \"john\", \"age\": 130}, {\"name\": \"kay\", \"age\": 130}] [{\"name\": \"john\", \"age\": 1}, {\"name\": \"alice\", \"age\": 76}]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3581", "language": "lean", "source": "fvapps", "source-id": "fvapps_003581", "source-notes": "", "vc-description": "/-\nIn genetics a reading frame is a way to divide a sequence of nucleotides (DNA bases) into a set of consecutive non-overlapping triplets (also called codon). Each of this triplets is translated into an amino-acid during a translation process to create proteins.\n\nIn a single strand of DNA you find 3 Reading frames, for example the following sequence:\n```\nAGGTGACACCGCAAGCCTTATATTAGC\n```\nwill be decompose in:\n```\nFrame 1: AGG·TGA·CAC·CGC·AAG·CCT·TAT·ATT·AGC\nFrame 2: A·GGT·GAC·ACC·GCA·AGC·CTT·ATA·TTA·GC\nFrame 3: AG·GTG·ACA·CCG·CAA·GCC·TTA·TAT·TAG·C\n```\nIn a double strand DNA you find 3 more Reading frames base on the reverse complement-strand, given the previous DNA sequence, in the reverse complement ( A-->T, G-->C, T-->A, C-->G).\nDue to the splicing of DNA strands and the fixed reading direction of a nucleotide strand, the reverse complement gets read from right to left\n\n```\n                        AGGTGACACCGCAAGCCTTATATTAGC\nReverse complement:     TCCACTGTGGCGTTCGGAATATAATCG  \nreversed reverse frame: GCTAATATAAGGCTTGCGGTGTCACCT\n```\n\nYou have:\n```\nReverse Frame 1: GCT AAT ATA AGG CTT GCG GTG TCA CCT\nreverse Frame 2: G CTA ATA TAA GGC TTG CGG TGT CAC CT\nreverse Frame 3: GC TAA TAT AAG GCT TGC GGT GTC ACC T\n```\n\nYou can find more information about the Open Reading frame in wikipedia just [here] (https://en.wikipedia.org/wiki/Reading_frame)\n\nGiven the [standard table of genetic code](http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi#SG1):\n\n```\n    AAs  = FFLLSSSSYY**CC*WLLLLPPPPHHQQRRRRIIIMTTTTNNKKSSRRVVVVAAAADDEEGGGG\n  Base1  = TTTTTTTTTTTTTTTTCCCCCCCCCCCCCCCCAAAAAAAAAAAAAAAAGGGGGGGGGGGGGGGG\n  Base2  = TTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGGTTTTCCCCAAAAGGGG\n  Base3  = TCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAG\n```\n\nThe tri-nucleotide TTT = F, TTC = F, TTA = L...\n\nSo our 6 frames will be translate as:\n\n```\nFrame 1: AGG·TGA·CAC·CGC·AAG·CCT·TAT·ATT·AGC\n          R   *   H   R   K   P   Y   I   S\n\nFrame 2: A·GGT·GAC·ACC·GCA·AGC·CTT·ATA·TTA·GC\n             G  D   T   A   S   L   I   L  \n\nFrame 3: AG·GTG·ACA·CCG·CAA·GCC·TTA·TAT·TAG·C\n             V   T   P   Q   A   L   Y   *\n\nReverse Frame 1: GCT AAT ATA AGG CTT GCG GTG TCA CCT\n                  A   N   I   R   L   A   V   S   P\n\nReverse Frame 2: G CTA ATA TAA GGC TTG CGG TGT CAC CT\n                    L   I   *   G   L   R   C   H\n\nReverse Frame 3: GC TAA TAT AAG GCT TGC GGT GTC ACC T\n                     *   Y   K   A   C   G   V   T\n\n```\n\nIn this kata you should create a function that translates DNA on all 6 frames, this function takes 2 arguments.\nThe first one is the DNA sequence the second one is an array of frame number for example if we want to translate in Frame 1 and Reverse 1 this array will be [1,-1]. Valid frames are 1, 2, 3 and -1, -2, -3.\n\nThe translation hash is available for you under a translation hash `$codons` [Ruby] or `codon` [other languages] (for example to access value of 'TTT' you should  call $codons['TTT'] => 'F').\n\nThe function should return an array with all translation asked for, by default the function do the translation on all 6 frames.\n-/", "vc-preamble": "def DNA := String\ndef Protein := String\n\ninstance : Inhabited Protein where\n  default := \"\"\n\ndef validate_frame (f : Frame) : Bool :=\n  match f with\n  | Frame.mk n => n ≠ 0", "vc-helpers": "", "vc-definitions": "def translate_with_frame : DNA → List Frame → List Protein := sorry\ndef isValidAminoAcid (c : Char) : Bool := sorry", "vc-theorems": "theorem translate_length_matches_frames (dna : DNA) (frames : List Frame) :\n  frames.all validate_frame →\n  (translate_with_frame dna frames).length = frames.length := sorry\n\ntheorem translate_produces_valid_strings (dna : DNA) (frames : List Frame) :\n  frames.all validate_frame →\n  (translate_with_frame dna frames).all (fun x => true) := sorry\n\ntheorem empty_dna_gives_empty_proteins (frames : List Frame) :\n  frames.all validate_frame →\n  (translate_with_frame \"\" frames).all String.isEmpty := sorry\n\ntheorem valid_amino_acids_only (dna : DNA) (frames : List Frame) :\n  frames.all validate_frame →\n  (translate_with_frame dna frames).all (fun protein => \n    protein.data.all isValidAminoAcid) := sorry\n\ndef default_frames : List Frame := \n  [Frame.mk 1, Frame.mk 2, Frame.mk 3, Frame.mk (-1), Frame.mk (-2), Frame.mk (-3)]\n\ntheorem default_frames_gives_six (dna : DNA) :\n  (translate_with_frame dna default_frames).length = 6 := sorry\n\ntheorem complementary_frames_equal_length (dna : DNA) :\n  dna.length ≥ 3 →\n  let result := translate_with_frame dna [Frame.mk 1, Frame.mk (-1)]\n  result[0]!.length = result[1]!.length := sorry\n\n/-\ninfo: ['K']\n-/\n-- #guard_msgs in\n-- #eval translate_with_frame \"AAA\" [1]\n\n/-\ninfo: ['K']\n-/\n-- #guard_msgs in\n-- #eval translate_with_frame \"AAAA\" [2]\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval translate_with_frame \"AGGTGACACCGCAAGCCTTATATTAGC\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3585", "language": "lean", "source": "fvapps", "source-id": "fvapps_003585", "source-notes": "", "vc-description": "/-\n# Task\n Given some points(array `A`) on the same line, determine the minimum number of line segments with length `L` needed to cover all of the given points. A point is covered if it is located inside some segment or on its bounds.\n\n# Example\n\n For `A = [1, 3, 4, 5, 8]` and `L = 3`, the output should be `2`.\n\n Check out the image below for better understanding:\n\n![](https://codefightsuserpics.s3.amazonaws.com/tasks/segmentCover/img/example.png?_tm=1474900035857)\n\n For `A = [1, 5, 2, 4, 3]` and `L = 1`, the output should be `3`.\n\n segment1: `1-2`(covered points 1,2), \n\n segment2: `3-4`(covered points 3,4),\n\n segment3: `5-6`(covered point 5)\n\n For `A = [1, 10, 100, 1000]` and `L = 1`, the output should be `4`.\n\n segment1: `1-2`(covered point 1), \n\n segment2: `10-11`(covered point 10),\n\n segment3: `100-101`(covered point 100), \n\n segment4: `1000-1001`(covered point 1000)\n\n# Input/Output\n\n - `[input]` integer array A\n\n    Array of point coordinates on the line (all points are different).\n\n    Constraints:\n\n    `1 ≤ A.length ≤ 50,`\n\n    `-5000 ≤ A[i] ≤ 5000.`\n\n - `[input]` integer `L`\n\n    Segment length, a positive integer.\n\n    Constraints: `1 ≤ L ≤ 100.`\n\n - `[output]` an integer\n\n   The minimum number of line segments that can cover all of the given points.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def segment_cover (A : List Int) (L : Nat) : Nat := sorry\n\ntheorem segment_cover_bounds {A : List Int} {L : Nat} (h : A.length > 0) : \n  1 ≤ segment_cover A L ∧ segment_cover A L ≤ A.length := sorry", "vc-theorems": "theorem larger_L_needs_fewer_segments {A : List Int} {L : Nat} (h : A.length > 0) (hL : L > 0) :\n  segment_cover A L ≤ segment_cover A (L-1) := sorry\n\ntheorem ordered_preserves_segments {A B : List Int} {L : Nat} (h : A.length > 0) (h2 : List.Perm A B) :\n  segment_cover A L = segment_cover B L := sorry\n\ntheorem large_L_single_segment {A : List Int} (h : A.length > 0) :\n  let max_dist := (List.maximum? A).getD 0 - (List.minimum? A).getD 0\n  segment_cover A ((max_dist : Int).toNat) = 1 := sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval segment_cover [1, 3, 4, 5, 8] 3\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval segment_cover [1, 5, 2, 4, 3] 1\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval segment_cover [1, 10, 100, 1000] 1", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3606", "language": "lean", "source": "fvapps", "source-id": "fvapps_003606", "source-notes": "", "vc-description": "/-\nYou've came to visit your grandma and she straight away found you a job - her Christmas tree needs decorating!\n\nShe first shows you a tree with an identified number of branches, and then hands you a some baubles (or loads of them!).\n\nYou know your grandma is a very particular person and she would like the baubles to be distributed in the orderly manner. You decide the best course of action would be to put the same number of baubles on each of the branches (if possible) or add one more bauble to some of the branches - starting from the beginning of the tree. \n\nIn this kata you will return an array of baubles on each of the branches.\n\nFor example: \n\n10 baubles, 2 branches: [5,5]\n5 baubles, 7 branches: [1,1,1,1,1,0,0]\n12 baubles, 5 branches: [3,3,2,2,2]\n\nThe numbers of branches and baubles will be always greater or equal to 0.\nIf there are 0 branches return: \"Grandma, we will have to buy a Christmas tree first!\".\n\nGood luck - I think your granny may have some minced pies for you if you do a good job!\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | h::t => h + sum t", "vc-helpers": "", "vc-definitions": "def baubles_on_tree (baubles : Nat) (branches : Nat) : List Nat × String := sorry\n\ntheorem baubles_distribution (baubles : Nat) (branches : Nat)\n  (h1 : baubles ≤ 1000)\n  (h2 : branches ≤ 100) \n  (h3 : branches > 0) : \n  let (list, _) := baubles_on_tree baubles branches\n  -- Sum equals input baubles\n  List.sum list = baubles ∧ \n  -- Length equals branches \n  list.length = branches ∧\n  -- Max difference ≤ 1\n  (∀ x y, x ∈ list → y ∈ list → x - y ≤ 1) ∧\n  -- All non-negative\n  (∀ x, x ∈ list → x ≥ 0) := sorry", "vc-theorems": "theorem zero_branches (baubles : Nat) (h : baubles ≤ 1000) :\n  let (_, msg) := baubles_on_tree baubles 0\n  msg = \"Grandma, we will have to buy a Christmas tree first!\" := sorry\n\ntheorem zero_baubles (branches : Nat) (h1 : branches ≤ 100) (h2 : branches > 0) :\n  let (list, _) := baubles_on_tree 0 branches\n  list.length = branches ∧\n  (∀ x, x ∈ list → x = 0) := sorry\n\n/-\ninfo: [1, 1, 1, 1, 1]\n-/\n-- #guard_msgs in\n-- #eval baubles_on_tree 5 5\n\n/-\ninfo: 'Grandma, we will have to buy a Christmas tree first!'\n-/\n-- #guard_msgs in\n-- #eval baubles_on_tree 5 0\n\n/-\ninfo: [2, 1, 1, 1, 1]\n-/\n-- #guard_msgs in\n-- #eval baubles_on_tree 6 5", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3611", "language": "lean", "source": "fvapps", "source-id": "fvapps_003611", "source-notes": "", "vc-description": "/-\n# Task:\n\nWe define the \"self reversed power sequence\" as one shown below:\n\nImplement a function that takes 2 arguments (`ord max` and `num dig`), and finds the smallest term of the sequence whose index is less than or equal to `ord max`, and has exactly `num dig` number of digits.\n\nIf there is a number with correct amount of digits, the result should be an array in the form:\n\n```python\n[True, smallest found term]\n[False, -1]\n```\n\n## Input range:\n\n```python\nord_max <= 1000\n```\n\n___\n\n## Examples:\n\n```python\nmin_length_num(5, 10) == [True, 10]   # 10th term has 5 digits\nmin_length_num(7, 11) == [False, -1]  # no terms before the 13th one have 7 digits\nmin_length_num(7, 14) == [True, 13]   # 13th term is the first one which has 7 digits\n```\n\nWhich you can see in the table below:\n\n```\nn-th Term    Term Value\n1              0\n2              1\n3              3\n4              8\n5              22\n6              65\n7              209\n8              732\n9              2780\n10             11377\n11             49863\n12             232768\n13             1151914\n14             6018785\n```\n\n___\n\nEnjoy it and happy coding!!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def min_length_num (digits max_num : Int) : Result := sorry\n\ntheorem min_length_num_valid_input (digits max_num : Int)\n  (h1 : digits ≥ 1) (h2 : digits ≤ 100)\n  (h3 : max_num ≥ 1) (h4 : max_num ≤ 1000) :\n  let result := min_length_num digits max_num\n  result.success → (\n    result.value ≤ max_num ∧\n    result.value > 0\n  ) := sorry", "vc-theorems": "theorem min_length_num_invalid_digits (digits max_num : Int)\n  (h1 : digits ≤ 0) (h2 : max_num ≥ 1) (h3 : max_num ≤ 1000) :\n  min_length_num digits max_num = ⟨false, -1⟩ := sorry\n\ntheorem min_length_num_invalid_max_num (digits max_num : Int)\n  (h1 : digits ≥ 1) (h2 : digits ≤ 100) (h3 : max_num ≤ 0) :\n  min_length_num digits max_num = ⟨false, -1⟩ := sorry\n\n/-\ninfo: [True, 10]\n-/\n-- #guard_msgs in\n-- #eval min_length_num 5 10\n\n/-\ninfo: [False, -1]\n-/\n-- #guard_msgs in\n-- #eval min_length_num 7 11\n\n/-\ninfo: [True, 13]\n-/\n-- #guard_msgs in\n-- #eval min_length_num 7 14", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3626", "language": "lean", "source": "fvapps", "source-id": "fvapps_003626", "source-notes": "", "vc-description": "/-\nWrite a function which takes one parameter representing the dimensions of a checkered board. The board will always be square, so 5 means you will need a 5x5 board.\n\nThe dark squares will be represented by a unicode white square, while the light squares will be represented by a unicode black square (the opposite colours ensure the board doesn't look reversed on code wars' dark background). It should return a string of the board with a space in between each square and taking into account new lines. \n\nAn even number should return a board that begins with a dark square. An odd number should return a board that begins with a light square.\n\nThe input is expected to be a whole number that's at least two, and returns false otherwise (Nothing in Haskell).\n\nExamples:\n\n```python\ncheckered_board(5)\n```\n\nreturns the string\n```\n■ □ ■ □ ■\n□ ■ □ ■ □\n■ □ ■ □ ■\n□ ■ □ ■ □\n■ □ ■ □ ■\n```\n\n**There should be no trailing white space at the end of each line, or new line characters at the end of the string.**\n\n**Note**   \nDo not use HTML entities for the squares (e.g. `□` for white square) as the code doesn't consider it a valid square. A good way to check is if your solution prints a correct checker board on your local terminal.  \n\n**Ruby note:**\nCodeWars has encoding issues with rendered unicode in Ruby.\nYou'll need to use unicode source code (e.g. \"\\u25A0\") instead of rendered unicode (e.g \"■\").\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def checkered_board (n : Int) : String := sorry\n\n/- For valid inputs (n ≥ 2), checkered_board produces a string with:\n    1. n rows\n    2. n columns in each row\n    3. Alternating pattern of □ and ■ where:\n       - For even n, top-left is □\n       - For odd n, top-left is ■ -/", "vc-theorems": "theorem valid_board_pattern (n : Int) (h : n ≥ 2) :\n  let result := checkered_board n\n  let rows := result.splitOn \"\\n\"\n  (result.isEmpty = false) ∧ \n  (rows.length = n) ∧ \n  (∀ row ∈ rows, (row.splitOn \" \").length = n) ∧\n  (∀ (i j : Nat), i < n.toNat → j < n.toNat → \n    ((rows.get! i).splitOn \" \").get! j = \n      if ((i : Int) + j) % 2 = n % 2 \n      then \"■\" \n      else \"□\") := sorry\n\n/- For invalid inputs (n ≤ 1), checkered_board returns false -/\n\ntheorem invalid_inputs (n : Int) (h : n ≤ 1) :\n  checkered_board n = \"false\" := sorry\n\nend CheckeredBoard\n\n/-\ninfo: '■ □ ■ □ ■\\n□ ■ □ ■ □\\n■ □ ■ □ ■\\n□ ■ □ ■ □\\n■ □ ■ □ ■'\n-/\n-- #guard_msgs in\n-- #eval checkered_board 5\n\n/-\ninfo: '■ □ ■\\n□ ■ □\\n■ □ ■'\n-/\n-- #guard_msgs in\n-- #eval checkered_board 3\n\n/-\ninfo: '□ ■\\n■ □'\n-/\n-- #guard_msgs in\n-- #eval checkered_board 2\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval checkered_board 1\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval checkered_board -1\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval checkered_board \"test\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval checkered_board None", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3629", "language": "lean", "source": "fvapps", "source-id": "fvapps_003629", "source-notes": "", "vc-description": "/-\n```if:javascript\n`Array.prototype.length` will give you the number of top-level elements in an array.\n```\n```if:ruby\n`Array#length` will give you the number of top-level elements in an array.\n```\n```if:csharp\nThe `Length` property of an array will give you the number of top-level elements in an array.\n```\n```if:php\n`count()` will give you the number of top-level elements in an array if exactly one argument `$a` is passed in which is the array.\n```\n```if:python\n`len(a)` will give you the number of top-level elements in the list/array named `a`.\n```\n\nYour task is to create a function ```deepCount``` that returns the number of ALL elements within an array, including any within inner-level arrays.\n\nFor example:\n\n```if:javascript\n    deepCount([1, 2, 3]);  \n    //>>>>> 3\n    deepCount([\"x\", \"y\", [\"z\"]]);  \n    //>>>>> 4\n    deepCount([1, 2, [3, 4, [5]]]);  \n    //>>>>> 7\n```\n```if:ruby\n    deepCount([1, 2, 3]);  \n    //>>>>> 3\n    deepCount([\"x\", \"y\", [\"z\"]]);  \n    //>>>>> 4\n    deepCount([1, 2, [3, 4, [5]]]);  \n    //>>>>> 7\n```\n```if:csharp\n    deepCount([1, 2, 3]);  \n    //>>>>> 3\n    deepCount([\"x\", \"y\", [\"z\"]]);  \n    //>>>>> 4\n    deepCount([1, 2, [3, 4, [5]]]);  \n    //>>>>> 7\n```\n```if:php\n    deep_c([1, 2, 3]);\n    //>>>>> 3\n    deep_c([\"x\", \"y\", [\"z\"]]);\n    //>>>>> 4\n    deep_c([1, 2, [3, 4, [5]]]);\n    //>>>>> 7\n```\n```if:python\n    deepCount([1, 2, 3]);  \n    //>>>>> 3\n    deepCount([\"x\", \"y\", [\"z\"]]);  \n    //>>>>> 4\n    deepCount([1, 2, [3, 4, [5]]]);  \n    //>>>>> 7\n```\n\nThe input will always be an array.\n\n```if:php\nIn PHP you may *not* assume that the array passed in will be non-associative.\n\nPlease note that `count()`, `eval()` and `COUNT_RECURSIVE` are disallowed - you should be able to implement the logic for `deep_c()` yourself ;)\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def deep_count {α : Type} (l : NestedList α) : Nat :=\n  sorry", "vc-theorems": "theorem deep_count_nonnegative {α : Type} (l : NestedList α) :\n  deep_count l ≥ 0 :=\nsorry\n\ntheorem deep_count_geq_outer_length {α : Type} (l : List (NestedList α)) :\n  deep_count (NestedList.list l) ≥ l.length :=\nsorry\n\ntheorem deep_count_flat_list {α : Type} (l : List α) :\n  deep_count (NestedList.list (l.map NestedList.elem)) = l.length :=\nsorry\n\ntheorem deep_count_nested_list {α : Type} (outer : List (List α)) :\n  deep_count (NestedList.list (outer.map (fun inner => NestedList.list (inner.map NestedList.elem)))) =\n  outer.length + (outer.foldl (fun acc l => acc + l.length) 0) :=\nsorry\n\ntheorem deep_count_empty {α : Type} :\n  deep_count (NestedList.list ([] : List (NestedList α))) = 0 :=\nsorry\n\ntheorem deep_count_empty_nested {α : Type} :\n  deep_count (NestedList.list [NestedList.list ([] : List (NestedList α))]) = 1 :=\nsorry\n\ntheorem deep_count_two_empty {α : Type} :\n  deep_count (NestedList.list [NestedList.list ([] : List (NestedList α)), NestedList.list ([] : List (NestedList α))]) = 2 :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval deep_count [1, 2, 3]\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval deep_count [\"x\", \"y\", [\"z\"]]\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval deep_count [1, 2, [3, 4, [5]]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3630", "language": "lean", "source": "fvapps", "source-id": "fvapps_003630", "source-notes": "", "vc-description": "/-\nGiven a certain integer  ```n, n > 0```and a number of partitions,  ```k, k > 0```; we want to know the partition which has the maximum or minimum product of its terms.\n\nThe function ```find_spec_partition() ```, will receive three arguments,  ```n```,  ```k```, and a command:  ```'max' or 'min'```\n\nThe function should output the partition that has maximum or minimum value product (it depends on the given command) as an array with its terms in decreasing order.\n\nLet's see some cases (Python and Ruby)\n```\nfind_spec_partition(10, 4, 'max') == [3, 3, 2, 2]\nfind_spec_partition(10, 4, 'min') == [7, 1, 1, 1]\n```\nand Javascript:\n```\nfindSpecPartition(10, 4, 'max') == [3, 3, 2, 2]\nfindSpecPartition(10, 4, 'min') == [7, 1, 1, 1]\n```\nThe partitions of 10 with 4 terms with their products are:\n```\n(4, 3, 2, 1): 24\n(4, 2, 2, 2): 32\n(6, 2, 1, 1): 12\n(3, 3, 3, 1): 27\n(4, 4, 1, 1): 16\n(5, 2, 2, 1): 20 \n(7, 1, 1, 1): 7   <------- min. productvalue\n(3, 3, 2, 2): 36  <------- max.product value\n(5, 3, 1, 1): 15\n```\nEnjoy it!\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + xs.sum\n\ndef List.prod : List Nat → Nat \n  | [] => 1\n  | x::xs => x * xs.prod", "vc-helpers": "", "vc-definitions": "def find_spec_partition (n k : Nat) (command : String) : List Nat :=\n  sorry", "vc-theorems": "theorem find_spec_partition_length (n k : Nat) (h : k ≤ n) :\n  ∀ command, command = \"max\" ∨ command = \"min\" →\n    (find_spec_partition n k command).length = k := sorry\n\ntheorem find_spec_partition_positive (n k : Nat) (h : k ≤ n) :\n  ∀ command, command = \"max\" ∨ command = \"min\" →\n    ∀ x, x ∈ find_spec_partition n k command → x > 0 := sorry\n\ntheorem find_spec_partition_max_diff (n k : Nat) (h : k ≤ n) :\n  let result := find_spec_partition n k \"max\"\n  ∀ x y, x ∈ result → y ∈ result → x - y ≤ 1 := sorry\n\n/-\ninfo: [3, 3, 2, 2]\n-/\n-- #guard_msgs in\n-- #eval find_spec_partition 10 4 \"max\"\n\n/-\ninfo: [7, 1, 1, 1]\n-/\n-- #guard_msgs in\n-- #eval find_spec_partition 10 4 \"min\"\n\n/-\ninfo: [3, 3, 2]\n-/\n-- #guard_msgs in\n-- #eval find_spec_partition 8 3 \"max\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3639", "language": "lean", "source": "fvapps", "source-id": "fvapps_003639", "source-notes": "", "vc-description": "/-\nTake 2 strings `s1` and `s2` including only letters from `a`to `z`.\nReturn a new **sorted** string, the longest possible, containing distinct letters,\n- each taken only once - coming from s1 or s2.\n\n# Examples:\n```\na = \"xyaabbbccccdefww\"\nb = \"xxxxyyyyabklmopq\"\nlongest(a, b) -> \"abcdefklmopqwxy\"\n\na = \"abcdefghijklmnopqrstuvwxyz\"\nlongest(a, a) -> \"abcdefghijklmnopqrstuvwxyz\"\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def longest (s1 s2 : List Char) : List Char :=\n  sorry", "vc-theorems": "theorem longest_unique_chars {s1 s2 : List Char} :\n  let result := longest s1 s2\n  ∀ x ∈ result, ∀ y ∈ result, x = y → result.indexOf x = result.indexOf y :=\n  sorry\n\ntheorem longest_sorted {s1 s2 : List Char} :\n  let result := longest s1 s2\n  ∀ i j, i < j → j < result.length → result[i]! ≤ result[j]! :=\n  sorry\n\ntheorem longest_chars_from_inputs {s1 s2 : List Char} :\n  let result := longest s1 s2\n  ∀ c ∈ result, c ∈ s1 ++ s2 :=\n  sorry\n\ntheorem longest_contains_all_unique_inputs {s1 s2 : List Char} :\n  let result := longest s1 s2\n  ∀ c ∈ s1 ++ s2, c ∈ result :=\n  sorry\n\ntheorem longest_identity {s : List Char} :\n  longest s s = longest s [] ∧ longest s [] = longest [] s :=\n  sorry\n\ntheorem longest_commutative {s1 s2 : List Char} :\n  longest s1 s2 = longest s2 s1 :=\n  sorry\n\n/-\ninfo: 'abcdefklmopqwxy'\n-/\n-- #guard_msgs in\n-- #eval longest \"xyaabbbccccdefww\" \"xxxxyyyyabklmopq\"\n\n/-\ninfo: 'aehrsty'\n-/\n-- #guard_msgs in\n-- #eval longest \"aretheyhere\" \"yestheyarehere\"\n\n/-\ninfo: 'adefghklmnorstu'\n-/\n-- #guard_msgs in\n-- #eval longest \"lordsofthefallen\" \"gamekult\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3648", "language": "lean", "source": "fvapps", "source-id": "fvapps_003648", "source-notes": "", "vc-description": "/-\nYour job is to write a function that takes a string and a maximum number of characters per line and then inserts line breaks as necessary so that no line in the resulting string is longer than the specified limit.\n\nIf possible, line breaks should not split words. However, if a single word is longer than the limit, it obviously has to be split. In this case, the line break should be placed after the first part of the word (see examples below).\n\nReally long words may need to be split multiple times.\n\n#Input\n\nA word consists of one or more letters.\n\nInput text will be the empty string or a string consisting of one or more words separated by single spaces. It will not contain any punctiation or other special characters.\n\nThe limit will always be an integer greater or equal to one.\n\n#Examples\n\n**Note:** Line breaks in the results have been replaced with two dashes to improve readability.\n\n1. (\"test\", 7) -> \"test\"\n2. (\"hello world\", 7) -> \"hello--world\"\n3. (\"a lot of words for a single line\", 10) -> \"a lot of--words for--a single--line\"\n4. (\"this is a test\", 4) -> \"this--is a--test\"\n5. (\"a longword\", 6) -> \"a long--word\"\n6. (\"areallylongword\", 6) -> \"areall--ylongw--ord\"\n\n**Note:** Sometimes spaces are hard to see in the test results window.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def word_wrap (text : String) (limit : Nat) : String := sorry\n\ntheorem word_wrap_line_length {text : String} {limit : Nat}\n  (h_text : ∀ c ∈ text.data, c.isAlpha ∨ c = ' ')\n  (h_limit : limit > 0) :\n  let result := word_wrap text limit\n  ∀ line ∈ result.splitOn \"\\n\", line.length ≤ limit := sorry", "vc-theorems": "theorem word_wrap_preserves_content {text : String} {limit : Nat}\n  (h_text : ∀ c ∈ text.data, c.isAlpha ∨ c = ' ')\n  (h_limit : limit > 0) :\n  let result := word_wrap text limit\n  (String.join (text.splitOn \" \")).data = (String.join (result.replace \"\\n\" \"\" |>.splitOn \" \")).data := sorry\n\ntheorem single_word_wrap_properties {text : String} {limit : Nat}\n  (h_text : ∀ c ∈ text.data, c.isAlpha)\n  (h_text_nonempty : text.length > 0)\n  (h_limit : limit > 0)\n  (h_limit_bound : limit ≤ text.length) :\n  let result := word_wrap text limit\n  let lines := result.splitOn \"\\n\"\n  (∀ i : Fin lines.length, i.val < lines.length - 1 → (lines[i]).length = limit) ∧\n  (match lines.get? (lines.length - 1) with\n   | none => 0\n   | some lastLine => lastLine.length) ≤ limit ∧\n  String.join lines = text := sorry\n\ntheorem multiple_words_no_splitting {words : List String} {limit : Nat}\n  (h_words_nonempty : words ≠ [])\n  (h_words_alpha : ∀ w ∈ words, ∀ c ∈ w.data, c.isAlpha)\n  (h_max_word := words.map String.length |>.maximum?)\n  (h_limit : ∀ w ∈ words, w.length < limit) :\n  let text := String.join (List.intersperse \" \" words)\n  let result := word_wrap text limit\n  (result.replace \"\\n\" \" \").splitOn \" \" = words := sorry\n\n/-\ninfo: 'test'\n-/\n-- #guard_msgs in\n-- #eval word_wrap \"test\" 7\n\n/-\ninfo: 'hello\\nworld'\n-/\n-- #guard_msgs in\n-- #eval word_wrap \"hello world\" 7\n\n/-\ninfo: 'areall\\nylongw\\nord'\n-/\n-- #guard_msgs in\n-- #eval word_wrap \"areallylongword\" 6", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3650", "language": "lean", "source": "fvapps", "source-id": "fvapps_003650", "source-notes": "", "vc-description": "/-\n*** Nova polynomial from roots*** \n\nThis kata is from a series on polynomial handling. ( [#1](http://www.codewars.com/kata/nova-polynomial-1-add-1)   [#2](http://www.codewars.com/kata/570eb07e127ad107270005fe)  [#3](http://www.codewars.com/kata/5714041e8807940ff3001140 )   [#4](http://www.codewars.com/kata/571a2e2df24bdfd4e20001f5))\n\nConsider a polynomial in a list where each element in the list element corresponds to the factors. The factor order is the position in the list. The first element is the zero order factor (the constant).\n\np = [a0, a1, a2, a3] signifies the polynomial a0 + a1x + a2x^2 + a3*x^3\n\nIn this kata create the polynomial from a list of roots:\n\n[r0, r1 ,r2, r3 ]\n\np = (x-r0)(x-r1)(x-r2)(x-r3)\n\nnote: no roots should return the identity polynomial.\n\n```python \npoly_from_roots([4]) = [-4, 1]\npoly_from_roots([0, 0, 0, 0] ) = [0, 0, 0, 0, 1]\npoly_from_roots([]) = [1]\n```\nThe first katas of this series is preloaded in the code and can be used: [poly_add](http://www.codewars.com/kata/570eb07e127ad107270005fe) [poly_multiply](http://www.codewars.com/kata/570eb07e127ad107270005fe)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def poly_from_roots (roots : List float) : List float := sorry\n\ndef evaluatePolynomial (coeffs : List float) (x : float) : float := sorry", "vc-theorems": "theorem poly_from_roots_length {roots : List float} \n  (h : ∀ x ∈ roots, x.value ≥ -10 ∧ x.value ≤ 10) :\n  (poly_from_roots roots).length = roots.length + 1 := sorry\n\ntheorem poly_from_roots_last_coeff {roots : List float}\n  (h : ∀ x ∈ roots, x.value ≥ -10 ∧ x.value ≤ 10) :\n  let result := poly_from_roots roots\n  (result.getLast (sorry)).value = float.one.value := sorry\n\ntheorem poly_evaluates_to_zero {roots : List float} (root : float)\n  (h1 : ∀ x ∈ roots, x.value ≥ -10 ∧ x.value ≤ 10)\n  (h2 : root ∈ roots) :\n  let result := poly_from_roots roots\n  evaluatePolynomial result root = float.zero := sorry\n\ntheorem empty_roots :\n  poly_from_roots [] = [float.one] := sorry\n\ntheorem zero_roots {n : Nat} (h : n > 0 ∧ n ≤ 10) :\n  poly_from_roots (List.replicate n float.zero) = List.replicate n float.zero ++ [float.one] := sorry\n\n/-\ninfo: [-4, 1]\n-/\n-- #guard_msgs in\n-- #eval poly_from_roots [4]\n\n/-\ninfo: [0, 0, 0, 0, 1]\n-/\n-- #guard_msgs in\n-- #eval poly_from_roots [0, 0, 0, 0]\n\n/-\ninfo: [1]\n-/\n-- #guard_msgs in\n-- #eval poly_from_roots []", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3662", "language": "lean", "source": "fvapps", "source-id": "fvapps_003662", "source-notes": "", "vc-description": "/-\n###BACKGROUND:\nJacob recently decided to get healthy and lose some weight. He did a lot of reading and research and after focusing on steady exercise and a healthy diet for several months, was able to shed over 50 pounds! Now he wants to share his success, and has decided to tell his friends and family how much weight they could expect to lose if they used the same plan he followed.\n\nLots of people are really excited about Jacob's program and they want to know how much weight they would lose if they followed his plan. Unfortunately, he's really bad at math, so he's turned to you to help write a program that will calculate the expected weight loss for a particular person, given their weight and how long they think they want to continue the plan.\n\n###TECHNICAL DETAILS:\nJacob's weight loss protocol, if followed closely, yields loss according to a simple formulae, depending on gender. Men can expect to lose 1.5% of their current body weight each week they stay on plan. Women can expect to lose 1.2%. (Children are advised to eat whatever they want, and make sure to play outside as much as they can!)\n\n###TASK:\nWrite a function that takes as input:\n```\n- The person's gender ('M' or 'F');\n- Their current weight (in pounds);\n- How long they want to stay true to the protocol (in weeks);\n```\nand then returns the expected weight at the end of the program.\n\n###NOTES:\nWeights (both input and output) should be decimals, rounded to the nearest tenth.\nDuration (input) should be a whole number (integer). If it is not, the function should round to the nearest whole number.\nWhen doing input parameter validity checks, evaluate them in order or your code will not pass final tests.\n-/", "vc-preamble": "def lose_weight (gender : Gender) (weight : Float) (duration : Nat) : String ⊕ Float := sorry\n\ntheorem weight_always_decreases\n  (gender : Gender) (weight : Float) (duration : Nat)\n  (h1 : weight > 0)\n  (h2 : duration > 0) :\n  match lose_weight gender weight duration with\n  | Sum.inr result => result ≤ weight\n  | Sum.inl _ => True\n  := sorry", "vc-helpers": "", "vc-definitions": "def lose_weight_string (gender : String) (weight : Float) (duration : Nat) : String := sorry\n\ntheorem invalid_gender\n  (gender : String) (weight : Float) (duration : Nat)\n  (h : gender ≠ \"M\" ∧ gender ≠ \"F\")\n  (h1 : weight > 0)\n  (h2 : duration > 0) :\n  lose_weight_string gender weight duration = \"Invalid gender\" := sorry", "vc-theorems": "theorem weight_loss_proportional_to_duration\n  (gender : Gender) (weight : Float) (duration : Nat)\n  (h1 : weight > 0)\n  (h2 : duration > 0) :\n  match lose_weight gender weight duration, lose_weight gender weight (2 * duration) with\n  | Sum.inr result1, Sum.inr result2 => result2 ≤ result1\n  | _, _ => True\n  := sorry\n\ntheorem invalid_weight\n  (gender : Gender) (weight : Float) (duration : Nat)\n  (h : weight ≤ 0)\n  (h2 : duration > 0) :\n  match lose_weight gender weight duration with\n  | Sum.inl s => s = \"Invalid weight\"\n  | _ => False\n  := sorry\n\ntheorem invalid_duration\n  (gender : Gender) (weight : Float) (duration : Nat)\n  (h : duration = 0)\n  (h1 : weight > 0) :\n  match lose_weight gender weight duration with\n  | Sum.inl s => s = \"Invalid duration\"\n  | _ => False\n  := sorry\n\nend LoseWeight\n\n/-\ninfo: 231.8\n-/\n-- #guard_msgs in\n-- #eval lose_weight \"M\" 250 5\n\n/-\ninfo: 172.5\n-/\n-- #guard_msgs in\n-- #eval lose_weight \"F\" 190 8\n\n/-\ninfo: 'Invalid gender'\n-/\n-- #guard_msgs in\n-- #eval lose_weight \"X\" 200 10\n\n/-\ninfo: 'Invalid weight'\n-/\n-- #guard_msgs in\n-- #eval lose_weight \"M\" -5 10\n\n/-\ninfo: 'Invalid duration'\n-/\n-- #guard_msgs in\n-- #eval lose_weight \"F\" 160 0", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3671", "language": "lean", "source": "fvapps", "source-id": "fvapps_003671", "source-notes": "", "vc-description": "/-\nThree candidates take part in a TV show.\n\nIn order to decide who will take part in the final game and probably become rich, they have to roll the Wheel of Fortune!\n\nThe Wheel of Fortune is divided into 20 sections, each with a number from 5 to 100 (only mulitples of 5).\n\nEach candidate can roll the wheel once or twice and sum up the score of each roll.\nThe winner one that is closest to 100 (while still being lower or equal to 100). \nIn case of a tie, the candidate that rolled the wheel first wins.\n\nYou receive the information about each candidate as an array of objects: each object should have a `name` and a `scores` array with the candidate roll values.\n\nYour solution should return the name of the winner or `false` if there is no winner (all scored more than 100).\n\n__Example:__\n\n```python\nc1 = {\"name\": \"Bob\", \"scores\": [10, 65]}\nc2 = {\"name\": \"Bill\", \"scores\": [90, 5]}\nc3 = {\"name\": \"Charlie\", \"scores\": [40, 55]}\nwinner([c1, c2, c3]) #Returns \"Bill\"\n```\n\nPlease note that inputs may be invalid: in this case, the function should return false.\n\nPotential errors derived from the specifications are:\n- More or less than three candidates take part in the game.\n- A candidate did not roll the wheel or rolled it more than twice.\n- Scores are not valid.\n- Invalid user entry (no name or no score).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def winner : List Candidate → Option String := sorry\n\ntheorem invalid_candidate_count \n  {cs : List Candidate} : \n  cs.length ≠ 3 → winner cs = none := sorry", "vc-theorems": "theorem invalid_scores \n  {cs : List Candidate}\n  (h_length : cs.length = 3)\n  (h_invalid : ∃ c, c ∈ cs ∧ ∃ s, s ∈ c.scores ∧ ¬(s % 5 = 0 ∧ 5 ≤ s ∧ s ≤ 100)) :\n  winner cs = none := sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval len candidates\n\n/-\ninfo: 'Bill'\n-/\n-- #guard_msgs in\n-- #eval winner [c1, c2, c3]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval winner []\n\n/-\ninfo: 'Bill'\n-/\n-- #guard_msgs in\n-- #eval winner [c1, c2, c3]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3684", "language": "lean", "source": "fvapps", "source-id": "fvapps_003684", "source-notes": "", "vc-description": "/-\nThe concept of \"[smooth number](https://en.wikipedia.org/wiki/Smooth_number)\" is applied to all those numbers whose prime factors are lesser than or equal to `7`: `60` is a smooth number (`2 * 2 * 3 * 5`), `111` is not (`3 * 37`).\n\nMore specifically, smooth numbers are classified by their highest prime factor and your are tasked with writing a `isSmooth`/`is_smooth` function that returns a string with this classification as it follows:\n\n* 2-smooth numbers should be all defined as a `\"power of 2\"`, as they are merely that;\n* 3-smooth numbers are to return a result of `\"3-smooth\"`;\n* 5-smooth numbers will be labelled as `\"Hamming number\"`s (incidentally, you might appreciate [this nice kata on them](https://www.codewars.com/kata/hamming-numbers));\n* 7-smooth numbers are classified as `\"humble numbers\"`s;\n* for all the other numbers, just return `non-smooth`.\n\nExamples:\n```python\nis_smooth(16) == \"power of 2\"\nis_smooth(36) == \"3-smooth\"\nis_smooth(60) == \"Hamming number\"\nis_smooth(98) == \"humble number\"\nis_smooth(111) == \"non-smooth\"\n```\nThe provided input `n` is always going to be a positive number `> 1`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def is_smooth (n: Nat) : SmoothType := sorry\n\ntheorem is_smooth_valid_output (n: Nat) (h: n ≥ 2) : \n  is_smooth n = SmoothType.PowerOfTwo ∨ \n  is_smooth n = SmoothType.ThreeSmooth ∨\n  is_smooth n = SmoothType.HammingNumber ∨ \n  is_smooth n = SmoothType.HumbleNumber ∨\n  is_smooth n = SmoothType.NonSmooth := sorry", "vc-theorems": "theorem power_of_two (exp: Nat) (h: exp > 0) :\n  is_smooth (2^exp) = SmoothType.PowerOfTwo := sorry\n\ntheorem product_of_two_and_three (exp2 exp3: Nat) (h1: exp2 > 0) (h2: exp3 > 0) :\n  is_smooth ((2^exp2) * (3^exp3)) = SmoothType.ThreeSmooth := sorry\n\ntheorem hamming_numbers (exp2 exp3 exp5: Nat) \n  (h1: exp2 > 0) (h2: exp3 > 0) (h3: exp5 > 0) :\n  is_smooth ((2^exp2) * (3^exp3) * (5^exp5)) = SmoothType.HammingNumber := sorry\n\ntheorem large_prime_factors (n: Nat) \n  (h1: n ≥ 13)\n  (h2: ∃ p ∈ [11, 13, 17, 19, 23], n % p = 0) :\n  is_smooth n = SmoothType.NonSmooth := sorry\n\n/-\ninfo: 'power of 2'\n-/\n-- #guard_msgs in\n-- #eval is_smooth 16\n\n/-\ninfo: '3-smooth'\n-/\n-- #guard_msgs in\n-- #eval is_smooth 36\n\n/-\ninfo: 'Hamming number'\n-/\n-- #guard_msgs in\n-- #eval is_smooth 60", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3690", "language": "lean", "source": "fvapps", "source-id": "fvapps_003690", "source-notes": "", "vc-description": "/-\nIn this Kata, you will be given an integer array and your task is to return the sum of elements occupying prime-numbered indices. \n\n~~~if-not:fortran\nThe first element of the array is at index `0`.\n~~~\n\n~~~if:fortran\nThe first element of an array is at index `1`.\n~~~\n\nGood luck! \n\nIf you like this Kata, try:\n\n[Dominant primes](https://www.codewars.com/kata/59ce11ea9f0cbc8a390000ed). It takes this idea a step further.\n\n[Consonant value](https://www.codewars.com/kata/59c633e7dcc4053512000073)\n-/", "vc-preamble": "def is_prime (n : Nat) : Bool :=\n  sorry\n\ndef total (arr : List Int) : Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def sqrt (n : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem total_empty_property (arr : List Int) :\n  arr = [] → total arr = 0 :=\nsorry\n\ntheorem total_properties (arr : List Int) :\n  total arr = (List.enum arr).foldl (fun acc (i, x) => if is_prime i then acc + x else acc) 0 :=\nsorry\n\ntheorem total_sign (arr : List Int) :\n  total arr ≥ 0 ∨ ∃ x ∈ arr, x < 0 :=\nsorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval total []\n\n/-\ninfo: 7\n-/\n-- #guard_msgs in\n-- #eval total [1, 2, 3, 4]\n\n/-\ninfo: 21\n-/\n-- #guard_msgs in\n-- #eval total [1, 2, 3, 4, 5, 6, 7, 8]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3695", "language": "lean", "source": "fvapps", "source-id": "fvapps_003695", "source-notes": "", "vc-description": "/-\nThe new £5 notes have been recently released in the UK and they've certainly became a sensation! Even those of us who haven't been carrying any cash around for a while, having given in to the convenience of cards, suddenly like to have some of these in their purses and pockets. But how many of them could you get with what's left from your salary after paying all bills? The programme that you're about to write will count this for you!\n\nGiven a salary and the array of bills, calculate your disposable income for a month and return it as a number of new £5 notes you can get with that amount. If the money you've got (or do not!) doesn't allow you to get any £5 notes return 0.\n\n£££ GOOD LUCK! £££\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + List.sum xs", "vc-helpers": "", "vc-definitions": "def get_new_notes (salary: Nat) (bills: List Nat) : Nat :=\n  sorry", "vc-theorems": "theorem get_new_notes_edge_zero_salary : \n  get_new_notes 0 [] = 0 := sorry\n\ntheorem get_new_notes_edge_min_note : \n  get_new_notes 5 [] = 1 := sorry\n\ntheorem get_new_notes_edge_no_remainder :\n  get_new_notes 100 [100] = 0 := sorry\n\ntheorem get_new_notes_edge_insufficient :\n  get_new_notes 100 [200] = 0 := sorry\n\n/-\ninfo: 188\n-/\n-- #guard_msgs in\n-- #eval get_new_notes 2000 [500, 160, 400]\n\n/-\ninfo: 122\n-/\n-- #guard_msgs in\n-- #eval get_new_notes 1260 [500, 50, 100]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval get_new_notes 2000 [500, 495, 100, 900]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3708", "language": "lean", "source": "fvapps", "source-id": "fvapps_003708", "source-notes": "", "vc-description": "/-\nWrite a function that takes an array/list of numbers and returns a number such that \n\nExplanation\ntotal([1,2,3,4,5]) => 48\n\n1+2=3--\\ 3+5 =>     8 \\\n2+3=5--/ \\            ==  8+12=>20\\     \n          ==>5+7=> 12 / \\           20+28 => 48\n3+4=7--\\ /            == 12+16=>28/\n4+5=9--/ 7+9 =>     16  /\n\nif total([1,2,3]) => 8 then \n\nfirst+second => 3 \\\n                   then 3+5 => 8\nsecond+third => 5 /\n\n### Examples\n```python\ntotal([-1,-1,-1]) => -4\ntotal([1,2,3,4])  => 20\n```\n\n**Note:** each array/list will have at least an element and all elements will be valid numbers.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def total (arr: List Int) : Int :=\n  sorry", "vc-theorems": "theorem total_sequence_property {arr: List Int} (h: arr.length ≥ 2) :\n  let first_iter := (arr.zip (arr.tail!)).map (fun p => p.1 + p.2)\n  first_iter.length = arr.length - 1 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3709", "language": "lean", "source": "fvapps", "source-id": "fvapps_003709", "source-notes": "", "vc-description": "/-\nWe need you to implement a method of receiving commands over a network, processing the information and responding.\n\nOur device will send a single packet to you containing data and an instruction which you must perform before returning your reply.\n\nTo keep things simple, we will be passing a single \"packet\" as a string. \nEach \"byte\" contained in the packet is represented by 4 chars.\n\nOne packet is structured as below:\n```\nHeader  Instruction   Data1    Data2   Footer\n------   ------       ------   ------  ------\n H1H1     0F12         0012     0008    F4F4\n------   ------       ------   ------  ------\n\nThe string received in this case would be - \"H1H10F1200120008F4F4\"\n\nInstruction: The calculation you should perform, always one of the below.\n            0F12 = Addition\n            B7A2 = Subtraction\n            C3D9 = Multiplication\n            FFFF = This instruction code should be used to identify your return value.\n``` \n- The Header and Footer are unique identifiers which you must use to form your reply.\n\n- Data1 and Data2 are the decimal representation of the data you should apply your instruction to. _i.e 0109 = 109._\n\n- Your response must include the received header/footer, a \"FFFF\" instruction code, and the result of your calculation stored in Data1.\n\n- Data2 should be zero'd out to \"0000\".\n\n```\nTo give a complete example:\n\nIf you receive message \"H1H10F1200120008F4F4\".\nThe correct response would be \"H1H1FFFF00200000F4F4\"\n\n```\nIn the event that your calculation produces a negative result, the value returned should be \"0000\", similarily if the value is above 9999 you should return \"9999\".\n\nGoodluck, I look forward to reading your creative solutions!\n-/", "vc-preamble": "def String.substring (s : String) (start len : Nat) : String :=\n  sorry\n\ndef INSTRUCTIONS : Instruction → Operation :=\n  sorry", "vc-helpers": "", "vc-definitions": "def communication_module (packet : String) : String :=\n  sorry", "vc-theorems": "theorem communication_module_properties \n  (header : HeaderFooter) (inst : Instruction)\n  (d1 d2 : Data) (footer : HeaderFooter) :\n  let packet := header.value ++ inst.value ++ toString d1.value ++ toString d2.value ++ footer.value\n  let result := communication_module packet\n  let resultValue := String.toNat? (result.substring 8 4)\n  String.length result = 20 ∧\n  result.startsWith header.value ∧ \n  result.substring 4 4 = \"FFFF\" ∧\n  result.substring 12 4 = \"0000\" ∧\n  result.endsWith footer.value ∧\n  ∃ n : Nat, resultValue = some n ∧ \n  n < 10000 ∧\n  n = min 9999 (max 0 ((INSTRUCTIONS inst d1 d2).value)) :=\n  sorry\n\ntheorem addition_properties\n  (header : HeaderFooter) (d1 d2 : Data) (footer : HeaderFooter) :\n  let packet := header.value ++ \"0F12\" ++ toString d1.value ++ toString d2.value ++ footer.value  \n  let result := communication_module packet\n  let resultValue := String.toNat? (result.substring 8 4)\n  ∃ n : Nat, resultValue = some n ∧\n  n = min 9999 (max 0 (d1.value + d2.value)) :=\n  sorry\n\ntheorem packet_length_property\n  (packet : String)\n  (h : String.length packet = 20) :\n  String.length (communication_module packet) = 20 :=\n  sorry\n\n/-\ninfo: 'H1H1FFFF00200000F4F4'\n-/\n-- #guard_msgs in\n-- #eval communication_module \"H1H10F1200120008F4F4\"\n\n/-\ninfo: 'Y2Y2FFFF00980000N5N5'\n-/\n-- #guard_msgs in\n-- #eval communication_module \"Y2Y2B7A210000902N5N5\"\n\n/-\ninfo: 'A6A6FFFF99990000M0M0'\n-/\n-- #guard_msgs in\n-- #eval communication_module \"A6A6C3D911150015M0M0\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3736", "language": "lean", "source": "fvapps", "source-id": "fvapps_003736", "source-notes": "", "vc-description": "/-\n# History\n\nThis kata is a sequel of my [Mixbonacci](https://www.codewars.com/kata/mixbonacci/python) kata. Zozonacci is a special integer sequence named after [**ZozoFouchtra**](https://www.codewars.com/users/ZozoFouchtra), who came up with this kata idea in the [Mixbonacci discussion](https://www.codewars.com/kata/mixbonacci/discuss/python). \n\nThis sequence combines the rules for computing the n-th elements of fibonacci, jacobstal, pell, padovan, tribonacci and tetranacci sequences according to a given pattern.\n\n# Task\n\nCompute the first `n` elements of the Zozonacci sequence for a given pattern `p`.\n\n## Rules\n\n1. `n` is given as integer and `p` is given as a list of as abbreviations as strings (e.g. `[\"fib\", \"jac\", \"pad\"]`)\n2. When `n` is 0 or `p` is empty return an empty list.\n3. The first four elements of the sequence are determined by the first abbreviation in the pattern (see the table below).\n4. Compute the fifth element using the formula corespoding to the first element of the pattern, the sixth element using the formula for the second element and so on. (see the table below and the examples)\n5. If `n` is more than the length of `p` repeat the pattern.\n\n```\n+------------+--------------+------------------------------------------+---------------------+\n|  sequence  | abbreviation |         formula for n-th element         | first four elements |\n+------------|--------------+------------------------------------------|---------------------|\n| fibonacci  |     fib      | a[n] = a[n-1] + a[n-2]                   |     0, 0, 0, 1      |\n| jacobsthal |     jac      | a[n] = a[n-1] + 2 * a[n-2]               |     0, 0, 0, 1      |\n| padovan    |     pad      | a[n] = a[n-2] + a[n-3]                   |     0, 1, 0, 0      |\n| pell       |     pel      | a[n] = 2 * a[n-1] + a[n-2]               |     0, 0, 0, 1      |\n| tetranacci |     tet      | a[n] = a[n-1] + a[n-2] + a[n-3] + a[n-4] |     0, 0, 0, 1      |\n| tribonacci |     tri      | a[n] = a[n-1] + a[n-2] + a[n-3]          |     0, 0, 0, 1      |\n+------------+--------------+------------------------------------------+---------------------+\n```\n\n## Example\n\n```\nzozonacci([\"fib\", \"tri\"], 7) == [0, 0, 0, 1, 1, 2, 3]\n\nExplanation: \n\n          b     d\n       /-----\\/----\\\n[0, 0, 0, 1, 1, 2, 3]\n \\--------/  \n     | \\--------/\n     a     c\n\na - [0, 0, 0, 1] as \"fib\" is the first abbreviation\nb - 5th element is 1 as the 1st element of the pattern is \"fib\": 1 = 0 + 1\nc - 6th element is 2 as the 2nd element of the pattern is \"tri\": 2 = 0 + 1 + 1\nd - 7th element is 3 as the 3rd element of the pattern is \"fib\" (see rule no. 5): 3 = 2 + 1\n```\n\n## Sequences\n\n* [fibonacci](https://oeis.org/A000045) : 0, 1, 1, 2, 3 ...\n* [padovan](https://oeis.org/A000931): 1, 0, 0, 1, 0 ...\n* [jacobsthal](https://oeis.org/A001045): 0, 1, 1, 3, 5 ...\n* [pell](https://oeis.org/A000129): 0, 1, 2, 5, 12 ...\n* [tribonacci](https://oeis.org/A000073): 0, 0, 1, 1, 2 ...\n* [tetranacci](https://oeis.org/A000078): 0, 0, 0, 1, 1 ...\n-/", "vc-preamble": "def zozonacci (pattern : List String) (n : Nat) : List Nat := sorry\n\ndef isNonNegative (l : List Nat) : Prop := \n  ∀ x ∈ l, x ≥ 0", "vc-helpers": "", "vc-definitions": "def isMonotonicFrom (l : List Nat) (start : Nat) : Prop :=\n  ∀ i v1 v2, start ≤ i → i < l.length - 1 → l[i]? = some v1 → l[i+1]? = some v2 → v1 ≤ v2", "vc-theorems": "theorem empty_pattern_returns_empty (n : Nat) :\n  zozonacci [] n = [] := sorry\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval zozonacci [] 10\n\n/-\ninfo: [0, 0, 0, 1, 1, 2, 3, 5, 8, 13]\n-/\n-- #guard_msgs in\n-- #eval zozonacci [\"fib\"] 10\n\n/-\ninfo: [0, 0, 0, 1, 1, 2, 3]\n-/\n-- #guard_msgs in\n-- #eval zozonacci [\"fib\", \"tri\"] 7", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3738", "language": "lean", "source": "fvapps", "source-id": "fvapps_003738", "source-notes": "", "vc-description": "/-\nAssume you are creating a webshop and you would like to help the user in the search. You have products with brands, prices and name. You have the history of opened products (the most recently opened being the first item).\n\nYour task is to create a list of brands ordered by popularity, if two brands have the same popularity level then choose the one which was opened last from the two and second the other one.\n\nProduct popularity is calculated from the history. If a product is more times in the history than it is more popular.\n\nYour function will have one parameter which will be always an array/list of object.\n\nexample product:\n{\n  name: \"Phone\",\n  price: 25,\n  brand: \"Fake brand\"\n}\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sorted_brands (history : List Product) : List String :=\n  sorry", "vc-theorems": "theorem sorted_brands_unique_brands {history : List Product} : \n  let result := sorted_brands history\n  List.length result = List.length (List.eraseDups result) := by\n  sorry\n\ntheorem sorted_brands_subset {history : List Product} :\n  let result := sorted_brands history\n  match history with\n  | [] => result = []\n  | _ => result = (List.map (fun h => h.brand) history).eraseDups \n  := by \n  sorry\n\ntheorem sorted_brands_frequency_order {history : List Product} :\n  let result := sorted_brands history\n  let brand_counts := fun b => \n    (List.filter (fun h => h.brand = b) history).length\n  ∀ (i j : Fin result.length), i.val < j.val →\n    brand_counts (result[i]) ≥ brand_counts (result[j]) := by\n  sorry\n\ntheorem sorted_brands_equal_freq_ordering {history : List Product} :\n  let result := sorted_brands history\n  let brand_counts := fun b => \n    (List.filter (fun h => h.brand = b) history).length\n  let first_index := fun b => \n    Option.get! (List.findIdx? (fun h => h.brand = b) history)\n  ∀ (i j : Fin result.length), i.val < j.val →\n    brand_counts (result[i]) = brand_counts (result[j]) →\n    first_index (result[i]) < first_index (result[j]) := by\n  sorry\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval sorted_brands []\n\n/-\ninfo: ['Fake brand']\n-/\n-- #guard_msgs in\n-- #eval sorted_brands [product1]\n\n/-\ninfo: ['Fake brand', 'Other brand']\n-/\n-- #guard_msgs in\n-- #eval sorted_brands [product1, product2, product3, product1]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3739", "language": "lean", "source": "fvapps", "source-id": "fvapps_003739", "source-notes": "", "vc-description": "/-\n# Rock Paper Scissors\n\nLet's play! You have to return which player won! In case of a draw return `Draw!`.\n\nExamples:\n\n![rockpaperscissors](http://i.imgur.com/aimOQVX.png)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def rps (p1 p2 : Move) : Outcome :=\n  sorry", "vc-theorems": "theorem rps_symmetry (p1 p2 : Move) :\n  match rps p1 p2 with\n  | Outcome.draw => rps p2 p1 = Outcome.draw\n  | Outcome.player1Wins => rps p2 p1 = Outcome.player2Wins\n  | Outcome.player2Wins => rps p2 p1 = Outcome.player1Wins\n  := sorry\n\ntheorem rps_draw (m : Move) :\n  rps m m = Outcome.draw := sorry\n\ntheorem rps_valid_result (p1 p2 : Move) :\n  match rps p1 p2 with\n  | Outcome.player1Wins => True\n  | Outcome.player2Wins => True\n  | Outcome.draw => True := sorry\n\n/-\ninfo: 'Player 1 won!'\n-/\n-- #guard_msgs in\n-- #eval rps \"rock\" \"scissors\"\n\n/-\ninfo: 'Player 2 won!'\n-/\n-- #guard_msgs in\n-- #eval rps \"scissors\" \"rock\"\n\n/-\ninfo: 'Draw!'\n-/\n-- #guard_msgs in\n-- #eval rps \"rock\" \"rock\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3757", "language": "lean", "source": "fvapps", "source-id": "fvapps_003757", "source-notes": "", "vc-description": "/-\n>When no more interesting kata can be resolved, I just choose to create the new kata, to solve their own, to enjoy the process  --myjinxin2015 said\n\n# Description:\n\n```if:javascript\nGiven an array `arr` that contains some integers(positive, negative or 0), and a `range` list such as `[[start1,end1],[start2,end2],...]`, start and end are the index of `arr` and start always less than end. Your task is to calculate the sum value of each range (start index and end index are both inclusive), and return the maximum sum value.\n```\n```if:ruby\nGiven an array (`arr`) of integers and an array (`ranges`) of ranges (e.g. `[[1, 32], [16, 24],...]`), which represent an index range of `arr`, calculate the sum of each range (start index and end index are both inclusive) of `arr`, and return the maximum sum.\n```\n```if:php\nGiven an array `$a` that contains some integers and a `$range` list such as `[[$start1, $end1], [$start2, $end2], ... ]` where `$start(n)` and `$end(n)` are valid keys of the non-associative array `$a` and `$start(n)` is always guaranteed to be strictly less than `$end(n)`.  Your task is to calculate the sum value of each range (start index and end index are both inclusive) and return the maximum sum value.\n```\n```if:haskell\nGiven a list `arr` that contains some integers(positive, negative or 0), and a `range` list such as `[(start1,end1),(start2,end2),...]`, start and end are the index of `arr` and start always less than end. Your task is to calculate the sum value of each range (start index and end index are both inclusive), and return the maximum sum value.\n```\n\nFor example:\n\n# Note:\n\n - `arr`/`$a` always has at least 5 elements;\n - `range`/`$range`/`ranges` always has at least 1 element;\n - All inputs are valid;\n - This is a simple version, if you want some challenge, please [try the challenge version](https://www.codewars.com/kata/the-maximum-sum-value-of-ranges-challenge-version/).\n\n# Some Examples\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def maxSum (arr : List Int) (ranges : List (Nat × Nat)) : Int := sorry\n\ndef sumRange (arr : List Int) (start stop : Nat) : Int :=\n  (arr.take (stop + 1)).drop start |>.foldl (· + ·) 0", "vc-theorems": "theorem maxSum_ge_range_sums {arr : List Int} {ranges : List (Nat × Nat)}\n    (arr_nonempty : arr.length > 0)\n    (ranges_valid : ∀ (r : Nat × Nat), r ∈ ranges → r.2 < arr.length ∧ r.1 ≤ r.2) :\n  ∀ (start stop : Nat), (start, stop) ∈ ranges → \n    maxSum arr ranges ≥ sumRange arr start stop\n  := sorry\n\ntheorem maxSum_equals_max_range_sum {arr : List Int} {ranges : List (Nat × Nat)}\n    (arr_nonempty : arr.length > 0)\n    (ranges_valid : ∀ (r : Nat × Nat), r ∈ ranges → r.2 < arr.length ∧ r.1 ≤ r.2) :\n  maxSum arr ranges = (ranges.map (λ (r : Nat × Nat) => sumRange arr r.1 r.2)).maximum?.getD 0\n  := sorry\n\ntheorem maxSum_invariant_under_zero_ranges {arr : List Int} {ranges : List (Nat × Nat)}\n    (arr_nonempty : arr.length > 0)\n    (ranges_valid : ∀ (r : Nat × Nat), r ∈ ranges → r.2 < arr.length ∧ r.1 ≤ r.2)\n    (ranges_nonempty : ranges.length > 1) :\n  let zero_ranges := ranges ++ (List.range arr.length).map (λ i => (i,i))\n  maxSum arr zero_ranges = maxSum arr ranges\n  := sorry\n\ntheorem maxSum_single_element_ranges {arr : List Int}\n    (arr_nonempty : arr.length > 0) :\n  let ranges := (List.range arr.length).map (λ i => (i,i))\n  maxSum arr ranges = arr.maximum?.getD 0\n  := sorry\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval max_sum [1, -2, 3, 4, -5, -4, 3, 2, 1] [[1, 3], [0, 4], [6, 8]]\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval max_sum [1, -2, 3, 4, -5, -4, 3, 2, 1] [[1, 3]]\n\n/-\ninfo: 88\n-/\n-- #guard_msgs in\n-- #eval max_sum [11, -22, 31, 34, -45, -46, 35, 32, 21] [[1, 4], [0, 3], [6, 8], [0, 8]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3762", "language": "lean", "source": "fvapps", "source-id": "fvapps_003762", "source-notes": "", "vc-description": "/-\n# Task\n Given an array `arr`, find the rank of the element at the ith position.\n\n The `rank` of the arr[i] is a value equal to the number of elements `less than or equal to` arr[i] standing before arr[i], plus the number of elements `less than` arr[i] standing after arr[i].\n\n# Example\n\n For `arr = [2,1,2,1,2], i = 2`, the result should be `3`.\n\n There are 2 elements `less than or equal to` arr[2] standing before arr[2]: \n\n `arr[0] <= arr[2]`\n\n `arr[1] <= arr[2]`\n\n There is only 1 element `less than` arr[2] standing after arr[2]: \n\n `arr[3] < arr[2]`\n\n So the result is `2 + 1 = 3`.\n\n# Input/Output\n\n - `[input]` integer array `arr`\n\n  An array of integers.\n\n  `3 <= arr.length <= 50.`\n\n - `[input]` integer `i`\n\n  Index of the element whose rank is to be found.\n\n - `[output]` an integer\n\n  Rank of the element at the ith position.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def rank_of_element (arr : List Int) (i : Nat) : Nat :=\n  sorry", "vc-theorems": "theorem rank_within_bounds {arr : List Int} {i : Nat} (h : i < arr.length) :\n  let rank := rank_of_element arr i\n  0 ≤ rank ∧ rank ≤ arr.length :=\nsorry\n\ntheorem rank_exceeds_strictly_less {arr : List Int} {i : Nat} (h : i < arr.length) :\n  let rank := rank_of_element arr i\n  let target := arr[i]\n  let strictly_less := (List.enum arr).filter (fun p => p.2 < target ∧ p.1 ≠ i) |>.length\n  rank ≥ strictly_less :=\nsorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval rank_of_element [2, 1, 2, 1, 2] 2\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval rank_of_element [2, 1, 2, 2, 2] 2\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval rank_of_element [3, 2, 3, 4, 1] 1", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3767", "language": "lean", "source": "fvapps", "source-id": "fvapps_003767", "source-notes": "", "vc-description": "/-\nAdding tip to a restaurant bill in a graceful way can be tricky, thats why you need make a function for it.\n\nThe function will receive the restaurant bill (always a positive number) as an argument. You need to 1) **add at least 15%** in tip, 2) round that number up to an *elegant* value and 3) return it.\n\nWhat is an *elegant* number? It depends on the magnitude of the number to be rounded. Numbers below 10 should simply be rounded to whole numbers. Numbers 10 and above should be rounded like this:\n\n10 - 99.99... ---> Round to number divisible by 5\n\n100 - 999.99... ---> Round to number divisible by 50\n\n1000 - 9999.99... ---> Round to number divisible by 500\n\nAnd so on...\n\nGood luck!\n\n## Examples\n```\n 1  -->    2\n 7  -->    9\n12  -->   15\n86  -->  100\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def graceful_tipping (bill : NonNegFloat) : Float := sorry\n\ntheorem tip_at_least_15_percent (bill : NonNegFloat) \n  (h1 : bill.val ≥ 0.01) \n  (h2 : bill.val ≤ 10000) :\n  graceful_tipping bill ≥ bill.val * 1.15 := sorry", "vc-theorems": "theorem result_is_clean_number (bill : NonNegFloat)\n  (h1 : bill.val ≥ 0.01)\n  (h2 : bill.val ≤ 10000) :\n  let result := graceful_tipping bill\n  let intResult := Float.toUInt64 result \n  (bill.val * 1.15 ≥ 10 →\n    let magnitude := UInt64.ofNat (10 ^ (String.length (toString intResult) - 1))\n    intResult % (magnitude / 2) = 0) := sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval graceful_tipping 1\n\n/-\ninfo: 15\n-/\n-- #guard_msgs in\n-- #eval graceful_tipping 12\n\n/-\ninfo: 100\n-/\n-- #guard_msgs in\n-- #eval graceful_tipping 86\n\n/-\ninfo: 1500\n-/\n-- #guard_msgs in\n-- #eval graceful_tipping 1149", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3783", "language": "lean", "source": "fvapps", "source-id": "fvapps_003783", "source-notes": "", "vc-description": "/-\n## The galactic games have begun!\n\nIt's the galactic games! Beings of all worlds come together to compete in several interesting sports, like nroogring, fredling and buzzing (the beefolks love the last one). However, there's also the traditional marathon run.\n\nUnfortunately, there have been cheaters in the last years, and the committee decided to place sensors on the track. Committees being committees, they've come up with the following rule:\n\n> A sensor should be placed every 3 and 5 meters from the start, e.g.\n> at 3m, 5m, 6m, 9m, 10m, 12m, 15m, 18m….\n\nSince you're responsible for the track, you need to buy those sensors. Even worse, you don't know how long the track will be! And since there might be more than a single track, and you can't be bothered to do all of this by hand, you decide to write a program instead.\n\n## Task\nReturn the sum of the multiples of 3 and 5 __below__ a number. Being the _galactic_ games, the tracks can get rather large, so your solution should work for _really_ large numbers (greater than 1,000,000).\n\n### Examples\n```python\nsolution (10) # => 23 = 3 + 5 + 6 + 9\nsolution (20) # => 78 = 3 + 5 + 6 + 9 + 10 + 12 + 15 + 18\n```\n-/", "vc-preamble": "def solution (n : Nat) : Nat :=\n  sorry\n\ndef summ (n d : Nat) : Nat :=\n  sorry\n\ndef list_sum (l : List Nat) : Nat :=\n  l.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def filter_sum (l : List Nat) (f : Nat → Bool) : Nat :=\n  list_sum (l.filter f)", "vc-theorems": "theorem solution_positive (n : Nat) (h : n ≥ 1) :\n  solution n ≥ 0 :=\n  sorry\n\ntheorem summ_nonneg (n d : Nat) (h₁ : n ≥ 1) (h₂ : d ≥ 1) :\n  summ n d ≥ 0 :=\n  sorry\n\ntheorem solution_inclusion_exclusion (n : Nat) (h : n ≥ 1) :\n  solution n = summ n 3 + summ n 5 - summ n 15 :=\n  sorry\n\nend Ex\n\n/-\ninfo: 23\n-/\n-- #guard_msgs in\n-- #eval solution 10\n\n/-\ninfo: 78\n-/\n-- #guard_msgs in\n-- #eval solution 20\n\n/-\ninfo: 2318\n-/\n-- #guard_msgs in\n-- #eval solution 100", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3790", "language": "lean", "source": "fvapps", "source-id": "fvapps_003790", "source-notes": "", "vc-description": "/-\nWrite a method `alternate_sq_sum()` (JS: `alternateSqSum` ) that takes an array of integers as input and finds the sum of squares of the elements at even positions (*i.e.,* 2nd, 4th, *etc.*) plus the sum of the rest of the elements at odd position.\n\nNOTE:\nThe values at even *position* need to be squared. For a language with zero-based indices, this will occur at oddly-indexed locations. For instance, in Python, the values at indices 1, 3, 5, *etc.* should be squared because these are the second, fourth, and sixth positions in the list.\nFor Example:\n\n```python\nalternate_sq_sum([11, 12, 13, 14, 15]) #should return 379\n```\n\nExplanation:\n\nElements at indices 0, 2, 4 are 11, 13, 15 and they are at odd positions as 11 is at position #1, 13 is at position #3 and 15 at #5.\n\nElements at indices 1, 3 are 12 and 14 and they are at even position.\nSo we need to add 11, 13, 15 as they are and square of 12 and 14\n\n--> 11 + 13 + 15 + 12^2 + 14^2\n  = 11 + 13 + 15 + 144 + 196\n  = 379\n\nFor empty arrays, result should be 0 (zero) (except for Haskell).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def alternate_sq_sum (l : List Int) : Int := sorry\n\ntheorem alternate_sq_sum_empty :\n  alternate_sq_sum [] = 0 := sorry", "vc-theorems": "theorem alternate_sq_sum_formula (l : List Int) :\n  alternate_sq_sum l = (List.enum l).foldr (fun (i, x) acc => \n    acc + if i % 2 = 1 then x * x else x) 0 := sorry\n\ntheorem alternate_sq_sum_singleton (x : Int) :\n  alternate_sq_sum [x] = x := sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval alternate_sq_sum []\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval alternate_sq_sum [-1, 0, -3, 0, -5, 3]\n\n/-\ninfo: 379\n-/\n-- #guard_msgs in\n-- #eval alternate_sq_sum [11, 12, 13, 14, 15]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3810", "language": "lean", "source": "fvapps", "source-id": "fvapps_003810", "source-notes": "", "vc-description": "/-\nMike and Joe are fratboys that love beer and games that involve drinking. They play the following game: Mike chugs one beer, then Joe chugs 2 beers, then Mike chugs 3 beers, then Joe chugs 4 beers, and so on. Once someone can't drink what he is supposed to drink, he loses.\n\nMike can chug at most A beers in total (otherwise he would pass out), while Joe can chug at most B beers in total. Who will win the game? \n\nWrite the function ```game(A,B)``` that returns the winner, ```\"Mike\"``` or ```\"Joe\"``` accordingly, for any given integer values of A and B.\n\nNote: If either Mike or Joe cannot drink at least 1 beer, return the string  ```\"Non-drinkers can't play\"```.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def game (mike : Nat) (joe : Nat) : GameResult :=\n  sorry", "vc-theorems": "theorem game_returns_valid_result (mike joe : Nat) :\n  let result := game mike joe\n  result = GameResult.Mike ∨ result = GameResult.Joe ∨ result = GameResult.NonDrinkers\n  := sorry\n\ntheorem game_deterministic (mike joe : Nat) :\n  game mike joe = game mike joe := sorry\n\ntheorem game_non_drinkers :\n  (game 0 1 = GameResult.NonDrinkers) ∧\n  (game 1 0 = GameResult.NonDrinkers) ∧\n  (game 0 0 = GameResult.NonDrinkers) := sorry\n\ntheorem game_positive_inputs_valid_winner (mike joe : Nat) :\n  mike > 0 → joe > 0 →\n  let result := game mike joe\n  result = GameResult.Mike ∨ result = GameResult.Joe := sorry\n\n/-\ninfo: 'Joe'\n-/\n-- #guard_msgs in\n-- #eval game 3 2\n\n/-\ninfo: 'Mike'\n-/\n-- #guard_msgs in\n-- #eval game 4 2\n\n/-\ninfo: \"Non-drinkers can't play\"\n-/\n-- #guard_msgs in\n-- #eval game 0 1", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3819", "language": "lean", "source": "fvapps", "source-id": "fvapps_003819", "source-notes": "", "vc-description": "/-\nIn this kata, you have to define a function named **func** that will take a list as input.\n\nYou must try and guess the pattern how we get the output number and return list - **[output number,binary representation,octal representation,hexadecimal representation]**, but **you must convert that specific number without built-in : bin,oct and hex functions.**\n\nExamples : \n\n```python\nfunc([12,13,6,3,6,45,123]) returns - [29,'11101','35','1d']\n\nfunc([1,9,23,43,65,31,63,99]) returns - [41,'101001','51','29']\n\nfunc([2,4,6,8,10,12,14,16,18,19]) returns - [10,'1010','12','a']\n```\n-/", "vc-preamble": "def func (numbers : List Nat) : List (Nat ⊕ String) := sorry\n\ndef toBinary (n : Nat) : String := sorry", "vc-helpers": "", "vc-definitions": "def toOctal (n : Nat) : String := sorry\ndef toHex (n : Nat) : String := sorry", "vc-theorems": "theorem conversion_properties {numbers : List Nat} (h : numbers.length > 0) :\n  let result := func numbers\n  let expected_n := numbers.foldl (· + ·) 0 / numbers.length\n  List.get! result 0 = .inl expected_n ∧ \n  List.get! result 1 = .inr (toBinary expected_n) ∧\n  List.get! result 2 = .inr (toOctal expected_n) ∧\n  List.get! result 3 = .inr (toHex expected_n) := sorry\n\ntheorem length_properties {numbers : List Nat} (h : numbers.length > 0) :\n  let result := func numbers\n  result.length = 4 ∧\n  (match List.get! result 0 with | .inl _ => true | .inr _ => false) ∧\n  (∀ i, i > 0 → i < 4 → match List.get! result i with | .inl _ => false | .inr _ => true) := sorry\n\ntheorem zero_case {numbers : List Nat} (h : numbers.length > 0) \n    (h' : ∀ x ∈ numbers, x = 0) :\n  func numbers = [.inl 0, .inr \"0\", .inr \"0\", .inr \"0\"] := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3820", "language": "lean", "source": "fvapps", "source-id": "fvapps_003820", "source-notes": "", "vc-description": "/-\nBuild a function `sumNestedNumbers`/`sum_nested_numbers` that finds the sum of all numbers in a series of nested arrays raised to the power of their respective nesting levels.  Numbers in the outer most array should be raised to the power of 1.\n\nFor example,\n\nshould return `1 + 2*2 + 3 + 4*4 + 5*5*5 === 149`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sumNestedNumbers : NestedList Int → Int := sorry\n\ndef List.sum : List Int → Int \n  | [] => 0\n  | x :: xs => x + List.sum xs", "vc-theorems": "theorem flat_list_sum (lst : List Int) : \n  sumNestedNumbers (NestedList.list (lst.map NestedList.atom)) = lst.sum := sorry\n\ntheorem single_element (x : Int) : \n  sumNestedNumbers (NestedList.list [NestedList.atom x]) = x := sorry\n\ntheorem single_nested_element (x : Int) :\n  sumNestedNumbers (NestedList.list [NestedList.list [NestedList.atom x]]) = x * x := sorry\n\ntheorem double_nested_element (x : Int) :\n  sumNestedNumbers (NestedList.list [NestedList.list [NestedList.list [NestedList.atom x]]]) = \n    x * x * x := sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval sum_nested_numbers [[0]]\n\n/-\ninfo: 15\n-/\n-- #guard_msgs in\n-- #eval sum_nested_numbers [1, 2, 3, 4, 5]\n\n/-\ninfo: 149\n-/\n-- #guard_msgs in\n-- #eval sum_nested_numbers [1, [2], 3, [4, [5]]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3823", "language": "lean", "source": "fvapps", "source-id": "fvapps_003823", "source-notes": "", "vc-description": "/-\nImplement a function which \ncreates a **[radix tree](https://en.wikipedia.org/wiki/Radix_tree)** (a space-optimized trie [prefix tree]) \nin which each node that is the only child is merged with its parent [unless a word from the input ends there]) \nfrom a given list of words \nusing dictionaries (aka hash maps or hash tables) where:\n\n1. The dictionary keys are the nodes.\n2. Leaf nodes are empty dictionaries.\n3. The value for empty input is an empty dictionary.\n4. Words are all lowercase or empty strings.\n5. Words can contain duplicates.\n\n### Examples:\n\n```python\n>>> radix_tree()\n{}\n\n>>> radix_tree(\"\")\n{}\n\n>>> radix_tree(\"\", \"\")\n{}\n\n>>> radix_tree(\"radix\", \"tree\")\n{\"radix\": {}, \"tree\": {}}\n\n>>> radix_tree(\"ape\", \"apple\")\n{\"ap\": {\"e\": {}, \"ple\": {}}}\n\n>>> radix_tree(\"apple\", \"applet\", \"apple\", \"ape\")\n{\"ap\": {\"ple\": {\"t\": {}}, \"e\": {}}}\n\n>>> radix_tree(\"romane\", \"romanus\", \"romulus\", \"rubens\", \"rubicon\", \"rubicundus\")\n{\"r\": {\"om\": {\"an\": {\"e\": {}, \"us\": {}}, \"ulus\": {}},\n       \"ub\": {\"ens\": {}, \"ic\": {\"on\": {}, \"undus\": {}}}}}\n\n>>> radix_tree(\"appleabcd\", \"apple\")\n{\"apple\": {\"abcd\": {}}}\n```\n-/", "vc-preamble": "def radix_tree (words: List String) : NodeMap :=\n  sorry\n\ndef reconstruct_word (t: NodeMap) : String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def get_all_prefixes (t: NodeMap) : List String :=\n  sorry", "vc-theorems": "theorem radix_tree_empty_input :  \n  ∀ (words: List String), \n  (∀ w ∈ words, w = \"\") → \n  radix_tree words = NodeMap.leaf :=\nsorry\n\ntheorem radix_tree_deterministic :\n  ∀ (words: List String),\n  radix_tree words = radix_tree words :=\nsorry \n\ntheorem radix_tree_order_independent :\n  ∀ (words₁ words₂: List String),\n  words₁.length = words₂.length →\n  (∀ w, w ∈ words₁ ↔ w ∈ words₂) →\n  radix_tree words₁ = radix_tree words₂ :=\nsorry\n\ntheorem radix_tree_single_word :\n  ∀ (w: String),\n  w ≠ \"\" →\n  reconstruct_word (radix_tree [w]) = w :=\nsorry\n\ntheorem radix_tree_prefixes_shared :\n  ∀ (words: List String) (p: String),\n  p ∈ get_all_prefixes (radix_tree words) →\n  ∃ w₁ w₂, w₁ ∈ words ∧ w₂ ∈ words ∧ w₁ ≠ w₂ :=\nsorry\n\n/-\ninfo: {}\n-/\n-- #guard_msgs in\n-- #eval radix_tree \"\"\n\n/-\ninfo: {'ap': {'e': {}, 'ple': {}}}\n-/\n-- #guard_msgs in\n-- #eval radix_tree \"ape\" \"apple\"\n\n/-\ninfo: {'rom': {'an': {'e': {}, 'us': {}}, 'ulus': {}}}\n-/\n-- #guard_msgs in\n-- #eval radix_tree \"romane\" \"romanus\" \"romulus\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3836", "language": "lean", "source": "fvapps", "source-id": "fvapps_003836", "source-notes": "", "vc-description": "/-\n# Task\n\nJohn won the championship of a TV show. He can get some bonuses.\n\nHe needs to play a game to determine the amount of his bonus.\n\nHere are `n` rows and `m` columns of cards were placed on the ground. A non-negative number is written on each card.\n\nThe rules of the game are:\n\n- Player starts from the top-left coner, walk to the bottom-right coner. \n\n- Players can only walk downward or right. \n\n- The sum of the numbers collected by the players will be used as the bonus.\n\nJohn has two chances to play this game on a game map. Specifically, when John finishes the game, the card on his path will be removed, and then he can walk again.\n\nYour task is to help John calculate the maximum amount of bonuses he can get.\n\n# Input\n\n- `gameMap/gamemap`: A `n` x `m` integer array. Each element represents the number on the card.\n  - `4 <= n,m <= 40(Pyhon)/100(JS)`\n\n- All inputs are valid.\n\n# Output\n\nAn integer. the maximum amount of bonuses John can get.\n\n# Eaxmple\n\nFor \n```\ngameMap=\n[\n[1, 3, 9],\n[2, 8, 5],\n[5, 7, 4]\n]\n```\nThe output should be `39`.\n\nOne of the possible solution is:\n```\n1st game:\n[\n[>, >, v],\n[2, 8, v],\n[5, 7, v]\n]\n1+3+9+5+4=22\n\n2nd game:\n[\n[v, 0, 0],\n[>, v, 0],\n[5, >, >]\n]\n0+2+8+7+0=17\n\nFinal bonus = 22 + 17 = 39\n```\n-/", "vc-preamble": "def calcGame (gamemap : Matrix) : Nat := sorry\n\ndef rotateMatrix (m : Matrix) : Matrix := sorry", "vc-helpers": "", "vc-definitions": "def getMinValue (gamemap : Matrix) : Nat :=\n  gamemap.map (List.foldl min 0) |> List.foldl min 0", "vc-theorems": "theorem gamemap_value_minimum {gamemap : Matrix} : \n  getMinValue gamemap ≤ calcGame gamemap := sorry\n\ntheorem gamemap_rotation_symmetry {gamemap : Matrix} :\n  calcGame gamemap = calcGame (rotateMatrix gamemap) := sorry\n\ntheorem gamemap_monotonicity {gamemap : Matrix} {increased : Matrix} :\n  (∀ i j, (gamemap.get! i).get! j + 1 = (increased.get! i).get! j) →\n  calcGame gamemap ≤ calcGame increased := sorry\n\n/-\ninfo: 39\n-/\n-- #guard_msgs in\n-- #eval calc [[1, 3, 9], [2, 8, 5], [5, 7, 4]]\n\n/-\ninfo: 560\n-/\n-- #guard_msgs in\n-- #eval calc [[11, 72, 38], [80, 69, 65], [68, 96, 99]]\n\n/-\ninfo: 40\n-/\n-- #guard_msgs in\n-- #eval calc [[1, 5, 1, 1], [1, 5, 5, 1], [5, 5, 5, 1], [1, 1, 5, 1]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3847", "language": "lean", "source": "fvapps", "source-id": "fvapps_003847", "source-notes": "", "vc-description": "/-\n# Leaderboard climbers\n\nIn this kata you will be given a leaderboard of unique names for example:\n\n```python\n['John',\n 'Brian',\n 'Jim',\n 'Dave',\n 'Fred']\n```\n\nThen you will be given a list of strings for example:\n\n```python\n['Dave +1', 'Fred +4', 'Brian -1']\n```\n\nThen you sort the leaderboard.\n\nThe steps for our example would be:\n\n```python\n# Dave up 1\n['John',\n 'Brian',\n 'Dave',\n 'Jim',\n 'Fred']\n```\n\n```python\n# Fred up 4\n['Fred',\n 'John',\n 'Brian',\n 'Dave',\n 'Jim']\n```\n\n```python\n# Brian down 1\n['Fred',\n 'John',\n 'Dave',\n 'Brian',\n 'Jim']\n```\n\nThen once you have done this you need to return the leaderboard.\n\nAll inputs will be valid. All strings in the second list will never ask to move a name up higher or lower than possible eg. `\"John +3\"` could not be added to the end of the second input list in the example above.\n\nThe strings in the second list will always be something in the leaderboard followed by a space and a `+` or `-` sign followed by a number.\n-/", "vc-preamble": "def leaderboard_sort (names : List String) (changes : List String) : List String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def parseChange (change : String) : String × Int :=\n  sorry", "vc-theorems": "theorem leaderboard_invariants\n  (names : List String)\n  (changes : List String)\n  (h_names : names.length > 0)\n  (h_unique : ∀ x y, x ∈ names → y ∈ names → x = y → names.indexOf x = names.indexOf y) :\n  let result := leaderboard_sort names changes\n  -- Length preserved\n  (result.length = names.length) ∧\n  -- All elements preserved\n  (∀ x, x ∈ names ↔ x ∈ result) ∧\n  -- Valid movements\n  (∀ change ∈ changes,\n    let (name, delta) := parseChange change\n    name ∈ names →\n    names.indexOf name - result.indexOf name = delta) :=\n  sorry\n\ntheorem leaderboard_bounds\n  (names : List String)\n  (changes : List String)\n  (h : changes.length = 1) :\n  let result := leaderboard_sort names changes\n  let (name, delta) := parseChange changes.head!\n  -- Result maintains bounds\n  (result.indexOf name ≥ 0) ∧\n  (result.indexOf name < names.length) :=\n  sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval leaderboard_sort [\"John\", \"Brian\", \"Jim\", \"Dave\", \"Fred\"] [\"Dave +1\", \"Fred +4\", \"Brian -1\"]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval leaderboard_sort [\"Bob\", \"Larry\", \"Kevin\", \"Jack\", \"Max\"] [\"Max +3\", \"Kevin -1\", \"Kevin +3\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3855", "language": "lean", "source": "fvapps", "source-id": "fvapps_003855", "source-notes": "", "vc-description": "/-\nWrite a function to split a string and convert it into an array of words. For example:\n\n```python\n\"Robin Singh\" ==> [\"Robin\", \"Singh\"]\n\n\"I love arrays they are my favorite\" ==> [\"I\", \"love\", \"arrays\", \"they\", \"are\", \"my\", \"favorite\"]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def string_to_array (s : String) : Array String := sorry\n\ntheorem string_to_array_split_join\n  (words : Array String)\n  (h₁ : words.size > 0)\n  (h₂ : ∀ (i : Fin words.size), words.get i ≠ \"\") :\n  string_to_array (\" \".intercalate words.toList) = words := sorry", "vc-theorems": "theorem string_to_array_empty :\n  string_to_array \"\" = #[\"\"] := sorry\n\ntheorem string_to_array_no_empty_elements\n  (s : String)\n  (h : s ≠ \"\")\n  (i : Nat)\n  (h₂ : i < (string_to_array s).size - 1) :\n  ∃ h₃ : i < (string_to_array s).size, \n    (string_to_array s).get ⟨i, h₃⟩ ≠ \"\" := sorry\n\n/-\ninfo: ['Robin', 'Singh']\n-/\n-- #guard_msgs in\n-- #eval string_to_array \"Robin Singh\"\n\n/-\ninfo: ['I', 'love', 'arrays', 'they', 'are', 'my', 'favorite']\n-/\n-- #guard_msgs in\n-- #eval string_to_array \"I love arrays they are my favorite\"\n\n/-\ninfo: ['']\n-/\n-- #guard_msgs in\n-- #eval string_to_array \"\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3865", "language": "lean", "source": "fvapps", "source-id": "fvapps_003865", "source-notes": "", "vc-description": "/-\nError Handling is very important in coding and seems to be overlooked or not implemented properly.\n\n#Task\n\nYour task is to implement a function which takes a string as input and return an object containing the properties\nvowels and consonants. The vowels property must contain the total count of vowels {a,e,i,o,u}, and the total count of consonants {a,..,z} - {a,e,i,o,u}. Handle invalid input and don't forget to return valid ones.\n\n#Input\n\nThe input is any random string. You must then discern what are vowels and what are consonants and sum for each category their total occurrences in an object. However you could also receive inputs that are not strings. If this happens then you must return an object with a vowels and consonants total of 0 because the input was NOT a string. Refer to the Example section for a more visual representation of which inputs you could receive and the outputs expected. :)\n\nExample:\n\n```python\nInput: get_count('test')\nOutput: {vowels:1,consonants:3}\n\nInput: get_count('tEst')\nOutput: {vowels:1,consonants:3}\n\nInput get_count('    ')\nOutput: {vowels:0,consonants:0}\n\nInput get_count()\nOutput: {vowels:0,consonants:0}\n```\n\nC#\n\nA Counter class has been put in the preloaded section taking two parameters Vowels and Consonants this must be the Object you return!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_count (s : String := \"\") : Count :=\n  sorry", "vc-theorems": "theorem get_count_nonnegative (s : String) :\n  let result := get_count s\n  result.vowels ≥ 0 ∧ result.consonants ≥ 0 :=\n  sorry\n\ntheorem get_count_sum_equals_letters (s : String) :\n  let result := get_count s\n  let letter_count := (s.data.filter Char.isAlpha).length\n  result.vowels + result.consonants = letter_count :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3866", "language": "lean", "source": "fvapps", "source-id": "fvapps_003866", "source-notes": "", "vc-description": "/-\nThe new football league season is coming and the Football Association need some help resetting the league standings. Normally the initial league standing is done in alphabetical order (from A to Z) but this year the FA have decided to freshen it up. \n\nIt has been decided that team who finished first last season will begin the next season in first place. Regardless of what letter their club begins with. e.g. if Manchester City were in first place last year, they will begin the season in position one. All other teams should be in alphabetical order. \n\nThe teams will be fed in as an object ({}). The key will be will be their position from last season and the value is the club's name e.g. Arsenal. \n\nThe output should be an object ({}) with the key as the club's starting position for the new season and the value should be club's name e.g. Arsenal.\n\nFor example. If in the previous season the standings were:\n\n1:'Leeds United'\n2:'Liverpool'\n3:'Manchester City'\n4:'Coventry'\n5:'Arsenal' \n\nThen the new season standings should \n\n1:'Leeds United' (first last season)\n2:'Arsenal' (alphabetical)\n3:'Coventry' (alphabetical) \n4:'Liverpool' (alphabetical) \n5:'Manchester City' (alphabetical)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def premier_league_standings (teams : TeamMap) : TeamMap := sorry\n\ntheorem first_place_always_present (teams : TeamMap) \n  (h : teams.teams.any (fun p => p.1 = \"1\")) :\n  let result := premier_league_standings teams\n  result.teams.any (fun p => p.1 = \"1\") ∧\n  (result.teams.find? (fun p => p.1 = \"1\")).map Prod.snd = \n  (teams.teams.find? (fun p => p.1 = \"1\")).map Prod.snd := sorry", "vc-theorems": "theorem result_is_sorted (teams : TeamMap)\n  (h1 : teams.teams.any (fun p => p.1 = \"1\"))\n  (h2 : teams.teams.length ≥ 2) :\n  let result := premier_league_standings teams\n  let first_team := (teams.teams.find? (fun p => p.1 = \"1\")).map Prod.snd\n  let rest_teams := (teams.teams.map Prod.snd).filter (fun x => \n    match first_team with\n    | none => true\n    | some ft => x ≠ ft)\n  result.teams.head?.map Prod.snd = first_team ∧ \n  match result.teams.tail with\n  | [] => true\n  | xs => ∀ i j, i < j → j < xs.length → \n         (xs.get ⟨i, sorry⟩).2 ≤ (xs.get ⟨j, sorry⟩).2 := sorry\n\ntheorem keys_are_sequential (teams : TeamMap)\n  (h : teams.teams.any (fun p => p.1 = \"1\")) :\n  let result := premier_league_standings teams\n  ∀ i, i < result.teams.length → \n  result.teams.any (fun p => p.1 = toString (i + 1)) := sorry\n\ntheorem no_duplicate_teams (teams : TeamMap)\n  (h : teams.teams.any (fun p => p.1 = \"1\")) :\n  let result := premier_league_standings teams\n  (result.teams.map Prod.snd).Nodup := sorry\n\n/-\ninfo: {'1': 'Arsenal'}\n-/\n-- #guard_msgs in\n-- #eval premier_league_standings {\"1\": \"Arsenal\"}\n\n/-\ninfo: {'1': 'Leeds United', '2': 'Accrington Stanley', '3': 'Arsenal'}\n-/\n-- #guard_msgs in\n-- #eval premier_league_standings {\"2\": \"Arsenal\", \"3\": \"Accrington Stanley\", \"1\": \"Leeds United\"}\n\n/-\ninfo: {'1': 'Leeds United', '2': 'Arsenal', '3': 'Coventry', '4': 'Liverpool', '5': 'Manchester City'}\n-/\n-- #guard_msgs in\n-- #eval premier_league_standings {\"1\": \"Leeds United\", \"2\": \"Liverpool\", \"3\": \"Manchester City\", \"4\": \"Coventry\", \"5\": \"Arsenal\"}", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3879", "language": "lean", "source": "fvapps", "source-id": "fvapps_003879", "source-notes": "", "vc-description": "/-\nFarmer Bob have a big farm, where he growths chickens, rabbits and cows. It is very difficult to count the number of animals for each type manually, so he diceded to buy a system to do it. But he bought a cheap system that can count only total number of heads, total number of legs and total number of horns of animals on the farm.\nHelp Bob to figure out how many chickens, rabbits and cows does he have?\n\nAll chickens have 2 legs, 1 head and no horns; all rabbits have 4 legs, 1 head and no horns; all cows have 4 legs, 1 head and 2 horns.\n\nYour task is to write a function \n```Python\nget_animals_count(legs_number, heads_number, horns_number)\n```\n```Csharp\nDictionary get_animals_count(int legs_number, int heads_number, int horns_number)\n```\n, which returns a dictionary \n```python\n{\"rabbits\" : rabbits_count, \"chickens\" : chickens_count, \"cows\" : cows_count}\n``` \n```Csharp\nnew Dictionary(){{\"rabbits\", rabbits_count},{\"chickens\", chickens_count},{\"cows\", cows_count}}\n```\n\nParameters `legs_number, heads_number, horns_number` are integer, all tests have valid input.\n\nExample:\n\n```python\nget_animals_count(34, 11, 6); # Should return {\"rabbits\" : 3, \"chickens\" : 5, \"cows\" : 3}\nget_animals_count(154, 42, 10); # Should return {\"rabbits\" : 30, \"chickens\" : 7, \"cows\" : 5}\n```\n\n```Csharp\nget_animals_count(34, 11, 6); //Should return  Dictionary(){{\"rabbits\", 3},{\"chickens\", 5},{\"cows\", 3}}\nget_animals_count(154, 42, 10); //Should return Dictionary(){{\"rabbits\", 30},{\"chickens\", 7},{\"cows\", 5}}\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def get_animals_count (legs heads horns : Nat) : AnimalCounts := sorry\n\ntheorem animal_counts_sum_to_heads {legs heads horns : Nat} :\n  let result := get_animals_count legs heads horns\n  result.cows + result.rabbits + result.chickens = heads := sorry", "vc-theorems": "", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3886", "language": "lean", "source": "fvapps", "source-id": "fvapps_003886", "source-notes": "", "vc-description": "/-\nHi guys, welcome to introduction to DocTesting.\n\nThe kata is composed of two parts; in part (1) we write three small functions, and in part (2) we write a few doc tests for those functions.\n\nLets talk about the functions first...\n\n    The reverse_list function takes a list and returns the reverse of it.\n    If given an empty list, simply return an empty list.\n\nThe second function...\n\n    The sum_list function takes a list as input and adds up all the values, \n    returning an integer. If the list is empty, return 0.\n\nThe third function...\n\n    The head_of_list function simply returns the first item in the list.\n    If the list is empty return None.\n\nEach of these functions can be easily written with a single line of code; there are some tests for correctness but no tests for effciency.\n\nOnce you have implemented all three of these functions you can move onto phase two, which is writing doc tests. If you haven't written doc tests before then I suggest you check out the following documentation: \nhttps://docs.python.org/3/library/doctest.html\n\nTo complete this kata all you have to do is write **EXACTLY TWO** doc tests for each of the three functions (any more/less than that and you will fail the tests).\n\nHere is an example:\n\n    def double(y):\n      \"\"\"Function returns y * 2\n      >>> double(2)\n      4\n      \"\"\"\n      return y * 2\n\nIn the example above we have a function called 'double' and a single doctest. When we run the doctest module Python will check if double(2) equals 4. If it does not, then the doctest module will flag up an error.\n\nPlease note that this is intended as a beginners introduction to docstrings, if you try to do something clever (such as writing doc tests to catch exceptions, or tinkering with the 'option flags'), you will probably fail a test or two. This is due to how the tests are written.  \n\nOh and one last thing, don't try and get too 'cheeky' and try something like:\n\n    \"\"\"\n    >>> True\n    True\n    \"\"\"\n\nsuch a solution is (a) not in the spirit of things and (b) I got tests for that! :p\n\nGood Luck!\n\n~~~~~~~~~~~~~~~ Issues & Helpful hints ~~~~~~~~~~~~~~~~~~~~~~~\n\n1) In addition to the 'don't get too clever rule', please try to be precise when making your doctests; [1,2] may fail where [1, 2] may succeed. Likewise, \">>>function(x)\" may fail where \">>> function(x)\" is likely to suceed *(note the difference is single \" \" character)*. In short, if you fail a test the first thing to check is that you dont have any unecessary characters/spaces and/or odd formating.\n\n2) As you shall see from the kata discussion testing for None is tricky and lots of people are struggling to get None tests working. So I'm going to quickly show you a way to test for not that will (should) pass the kata:\n\n    def is_string(string):\n        \"\"\"\n        returns the string if the string is Not empty, otherwise returns None\n        >>> is_string(\"\") is None\n        True\n        \"\"\"\n        return string if string else None\n\n3) If you happen to be struggling to actually complete the three functions in the first place then I would recomend you google *\"Python Indexing\", \"Pythons sum function\" and \"if/else statements in Python\"*.\n-/", "vc-preamble": "def reverse_list (xs : List α) : List α := sorry\ndef sum_list (xs : List Int) : Int := sorry\n\ndef head_of_list (xs : List α) : Option α := sorry\n\ntheorem reverse_length {α : Type} (xs : List α) :\n  (reverse_list xs).length = xs.length := sorry", "vc-helpers": "", "vc-definitions": "def List.sum : List Int → Int\n  | [] => 0 \n  | x::xs => x + List.sum xs", "vc-theorems": "theorem reverse_correct {α : Type} (xs : List α) :\n  reverse_list xs = xs.reverse := sorry\n\ntheorem reverse_involution {α : Type} (xs : List α) :\n  reverse_list (reverse_list xs) = xs := sorry\n\ntheorem sum_list_correct (xs : List Int) :\n  sum_list xs = List.sum xs := sorry\n\ntheorem sum_list_double (xs : List Int) :\n  sum_list (xs ++ xs) = sum_list xs * 2 := sorry\n\ntheorem sum_list_nil :\n  sum_list [] = 0 := sorry\n\ntheorem head_of_list_nonempty {α : Type} (xs : List α) (h : xs ≠ []) :\n  head_of_list xs = xs.head? := sorry\n\ntheorem head_of_list_empty {α : Type} :\n  head_of_list ([] : List α) = none := sorry\n\n/-\ninfo: [3, 2, 1]\n-/\n-- #guard_msgs in\n-- #eval reverse_list [1, 2, 3]\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval reverse_list []\n\n/-\ninfo: 10\n-/\n-- #guard_msgs in\n-- #eval sum_list [1, 2, 3, 4]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval sum_list []\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval head_of_list [1, 2, 3]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3891", "language": "lean", "source": "fvapps", "source-id": "fvapps_003891", "source-notes": "", "vc-description": "/-\nSanta is coming to town and he needs your help finding out who's been naughty or nice. You will be given an entire year of JSON data following this format:\n\nYour function should return `\"Naughty!\"` or `\"Nice!\"` depending on the total number of occurrences in a given year (whichever one is greater). If both are equal, return `\"Nice!\"`\n-/", "vc-preamble": "def Month := String\ndef Day := String", "vc-helpers": "", "vc-definitions": "def BehaviorMap := List (Month × List (Day × BehaviorType))\n\ndef naughty_or_nice (behaviors: BehaviorMap) : String :=\nsorry", "vc-theorems": "theorem naughty_or_nice_returns_valid_result (behaviors: BehaviorMap) :\n  naughty_or_nice behaviors = \"Nice!\" ∨ naughty_or_nice behaviors = \"Naughty!\" :=\nsorry\n\ntheorem naughty_or_nice_matches_count (behaviors: BehaviorMap) :\n  let nice_count := behaviors.foldl (fun acc m => \n    acc + m.2.foldl (fun inner_acc d => \n      inner_acc + match d.2 with\n      | BehaviorType.Nice => 1\n      | BehaviorType.Naughty => -1) 0) 0\n  naughty_or_nice behaviors = if nice_count >= 0 then \"Nice!\" else \"Naughty!\" :=\nsorry\n\ntheorem all_nice_returns_nice (behaviors: BehaviorMap) \n  (h: behaviors.all (fun m => \n      m.2.all (fun d => match d.2 with\n        | BehaviorType.Nice => true\n        | BehaviorType.Naughty => false))) :\n  naughty_or_nice behaviors = \"Nice!\" :=\nsorry\n\n/-\ninfo: 'Nice!'\n-/\n-- #guard_msgs in\n-- #eval naughty_or_nice {\"January\": {\"1\": \"Nice\", \"2\": \"Naughty\", \"3\": \"Nice\"}, \"February\": {\"1\": \"Naughty\", \"2\": \"Nice\", \"3\": \"Naughty\"}}\n\n/-\ninfo: 'Nice!'\n-/\n-- #guard_msgs in\n-- #eval naughty_or_nice {\"January\": {\"1\": \"Nice\", \"2\": \"Nice\", \"3\": \"Nice\"}, \"February\": {\"1\": \"Nice\", \"2\": \"Nice\", \"3\": \"Nice\"}}\n\n/-\ninfo: 'Naughty!'\n-/\n-- #guard_msgs in\n-- #eval naughty_or_nice {\"January\": {\"1\": \"Naughty\", \"2\": \"Naughty\", \"3\": \"Naughty\"}, \"February\": {\"1\": \"Naughty\", \"2\": \"Naughty\", \"3\": \"Naughty\"}}", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3892", "language": "lean", "source": "fvapps", "source-id": "fvapps_003892", "source-notes": "", "vc-description": "/-\n# Task\n\n**_Given_** an *array/list [] of n integers* , *find maximum triplet sum in the array* **_Without duplications_**   .\n___\n\n# Notes :\n\n* **_Array/list_** size is *at least 3* .\n\n* **_Array/list_** numbers could be a *mixture of positives , negatives and zeros* .\n\n* **_Repetition_** of numbers in *the array/list could occur* , So **_(duplications are not included when summing)_**.\n___\n# Input >> Output Examples \n\n## **_Explanation_**:\n\n* As the **_triplet_** that *maximize the sum* **_{6,8,3}_** in order , **_their sum is (17)_** \n\n* *Note* : **_duplications_** *are not included when summing* , **(i.e) the numbers added only once** .\n___\n## **_Explanation_**:\n\n* As the **_triplet_** that *maximize the sum* **_{8, 6, 4}_** in order , **_their sum is (18)_** , \n* *Note* : **_duplications_** *are not included when summing* , **(i.e) the numbers added only once** .\n___\n## **_Explanation_**:\n\n* As the **_triplet_** that *maximize the sum* **_{12 , 29 , 0}_** in order , **_their sum is (41)_** , \n* *Note* : **_duplications_** *are not included when summing* , **(i.e) the numbers added only once** .\n___\n# [Playing with Numbers Series](https://www.codewars.com/collections/playing-with-numbers)\n\n# [Playing With Lists/Arrays Series](https://www.codewars.com/collections/playing-with-lists-slash-arrays)\n\n# [For More Enjoyable Katas](http://www.codewars.com/users/MrZizoScream/authored)\n___\n___\n___\n\n## ALL translations are welcomed\n\n## Enjoy Learning !!\n# Zizou\n-/", "vc-preamble": "def max_tri_sum (nums : List Int) : Int := \nsorry\n\ndef List.sort (lt : α → α → Bool) : List α → List α :=\nsorry\n\ndef List.sum : List Int → Int :=\nsorry", "vc-helpers": "", "vc-definitions": "def List.dedup : List α → List α :=\nsorry", "vc-theorems": "theorem max_tri_sum_perm_invariant {nums₁ nums₂ : List Int} \n  (h₁ : nums₁.length ≥ 3)\n  (h₂ : nums₂.length ≥ 3)\n  (h_perm : List.Perm nums₁ nums₂) : \n  max_tri_sum nums₁ = max_tri_sum nums₂ := sorry\n\n/-\ninfo: 17\n-/\n-- #guard_msgs in\n-- #eval max_tri_sum [3, 2, 6, 8, 2, 3]\n\n/-\ninfo: -9\n-/\n-- #guard_msgs in\n-- #eval max_tri_sum [-3, -27, -4, -2, -27, -2]\n\n/-\ninfo: 41\n-/\n-- #guard_msgs in\n-- #eval max_tri_sum [-7, 12, -7, 29, -5, 0, -7, 0, 0, 29]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3897", "language": "lean", "source": "fvapps", "source-id": "fvapps_003897", "source-notes": "", "vc-description": "/-\nGiven a name, turn that name into a perfect square matrix (nested array with the amount of arrays equivalent to the length of each array). \n\nYou will need to add periods (`.`) to the end of the name if necessary, to turn it into a matrix. \n\nIf the name has a length of 0, return `\"name must be at least one letter\"`\n\n## Examples\n\n\"Bill\" ==> [ [\"B\", \"i\"],\n             [\"l\", \"l\"] ]\n\n\"Frank\" ==> [ [\"F\", \"r\", \"a\"],\n              [\"n\", \"k\", \".\"],\n              [\".\", \".\", \".\"] ]\n-/", "vc-preamble": "def matrixfy (s : String) : String ⊕ (List (List Char)) := sorry \n\ntheorem matrixfy_empty_input (s : String) : \n  s.length = 0 → matrixfy s = Sum.inl \"name must be at least one letter\" := sorry", "vc-helpers": "", "vc-definitions": "def getSideLength (n : Nat) : Nat :=\n  let sqrt := Float.sqrt (Float.ofNat n)\n  let ceil := Float.ceil sqrt\n  ceil.toUInt64.toNat", "vc-theorems": "theorem matrixfy_square_matrix (s : String) :\n  s.length > 0 → \n  match matrixfy s with\n  | Sum.inr matrix => ∃ n, matrix.length = n ∧ matrix.all (fun row => row.length = n) \n  | _ => False\n  := sorry\n\ntheorem matrixfy_size (s : String) :\n  s.length > 0 →\n  match matrixfy s with\n  | Sum.inr matrix => matrix.length = getSideLength s.length\n  | _ => False\n  := sorry\n\ntheorem matrixfy_preserves_string (s : String) :\n  s.length > 0 →\n  match matrixfy s with\n  | Sum.inr matrix => \n    let flattened := matrix.join.asString\n    flattened.take s.length = s ∧\n    (flattened.drop s.length).all (· = '.')\n  | _ => False\n  := sorry\n\ntheorem matrixfy_single_chars (s : String) :\n  s.length > 0 →\n  match matrixfy s with\n  | Sum.inr matrix => matrix.all (fun row => row.all (fun _ => true))\n  | _ => False\n  := sorry\n\n/-\ninfo: 'name must be at least one letter'\n-/\n-- #guard_msgs in\n-- #eval matrixfy \"\"\n\n/-\ninfo: [['G']]\n-/\n-- #guard_msgs in\n-- #eval matrixfy \"G\"\n\n/-\ninfo: [['F', 'r', 'a'], ['n', 'k', '.'], ['.', '.', '.']]\n-/\n-- #guard_msgs in\n-- #eval matrixfy \"Frank\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3904", "language": "lean", "source": "fvapps", "source-id": "fvapps_003904", "source-notes": "", "vc-description": "/-\nGiven a random string consisting of numbers, letters, symbols, you need to sum up the numbers in the string. \n\nNote:\n\n- Consecutive integers should be treated as a single number. eg, `2015` should be treated as a single number `2015`, NOT four numbers\n- All the numbers should be treaded as positive integer. eg, `11-14` should be treated as two numbers `11` and `14`. Same as `3.14`, should be treated as two numbers `3` and `14`\n- If no number was given in the string, it should return `0`\n\nExample:\n\n```\nstr = \"In 2015, I want to know how much does iPhone 6+ cost?\"\n```\n\n The numbers are `2015`, `6`\n\nSum is `2021`.\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + sum xs", "vc-helpers": "", "vc-definitions": "def sum_from_string (s : String) : Nat :=\n  sorry", "vc-theorems": "theorem sum_single_number (n : Nat) :\n  sum_from_string (toString n) = n :=\n  sorry\n\ntheorem sum_empty_string :\n  sum_from_string \"\" = 0 :=\n  sorry\n\n/-\ninfo: 2021\n-/\n-- #guard_msgs in\n-- #eval sum_from_string \"In 2015, I want to know how much does iPhone 6+ cost?\"\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval sum_from_string \"1+1=2\"\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval sum_from_string \"Hello World\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3906", "language": "lean", "source": "fvapps", "source-id": "fvapps_003906", "source-notes": "", "vc-description": "/-\n## Emotional Sort ( ︶︿︶)\n\nYou'll have a function called \"**sortEmotions**\" that will return an array of **emotions** sorted. It has two parameters, the first parameter called \"**arr**\" will expect an array of **emotions** where an **emotion** will be one of the following:\n\n- **:D** -> Super Happy\n- **:)** -> Happy\n- **:|** -> Normal\n- **:(** -> Sad\n- **T\\_T** -> Super Sad\n\nExample of the array:``[ 'T_T', ':D', ':|', ':)', ':(' ]``\n\nAnd the second parameter is called \"**order**\", if this parameter is **true** then the order of the emotions will be descending (from **Super Happy** to **Super Sad**) if it's **false** then it will be ascending (from **Super Sad** to **Super Happy**)\n\nExample if **order** is true with the above array: ``[ ':D', ':)', ':|', ':(', 'T_T' ]``\n\n- Super Happy -> Happy -> Normal -> Sad -> Super Sad\n\nIf **order** is false: ``[ 'T_T', ':(', ':|', ':)', ':D' ]``\n\n- Super Sad -> Sad -> Normal -> Happy -> Super Happy\n\nExample:\n```\narr = [':D', ':|', ':)', ':(', ':D']\nsortEmotions(arr, true) // [ ':D', ':D', ':)', ':|', ':(' ]\nsortEmotions(arr, false) // [ ':(', ':|', ':)', ':D', ':D' ]\n\n```\n\n**More in test cases!**\n\nNotes:\n- The array could be empty, in that case return the same empty array ¯\\\\\\_( ツ )\\_/¯\n- All **emotions** will be valid\n\n## Enjoy! (づ｡◕‿‿◕｡)づ\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def valid_emotions := [\":D\", \":)\", \":|\", \":(\", \"T_T\"]\n\ndef sort_emotions (emotions : List String) (ascending : Bool) : List String :=\n  sorry", "vc-theorems": "theorem sort_emotions_length_preserved \n  (emotions : List String) (ascending : Bool) : \n  List.length (sort_emotions emotions ascending) = List.length emotions :=\n  sorry\n\ntheorem sort_emotions_elements_preserved \n  (emotions : List String) (ascending : Bool) :\n  List.all (sort_emotions emotions ascending) (· ∈ emotions) ∧ \n  List.all emotions (· ∈ sort_emotions emotions ascending) :=\n  sorry\n\ntheorem sort_emotions_ascending_ordered\n  (emotions : List String) (h : List.length emotions > 1) :\n  let result := sort_emotions emotions true\n  ∀ i, ∀ h : i + 1 < result.length,\n    let idx₁ := ⟨i, Nat.lt_trans (Nat.lt_succ_self i) h⟩\n    let idx₂ := ⟨i + 1, h⟩\n    let pos₁ := valid_emotions.indexOf (result.get idx₁)\n    let pos₂ := valid_emotions.indexOf (result.get idx₂)\n    pos₁ ≤ pos₂ :=\n  sorry\n\ntheorem sort_emotions_descending_ordered\n  (emotions : List String) (h : List.length emotions > 1) :\n  let result := sort_emotions emotions false\n  ∀ i, ∀ h : i + 1 < result.length,\n    let idx₁ := ⟨i, Nat.lt_trans (Nat.lt_succ_self i) h⟩\n    let idx₂ := ⟨i + 1, h⟩\n    let pos₁ := valid_emotions.indexOf (result.get idx₁)\n    let pos₂ := valid_emotions.indexOf (result.get idx₂)\n    pos₁ ≥ pos₂ :=\n  sorry\n\ntheorem sort_emotions_empty (ascending : Bool) :\n  sort_emotions [] ascending = [] :=\n  sorry\n\ntheorem sort_emotions_single (emotion : String) (ascending : Bool)\n  (h : emotion ∈ valid_emotions) :\n  sort_emotions [emotion] ascending = [emotion] :=\n  sorry\n\n/-\ninfo: [':D', ':D', ':(', 'T_T']\n-/\n-- #guard_msgs in\n-- #eval sort_emotions [\":D\", \"T_T\", \":D\", \":(\"] True\n\n/-\ninfo: ['T_T', ':(', ':(', ':D']\n-/\n-- #guard_msgs in\n-- #eval sort_emotions [\"T_T\", \":D\", \":(\", \":(\"] False\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval sort_emotions [] True", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3907", "language": "lean", "source": "fvapps", "source-id": "fvapps_003907", "source-notes": "", "vc-description": "/-\nPython dictionaries are inherently unsorted. So what do you do if you need to sort the contents of a dictionary?\n\nCreate a function that returns a sorted list of `(key, value)` tuples (Javascript: arrays of 2 items).\n\nThe list must be sorted by the `value` and be sorted **largest to smallest**.\n\n## Examples\n\n```python\nsort_dict({3:1, 2:2, 1:3}) == [(1,3), (2,2), (3,1)]\nsort_dict({1:2, 2:4, 3:6}) == [(3,6), (2,4), (1,2)]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sort_dict (d : Dict) : List (String × Int) := sorry\n\ntheorem sort_dict_preserves_items (d : Dict) :\n  Dict.mk (sort_dict d) = d := sorry", "vc-theorems": "theorem sort_dict_ordering (d : Dict) (h : (d.items).length ≥ 2) :\n  ∀ i : Nat, i < (sort_dict d).length - 1 →\n    ((sort_dict d).get! i).2 ≥ ((sort_dict d).get! (i+1)).2 := sorry\n\ntheorem sort_dict_length (d : Dict) :\n  (sort_dict d).length = d.items.length := sorry\n\ntheorem sort_dict_returns_tuples (d : Dict) :\n  ∀ x ∈ sort_dict d, ∃ s : String, ∃ n : Int, x = (s, n) := sorry\n\n/-\ninfo: [('1', 3), ('2', 2), ('3', 1)]\n-/\n-- #guard_msgs in\n-- #eval sort_dict {\"1\": 3, \"2\": 2, \"3\": 1}\n\n/-\ninfo: [('3', 6), ('2', 4), ('1', 2)]\n-/\n-- #guard_msgs in\n-- #eval sort_dict {\"1\": 2, \"2\": 4, \"3\": 6}\n\n/-\ninfo: [('a', 6), ('c', 4), ('b', 2)]\n-/\n-- #guard_msgs in\n-- #eval sort_dict {\"a\": 6, \"b\": 2, \"c\": 4}", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3908", "language": "lean", "source": "fvapps", "source-id": "fvapps_003908", "source-notes": "", "vc-description": "/-\nYou are making your very own boardgame. The game is played by two opposing players, featuring a 6 x 6 tile system, with the players taking turns to move their pieces (similar to chess). The design is finished, now it's time to actually write and implement the features. Being the good programmer you are, you carefully plan the procedure and break the program down into smaller managable sections. You decide to start coding the logic for resolving \"fights\" when two pieces engage in combat on a tile. \n\nYour boardgame features four unique pieces: \n\nSwordsman, Cavalry, Archer and Pikeman\n\nEach piece has unique movement and has advantages and weaknesses in combat against one of the other pieces. \n\nTask\n\nYou must write a function ```fightResolve``` that takes the attacking and defending piece as input parameters, and returns the winning piece. It may be the case that both the attacking and defending piece belong to the same player, after which you must return an error value to indicate an illegal move. \n\nIn C++ and C, the pieces will be represented as ```chars```. Values will be case-sensitive to display ownership. Let the following char values represent each piece from their respective player.\n\nPlayer 1:  ```p```= Pikeman, ```k```= Cavalry, ```a```= Archer, ```s```= Swordsman \n\nPlayer 2:  ```P```= Pikeman, ```K```= Cavalry, ```A```= Archer, ```S```= Swordsman \n\nThe outcome of the fight between two pieces depends on which piece attacks, the type of the attacking piece and the type of the defending piece. Archers always win against swordsmens, swordsmen always win against pikemen, pikemen always win against cavalry and cavalry always win against archers. If a matchup occurs that was not previously mentioned (for example Archers vs Pikemen) the attacker will always win. This table represents the winner of each possible engagement between an attacker and a defender.\n\n(Attacker→)\n    (Defender↓)\nArcher\nPikeman\nSwordsman\nKnight\n\nKnight\nDefender\nAttacker\nAttacker\nAttacker\n\nSwordsman\nAttacker\nDefender\nAttacker\nAttacker\n\nArcher\nAttacker\nAttacker\nDefender\nAttacker\n\nPikeman\nAttacker\nAttacker\nAttacker\nDefender\n\nIf two pieces from the same player engage in combat, i.e P vs S or k vs a, the function must return -1 to signify and illegal move. Otherwise assume that no other illegal values will be passed.\n\nExamples\n\nFunction prototype: fightResolve(defender, attacker)\n1. fightResolve('a', 'P') outputs 'P'. No interaction defined between Pikemen and Archer. Pikemen is the winner here because it is the attacking piece.\n\n2. fightResolve('k', 'A') outputs 'k'. Knights always defeat archers, even if Archer is the attacking piece here.\n\n3. fightResolve('S', 'A') outputs -1. Friendly units don't fight. Return -1 to indicate error.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isWhite (p: Piece) : Bool := sorry \n\ndef fight_resolve (defender attacker : Piece) : Option Piece := sorry", "vc-theorems": "theorem same_team_invalid {d a : Piece} : \n  isWhite d = isWhite a → fight_resolve d a = none := sorry\n\ntheorem result_is_valid {d a : Piece} :\n  fight_resolve d a = some d ∨ fight_resolve d a = some a ∨ fight_resolve d a = none := sorry\n\ntheorem winning_matchups_symmetrical {d a : Piece} :\n  fight_resolve d a = some d →\n  ((d = Piece.King ∧ a = Piece.Assassin) ∨\n   (d = Piece.Shield ∧ a = Piece.Pike) ∨ \n   (d = Piece.Assassin ∧ a = Piece.Shield) ∨\n   (d = Piece.Pike ∧ a = Piece.King)) := sorry\n\ntheorem default_attacker_wins {d a : Piece} :\n  fight_resolve d a ≠ none →\n  fight_resolve d a ≠ some d →\n  fight_resolve d a = some a := sorry\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval fight_resolve \"K\" \"A\"\n\n/-\ninfo: 'k'\n-/\n-- #guard_msgs in\n-- #eval fight_resolve \"k\" \"A\"\n\n/-\ninfo: 'P'\n-/\n-- #guard_msgs in\n-- #eval fight_resolve \"a\" \"P\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3955", "language": "lean", "source": "fvapps", "source-id": "fvapps_003955", "source-notes": "", "vc-description": "/-\n**This Kata is intended as a small challenge for my students**\n\nAll Star Code Challenge #16\n\nCreate a function called noRepeat() that takes a string argument and returns a single letter string of the **first** not repeated character in the entire string.\n\n``` haskell\nnoRepeat \"aabbccdde\" `shouldBe` 'e'\nnoRepeat \"wxyz\"      `shouldBe` 'w'\nnoRepeat \"testing\"   `shouldBe` 'e'\n```\n\nNote:\nONLY letters from the english alphabet will be used as input\nThere will ALWAYS be at least one non-repeating letter in the input string\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def no_repeat (s : String) : Option Char := sorry\n\n/- If a string has any character that appears exactly once,\n    then the result of no_repeat is a character from the string\n    that appears exactly once -/", "vc-theorems": "theorem no_repeat_in_string (s : String) (h : ∃ c, s.data.count c = 1) :\n  let result := no_repeat s\n  match result with\n  | none => False\n  | some c => c ∈ s.data ∧ s.data.count c = 1 := sorry\n\n/- If a string has any character that appears exactly once,\n    then no_repeat returns the first such character in the string -/\n\ntheorem no_repeat_first_single (s : String) (h : ∃ c, s.data.count c = 1) :\n  let result := no_repeat s\n  match result with\n  | none => False\n  | some c => ∀ c', c' ∈ s.data → s.data.count c' = 1 →\n             s.data.indexOf c' ≥ s.data.indexOf c := sorry\n\n/- If a string has no characters that appear exactly once,\n    then no_repeat returns none -/\n\ntheorem no_repeat_no_singles (s : String) (h : ∀ c, c ∈ s.data → s.data.count c ≠ 1) :\n  no_repeat s = none := sorry\n\n/-\ninfo: 'e'\n-/\n-- #guard_msgs in\n-- #eval no_repeat \"aabbccdde\"\n\n/-\ninfo: 'w'\n-/\n-- #guard_msgs in\n-- #eval no_repeat \"wxyz\"\n\n/-\ninfo: 'e'\n-/\n-- #guard_msgs in\n-- #eval no_repeat \"testing\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3972", "language": "lean", "source": "fvapps", "source-id": "fvapps_003972", "source-notes": "", "vc-description": "/-\nCreate a function `isAlt()` that accepts a string as an argument and validates whether the vowels (a, e, i, o, u) and consonants are in alternate order.\n\n```python\nis_alt(\"amazon\")\n// true\nis_alt(\"apple\")\n// false\nis_alt(\"banana\")\n// true\n```\n\nArguments consist of only lowercase letters.\n-/", "vc-preamble": "def VOWELS : List Char := ['a', 'e', 'i', 'o', 'u']\n\ndef isVowel (c : Char) : Bool := c ∈ VOWELS", "vc-helpers": "", "vc-definitions": "def is_alt (s : String) : Bool := sorry\n\ntheorem matches_reference_implementation (s : String) : \n  is_alt s = (if s.isEmpty then true\n             else let pairs := s.toList.zip (s.toList.tail!)\n                  pairs.all (fun p => isVowel p.fst ≠ isVowel p.snd)) := \n  sorry", "vc-theorems": "theorem consecutive_vowels_false {s : String} (h : s.length ≥ 2) \n  (h2 : ∀ c ∈ s.toList, isVowel c) : \n  ¬(is_alt s) :=\n  sorry\n\ntheorem consecutive_consonants_false {s : String} (h : s.length ≥ 2)\n  (h2 : ∀ c ∈ s.toList, ¬(isVowel c)) :\n  ¬(is_alt s) := \n  sorry\n\ntheorem alternating_pattern_true {s : String} (h : ∀ c ∈ s.toList, ¬(isVowel c)) :\n  let result := s.toList.enum.map (fun (i, c) => if i % 2 = 0 then c else 'a')\n  is_alt (String.mk result) :=\n  sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval is_alt \"amazon\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval is_alt \"apple\"\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval is_alt \"banana\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3976", "language": "lean", "source": "fvapps", "source-id": "fvapps_003976", "source-notes": "", "vc-description": "/-\nYou're fed up about changing the version of your software manually. Instead, you will create a little script that will make it for you.\n\n# Exercice\n\nCreate a function `nextVersion`, that will take a string in parameter, and will return a string containing the next version number.\n\nFor example:\n\n# Rules\n\nAll numbers, except the first one, must be lower than 10: if there are, you have to set them to 0 and increment the next number in sequence.\n\nYou can assume all tests inputs to be valid.\n-/", "vc-preamble": "def splitVersion (v : String) : Version := sorry\ndef joinVersion (v : Version) : String := sorry", "vc-helpers": "", "vc-definitions": "def nextVersion (v : String) : String := sorry\n\ntheorem nextVersion_outputs_valid_version (v : String) \n    (h : ∀ n ∈ (splitVersion v).nums, n ≤ 8) :\n  ∀ n ∈ (splitVersion (nextVersion v)).nums, n ≥ 0 := sorry", "vc-theorems": "theorem nextVersion_preserves_length (v : String)\n    (h : ∀ n ∈ (splitVersion v).nums, n ≤ 8) :\n  (splitVersion (nextVersion v)).nums.length = (splitVersion v).nums.length := sorry\n\ntheorem nextVersion_preserves_prefix_parts (v : String)\n    (h : ∀ n ∈ (splitVersion v).nums, n ≤ 8)\n    (h2 : (splitVersion v).nums ≠ [])\n    (h3 : ((splitVersion v).nums.getLast h2) < 9) : \n  (splitVersion (nextVersion v)).nums.dropLast = (splitVersion v).nums.dropLast ∧ \n  ((splitVersion (nextVersion v)).nums.getLast h2 = (splitVersion v).nums.getLast h2 + 1) := sorry\n\n/-\ninfo: '1.2.4'\n-/\n-- #guard_msgs in\n-- #eval next_version \"1.2.3\"\n\n/-\ninfo: '1.0.0'\n-/\n-- #guard_msgs in\n-- #eval next_version \"0.9.9\"\n\n/-\ninfo: '2'\n-/\n-- #guard_msgs in\n-- #eval next_version \"1\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3986", "language": "lean", "source": "fvapps", "source-id": "fvapps_003986", "source-notes": "", "vc-description": "/-\nAhoy Matey!\n\nWelcome to the seven seas.\n\nYou are the captain of a pirate ship.\n\nYou are in battle against the royal navy.\n\nYou have cannons at the ready.... or are they?\n\nYour task is to check if the gunners are loaded and ready, if they are: ```Fire!```\n\nIf they aren't ready: ```Shiver me timbers!```\n\nYour gunners for each test case are 4 or less.\n\nWhen you check if they are ready their answers are in a dictionary and will either be: ```aye``` or ```nay```\n\nFiring with less than all gunners ready is non-optimum (this is not fire at will, this is fire by the captain's orders or walk the plank, dirty sea-dog!)\n\nIf all answers are 'aye' then Fire!\nif one or more are 'nay' then Shiver me timbers!\n\nAlso, check out the new Pirates!! Kata:\nhttps://www.codewars.com/kata/57e2d5f473aa6a476b0000fe\n-/", "vc-preamble": "def HashMap.toArray {α β : Type} : HashMap α β → Array (α × β) :=\n  fun _ => #[]\n\ndef isAye : String → Bool\n| \"aye\" => true\n| _ => false", "vc-helpers": "", "vc-definitions": "def cannons_ready (gunners : HashMap Gunner Response) : String :=\nsorry", "vc-theorems": "theorem cannons_ready_all_conditions {gunners : HashMap Gunner Response} :\n  cannons_ready gunners = if (gunners.toArray.all (fun p => isAye p.2))\n    then \"Fire!\"\n    else \"Shiver me timbers!\"\n  := sorry\n\ntheorem cannons_ready_all_aye {gunners : HashMap Gunner Response} :\n  (gunners.toArray.all (fun p => isAye p.2)) →\n  cannons_ready gunners = \"Fire!\"\n  := sorry\n\ntheorem cannons_ready_all_nay {gunners : HashMap Gunner Response} :\n  (gunners.toArray.all (fun p => ¬isAye p.2)) →\n  cannons_ready gunners = \"Shiver me timbers!\"\n  := sorry\n\n/-\ninfo: 'Shiver me timbers!'\n-/\n-- #guard_msgs in\n-- #eval cannons_ready {\"Joe\": \"nay\", \"Johnson\": \"nay\", \"Peter\": \"aye\"}\n\n/-\ninfo: 'Fire!'\n-/\n-- #guard_msgs in\n-- #eval cannons_ready {\"Mike\": \"aye\", \"Joe\": \"aye\", \"Johnson\": \"aye\", \"Peter\": \"aye\"}\n\n/-\ninfo: 'Shiver me timbers!'\n-/\n-- #guard_msgs in\n-- #eval cannons_ready {\"Joe\": \"aye\", \"Steve\": \"nay\"}", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3992", "language": "lean", "source": "fvapps", "source-id": "fvapps_003992", "source-notes": "", "vc-description": "/-\nYou are going to be given a word. Your job will be to make sure that each character in that word has the exact same number of occurrences. You will return `true` if it is valid, or `false` if it is not.\n\nFor example:\n\n`\"abcabc\"` is a valid word because `'a'` appears twice, `'b'` appears twice, and`'c'` appears twice.  \n`\"abcabcd\"` is **NOT** a valid word because `'a'` appears twice, `'b'` appears twice, `'c'` appears twice, but `'d'` only appears once!  \n`\"123abc!\"` is a valid word because all of the characters only appear once in the word.\n\nFor this kata, capitals are considered the same as lowercase letters. Therefore: `'A' == 'a'` .\n\n#Input \nA string (no spaces) containing `[a-z],[A-Z],[0-9]` and common symbols. The length will be `0 < string < 100`.\n\n#Output\n`true` if the word is a valid word, or `false` if the word is not valid.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def validate_word (s : String) : Bool := sorry\n\ntheorem permutations_invariant (s₁ s₂ : String) : \n  Perm s₁.toList s₂.toList → validate_word s₁ = validate_word s₂ := sorry", "vc-theorems": "theorem repeat_string_equiv (s : String) (n : Nat) :\n  n > 0 → validate_word (String.join (List.replicate n s)) = validate_word s := sorry \n\ntheorem single_char_string_valid (c : Char) (n : Nat) :\n  n > 0 → validate_word (String.mk (List.replicate n c)) = true := sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval validate_word \"abcabc\"\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval validate_word \"AbcCBa\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval validate_word \"abcabcd\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3993", "language": "lean", "source": "fvapps", "source-id": "fvapps_003993", "source-notes": "", "vc-description": "/-\nWrite a function that takes one or more arrays and returns a new array of unique values in the order of the original provided arrays.\n\nIn other words, all values present from all arrays should be included in their original order, but with no duplicates in the final array.\n\nThe unique numbers should be sorted by their original order, but the final array should not be sorted in numerical order.\n\nCheck the assertion tests for examples.\n\n*Courtesy of [FreeCodeCamp](https://www.freecodecamp.com/challenges/sorted-union), a great place to learn web-dev; plus, its founder Quincy Larson is pretty cool and amicable. I made the original one slightly more tricky ;)*\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def unite_unique [BEq α] : List (List α) → List α\n  | _ => sorry", "vc-theorems": "theorem unite_unique_maintains_order [BEq α] (arrays : List (List α)) :\n  let result := unite_unique arrays\n  -- Result has no duplicates\n  (∀ (i j : Fin result.length),\n    result.get i = result.get j → i = j) ∧\n  -- All input elements are present\n  (∀ arr ∈ arrays, ∀ val ∈ arr, val ∈ result) ∧\n  -- Order is preserved between arrays\n  (∀ (i j : Fin result.length), i.val < j.val →\n    let val := result.get j\n    let prior_val := result.get i\n    ∃ (array_idx₁ array_idx₂ : Nat), array_idx₁ ≤ array_idx₂ ∧ \n      array_idx₂ < arrays.length ∧\n      prior_val ∈ arrays.get! array_idx₁ ∧\n      val ∈ arrays.get! array_idx₂) :=\nsorry\n\ntheorem unite_unique_bound [BEq α] (arrays : List (List α)) :\n  let result := unite_unique arrays\n  result.length ≤ (arrays.map List.length).foldl Nat.add 0 :=\nsorry\n\ntheorem unite_unique_empty_arrays [BEq α] (arrays : List (List α)) :\n  let result := unite_unique arrays\n  let flattened := arrays.join\n  -- Result has same elements as flattened arrays\n  (∀ x, x ∈ result ↔ x ∈ flattened) ∧\n  -- First occurrence property\n  (∀ (i j : Fin result.length),\n    result.get i = result.get j → i.val ≤ j.val) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3994", "language": "lean", "source": "fvapps", "source-id": "fvapps_003994", "source-notes": "", "vc-description": "/-\nBrief\n=====\nSometimes we need information about the list/arrays we're dealing with. You'll have to write such a function in this kata. Your function must provide the following informations:  \n\n* Length of the array\n* Number of integer items in the array\n* Number of float items in the array\n* Number of string character items in the array\n* Number of whitespace items in the array\n\nThe informations will be supplied in arrays that are items of another array. Like below:\n\n`Output array = [[array length],[no of integer items],[no of float items],[no of string chars items],[no of whitespace items]]`\n\nAdded Difficulty\n----------------\nIf any item count in the array is zero, you'll have to replace it with a **None/nil/null** value (according to the language). And of course, if the array is empty then return **'Nothing in the array!**. For the sake of simplicity, let's just suppose that there are no nested structures.   \nOutput\n======\nIf you're head is spinning (just kidding!) then these examples will help you out-   \n```\n\narray_info([1,2,3.33,4,5.01,'bass','kick',' '])--------->[[8],[3],[2],[2],[1]]    \narray_info([0.001,2,' '])------------------------------>[[3],[1],[1],[None],[1]]   \narray_info([])----------------------------------------->'Nothing in the array!'\narray_info([' '])-------------------------------------->[[1],[None],[None],[None],[1]]\n\n  ```    \nRemarks\n-------\nThe input will always be arrays/lists. So no need to check the inputs.    \nHint\n====\nSee the tags!!!   \nNow let's get going !\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def array_info {α : Type} (lst : List α) : Result := sorry\n\ntheorem array_info_empty (lst : List α) : \n  lst = [] → array_info lst = .Msg \"Nothing in the array!\" := sorry", "vc-theorems": "theorem array_info_nonempty_structure (lst : List α) :\n  lst ≠ [] →\n  ∃ result : List (List Nat),\n    array_info lst = .Nums result ∧\n    result.length = 5 ∧ \n    ∀ x ∈ result, ∃ y, x = [y] := sorry\n\ntheorem array_info_length (lst : List α) :\n  lst ≠ [] →\n  ∃ result : List (List Nat),\n    array_info lst = .Nums result ∧\n    result.get! 0 = [lst.length] := sorry\n\ntheorem array_info_all_ints (lst : List Int) :\n  lst ≠ [] →\n  ∃ result : List (List Nat),\n    array_info lst = .Nums result ∧\n    result.get! 1 = [lst.length] ∧\n    result.get! 2 = [0] ∧\n    result.get! 3 = [0] ∧\n    result.get! 4 = [0] := sorry\n\ntheorem array_info_all_spaces (lst : List String) :\n  lst ≠ [] →\n  (∀ s ∈ lst, s.all Char.isWhitespace) →\n  ∃ result : List (List Nat),\n    array_info lst = .Nums result ∧\n    result.get! 1 = [0] ∧\n    result.get! 2 = [0] ∧\n    result.get! 3 = [0] ∧\n    result.get! 4 = [lst.length] := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3998", "language": "lean", "source": "fvapps", "source-id": "fvapps_003998", "source-notes": "", "vc-description": "/-\nIf the first day of the month is a Friday, it is likely that the month will have an `Extended Weekend`. That is, it could have five Fridays, five Saturdays and five Sundays. \n\nIn this Kata, you will be given a start year and an end year. Your task will be to find months that have extended weekends and return:\n```\n- The first and last month in the range that has an extended weekend\n- The number of months that have extended weekends in the range, inclusive of start year and end year.\n```\n\nFor example:\n```python\nsolve(2016,2020) = (\"Jan\",\"May\",5). #The months are: Jan 2016, Jul 2016, Dec 2017, Mar 2019, May 2020\n```\n\nMore examples in test cases. Good luck!\n\nIf you found this Kata easy, please try [myjinxin2015](https://www.codewars.com/users/myjinxin2015) challenge version [here](https://www.codewars.com/kata/extended-weekends-challenge-edition)\n-/", "vc-preamble": "def monthAbbr : Month → String\n| Month.Jan => \"Jan\"\n| Month.Feb => \"Feb\" \n| Month.Mar => \"Mar\"\n| Month.Apr => \"Apr\"\n| Month.May => \"May\"\n| Month.Jun => \"Jun\"\n| Month.Jul => \"Jul\"\n| Month.Aug => \"Aug\"\n| Month.Sep => \"Sep\"\n| Month.Oct => \"Oct\"\n| Month.Nov => \"Nov\"\n| Month.Dec => \"Dec\"", "vc-helpers": "", "vc-definitions": "def solve (startYear endYear : Nat) : String × String × Nat :=\nsorry\n\n-- Theorems based on property tests", "vc-theorems": "theorem solve_result_type (startYear endYear : Nat) : \n  let result := solve startYear endYear\n  result.1 = result.1 ∧ result.2.1 = result.2.1 ∧ result.2.2 > 0 :=\nsorry \n\ntheorem solve_valid_months (startYear endYear : Nat) :\n  let result := solve startYear endYear\n  let months31 := [Month.Jan, Month.Mar, Month.May, Month.Jul, Month.Aug, Month.Oct, Month.Dec]\n  result.1 ∈ months31.map monthAbbr ∧ \n  result.2.1 ∈ months31.map monthAbbr :=\nsorry\n\ntheorem solve_count_bounds (startYear endYear : Nat) (h : endYear ≥ startYear) :\n  let result := solve startYear endYear \n  let yearDiff := endYear - startYear + 1\n  let maxPossible := yearDiff * 7\n  0 < result.2.2 ∧ result.2.2 ≤ maxPossible :=\nsorry\n\ntheorem solve_guaranteed_solution (startYear endYear : Nat) \n  (h1 : startYear ≥ 1800) (h2 : endYear ≤ 2500) (h3 : endYear ≥ startYear + 10) :\n  let result := solve startYear endYear\n  result.2.2 > 0 :=\nsorry\n\n/-\ninfo: ('Jan', 'May', 5)\n-/\n-- #guard_msgs in\n-- #eval solve 2016 2020\n\n/-\ninfo: ('Mar', 'Dec', 51)\n-/\n-- #guard_msgs in\n-- #eval solve 1900 1950\n\n/-\ninfo: ('Aug', 'Oct', 702)\n-/\n-- #guard_msgs in\n-- #eval solve 1800 2500", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF3999", "language": "lean", "source": "fvapps", "source-id": "fvapps_003999", "source-notes": "", "vc-description": "/-\nIt's the most hotly anticipated game of the school year - Gryffindor vs Slytherin! Write a function which returns the winning team. \n\nYou will be given two arrays with two values. \n\nThe first given value is the number of points scored by the team's Chasers and the second a string with a 'yes' or 'no' value if the team caught the golden snitch!\n\nThe team who catches the snitch wins their team an extra 150 points - but doesn't always win them the game.\n\nIf the score is a tie return \"It's a draw!\"\"\n\n** The game only ends when someone catches the golden snitch, so one array will always include 'yes' or 'no.' Points scored by Chasers can be any positive integer.\n-/", "vc-preamble": "def calculateScore (initialScore: Nat) (snitch: SnitchResult) : Nat :=\n  match snitch with\n  | SnitchResult.Yes => initialScore + 150\n  | SnitchResult.No => initialScore", "vc-helpers": "", "vc-definitions": "def gameWinners (gryffindor: Nat × SnitchResult) (slytherin: Nat × SnitchResult) : String :=\n  sorry", "vc-theorems": "theorem game_winners_valid_output (g s: Nat × SnitchResult) : \n  let result := gameWinners g s\n  result = \"Gryffindor wins!\" ∨ result = \"Slytherin wins!\" ∨ result = \"It's a draw!\" := by\n  sorry\n\ntheorem game_winners_correct_result (g s: Nat × SnitchResult) :\n  let g_score := calculateScore g.1 g.2\n  let s_score := calculateScore s.1 s.2\n  let result := gameWinners g s\n  (result = \"Gryffindor wins!\" ↔ g_score > s_score) ∧\n  (result = \"Slytherin wins!\" ↔ s_score > g_score) ∧\n  (result = \"It's a draw!\" ↔ g_score = s_score) := by\n  sorry\n\ntheorem equal_scores_no_snitch (score: Nat) :\n  gameWinners (score, SnitchResult.No) (score, SnitchResult.No) = \"It's a draw!\" := by\n  sorry\n\ntheorem only_one_snitch_possible (score: Nat) :\n  gameWinners (score, SnitchResult.Yes) (score, SnitchResult.Yes) = \"It's a draw!\" := by\n  sorry\n\n/-\ninfo: 'Gryffindor wins!'\n-/\n-- #guard_msgs in\n-- #eval game_winners [100, \"yes\"] [100, \"no\"]\n\n/-\ninfo: 'Slytherin wins!'\n-/\n-- #guard_msgs in\n-- #eval game_winners [350, \"no\"] [250, \"yes\"]\n\n/-\ninfo: \"It's a draw!\"\n-/\n-- #guard_msgs in\n-- #eval game_winners [100, \"yes\"] [250, \"no\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4012", "language": "lean", "source": "fvapps", "source-id": "fvapps_004012", "source-notes": "", "vc-description": "/-\nIn Math, an improper fraction is a fraction where the numerator (the top number) is greater than or equal to the denominator (the bottom number) For example: ```5/3``` (five third).\n\nA mixed numeral is a whole number and a fraction combined into one \"mixed\" number. For example: ```1 1/2``` (one and a half) is a mixed numeral.\n\n## Task\n\nWrite a function `convertToMixedNumeral` to convert the improper fraction into a mixed numeral.\n\nThe input will be given as a ```string``` (e.g. ```'4/3'```).\n\nThe output should be a ```string```, with a space in between the whole number and the fraction (e.g. ```'1 1/3'```).  You do not need to reduce the result to its simplest form.\n\nFor the purpose of this exercise, there will be no ```0```, ```empty string``` or ```null``` input value. However, the input can be:\n\n- a negative fraction\n- a fraction that does not require conversion\n- a fraction that can be converted into a whole number\n\n## Example\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def convert_to_mixed_numeral (fraction : String) : MixedNumeral := sorry\n\nstructure MixedNumeral where\n  whole : Int\n  numer : Nat\n  denom : Nat\n  deriving Repr", "vc-theorems": "theorem mixed_numeral_format \n  (n d : Int)\n  (h1 : d > 0)\n  (result : MixedNumeral) \n  (h2 : result = convert_to_mixed_numeral (\"{n}/{d}\")) :\n  (result.numer = 0 ∧ result.denom = 1 ∧ result.whole = n / d) ∨ \n  (result.whole = 0 ∧ result.numer = n.natAbs ∧ result.denom = d.natAbs) ∨\n  (0 < result.numer ∧ \n   result.numer < result.denom ∧\n   result.whole * result.denom + result.numer * (if result.whole ≥ 0 then 1 else -1) = n ∧\n   result.denom = d.natAbs) := sorry\n\ntheorem value_equivalence\n  (n d : Int)\n  (h1 : d > 0)\n  (result : MixedNumeral)\n  (h2 : result = convert_to_mixed_numeral (\"{n}/{d}\")) : \n  n / d = result.whole + result.numer / result.denom * (if result.whole ≥ 0 then 1 else -1) := sorry\n\n/-\ninfo: '1 2/3'\n-/\n-- #guard_msgs in\n-- #eval convert_to_mixed_numeral \"5/3\"\n\n/-\ninfo: '24 2/3'\n-/\n-- #guard_msgs in\n-- #eval convert_to_mixed_numeral \"74/3\"\n\n/-\ninfo: '-23 1/2'\n-/\n-- #guard_msgs in\n-- #eval convert_to_mixed_numeral \"-47/2\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4023", "language": "lean", "source": "fvapps", "source-id": "fvapps_004023", "source-notes": "", "vc-description": "/-\nYou are given an initial 2-value array (x). You will use this to calculate a score.\n\nIf both values in (x) are numbers, the score is the sum of the two. If only one is a number, the score is that number. If neither is a number, return 'Void!'.\n\nOnce you have your score, you must return an array of arrays. Each sub array will be the same as (x) and the number of sub arrays should be equal to the score.\n\nFor example:\n\nif (x) == ['a', 3]  you should return [['a', 3], ['a', 3], ['a', 3]].\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (h::t) => h + sum t\n\ndef explode {α : Type} : List α → List (List α) := sorry\n\ntheorem explode_integers {arr : List Nat} \n  (h1 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 10) \n  (h2 : 1 ≤ arr.length ∧ arr.length ≤ 5) :\n  let result := explode arr\n  (result.length = arr.sum) ∧ \n  (∀ x ∈ result, x = arr) := sorry", "vc-helpers": "", "vc-definitions": "def VoidResult := List (List String)\ndef VOID : VoidResult := []", "vc-theorems": "theorem explode_strings (arr : List String)\n  (h : 1 ≤ arr.length ∧ arr.length ≤ 5) \n  (h2 : ∀ s ∈ arr, s.length ≤ 5) :\n  explode arr = VOID := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4027", "language": "lean", "source": "fvapps", "source-id": "fvapps_004027", "source-notes": "", "vc-description": "/-\n# Base64 Numeric Translator\n\nOur standard numbering system is (Base 10). That includes 0 through 9. Binary is (Base 2), only 1’s and 0’s.  And Hexadecimal is (Base 16) (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F). A hexadecimal “F” has a (Base 10) value of 15. (Base 64) has 64 individual characters which translate in value in (Base 10) from between 0 to 63.\n\n####Write a method that will convert a string from (Base 64) to it's (Base 10) integer value.\n\nThe (Base 64) characters from least to greatest will be\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\n```\nWhere 'A' is equal to 0 and '/' is equal to 63.\n\nJust as in standard (Base 10) when you get to the highest individual integer 9 the next number adds an additional place and starts at the beginning 10; so also (Base 64) when you get to the 63rd digit '/' and the next number adds an additional place and starts at the beginning \"BA\".\n\nExample:\n```\nbase64_to_base10(\"/\") # => 63\nbase64_to_base10(\"BA\") # => 64\nbase64_to_base10(\"BB\") # => 65\nbase64_to_base10(\"BC\") # => 66\n```\n\nWrite a method `base64_to_base10` that will take a string (Base 64) number and output it's (Base 10) value as an integer.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def DIGITS : List Char := sorry\n\ndef base64_to_base10 (s : String) : Nat := sorry", "vc-theorems": "theorem base64_to_base10_nonnegative (s: String) \n  (h: s.length > 0)\n  (h2: ∀ c ∈ s.data, c ∈ DIGITS) :\n  base64_to_base10 s ≥ 0 := sorry\n\ntheorem base64_to_base10_longer_is_larger (s: String)\n  (h: s.length > 1)\n  (h2: ∀ c ∈ s.data, c ∈ DIGITS) :\n  base64_to_base10 s > base64_to_base10 (String.dropRight s 1) := sorry\n\ntheorem base64_to_base10_matches_manual (s: String)\n  (h: s.length > 0)\n  (h2: ∀ c ∈ s.data, c ∈ DIGITS) :\n  base64_to_base10 s = \n    (List.enum s.data.reverse).foldl\n      (fun acc (i, c) => acc + (DIGITS.findIdx? (· = c)).get! * (64 ^ i)) 0 := sorry\n\ntheorem base64_to_base10_type (s: String)\n  (h: s.length > 0)\n  (h2: ∀ c ∈ s.data, c ∈ DIGITS) :\n  base64_to_base10 s ≥ 0 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4056", "language": "lean", "source": "fvapps", "source-id": "fvapps_004056", "source-notes": "", "vc-description": "/-\nWrite a function groupIn10s which takes any number of arguments, and groups them into sets of 10s and sorts each group in ascending order.\n\nThe return value should be an array of arrays, so that numbers between 0-9 inclusive are in position 0 and numbers 10-19 are in position 1, etc. \n\nHere's an example of the required output:\n\n```python\ngrouped = group_in_10s(8, 12, 38, 3, 17, 19, 25, 35, 50) \n\ngrouped[0]     # [3, 8]\ngrouped[1]     # [12, 17, 19]\ngrouped[2]     # [25]\ngrouped[3]     # [35, 38]\ngrouped[4]     # None\ngrouped[5]     # [50]\n```\n``` haskell\ngroupIn10s [8, 12, 3, 17, 19, 24, 35, 50] `shouldBe`  [[3,8],[12,17,19],[24],[35],[],[50]]\n```\n-/", "vc-preamble": "def group_in_10s (nums : List Nat) : List (Option (List Nat)) := sorry\n\ntheorem group_in_10s_empty (nums : List Nat) :\n  nums = [] → group_in_10s nums = [] := sorry", "vc-helpers": "", "vc-definitions": "def listMax (l : List Nat) : Nat :=\nmatch l with\n| [] => 0\n| (x::xs) => max x (listMax xs)", "vc-theorems": "theorem group_in_10s_sorted (nums : List Nat) (group : List Nat) :\n  group ∈ (group_in_10s nums).filterMap id → \n  ∀ i j, i < j → j < group.length → \n  ∀ h1 : i < group.length, ∀ h2 : j < group.length, \n  group.get ⟨i,h1⟩ ≤ group.get ⟨j,h2⟩ := sorry\n\ntheorem group_in_10s_same_tens_digit (nums : List Nat) (group : List Nat) (group_idx : Nat) :\n  some group = (group_in_10s nums).get? group_idx → \n  ∀ n ∈ group, n / 10 = group_idx := sorry\n\ntheorem group_in_10s_preserves_elements (nums : List Nat) :\n  List.length (List.join ((group_in_10s nums).filterMap id)) = List.length nums ∧\n  ∀ n ∈ nums, n ∈ List.join ((group_in_10s nums).filterMap id) := sorry\n\ntheorem group_in_10s_single (n : Nat) :\n  n ≤ 1000 →\n  let result := group_in_10s [n]\n  (∀ i < n/10, result.get? i = some none) ∧ \n  result.get? (n/10) = some (some [n]) ∧\n  result.length = n/10 + 1 := sorry\n\ntheorem group_in_10s_max_length (nums : List Nat) :\n  nums ≠ [] →\n  (∀ n ∈ nums, n ≤ 99) →\n  (group_in_10s nums).length = (listMax nums) / 10 + 1 := sorry\n\n/-\ninfo: 11\n-/\n-- #guard_msgs in\n-- #eval len group_in_10s(100)", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4073", "language": "lean", "source": "fvapps", "source-id": "fvapps_004073", "source-notes": "", "vc-description": "/-\nWrite a program that outputs the `n` largest elements from a list.\n\nExample:\n```python\nlargest(2, [7,6,5,4,3,2,1])\n# => [6,7]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def largest (n : Nat) (xs : List Int) : List Int :=\n  sorry", "vc-theorems": "theorem largest_size {n : Nat} {xs : List Int} \n  (h_nonempty : xs ≠ []) \n  (h_n_valid : n ≤ xs.length) :\n  (largest n xs).length = n :=\n  sorry\n\ntheorem largest_elements {n : Nat} {xs : List Int}\n  (h_nonempty : xs ≠ [])\n  (h_n_valid : n ≤ xs.length) :\n  ∀ x ∈ largest n xs, x ∈ xs :=\n  sorry\n\ntheorem largest_order {n : Nat} {xs : List Int}\n  (h_nonempty : xs ≠ [])\n  (h_n_valid : n ≤ xs.length)\n  (i j : Nat) (h_i : i < n) (h_j : j < n) (h : i < j) :\n  let result := largest n xs\n  let i' : Fin result.length := ⟨i, by simp [largest_size h_nonempty h_n_valid, h_i]⟩\n  let j' : Fin result.length := ⟨j, by simp [largest_size h_nonempty h_n_valid, h_j]⟩\n  result.get i' ≥ result.get j' :=\n  sorry\n\ntheorem largest_max_property {n : Nat} {xs : List Int}\n  (h_nonempty : xs ≠ [])\n  (h_n_valid : n ≤ xs.length) :\n  ∀ x ∈ xs, x ∉ largest n xs → x ≤ (largest n xs).head! :=\n  sorry\n\ntheorem largest_full_list {xs : List Int}\n  (h_nonempty : xs ≠ []) :\n  largest xs.length xs = xs :=\n  sorry\n\n/-\ninfo: [6, 7]\n-/\n-- #guard_msgs in\n-- #eval largest 2 [7, 6, 5, 4, 3, 2, 1]\n\n/-\ninfo: [9, 10]\n-/\n-- #guard_msgs in\n-- #eval largest 2 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n/-\ninfo: [3, 4, 5]\n-/\n-- #guard_msgs in\n-- #eval largest 3 [1, 2, 3, 4, 5]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4083", "language": "lean", "source": "fvapps", "source-id": "fvapps_004083", "source-notes": "", "vc-description": "/-\nGiven few numbers, you need to print out the digits that are not being used.\n\nExample:\n\n```python\nunused_digits(12, 34, 56, 78) # \"09\"\nunused_digits(2015, 8, 26) # \"3479\"\n```\n\nNote:\n\n- Result string should be sorted\n- The test case won't pass Integer with leading zero\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def toString : Nat → String := sorry\ndef unused_digits : List Nat → String := sorry", "vc-theorems": "theorem unused_digits_length (args: List Nat) (result: String) :\n  result = unused_digits args →\n  (match args with\n  | [0] => result.length = 9\n  | [9] => result.length = 9\n  | [12, 34] => result.length = 6\n  | [123, 456, 789] => result.length = 1\n  | [1111] => result.length = 9\n  | [42] => result.length = 8\n  | _ => True) := sorry\n\ntheorem unused_digits_all_chars_are_digits (args: List Nat) :\n  ∀ c, c ∈ (unused_digits args).data → \n    '0' ≤ c ∧ c ≤ '9' := sorry\n\ntheorem unused_digits_is_ordered (args: List Nat) :\n  let s := unused_digits args\n  ∀ (i j : Fin s.length), i.val < j.val →\n    s.data[i.val]! ≤ s.data[j.val]! := sorry\n\ntheorem unused_digits_complement_size (args: List Nat) :\n  let used := List.join (args.map (fun n => (toString n).data))\n  (unused_digits args).length + used.length = 10 := sorry\n\ntheorem unused_digits_no_intersection (args: List Nat) :\n  let used := List.join (args.map (fun n => (toString n).data))\n  let unused := (unused_digits args).data\n  ∀ c, c ∈ unused → c ∉ used := sorry\n\ntheorem unused_digits_all_unique (args: List Nat) :\n  let chars := (unused_digits args).data\n  List.Nodup chars := sorry\n\ntheorem unused_digits_specific_values :\n  unused_digits [12, 34, 56, 78] = \"09\" ∧\n  unused_digits [2015, 8, 26] = \"3479\" ∧\n  unused_digits [93, 10, 11, 40] = \"25678\" := sorry\n\n/-\ninfo: '09'\n-/\n-- #guard_msgs in\n-- #eval unused_digits 12 34 56 78\n\n/-\ninfo: '3479'\n-/\n-- #guard_msgs in\n-- #eval unused_digits 2015 8 26\n\n/-\ninfo: '25678'\n-/\n-- #guard_msgs in\n-- #eval unused_digits 93 10 11 40", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4088", "language": "lean", "source": "fvapps", "source-id": "fvapps_004088", "source-notes": "", "vc-description": "/-\nIn this kata, you will write a function that returns the positions and the values of the \"peaks\" (or local maxima) of a numeric array.\n\nFor example, the array `arr = [0, 1, 2, 5, 1, 0]` has a peak at position `3` with a value of `5` (since `arr[3]` equals `5`).\n\n~~~if-not:php,cpp,java,csharp\nThe output will be returned as an object with two properties: pos and peaks. Both of these properties should be arrays. If there is no peak in the given array, then the output should be `{pos: [], peaks: []}`.\n~~~\n~~~if:php\nThe output will be returned as an associative array with two key-value pairs: `'pos'` and `'peaks'`.  Both of them should be (non-associative) arrays.  If there is no peak in the given array, simply return `['pos' => [], 'peaks' => []]`.\n~~~\n~~~if:cpp\nThe output will be returned as an object of type `PeakData` which has two members: `pos` and `peaks`.  Both of these members should be `vector`s.  If there is no peak in the given array then the output should be a `PeakData` with an empty vector for both the `pos` and `peaks` members.\n\n`PeakData` is defined in Preloaded as follows:\n\n~~~\n~~~if:java\nThe output will be returned as a ``Map>` with two key-value pairs: `\"pos\"` and `\"peaks\"`. If there is no peak in the given array, simply return `{\"pos\" => [], \"peaks\" => []}`.\n~~~\n~~~if:csharp\nThe output will be returned as a `Dictionary>` with two key-value pairs: `\"pos\"` and `\"peaks\"`. \nIf there is no peak in the given array, simply return `{\"pos\" => new List(), \"peaks\" => new List()}`.\n~~~\n\nExample: `pickPeaks([3, 2, 3, 6, 4, 1, 2, 3, 2, 1, 2, 3])` should return `{pos: [3, 7], peaks: [6, 3]}` (or equivalent in other languages)\n\nAll input arrays will be valid integer arrays (although it could still be empty), so you won't need to validate the input.\n\nThe first and last elements of the array will not be considered as peaks (in the context of a mathematical function, we don't know what is after and before and therefore, we don't know if it is a peak or not).\n\nAlso, beware of plateaus !!! `[1, 2, 2, 2, 1]` has a peak while `[1, 2, 2, 2, 3]` does not. In case of a plateau-peak, please only return the position and value of the beginning of the plateau. For example: \n`pickPeaks([1, 2, 2, 2, 1])` returns `{pos: [1], peaks: [2]}` (or equivalent in other languages)\n\nHave fun!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def pickPeaks : List Int → PeakResult := sorry\n\ntheorem pick_peaks_result_structure (arr : List Int) : \n  let result := pickPeaks arr\n  List.length result.pos = List.length result.peaks := sorry", "vc-theorems": "theorem peaks_correspond_to_positions (arr : List Int) :\n  let result := pickPeaks arr\n  ∀ (i : Nat), i < result.pos.length →\n    arr[result.pos[i]!]! = result.peaks[i]! := sorry\n\ntheorem positions_are_ordered (arr : List Int) :\n  let result := pickPeaks arr\n  ∀ i j, i < j → j < result.pos.length → \n    result.pos[i]! < result.pos[j]! := sorry\n\ntheorem peaks_higher_than_neighbors (arr : List Int) :\n  let result := pickPeaks arr\n  ∀ (pos : Nat), pos ∈ result.pos →\n    pos > 0 ∧ pos < arr.length - 1 ∧\n    arr[pos]! > arr[pos-1]! ∧\n    (∃ i, i > pos ∧ i < arr.length ∧\n      (∀ j, pos ≤ j ∧ j < i → arr[j]! = arr[pos]!) ∧\n      arr[i]! < arr[pos]!) := sorry\n\ntheorem plateau_peak_leftmost (arr : List Int) :\n  let result := pickPeaks arr\n  ∀ (pos : Nat), pos ∈ result.pos →\n    ∃ i, i > pos ∧ i < arr.length ∧\n    (∀ j, pos ≤ j ∧ j < i → arr[j]! = arr[pos]!) ∧\n    arr[i]! < arr[pos]! := sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval pick_peaks [1, 2, 3, 6, 4, 1, 2, 3, 2, 1]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval pick_peaks [2, 1, 3, 1, 2, 2, 2, 2, 1]\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval pick_peaks []", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4093", "language": "lean", "source": "fvapps", "source-id": "fvapps_004093", "source-notes": "", "vc-description": "/-\nLеt's create function to play cards. Our rules:\n\nWe have the preloaded `deck`:\n\n```\ndeck = ['joker','2♣','3♣','4♣','5♣','6♣','7♣','8♣','9♣','10♣','J♣','Q♣','K♣','A♣',\n                '2♦','3♦','4♦','5♦','6♦','7♦','8♦','9♦','10♦','J♦','Q♦','K♦','A♦',\n                '2♥','3♥','4♥','5♥','6♥','7♥','8♥','9♥','10♥','J♥','Q♥','K♥','A♥',\n                '2♠','3♠','4♠','5♠','6♠','7♠','8♠','9♠','10♠','J♠','Q♠','K♠','A♠']\n```\n\nWe have 3 arguments:\n\n`card1` and `card2` - any card of our deck.\n\n`trump` - the main suit of four ('♣', '♦', '♥', '♠').\n\nIf both cards have the same suit, the big one wins.\n\nIf the cards have different suits (and no one has trump) return 'Let's play again.'\n\nIf one card has `trump` unlike another, wins the first one.\n\nIf both cards have `trump`, the big one wins.\n\nIf `card1` wins, return 'The first card won.' and vice versa.\n\nIf the cards are equal, return 'Someone cheats.'\n\nA few games:\n\n```\n('3♣', 'Q♣', '♦') -> 'The second card won.'\n\n('5♥', 'A♣', '♦') -> 'Let us play again.'\n\n('8♠', '8♠', '♣') -> 'Someone cheats.'\n\n('2♦', 'A♠', '♦') -> 'The first card won.'\n\n('joker', 'joker', '♦') -> 'Someone cheats.'\n\n```\nP.S. As a card you can also get the string 'joker' - it means this card always wins.\n-/", "vc-preamble": "def card_game : Card → Card → String → String := sorry\n\ntheorem identical_cards_cheating\n  (card1 card2 : Card) (trump : String) :\n  card1 = card2 → card_game card1 card2 trump = \"Someone cheats.\" := sorry", "vc-helpers": "", "vc-definitions": "def card_values := [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\"]\n\naxiom card_value_index : String → Nat\n\naxiom card_value_index_valid :\n  ∀ s₁ s₂, s₁ ≠ s₂ → card_value_index s₁ ≠ card_value_index s₂", "vc-theorems": "theorem joker_always_wins_first\n  (card1 card2 : Card) (trump : String) :\n  card1 = Card.joker → card2 ≠ Card.joker →\n  card_game card1 card2 trump = \"The first card won.\" := sorry\n\ntheorem joker_always_wins_second\n  (card1 card2 : Card) (trump : String) :\n  card2 = Card.joker → card1 ≠ Card.joker →\n  card_game card1 card2 trump = \"The second card won.\" := sorry\n\ntheorem same_suit_comparison\n  (val1 val2 suit trump : String) :\n  val1 ≠ val2 →\n  let card1 := Card.regular val1 suit\n  let card2 := Card.regular val2 suit\n  card_value_index val2 > card_value_index val1 →\n  card_game card1 card2 trump = \"The second card won.\" := sorry\n\ntheorem same_suit_comparison_first_wins\n  (val1 val2 suit trump : String) :\n  val1 ≠ val2 →\n  let card1 := Card.regular val1 suit\n  let card2 := Card.regular val2 suit\n  card_value_index val1 > card_value_index val2 →\n  card_game card1 card2 trump = \"The first card won.\" := sorry\n\ntheorem trump_wins_first\n  (val1 val2 suit1 suit2 trump : String) :\n  suit1 ≠ suit2 →\n  suit1 = trump →\n  let card1 := Card.regular val1 suit1\n  let card2 := Card.regular val2 suit2\n  card_game card1 card2 trump = \"The first card won.\" := sorry\n\ntheorem trump_wins_second\n  (val1 val2 suit1 suit2 trump : String) :\n  suit1 ≠ suit2 →\n  suit2 = trump →\n  let card1 := Card.regular val1 suit1\n  let card2 := Card.regular val2 suit2\n  card_game card1 card2 trump = \"The second card won.\" := sorry\n\ntheorem no_trump_rematch\n  (val1 val2 suit1 suit2 trump : String) :\n  suit1 ≠ suit2 →\n  suit1 ≠ trump →\n  suit2 ≠ trump →\n  let card1 := Card.regular val1 suit1\n  let card2 := Card.regular val2 suit2\n  card_game card1 card2 trump = \"Let us play again.\" := sorry\n\n/-\ninfo: 'The second card won.'\n-/\n-- #guard_msgs in\n-- #eval card_game \"3♣\" \"Q♣\" \"♦\"\n\n/-\ninfo: 'Let us play again.'\n-/\n-- #guard_msgs in\n-- #eval card_game \"5♥\" \"A♣\" \"♦\"\n\n/-\ninfo: 'The first card won.'\n-/\n-- #guard_msgs in\n-- #eval card_game \"2♦\" \"A♠\" \"♦\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4096", "language": "lean", "source": "fvapps", "source-id": "fvapps_004096", "source-notes": "", "vc-description": "/-\nWrite a comparator for a list of phonetic words for the letters of the [greek alphabet](https://en.wikipedia.org/wiki/Greek_alphabet).\n\nA comparator is:\n> *a custom comparison function of two arguments (iterable elements) which should return a negative, zero or positive number depending on whether the first argument is considered smaller than, equal to, or larger than the second argument*\n\n*(source: https://docs.python.org/2/library/functions.html#sorted)*\n\nThe greek alphabet is preloded for you as `greek_alphabet`:\n\n```python\ngreek_alphabet = (\n    'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', \n    'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', \n    'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma',\n    'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega')\n```\n\n## Examples\n\n```python\ngreek_comparator('alpha', 'beta')   <  0\ngreek_comparator('psi', 'psi')      == 0\ngreek_comparator('upsilon', 'rho')  >  0\n```\n-/", "vc-preamble": "def greek_index (l : GreekLetter) : Nat :=\n  match l with\n  | .alpha => 0 | .beta => 1 | .gamma => 2 | .delta => 3\n  | .epsilon => 4 | .zeta => 5 | .eta => 6 | .theta => 7\n  | .iota => 8 | .kappa => 9 | .lambda => 10 | .mu => 11\n  | .nu => 12 | .xi => 13 | .omicron => 14 | .pi => 15\n  | .rho => 16 | .sigma => 17 | .tau => 18 | .upsilon => 19\n  | .phi => 20 | .chi => 21 | .psi => 22 | .omega => 23", "vc-helpers": "", "vc-definitions": "def greek_comparator (a b : GreekLetter) : Int :=\n  sorry", "vc-theorems": "theorem greek_comparator_reflexive (a : GreekLetter) : \n  greek_comparator a a = 0 :=\nsorry\n\ntheorem greek_comparator_antisymmetric (a b : GreekLetter) :\n  greek_comparator a b = -(greek_comparator b a) :=\nsorry \n\ntheorem greek_comparator_transitive (a b c : GreekLetter) :\n  greek_comparator a b > 0 → greek_comparator b c > 0 → greek_comparator a c > 0 :=\nsorry\n\ntheorem greek_comparator_position {a b : GreekLetter} :\n  a = b → greek_comparator a b = 0 :=\nsorry\n\ntheorem greek_comparator_order {a b : GreekLetter} :\n  greek_index a < greek_index b → greek_comparator a b < 0 :=\nsorry\n\ntheorem greek_comparator_order_reverse {a b : GreekLetter} :\n  greek_index a > greek_index b → greek_comparator a b > 0 :=\nsorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval greek_comparator \"chi\" \"chi\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4100", "language": "lean", "source": "fvapps", "source-id": "fvapps_004100", "source-notes": "", "vc-description": "/-\nDo you have in mind the good old TicTacToe?\n\nAssuming that you get all the data in one array, you put a space around each value, `|` as a columns separator and multiple `-` as rows separator, with something like `[\"O\", \"X\", \" \", \" \", \"X\", \" \", \"X\", \"O\", \" \"]` you should be returning this structure (inclusive of new lines):\n\n```\n O | X |   \n-----------\n   | X |   \n-----------\n X | O |   \n```\n\nNow, to spice up things a bit, we are going to expand our board well beyond a trivial `3` x `3` square and we will accept rectangles of big sizes, still all as a long linear array.\n\nFor example, for `\"O\", \"X\", \" \", \" \", \"X\", \" \", \"X\", \"O\", \" \", \"O\"]` (same as above, just one extra `\"O\"`) and knowing that the length of each row is `5`, you will be returning\n\n```\n O | X |   |   | X \n-------------------\n   | X | O |   | O \n```\n\nAnd worry not about missing elements, as the array/list/vector length is always going to be a multiple of the width.\n-/", "vc-preamble": "def display_board (board : List String) (width : Nat) : String := sorry\n\ndef getEvenElements (xs : List α) : List α :=\n  xs.enum.filter (fun (i, _) => i % 2 = 0) |>.map Prod.snd", "vc-helpers": "", "vc-definitions": "def getOddElements (xs : List α) : List α :=\n  xs.enum.filter (fun (i, _) => i % 2 = 1) |>.map Prod.snd", "vc-theorems": "theorem display_board_properties {board : List String} {width : Nat} \n  (h1 : ∀ x, x ∈ board → (x = \"X\" ∨ x = \"O\" ∨ x = \" \"))\n  (h2 : 0 < width)\n  (h3 : width ≤ 10) \n  (h4 : board.length % width = 0) :\n  let result := display_board board width\n  let lines := result.splitOn \"\\n\"\n  let content_lines := getEvenElements lines\n  ∃ line_length : Nat,\n    -- All content lines have same width\n    (∀ l ∈ content_lines, l.length = line_length) ∧\n    -- Correct number of separators between cells \n    (∀ l ∈ content_lines, (l.toList.filter (· = '|')).length = width - 1) ∧\n    -- Each cell is at most 3 chars wide\n    (∀ l ∈ content_lines, ∀ cell ∈ (l.splitOn \"|\").map String.trim, cell.length ≤ 3) ∧\n    -- Separator lines are correct length\n    (lines.length > 1 → \n      ∀ l ∈ getOddElements lines, l = String.mk (List.replicate (4*width - 1) '-')) := sorry\n\ntheorem width_one_no_pipes {board : List String}\n  (h1 : ∀ x, x ∈ board → (x = \"X\" ∨ x = \"O\" ∨ x = \" \"))\n  (h2 : 0 < board.length) :\n  ¬(display_board board 1).contains '|' := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4109", "language": "lean", "source": "fvapps", "source-id": "fvapps_004109", "source-notes": "", "vc-description": "/-\nYour task is to generate the Fibonacci sequence to `n` places, with each alternating value as `\"skip\"`. For example:\n\n`\"1 skip 2 skip 5 skip 13 skip 34\"`\n\nReturn the result as a string\n\nYou can presume that `n` is always a positive integer between (and including) 1 and 64.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def skiponacci (n : Nat) : String :=\n  sorry", "vc-theorems": "theorem skiponacci_output_type (n : Nat) (h : n > 0) : \n  (String.splitOn (skiponacci n) \" \").length > 0 := sorry\n\ntheorem skiponacci_length (n : Nat) (h : n > 0) :\n  (String.splitOn (skiponacci n) \" \").length = n := sorry\n\ntheorem skiponacci_odd_indices_skip (n : Nat) (h : n > 0) :\n  ∀ i : Nat, i < n → i % 2 = 1 → \n    ((String.splitOn (skiponacci n) \" \")[i]'sorry) = \"skip\" := sorry\n\ntheorem skiponacci_first_element (n : Nat) (h : n > 0) :  \n  (String.splitOn (skiponacci n) \" \").head? = some \"1\" := sorry\n\ntheorem skiponacci_even_indices_increasing (n : Nat) (h : n > 0) :\n  let evenNumbers := (String.splitOn (skiponacci n) \" \").enum.filter (fun p => p.fst % 2 = 0)\n  ∀ i j : Nat, i < j → j < evenNumbers.length →\n    String.toNat! (evenNumbers[i]'sorry).snd < String.toNat! (evenNumbers[j]'sorry).snd := sorry\n\n/-\ninfo: '1'\n-/\n-- #guard_msgs in\n-- #eval skiponacci 1\n\n/-\ninfo: '1 skip 2 skip 5'\n-/\n-- #guard_msgs in\n-- #eval skiponacci 5\n\n/-\ninfo: '1 skip 2 skip 5 skip 13'\n-/\n-- #guard_msgs in\n-- #eval skiponacci 7", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4112", "language": "lean", "source": "fvapps", "source-id": "fvapps_004112", "source-notes": "", "vc-description": "/-\nYou need to swap the head and the tail of the specified array:\n\nthe head (the first half) of array moves to the end, the tail (the second half) moves to the start. \nThe middle element (if it exists) leaves on the same position.\n\nReturn new array.\n\n For example:\n ```\n    [ 1, 2, 3, 4, 5 ]   =>  [ 4, 5, 3, 1, 2 ]\n     \\----/   \\----/         \n      head     tail \n\n    [ -1, 2 ]  => [ 2, -1 ] \n    [ 1, 2, -3, 4, 5, 6, -7, 8 ]   =>  [ 5, 6, -7, 8, 1, 2, -3, 4 ]  \n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def swap_head_tail (lst : List α) : List α := sorry\n\ntheorem swap_head_tail_length {α : Type} (lst : List α) :\n  (swap_head_tail lst).length = lst.length := sorry", "vc-theorems": "", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4120", "language": "lean", "source": "fvapps", "source-id": "fvapps_004120", "source-notes": "", "vc-description": "/-\nYou will be given a fruit which a farmer has harvested, your job is to see if you should buy or sell.\n\nYou will be given 3 pairs of fruit. Your task is to trade your harvested fruit back into your harvested fruit via the intermediate pair, you should return a string of 3 actions.\n\nif you have harvested apples, you would buy this fruit pair: apple_orange, if you have harvested oranges, you would sell that fruit pair.\n\n(In other words, to go from left to right (apples to oranges) you buy, and to go from right to left you sell (oranges to apple))\n\ne.g. \napple_orange, orange_pear, apple_pear\n1. if you have harvested apples, you would buy this fruit pair: apple_orange\n2. Then you have oranges, so again you would buy this fruit pair: orange_pear\n3. After you have pear, but now this time you would sell this fruit pair: apple_pear\n4. Finally you are back with the apples\n\nSo your function would return a list: [“buy”,”buy”,”sell”]\n\nIf any invalid input is given, \"ERROR\" should be returned\n-/", "vc-preamble": "def is_valid_path (pairs : List (List String)) (start : String) (actions : Result String) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def buy_or_sell (pairs : List (List String)) (start : String) : Result String :=\n  sorry", "vc-theorems": "theorem buy_or_sell_produces_valid_result (pairs : List (List String)) (start : String) : \n  match buy_or_sell pairs start with\n  | Result.Actions actions => (∀ a ∈ actions, a = \"buy\" ∨ a = \"sell\") ∧ \n                             actions.length = pairs.length\n  | Result.Error => True\n  := sorry\n\ntheorem buy_or_sell_preserves_path (pairs : List (List String)) (start : String) :\n  is_valid_path pairs start (buy_or_sell pairs start) = true := sorry\n\ntheorem buy_or_sell_works_with_arbitrary_strings (pairs : List (List String)) (start : String) :\n  match buy_or_sell pairs start with\n  | Result.Actions actions => ∀ a ∈ actions, a = \"buy\" ∨ a = \"sell\"\n  | Result.Error => True\n  := sorry\n\ntheorem path_validity_implies_result_validity (pairs : List (List String)) (start : String) :\n  is_valid_path pairs start (buy_or_sell pairs start) = true →\n  match buy_or_sell pairs start with\n  | Result.Actions actions => ∀ a ∈ actions, a = \"buy\" ∨ a = \"sell\"\n  | Result.Error => True\n  := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4123", "language": "lean", "source": "fvapps", "source-id": "fvapps_004123", "source-notes": "", "vc-description": "/-\nJust another day in the world of Minecraft, Steve is getting ready to start his next exciting project -- building a railway system!\n\n![Alt text](http://static.planetminecraft.com/files/resource_media/screenshot/1506/2015-02-02_0156508603066.jpg)\n\nBut first, Steve needs to melt some iron ores in the furnace to get the main building blocks of rails -- iron ingots. ![Alt text](http://www.blocksandgold.com/media/catalog/product/cache/3/image/35x/cbcbef48e5e3bcce7c7ed908f20bc5b4/i/r/ironingot_icon32.png)\n\nEach iron ingot takes 11 seconds* to produce. Steve needs a lot of them, and he has the following fuel options to add into the furnace: \n\n* Buckets of lava, each lasts 800 seconds* ![Alt text](http://www.minecraftguides.org/images/items/bucketL.gif)\n* Blaze rod, each lasts 120 seconds ![Alt text](http://www.minecraftguides.org/images/items/blazerod.gif)\n* Coals, each lasts 80 seconds ![Alt text](http://www.minecraftguides.org/images/items/coal.gif)\n* Blocks of Wood, each lasts 15 seconds ![Alt text](http://www.minecraftguides.org/images/itemGifs/logs.gif)\n* Sticks, each lasts 1 second* ![Alt text](http://www.minecraftguides.org/images/items/stick.gif)\n\nIn Ruby: \nWrite a function `calc_fuel` that calculates the **minimum** amount of fuel needed to produce a certain number of iron ingots. This function should return a hash of the form `{:lava => 2, :blaze_rod => 1, :coal => 1, :wood => 0, :stick => 0}`\nIn JavaScript:\nWrite a function `calcFuel` that calculates the **minimum** amount of fuel needed to produce a certain number of iron ingots. This function should return an object of the form `{lava: 2, blazeRod: 1, coal: 1, wood: 0, stick: 0}`\nIn Python:\nWrite a function `calc_fuel` that calculates the **minimum** amount of fuel needed to produce a certain number of iron ingots. This function should return a dictionary of the form `{\"lava\": 2, \"blaze rod\": 1, \"coal\": 1, \"wood\": 0, \"stick\": 0}`\n\n---\n*fictional values\n\nTo all the Minecraft players out there: \nfeel free to expand this series or let me know if you have any ideas related to Minecraft that can be turned into codewars puzzles. Some ideas I have that might potentially be turned into katas:\n\n* distance traveled in real world vs. in Nether\n* shortest path problems related to mining diamonds/gold/goodies that appears in different levels under ground\n* growth of animal population from breeding\n* redstone stuff?!\n\nIf you do end up expanding this series, please send me a link of your kata so I can check it out and include a link to your kata here :-)\n\n* [Minecraft Series #1: Steve wants to build a beacon pyramid](https://www.codewars.com/kata/minecraft-series-number-1-steve-wants-to-build-a-beacon-pyramid/ruby)\n* [Minecraft Series #3: Lava is amazing! ](https://www.codewars.com/kata/583a23d40cf946ec380002c2)\n* [Minecraft Series #4: Lava is amazing, however...](https://www.codewars.com/kata/583a6b0b171f3a3c3f0003e3)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calcFuel (n : Nat) : FuelMap := sorry\n\ntheorem calc_fuel_values_nonneg (n : Nat) : \n  let result := calcFuel n\n  result.lava ≥ 0 ∧ \n  result.blazeRod ≥ 0 ∧\n  result.coal ≥ 0 ∧\n  result.wood ≥ 0 ∧\n  result.stick ≥ 0 := sorry", "vc-theorems": "theorem calc_fuel_total_seconds (n : Nat) :\n  let result := calcFuel n\n  result.lava * 800 + \n  result.blazeRod * 120 + \n  result.coal * 80 + \n  result.wood * 15 + \n  result.stick = n * 11 := sorry\n\ntheorem calc_fuel_stick_wood_optimal (n : Nat) :\n  let result := calcFuel n\n  result.stick < 15 := sorry\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval calc_fuel 37\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval calc_fuel 21\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval calc_fuel 123", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4133", "language": "lean", "source": "fvapps", "source-id": "fvapps_004133", "source-notes": "", "vc-description": "/-\nYou are given a length of string and two thumbtacks. On thumbtack goes into the focus point *F₀* with coordinates *x₀* and *y₀*, and the other does into point *F₁* with points *x₁* and *y₁*. The string is then tied at the ends to the thumbtacks and has length *l* excluding the knots at the ends. If you pull the string taught with a pencil and draw around the plane you'll have an ellipse with focuses at *F₀* and *F₁*. Given a new point *P*, determine if it falls inside of the ellipse.\n\nYou must write a function that takes arguments `f0`, `f1`, `l`, and `p` and returns `true` or `false` depending on whether or not `p` falls inside the ellipse. \n\nEach of `f0`, `f1`, and `p` has has properties `x` and `y` for its coordinates.\n\nYou will never be given the case where the string is too short to reach between the points.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ellipse_contains_point (f0 : Point) (f1 : Point) (l : Float) (p : Point) : Bool :=\n  sorry", "vc-theorems": "theorem ellipse_contains_point_bool_result (f0 f1 : Point) (l : Float) (p : Point)\n  (h : l > 0) : \n  (ellipse_contains_point f0 f1 l p = true ∨ ellipse_contains_point f0 f1 l p = false) :=\nsorry\n\ntheorem coincident_foci_contains_focus (f0 : Point) (l : Float)\n  (h : l > 0) :\n  ellipse_contains_point f0 f0 l f0 = true :=\nsorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval ellipse_contains_point {\"x\": 0, \"y\": 0} {\"x\": 0, \"y\": 0} 2 {\"x\": 0, \"y\": 0}\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval ellipse_contains_point f0 f1 l {\"x\": 1, \"y\": 1}\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval ellipse_contains_point {\"x\": -1, \"y\": 0} {\"x\": 1, \"y\": 0} 4 {\"x\": 0, \"y\": 1}", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4147", "language": "lean", "source": "fvapps", "source-id": "fvapps_004147", "source-notes": "", "vc-description": "/-\nIt's the fourth quater of the Super Bowl and your team is down by 4 points. You're 10 yards away from the endzone, if your team doesn't score a touchdown in the next four plays you lose. On a previous play, you were injured and rushed to the hospital. Your hospital room has no internet, tv, or radio and you don't know the results of the game. You look at your phone and see that on your way to the hospital a text message came in from one of your teamates. It contains an array of the last 4 plays in chronological order. In each play element of the array you will receive the yardage of the play and the type of the play. Have your function let you know if you won or not.\n\n# What you know:\n\n* Gaining greater than 10 yds from where you started is a touchdown and you win.\n* Yardage of each play will always be a positive number greater than 0.\n* There are only four types of plays: \"run\", \"pass\", \"sack\", \"turnover\".\n* Type of plays that will gain yardage are: \"run\", \"pass\".\n* Type of plays that will lose yardage are: \"sack\".\n* Type of plays that will automatically lose the game are: \"turnover\".\n* When a game ending play occurs the remaining (plays) arrays will be empty.\n* If you win return true, if you lose return false.\n\n# Examples:\n\n[[8, \"pass\"],[5, \"sack\"],[3, \"sack\"],[5, \"run\"]]\n`false`\n[[12, \"pass\"],[],[],[]])\n`true`\n[[2, \"run\"],[5, \"pass\"],[3, \"sack\"],[8, \"pass\"]]\n`true`\n[[5, \"pass\"],[6, \"turnover\"],[],[]]\n`false`\n\nGood Luck!\n-/", "vc-preamble": "def Play := Int × PlayType\ndef PlayList := List Play\n\ndef turnover : PlayType := ⟨\"turnover\"⟩\ndef pass : PlayType := ⟨\"pass\"⟩", "vc-helpers": "", "vc-definitions": "def sack : PlayType := ⟨\"sack\"⟩\n\ndef did_we_win (plays : PlayList) : Bool := \n  sorry", "vc-theorems": "theorem did_we_win_properties (plays : PlayList) : \n  let filtered := plays.filter (fun p => true)\n  let hasNoTurnovers := ¬(filtered.any (fun p => p.2 == turnover))\n  let total := filtered.foldl (fun acc p => \n    acc + (if p.2 == sack then -p.1 else p.1)) 0\n\n  did_we_win plays → (hasNoTurnovers ∧ total > 10) ∧ \n  (¬(did_we_win plays) → (¬hasNoTurnovers ∨ total ≤ 10)) :=\n  sorry\n\ntheorem winning_plays (plays : PlayList) :\n  plays.all (fun p => p.1 ≥ 11 && p.2 == pass) ∧ plays.length > 0 →\n  did_we_win plays :=\n  sorry\n\ntheorem losing_plays_yardage (plays : PlayList) :\n  plays.all (fun p => p.1 ≤ 10 && p.2 == pass) ∧ plays.length > 0 →\n  ¬(did_we_win plays) :=\n  sorry\n\ntheorem losing_plays_turnover (plays : PlayList) :\n  plays.all (fun p => p.2 == turnover) ∧ plays.length > 0 →\n  ¬(did_we_win plays) :=\n  sorry\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval did_we_win [[8, \"pass\"], [5, \"sack\"], [3, \"sack\"], [5, \"run\"]]\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval did_we_win [[12, \"pass\"], [], [], []]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval did_we_win [[5, \"pass\"], [6, \"turnover\"], [], []]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4156", "language": "lean", "source": "fvapps", "source-id": "fvapps_004156", "source-notes": "", "vc-description": "/-\nWrite a function `generatePairs` that accepts an integer argument `n` and generates an array containing the pairs of integers `[a, b]` that satisfy the following conditions:\n```\n0 <= a <= b <= n\n```\n\nThe pairs should be sorted by increasing values of `a` then increasing values of `b`.\n\nFor example, `generatePairs(2)` should return\n```\n[ [0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2] ]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def generate_pairs (n : Nat) : List (Nat × Nat) := sorry\n\ntheorem generate_pairs_valid_bounds {n : Nat} :\n  ∀ p, p ∈ generate_pairs n → \n    (Prod.fst p ≤ Prod.snd p) ∧ (Prod.snd p ≤ n) := sorry", "vc-theorems": "theorem generate_pairs_unique {n : Nat} :\n  ∀ p₁ p₂, p₁ ∈ generate_pairs n → p₂ ∈ generate_pairs n →\n    p₁ = p₂ ∨ p₁ ≠ p₂ := sorry\n\ntheorem generate_pairs_length {n : Nat} :\n  (generate_pairs n).length = (n + 1) * (n + 2) / 2 := sorry\n\ntheorem generate_pairs_ordered {n : Nat} :\n  ∀ p₁ p₂, p₁ ∈ generate_pairs n → p₂ ∈ generate_pairs n →\n    (generate_pairs n).indexOf p₁ < (generate_pairs n).indexOf p₂ →\n    p₁.1 < p₂.1 ∨ (p₁.1 = p₂.1 ∧ p₁.2 ≤ p₂.2) := sorry\n\n/-\ninfo: [[0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2]]\n-/\n-- #guard_msgs in\n-- #eval generate_pairs 2\n\n/-\ninfo: [[0, 0]]\n-/\n-- #guard_msgs in\n-- #eval generate_pairs 0\n\n/-\ninfo: [[0, 0], [0, 1], [1, 1]]\n-/\n-- #guard_msgs in\n-- #eval generate_pairs 1", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4174", "language": "lean", "source": "fvapps", "source-id": "fvapps_004174", "source-notes": "", "vc-description": "/-\nSection numbers are strings of dot-separated integers. The highest level sections (chapters) are numbered 1, 2, 3, etc. Second level sections are numbered 1.1, 1.2, 1.3, 2.1, 2.2, 2.3, etc. Next level sections are numbered 1.1.1, 1.1.2, 1.1.2, 1.2.1, 1.2.2, erc. There is no bound on the number of sections a document may have, nor is there any bound on the number of levels. \n\nA section of a certain level may appear directly inside a section several levels higher without the levels between. For example, section 1.0.1 may appear directly under section 1, without there being any level 2 section. Section 1.1 comes after section 1.0.1. Sections with trailing \".0\" are considered to be the same as the section with the trailing \".0\" truncated. Thus, section 1.0 is the same as section 1, and section 1.2.0.0 is the same as section 1.2. \n\n```if:python\nWrite a function `compare(section1, section2)` that returns `-1`, `0`, or `1` depending on whether `section1` is before, same as, or after `section2` respectively.\n```\n```if:javascript\nWrite a function `cmp(section1, section2)` that returns `-1`, `0`, or `1` depending on whether `section1` is before, same as, or after `section2` respectively.\n```\n```if:haskell\nWrite a function `cmp section1 section2` that returns `LT`, `EQ` or `GT` depending on whether `section1` is before, same as, or after `section2` respectively.\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def compare (v1 v2 : String) : Int := sorry\n\n@[simp] theorem compare_symmetry {v1 v2 : String} :\n  VersionCompare.compare v1 v2 = -(VersionCompare.compare v2 v1) := sorry\n\n@[simp] theorem compare_identity {v : String} :\n  VersionCompare.compare v v = 0 := sorry", "vc-theorems": "theorem trailing_zeros_ignored {v : String} :\n  VersionCompare.compare v (v ++ \".0\") = 0 ∧ \n  VersionCompare.compare v (v ++ \".0.0\") = 0 := sorry\n\ntheorem compare_transitivity {v1 v2 v3 : String} :\n  VersionCompare.compare v1 v2 ≥ 0 → \n  VersionCompare.compare v2 v3 ≥ 0 → \n  VersionCompare.compare v1 v3 ≥ 0 := sorry\n\ntheorem compare_returns_valid {v1 v2 : String} :\n  VersionCompare.compare v1 v2 = -1 ∨ \n  VersionCompare.compare v1 v2 = 0 ∨ \n  VersionCompare.compare v1 v2 = 1 := sorry\n\nend VersionCompare\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval compare \"1\" \"2\"\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval compare \"3\" \"3.0.0\"\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval compare \"1.2.3.4\" \"1.2.3.4\"\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval compare \"1.2.1\" \"1.2.0\"\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval compare \"3.0.1\" \"3.1\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4185", "language": "lean", "source": "fvapps", "source-id": "fvapps_004185", "source-notes": "", "vc-description": "/-\nWelcome young Jedi! In this Kata you must create a function that takes an amount of US currency in `cents`, and returns a dictionary/hash which shows the least amount of coins used to make up that amount. The only coin denominations considered in this exercise are: `Pennies (1¢), Nickels (5¢), Dimes (10¢) and Quarters (25¢)`.\nTherefor the dictionary returned should contain exactly 4 key/value pairs.\n\nNotes:\n\n* If the function is passed either 0 or a negative number, the function should return the dictionary with all values equal to 0.\n* If a float is passed into the function, its value should be be rounded down, and the resulting dictionary should never contain fractions of a coin.\n\n## Examples\n```\nloose_change(56)    ==>  {'Nickels': 1, 'Pennies': 1, 'Dimes': 0, 'Quarters': 2}\nloose_change(-435)  ==>  {'Nickels': 0, 'Pennies': 0, 'Dimes': 0, 'Quarters': 0}\nloose_change(4.935) ==>  {'Nickels': 0, 'Pennies': 4, 'Dimes': 0, 'Quarters': 0}\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def looseChange (cents : Int) : CoinChange := sorry\n\ntheorem loose_change_valid_values (cents : Int) :\n  let result := looseChange cents\n  result.quarters ≥ 0 ∧ \n  result.dimes ≥ 0 ∧\n  result.nickels ≥ 0 ∧ \n  result.pennies ≥ 0 := sorry", "vc-theorems": "theorem loose_change_optimal (cents : Int) (h : cents ≥ 0) (h2 : cents ≤ 1000) :\n  let result := looseChange cents\n  result.pennies < 5 ∧ \n  result.nickels < 2 ∧ \n  result.dimes < 3 ∧\n  result.quarters * 25 + result.dimes * 10 + result.nickels * 5 + result.pennies = cents := sorry\n\n/-\ninfo: {'Nickels': 1, 'Pennies': 1, 'Dimes': 0, 'Quarters': 2}\n-/\n-- #guard_msgs in\n-- #eval loose_change 56\n\n/-\ninfo: {'Nickels': 0, 'Pennies': 0, 'Dimes': 0, 'Quarters': 4}\n-/\n-- #guard_msgs in\n-- #eval loose_change 100\n\n/-\ninfo: {'Nickels': 1, 'Pennies': 2, 'Dimes': 0, 'Quarters': 0}\n-/\n-- #guard_msgs in\n-- #eval loose_change 7.9", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4187", "language": "lean", "source": "fvapps", "source-id": "fvapps_004187", "source-notes": "", "vc-description": "/-\nThis is a follow-up from my previous Kata which can be found here: http://www.codewars.com/kata/5476f4ca03810c0fc0000098\n\nThis time, for any given linear sequence, calculate the function [f(x)] and return it as a function in Javascript or Lambda/Block in Ruby.\n\nFor example:\n\n```python\nget_function([0, 1, 2, 3, 4])(5) => 5\nget_function([0, 3, 6, 9, 12])(10) => 30\nget_function([1, 4, 7, 10, 13])(20) => 61\n```\n\nAssumptions for this kata are:\n```\nThe sequence argument will always contain 5 values equal to f(0) - f(4).\nThe function will always be in the format \"nx +/- m\", 'x +/- m', 'nx', 'x' or 'm'\nIf a non-linear sequence simply return 'Non-linear sequence' for javascript, ruby, and python. For C#, throw an ArgumentException.\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def isLinear (xs : List Int) : Bool := sorry\n\ntheorem linear_sequence_gives_linear_function\n  {seq : List Int} (h : seq.length = 5) (hlin : isLinear seq) :\n  ∃ f : Int → Int, get_function seq = Sum.inl f ∧\n  ∀ x : Int, f x = (seq[1]! - seq[0]!) * x + seq[0]! :=\nsorry", "vc-theorems": "theorem nonlinear_sequence_gives_error\n  {seq : List Int} (h : seq.length = 5) (hnlin : ¬isLinear seq) :\n  get_function seq = Sum.inr \"Non-linear sequence\" :=\nsorry\n\ntheorem linear_function_matches_input_points\n  {seq : List Int} (h : seq.length = 5) (hlin : isLinear seq) :\n  match get_function seq with\n  | Sum.inl f => ∀ i : Fin 5, f i.val = seq[i]!\n  | Sum.inr _ => False :=\nsorry\n\n/-\ninfo: 5\n-/\n-- #guard_msgs in\n-- #eval f1 5\n\n/-\ninfo: 30\n-/\n-- #guard_msgs in\n-- #eval f2 10", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4203", "language": "lean", "source": "fvapps", "source-id": "fvapps_004203", "source-notes": "", "vc-description": "/-\nYou need to write a function, that returns the first non-repeated character in the given string.\n\nFor example for string `\"test\"` function should return `'e'`.  \nFor string `\"teeter\"` function should return `'r'`.  \n\nIf a string contains all unique characters, then return just the first character of the string.  \nExample: for input `\"trend\"` function should return `'t'`  \n\nYou can assume, that the input string has always non-zero length.\n\nIf there is no repeating character, return `null` in JS or Java, and `None` in Python.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def first_non_repeated (s : String) : Option Char := sorry\n\ntheorem first_non_repeated_all_repeated (s : String) :\n  first_non_repeated (s ++ s) = none := sorry", "vc-theorems": "theorem first_non_repeated_single_unique (s : String) (h : s.length > 0) \n  (unique : Char) (h2 : ∀ c ∈ s.data, c ≠ unique) :\n  first_non_repeated (s ++ s ++ toString unique ++ s ++ s) = some unique := sorry\n\ntheorem first_non_repeated_empty :\n  first_non_repeated \"\" = none := sorry\n\ntheorem first_non_repeated_count_one {s : String} {c : Char} \n  (h : first_non_repeated s = some c) :\n  (s.data.count c = 1) ∧ \n  (c ∈ s.data) ∧\n  (∀ i : Nat, i < s.data.indexOf c → s.data[i]?.map (fun x => s.data.count x) ≠ some 1) := sorry\n\n/-\ninfo: 'e'\n-/\n-- #guard_msgs in\n-- #eval first_non_repeated \"test\"\n\n/-\ninfo: 'r'\n-/\n-- #guard_msgs in\n-- #eval first_non_repeated \"teeter\"\n\n/-\ninfo: '5'\n-/\n-- #guard_msgs in\n-- #eval first_non_repeated \"1122321235121222\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4210", "language": "lean", "source": "fvapps", "source-id": "fvapps_004210", "source-notes": "", "vc-description": "/-\nLot of junior developer can be stuck when they need to change the access permission to a file or a directory in an Unix-like operating systems.\n\nTo do that they can use the `chmod` command and with some magic trick they can change the permissionof a file or a directory. For more information about the `chmod` command you can take a look at the [wikipedia page](https://en.wikipedia.org/wiki/Chmod).\n\n`chmod` provides two types of syntax that can be used for changing permissions. An absolute form using octal to denote which permissions bits are set e.g: 766.\nYour goal in this kata is to define the octal you need to use in order to set yout permission correctly.\n\nHere is the list of the permission you can set with the octal representation of this one.\n\n- User\n  - read (4)\n  - write (2)\n  - execute (1)\n- Group\n  - read (4)\n  - write (2)\n  - execute (1)\n- Other\n  - read (4)\n  - write (2)\n  - execute (1)\n\nThe method take a hash in argument this one can have a maximum of 3 keys (`owner`,`group`,`other`). Each key will have a 3 chars string to represent the permission, for example the string `rw-` say that the user want the permission `read`, `write` without the `execute`.\nIf a key is missing set the permission to `---`\n\n**Note**: `chmod` allow you to set some special flags too (`setuid`, `setgid`, `sticky bit`) but to keep some simplicity for this kata we will ignore this one.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def chmod_calculator (perms : Permissions) : String := sorry\n\ntheorem empty_dict_gives_zeros :\n  chmod_calculator {} = \"000\" := sorry", "vc-theorems": "theorem known_values_first :\n  chmod_calculator { user := some \"rwx\", group := some \"r-x\", other := some \"r-x\" } = \"755\" := sorry\n\ntheorem known_values_second :\n  chmod_calculator { user := some \"rw-\", group := some \"r--\", other := some \"r--\" } = \"644\" := sorry\n\ntheorem group_only_rwx :\n  chmod_calculator { group := some \"rwx\" } = \"070\" := sorry\n\ntheorem user_rw_other_r :\n  chmod_calculator { user := some \"rw-\", other := some \"r--\" } = \"604\" := sorry\n\n/-\ninfo: '755'\n-/\n-- #guard_msgs in\n-- #eval chmod_calculator {\"user\": \"rwx\", \"group\": \"r-x\", \"other\": \"r-x\"}\n\n/-\ninfo: '744'\n-/\n-- #guard_msgs in\n-- #eval chmod_calculator {\"user\": \"rwx\", \"group\": \"r--\", \"other\": \"r--\"}\n\n/-\ninfo: '070'\n-/\n-- #guard_msgs in\n-- #eval chmod_calculator {\"group\": \"rwx\"}", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4234", "language": "lean", "source": "fvapps", "source-id": "fvapps_004234", "source-notes": "", "vc-description": "/-\nWrite a function that takes a string and returns an array of the repeated characters (letters, numbers, whitespace) in the string.\n\nIf a charater is repeated more than once, only show it once in the result array.\n\nCharacters should be shown **by the order of their first repetition**. Note that this may be different from the order of first appearance of the character.\n\nCharacters are case sensitive.\n\nFor F# return a \"char list\"\n\n## Examples:\n\n```python\nremember(\"apple\") => returns [\"p\"]\nremember(\"apPle\") => returns []          # no repeats, \"p\" != \"P\"\nremember(\"pippi\") => returns [\"p\",\"i\"]   # show \"p\" only once\nremember('Pippi') => returns [\"p\",\"i\"]   # \"p\" is repeated first\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def remember (s : String) : List Char := sorry\n\ntheorem remember_chars_in_input (s : String) : \n  ∀ c ∈ remember s, c ∈ s.data := by sorry", "vc-theorems": "theorem remember_only_duplicates (s : String) :\n  ∀ c ∈ remember s, (s.data.count c) > 1 := by sorry\n\ntheorem remember_no_duplicates (s : String) :\n  (remember s).Nodup := by sorry\n\ntheorem remember_maintains_order (s : String) (i j : Nat) \n  (h₁ : i < j) (h₂ : i < (remember s).length) (h₃ : j < (remember s).length) :\n  let c₁ := (remember s)[i]'h₂\n  let c₂ := (remember s)[j]'h₃\n  let pos₁ := s.data.indexOf c₁\n  let pos₂ := s.data.indexOf c₂\n  pos₁ ≤ pos₂ := by sorry\n\ntheorem remember_empty (s : String) : \n  s = \"\" → remember s = [] := by sorry\n\ntheorem remember_length_bound (s : String) :\n  (remember s).length ≤ s.length / 2 := by sorry\n\ntheorem remember_returns_chars (s : String) :\n  ∀ c ∈ remember s, c.toString.length = 1 := by sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4238", "language": "lean", "source": "fvapps", "source-id": "fvapps_004238", "source-notes": "", "vc-description": "/-\nA population of bears consists of black bears, brown bears, and white bears.\n\nThe input is an array of two elements. \n\nDetermine whether the offspring of the two bears will return `'black'`, `'brown'`, `'white'`, `'dark brown'`, `'grey'`, `'light brown'`, or `'unknown'`.\n\nElements in the the array will always be a string.\n\n## Examples:\n\n    bear_fur(['black', 'black'])  returns 'black'\n\n    bear_fur(['brown', 'brown'])  returns 'brown'\n\n    bear_fur(['white', 'white'])  returns 'white'\n\n    bear_fur(['black', 'brown'])  returns 'dark brown'\n\n    bear_fur(['black', 'white'])  returns 'grey'\n\n    bear_fur(['brown', 'white'])  returns 'light brown'\n\n    bear_fur(['yellow', 'magenta'])  returns 'unknown'\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bear_fur : List Color → Color\n  | _ => sorry", "vc-theorems": "theorem bear_fur_valid_output (bears : List Color)\n  (h : bears.length = 2) :\n  bear_fur bears ∈ [Color.black, Color.white, Color.brown] ∨\n  bear_fur bears = Color.brown ∨  -- representing \"dark brown\"\n  bear_fur bears = Color.brown ∨  -- representing \"light brown\" \n  bear_fur bears = Color.black    -- representing \"grey\"\n  := by sorry\n\ntheorem bear_fur_same_color (c : Color) :\n  bear_fur [c, c] = c := by sorry\n\ntheorem bear_fur_order_invariant (c1 c2 : Color) :\n  bear_fur [c1, c2] = bear_fur [c2, c1] := by sorry\n\ntheorem bear_fur_specific_pairs :\n  (bear_fur [Color.black, Color.brown] = Color.brown) ∧   -- dark brown\n  (bear_fur [Color.brown, Color.white] = Color.brown) ∧   -- light brown\n  (bear_fur [Color.black, Color.white] = Color.black)     -- grey\n  := by sorry\n\n/-\ninfo: 'black'\n-/\n-- #guard_msgs in\n-- #eval bear_fur [\"black\", \"black\"]\n\n/-\ninfo: 'white'\n-/\n-- #guard_msgs in\n-- #eval bear_fur [\"white\", \"white\"]\n\n/-\ninfo: 'brown'\n-/\n-- #guard_msgs in\n-- #eval bear_fur [\"brown\", \"brown\"]\n\n/-\ninfo: 'dark brown'\n-/\n-- #guard_msgs in\n-- #eval bear_fur [\"black\", \"brown\"]\n\n/-\ninfo: 'grey'\n-/\n-- #guard_msgs in\n-- #eval bear_fur [\"black\", \"white\"]\n\n/-\ninfo: 'light brown'\n-/\n-- #guard_msgs in\n-- #eval bear_fur [\"brown\", \"white\"]\n\n/-\ninfo: 'unknown'\n-/\n-- #guard_msgs in\n-- #eval bear_fur [\"pink\", \"black\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4248", "language": "lean", "source": "fvapps", "source-id": "fvapps_004248", "source-notes": "", "vc-description": "/-\n# Task\nGiven array of integers `sequence` and some integer `fixedElement`, output the number of `even` values in sequence before the first occurrence of `fixedElement` or `-1` if and only if `fixedElement` is not contained in sequence.\n\n# Input/Output\n\n`[input]` integer array `sequence`\n\nA non-empty array of positive integers.\n\n`4 ≤ sequence.length ≤ 100`\n\n`1 ≤ sequence[i] ≤ 9`\n\n`[input]` integer `fixedElement`\n\nAn positive integer\n\n`1 ≤ fixedElement ≤ 9`\n\n`[output]` an integer\n\n# Example\n\nFor `sequence = [1, 4, 2, 6, 3, 1] and fixedElement = 6`, the output should be `2`.\n\nThere are `2` even numbers before `6`: `4 and 2`\n\nFor `sequence = [2, 2, 2, 1] and fixedElement = 3`, the output should be `-1`.\n\nThere is no `3` appears in `sequence`. So returns `-1`.\n\nFor `sequence = [1, 3, 4, 3] and fixedElement = 3`, the output should be `0`.\n\n`3` appears in `sequence`, but there is no even number before `3`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def even_numbers_before_fixed (sequence : List Int) (fixed : Int) : Int :=\n  sorry", "vc-theorems": "theorem not_found_returns_neg_one (sequence : List Int) (fixed : Int) : \n  ¬(fixed ∈ sequence) → even_numbers_before_fixed sequence fixed = -1 :=\n  sorry\n\ntheorem count_evens_before_first_occurrence (sequence : List Int) (fixed : Int) :\n  fixed ∈ sequence →\n  even_numbers_before_fixed sequence fixed = \n    ((sequence.take (sequence.findIdx (· = fixed))).filter (·.mod 2 = 0)).length :=\n  sorry\n\ntheorem result_is_nonneg_when_found (sequence : List Int) (fixed : Int) :\n  fixed ∈ sequence →\n  even_numbers_before_fixed sequence fixed ≥ 0 :=\n  sorry\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval even_numbers_before_fixed [1, 4, 2, 6, 3, 1] 6\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval even_numbers_before_fixed [2, 2, 2, 1] 3\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval even_numbers_before_fixed [1, 3, 4, 3] 3", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4250", "language": "lean", "source": "fvapps", "source-id": "fvapps_004250", "source-notes": "", "vc-description": "/-\nWrite a function called calculate that takes 3 values. The first and third values are numbers. The second value is a character. If the character is \"+\" , \"-\", \"*\", or \"/\", the function will return the result of the corresponding mathematical function on the two numbers. If the string is not one of the specified characters, the function should return null (throw an `ArgumentException` in C#).\n\nKeep in mind, you cannot divide by zero. If an attempt to divide by zero is made, return null (throw an `ArgumentException` in C#)/(None in Python).\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate (x: Float) (op: Operation) (y: Float) : Option Float :=\n  sorry", "vc-theorems": "theorem calculator_valid_ops {x y : Float} {op : Operation} :\n  let result := calculate x op y\n  match op with\n  | Operation.add => result = some (x + y)\n  | Operation.sub => result = some (x - y) \n  | Operation.mul => result = some (x * y)\n  | Operation.div => result = some (x / y) ∨ result = none\n  := sorry\n\ntheorem calculator_div_by_zero {x : Float} :\n  calculate x Operation.div 0 = none := sorry\n\ntheorem calculator_outputs_valid {x y : Float} {op : Operation} :\n  ∃ (r: Float), calculate x op y = some r ∨ calculate x op y = none := sorry\n\n/-\ninfo: 11.2\n-/\n-- #guard_msgs in\n-- #eval calculate 3.2 \"+\" 8\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval calculate -3 \"/\" 0\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval calculate -3 \"w\" 1", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4254", "language": "lean", "source": "fvapps", "source-id": "fvapps_004254", "source-notes": "", "vc-description": "/-\n`Description:`\n\nGiven an input array (`arr`) of positive integers, the objective is to return an output array where each index represents the amount of times an element appeared (frequency) in the input array. \n\nMore specifically, the element at each index of the output array will be an array (bucket) containing integers that appeared index-amount-of-times. \n\nOtherwise, slot nulls (JavaScript, Java), None's (Python) nils (Ruby), or NULL's (C/C++) where appropriate. A valid array will always be provided.\n\nIf an array of [1,2,3,4,4,5,5,5] is passed in, the expected output should be: [null, [1,2,3], [4], [5], null, null, null, null, null].\n\n`Explanation:`\n\n```python\n# bucketize(arr) ======> outputArray\nbucketize(1,2,3,4,4,5,5,5) ======> [None, [1, 2, 3], [4], [5], None, None, None, None, None]\n```\n\nAn element cannot appear 0 times, so a null is placed at outputArray[0]. The elements 1, 2, and 3 appear once. This is why they are located at outputArray[1]. Notice the elements are grouped together in an array and sorted in ascending order. The element 4 appears twice. This is why it is located at outputArray[2]. The element 5 appears three times. This is why it is located at outputArray[3]. \n\nAlthough an integer could have possibly appeared four, five, six, seven, or eight times, this is not the case for this particular example. This is the reason why the elements at outputArray[4], outputArray[5], outputArray[6], outputArray[7], and outputArray[8] are all null values.\n\n`Examples:`\n\n```python\nbucketize(2,2,4,4,6,6,9,9,9,9) ==> [None, None, [2,4,6], None, [9], None, None, None, None, None, None]\nbucketize(3,3,3,3,2) ============> [None, [2], None, None, [3], None]\nbucketize(5,5,5,5,5) ============> [None, None, None, None, None, [5]]\nbucketize(77,3,40,40,40) ========> [None, [3,77], None, [40], None, None]\nbucketize(16,7,5,3,6,23) ========> [None, [3,5,6,7,16,23], None, None, None, None, None]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def bucketize : List Int → List (Option (List Int)) := sorry\n\n/-\n  The bucketize function returns a list with length equal to one plus\n  the length of the input list \n-/", "vc-theorems": "theorem bucketize_length (nums : List Int) : \n  (bucketize nums).length = nums.length + 1 := sorry\n\n/-\n  For each non-empty bucket in the output, its elements are sorted\n-/\n\ntheorem bucketize_sorted (nums : List Int) (i : Nat) (bucket : List Int) :\n  (bucketize nums).get? i = some (some bucket) →\n  ∀ x y, x ∈ bucket → y ∈ bucket → bucket.indexOf x ≤ bucket.indexOf y → x ≤ y := sorry\n\n/-\n  For each number in bucket i, that number appears exactly i times in the input list\n-/\n\ntheorem bucketize_frequency (nums : List Int) (i : Nat) (bucket : List Int) (n : Int) :\n  (bucketize nums).get? i = some (some bucket) → \n  n ∈ bucket →\n  (nums.filter (· = n)).length = i := sorry\n\nend Bucketize\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval bucketize 2 2 4 4 6 6 9 9 9 9\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval bucketize 3 3 3 3 2\n\n/-\ninfo: expected\n-/\n-- #guard_msgs in\n-- #eval bucketize 77 3 40 40 40", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4290", "language": "lean", "source": "fvapps", "source-id": "fvapps_004290", "source-notes": "", "vc-description": "/-\nGiven the number pledged for a year, current value and name of the month, return string that gives information about the challenge status:\n\n- ahead of schedule\n- behind schedule\n- on track\n- challenge is completed\n\nExamples:\n\n`(12, 1, \"February\")` - should return `\"You are on track.\"`\n\n`(12, 1, \"March\")` - should return `\"You are 1 behind schedule.\"`\n\n`(12, 5, \"March\")` - should return `\"You are 3 ahead of schedule.\"`\n\n`(12, 12, \"September\")` - should return `\"Challenge is completed.\"`\n\nDetails:\n- you do not need to do any prechecks (input will always be a natural number and correct name of the month)\n- months should be as even as possible (i.e. for 100 items: January, February, March and April - 9, other months 8)\n- count only the item for completed months (i.e. for March check the values from January and February) and it means that for January you should always return `\"You are on track.\"`.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def check_challenge (pledged current : Nat) (month : Month) : String := sorry\n\n/- Completeness property -/", "vc-theorems": "theorem check_challenge_completed \n  {pledged current : Nat} {month : Month}\n  (h : pledged = current) : \n  check_challenge pledged current month = \"Challenge is completed.\" := sorry\n\n/- January always on track -/\n\ntheorem check_challenge_january\n  {pledged current : Nat}\n  (h : pledged ≠ current) :\n  check_challenge pledged current Month.January = \"You are on track.\" := sorry\n\n/- Output format property -/\n\ntheorem check_challenge_format\n  {pledged current : Nat} {month : Month} :\n  (check_challenge pledged current month = \"Challenge is completed.\" ∨\n   check_challenge pledged current month = \"You are on track.\" ∨\n   ∃ n : Nat, check_challenge pledged current month = s!\"{n} ahead of schedule!\" ∨\n             check_challenge pledged current month = s!\"{n} behind schedule.\") := sorry\n\n/- Behind implies lower progress -/\n\ntheorem check_challenge_behind\n  {pledged current : Nat} {month : Month} {n : Nat}\n  (h : check_challenge pledged current month = s!\"{n} behind schedule.\") :\n  n > 0 := sorry\n\n/- Ahead implies higher progress -/\n\ntheorem check_challenge_ahead  \n  {pledged current : Nat} {month : Month} {n : Nat}\n  (h : check_challenge pledged current month = s!\"{n} ahead of schedule!\") :\n  n > 0 := sorry\n\n/- Zero current property -/\n\ntheorem check_challenge_zero\n  {pledged : Nat} {month : Month} :\n  check_challenge pledged 0 month = \n    if pledged = 0 then\n      \"Challenge is completed.\"\n    else if month = Month.January then \n      \"You are on track.\"\n    else\n      s!\"{pledged} behind schedule.\" := sorry\n\n/-\ninfo: 'You are on track.'\n-/\n-- #guard_msgs in\n-- #eval check_challenge 12 1 \"February\"\n\n/-\ninfo: 'You are 1 behind schedule.'\n-/\n-- #guard_msgs in\n-- #eval check_challenge 12 1 \"March\"\n\n/-\ninfo: 'Challenge is completed.'\n-/\n-- #guard_msgs in\n-- #eval check_challenge 12 12 \"September\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4291", "language": "lean", "source": "fvapps", "source-id": "fvapps_004291", "source-notes": "", "vc-description": "/-\n*SCHEDULE YOUR DA(RRA)Y*\n\nThe best way to have a productive day is to plan out your work schedule. Given the following three inputs, please create an an array of time alloted to work, broken up with time alloted with breaks:\n\nInput 1: Hours - Number of hours available to you to get your work done! \nInput 2: Tasks - How many tasks you have to do througout the day\nInput 3: Duration (minutes)- How long each of your tasks will take to complete\nCriteria to bear in mind:\n- Your schedule should start with work and end with work.\n- It should also be in minutes, rounded to the nearest whole minute. \n- If your work is going to take more time than you have, return \"You're not sleeping tonight!\"\nExample:\n\n```python\nday_plan(8, 5, 30) == [ 30, 82, 30, 82, 30, 82, 30, 82, 30 ]\nday_plan(3, 5, 60) == \"You're not sleeping tonight!\"\n```\n-/", "vc-preamble": "def day_plan (hours tasks duration : Int) : List Int ⊕ String := sorry\n\ndef List.get_even_indices (l : List Int) : List Int := \n  l.enum.filter (fun p => p.fst % 2 = 0) |>.map (fun p => p.snd)\n\ndef List.get_odd_indices (l : List Int) : List Int :=\n  l.enum.filter (fun p => p.fst % 2 = 1) |>.map (fun p => p.snd)\n\ndef List.allDistinctEq (l : List Int) : Bool :=\n  match l with\n  | [] => true\n  | x::xs => xs.all (fun y => y = x)\n\ndef validDurationDistribution (schedule : List Int) (duration : Int) (tasks : Nat) : Prop :=\n  schedule.get? 0 = some duration ∧ \n  schedule.get_even_indices = List.replicate tasks duration\n\ndef validBreakDistribution (schedule : List Int) : Prop := \n  let breaks := schedule.get_odd_indices\n  breaks.all (· ≥ 0) ∧ breaks.allDistinctEq", "vc-helpers": "", "vc-definitions": "def validTotalDuration (schedule : List Int) (hours : Int) : Prop :=\n  schedule.foldl (· + ·) 0 ≤ hours * 60", "vc-theorems": "theorem day_plan_properties {hours tasks duration : Int} \n  (h_hours : hours ≥ 4 ∧ hours ≤ 24)\n  (h_tasks : tasks ≥ 1 ∧ tasks ≤ 8)  \n  (h_duration : duration ≥ 5 ∧ duration ≤ 60) :\n  let result := day_plan hours tasks duration\n  if tasks * duration > hours * 60 then\n    result = Sum.inr \"You're not sleeping tonight!\"\n  else\n    (∃ schedule : List Int,\n      result = Sum.inl schedule ∧\n      schedule.length = 2 * tasks - 1 ∧\n      validDurationDistribution schedule duration tasks.toNat ∧\n      validBreakDistribution schedule ∧\n      validTotalDuration schedule hours) := \nsorry\n\n/-\ninfo: [30, 82, 30, 82, 30, 82, 30, 82, 30]\n-/\n-- #guard_msgs in\n-- #eval day_plan 8 5 30\n\n/-\ninfo: \"You're not sleeping tonight!\"\n-/\n-- #guard_msgs in\n-- #eval day_plan 3 5 60\n\n/-\ninfo: [60]\n-/\n-- #guard_msgs in\n-- #eval day_plan 2 1 60", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4303", "language": "lean", "source": "fvapps", "source-id": "fvapps_004303", "source-notes": "", "vc-description": "/-\nCheck if given numbers are prime numbers. \nIf number N is prime ```return \"Probable Prime\"``` else ``` return \"Composite\"```. \nHINT: Upper bount is really big so you should use an efficient algorithm.\n\nInput\n  1 < N ≤ 10^(100)\n\nExample\n  prime_or_composite(2)  # should return Probable Prime\n  prime_or_composite(200)  # should return Composite\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def prime_or_composite (n : Int) : Result :=\n  sorry", "vc-theorems": "theorem even_numbers_are_composite {n : Int} \n  (h1 : n ≥ 4) (h2 : n % 2 = 0) : \n  prime_or_composite n = Result.Composite :=\nsorry\n\ntheorem two_and_three_are_prime {n : Int}\n  (h : n = 2 ∨ n = 3) :\n  prime_or_composite n = Result.ProbablePrime := \nsorry\n\ntheorem numbers_less_than_2_are_probable_prime {n : Int}\n  (h : n ≤ 1) :\n  prime_or_composite n = Result.ProbablePrime :=\nsorry\n\ntheorem perfect_squares_are_composite {n : Int}\n  (h1 : n > 1) :\n  prime_or_composite (n * n) = Result.Composite :=\nsorry\n\ntheorem product_greater_than_one_is_composite {a b : Int}\n  (h1 : a > 1) (h2 : b > 1) :\n  prime_or_composite (a * b) = Result.Composite :=\nsorry\n\n/-\ninfo: 'Probable Prime'\n-/\n-- #guard_msgs in\n-- #eval prime_or_composite 2\n\n/-\ninfo: 'Probable Prime'\n-/\n-- #guard_msgs in\n-- #eval prime_or_composite 3\n\n/-\ninfo: 'Composite'\n-/\n-- #guard_msgs in\n-- #eval prime_or_composite 9\n\n/-\ninfo: 'Composite'\n-/\n-- #guard_msgs in\n-- #eval prime_or_composite 12", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4312", "language": "lean", "source": "fvapps", "source-id": "fvapps_004312", "source-notes": "", "vc-description": "/-\n# Your task\nOh no... more lemmings!! And in Lemmings Planet a huge battle\nis being fought between the two great rival races: the green\nlemmings and the blue lemmings. Everybody was now assigned\nto battle and they will fight until one of the races completely\ndissapears: the Deadly War has begun!\n\nEvery single lemming has a power measure that describes its\nability to fight. When two single lemmings fight with each one,\nthe lemming with more power survives and the other one dies.\nHowever, the power of the living lemming gets smaller after the\nfight, exactly in the value of the power of the lemming that died.\nFor example, if we have a green lemming with power ``50`` and a\nblue lemming with power ``40``, the blue one dies and the green one\nsurvives, but having only power 10 after the battle ``(50-40=10)``.\nIf two lemmings have the same power when they fight, both of\nthem die.\n\nIn the fight between the two races, there are a certain number of battlefields. Each race assigns one\nlemming for each battlefield, starting with the most powerful. So for example, if a race has 5 lemmings\nwith power ```{50, 50, 40, 40, 30}``` and we have `3` battlefields, then a lemming with power `50` will be assigned\nto battlefield 1, another with `50` power will be assigned to battlefield 2 and last a lemming with power `40` will go to battlefield 3. The other race will do the same.\n\nThe Deadly War is processed by having each race send its best soldiers as described to the battle-\nfields, making a battle round. Then, all battles process at the same time, and some of the lemmings\nwill emerge victorious (but with less power) and some of them will die. The surviving ones will return to their race’s army and then a new round will begin, with each race sending again its best remaining soldiers to the battlefields. If at some point a race does not have enough soldiers to fill all battlefields, then only the ones with soldiers from both races will have a fight.\n\nThe Deadly War ends when one of the races has no more lemmings or when both of them disappear\nat the same time. For example, imagine a war with 2 battlefields and a green army with powers `{20,10}` and a blue army with powers `{10, 10, 15}`. The first round will have `20 vs 15` in battlefield 1 and `10 vs 10` in battlefield 2. After these battles, green race will still have a power `5` lemming (that won on battlefield 1) and blue race will have one with power 10 (that did not fight). The ones in battlefield 2\ndied, since they both had the same power. Afer that comes a second round, and only battlefield 1 will have a fight, being `5 vs 10`. The blue lemming wins, killing the last green soldier and giving the victory to the blue race!\n\nBut in the real battle, will victory be green or blue?\n\nGiven the number of battefields and the armies of both races, your task is to discover which race\nwill win the Deadly War and show the power of the surviving soldiers.\n\n## Input\n\nYou are given B, SG and SB, representing respectively the number of battlefields available, a vector of integers size `n` of lemmings in the green army \nand a vector of integers size `n` of lemmings in the blue army  (1 ≤ B, SG, SB ≤ 100000).\n\nThe lemmings in each army do not need to come in any particular order.\n\n## Output\nFor each test case you should return :\n\n• \"Green and Blue died\" if both races died in the same round\n\n• \"Green wins : Each surviving soldier in descending order\" if the green army won the Deadly War\n\n• \"Blue wins : Each surviving soldier in descending order\" if the blue army won the Deadly War\n\n## Example\n\n```python\nlemming_battle(5, [10], [10]) == \"Green and Blue died\"\nlemming_battle(2, [20,10], [10,10,15]) == \"Blue wins: 5\"\nlemming_battle(3, [50,40,30,40,50], [50,30,30,20,60]) == \"Green wins: 10 10\"\n```\n-/", "vc-preamble": "def lemming_battle (battlefield : Nat) (green blue : List Nat) : String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def parse_survivors (s : String) : List Nat :=\n  sorry", "vc-theorems": "theorem lemming_battle_valid_result (battlefield : Nat) (green blue : List Nat)\n    (h1 : battlefield > 0) (h2 : battlefield ≤ 100)\n    (h3 : ∀ x ∈ green, x > 0 ∧ x ≤ 1000) \n    (h4 : ∀ x ∈ blue, x > 0 ∧ x ≤ 1000)\n    (h5 : green ≠ []) (h6 : blue ≠ []) :\n    let result := lemming_battle battlefield green blue\n    (result = \"Green and Blue died\" ∨ \n     (∃ s : String, result = \"Green wins: \" ++ s) ∨\n     (∃ s : String, result = \"Blue wins: \" ++ s)) := sorry\n\ntheorem lemming_battle_survivor_count (battlefield : Nat) (green blue : List Nat)\n    (h1 : battlefield > 0) (h2 : battlefield ≤ 100)\n    (h3 : ∀ x ∈ green, x > 0 ∧ x ≤ 1000)\n    (h4 : ∀ x ∈ blue, x > 0 ∧ x ≤ 1000)\n    (h5 : green ≠ []) (h6 : blue ≠ []) :\n    let result := lemming_battle battlefield green blue \n    ((result.startsWith \"Green wins\" → List.length (parse_survivors result) ≤ List.length green) ∧\n     (result.startsWith \"Blue wins\" → List.length (parse_survivors result) ≤ List.length blue)) := sorry\n\ntheorem lemming_battle_max_survivor_value (battlefield : Nat) (green blue : List Nat)\n    (h1 : battlefield > 0) (h2 : battlefield ≤ 100)\n    (h3 : ∀ x ∈ green, x > 0 ∧ x ≤ 1000)\n    (h4 : ∀ x ∈ blue, x > 0 ∧ x ≤ 1000)\n    (h5 : green ≠ []) (h6 : blue ≠ []) :\n    let result := lemming_battle battlefield green blue\n    let maxGreen := (List.maximum? green).getD 0\n    let maxBlue := (List.maximum? blue).getD 0\n    ∀ s ∈ parse_survivors result, s ≤ max maxGreen maxBlue := sorry\n\ntheorem equal_armies_draw (n : Nat) \n    (h1 : n > 0) (h2 : n ≤ 100) :\n    lemming_battle 1 [n] [n] = \"Green and Blue died\" := sorry\n\ntheorem battlefield_size_limit (battlefield army_size : Nat)\n    (h1 : battlefield > 0) (h2 : battlefield ≤ 100)\n    (h3 : army_size > 0) (h4 : army_size ≤ 100) :\n    lemming_battle battlefield (List.replicate army_size 1) (List.replicate army_size 1) = \"Green and Blue died\" := sorry\n\n/-\ninfo: 'Green and Blue died'\n-/\n-- #guard_msgs in\n-- #eval lemming_battle 5 [10] [10]\n\n/-\ninfo: 'Blue wins: 5'\n-/\n-- #guard_msgs in\n-- #eval lemming_battle 2 [20, 10] [10, 10, 15]\n\n/-\ninfo: 'Green wins: 10 10'\n-/\n-- #guard_msgs in\n-- #eval lemming_battle 3 [50, 40, 30, 40, 50] [50, 30, 30, 20, 60]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4313", "language": "lean", "source": "fvapps", "source-id": "fvapps_004313", "source-notes": "", "vc-description": "/-\nGet n seconds before the target time. See Example Test Cases about the format.\n-/", "vc-preamble": "def subtractSeconds (date_str : String) (seconds : Nat) : String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def seconds_ago (date_str : String) (seconds : Nat) : String :=\n  sorry\n\n/- Theorems -/", "vc-theorems": "theorem seconds_ago_subtracts_correctly (date_str : String) (seconds : Nat) \n  (h1 : seconds ≤ 86400) -- Max 1 day of seconds\n  (h2 : IsValidDateTime date_str) :\n  seconds_ago date_str seconds = \n    subtractSeconds date_str seconds\n  := sorry\n\ntheorem seconds_ago_zero (date_str : String)\n  (h : IsValidDateTime date_str) :\n  seconds_ago date_str 0 = date_str\n  := sorry\n\ntheorem seconds_ago_invalid_format (date_str : String)\n  (h : ¬IsValidDateTime date_str) :\n  IsError (seconds_ago date_str 1)\n  := sorry\n\n/-\ninfo: '1999-12-31 23:59:59'\n-/\n-- #guard_msgs in\n-- #eval seconds_ago \"2000-01-01 00:00:00\" 1\n\n/-\ninfo: '0001-02-03 04:04:59'\n-/\n-- #guard_msgs in\n-- #eval seconds_ago \"0001-02-03 04:05:06\" 7", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4326", "language": "lean", "source": "fvapps", "source-id": "fvapps_004326", "source-notes": "", "vc-description": "/-\nYou need count how many valleys you will pass.\n\nStart is always from zero level.\n\nEvery time you go down below 0 level counts as an entry of a valley, and as you go up to 0 level from valley counts as an exit of a valley.\n\nOne passed valley is equal one entry and one exit of a valley.\n```\ns='FUFFDDFDUDFUFUF'\nU=UP\nF=FORWARD\nD=DOWN\n```\n\nTo represent string above\n```\n(level 1)  __\n(level 0)_/  \\         _(exit we are again on level 0)\n(entry-1)     \\_     _/\n(level-2)       \\/\\_/\n```\nSo here we passed one valley\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def countValleys (path: List Step) : Nat := sorry\n\ntheorem valley_count_nonnegative (path : List Step) :\n  countValleys path ≥ 0 := sorry", "vc-theorems": "theorem valley_count_bounded_by_down_steps (path : List Step) \n  (h: (path.filter (· = Step.Up)).length = (path.filter (· = Step.Down)).length) :\n  countValleys path ≤ (path.filter (· = Step.Down)).length := sorry\n\ntheorem single_step_no_valley (s : Step) :\n  countValleys [s] = 0 := sorry\n\ntheorem valley_count_simple_segments (segments : List (Step × Step))\n  (h: ∀ p ∈ segments, p.1 = Step.Down ∧ p.2 = Step.Up) :\n  countValleys (segments.bind (fun p => [p.1, p.2])) = segments.length := sorry\n\ntheorem upward_path_no_valleys (path : List Step)\n  (h: ∀ s ∈ path, s = Step.Up) :\n  countValleys path = 0 := sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval counting_valleys \"UFFDDFDUDFUFU\"\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval counting_valleys \"UFFDDFDUDFUFUUFFDDFDUDFUFU\"\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval counting_valleys \"DFFFU\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4329", "language": "lean", "source": "fvapps", "source-id": "fvapps_004329", "source-notes": "", "vc-description": "/-\nGiven a sequence of items and a specific item in that sequence, return the item immediately following the item specified. If the item occurs more than once in a sequence, return the item after the first occurence. This should work for a sequence of any type.\n\nWhen the item isn't present or nothing follows it, the function should return nil in Clojure and Elixir, Nothing in Haskell, undefined in JavaScript, None in Python.\n\n```python\nnext_item([1, 2, 3, 4, 5, 6, 7], 3) # => 4\nnext_item(['Joe', 'Bob', 'Sally'], 'Bob') # => \"Sally\"\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def next_item {α} [BEq α] (xs : List α) (item : α) : Option α := sorry\n\ntheorem next_item_integers {xs : List Int} {x : Int} \n  (h1 : x ∈ xs) (h2 : x ≠ xs[xs.length - 1]!) \n  (h3 : List.indexOf x xs + 1 < xs.length) :\n  next_item xs x = some (xs[List.indexOf x xs + 1]!) := sorry", "vc-theorems": "theorem next_item_last {α} [BEq α] [Inhabited α] {xs : List α} {x : α} \n  (h : x = xs[xs.length - 1]!) :\n  next_item xs x = none := sorry\n\ntheorem next_item_not_found {α} [BEq α] {xs : List α} {x : α} \n  (h : x ∉ xs) :\n  next_item xs x = none := sorry\n\ntheorem next_item_chars {s : String} {c : Char} \n  (h1 : c ∈ s.toList) (h2 : c ≠ s.toList[s.toList.length - 1]!)\n  (h3 : List.indexOf c s.toList + 1 < s.toList.length) :\n  next_item s.toList c = some (s.toList[List.indexOf c s.toList + 1]!) := sorry\n\ntheorem next_item_sequential {xs : List Int} (h : xs.length ≥ 2) :\n  ∀ i, i < xs.length - 1 → \n    (xs[i]! ∉ List.take i xs → next_item xs xs[i]! = some xs[i+1]!) := sorry\n\ntheorem next_item_sequential_last {xs : List Int} \n  (h1 : xs.length ≥ 2) \n  (h2 : xs[xs.length - 1]! ∉ List.take (xs.length - 1) xs) :\n  next_item xs xs[xs.length - 1]! = none := sorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval next_item [1, 2, 3, 4, 5] 3\n\n/-\ninfo: 'l'\n-/\n-- #guard_msgs in\n-- #eval next_item \"hello\" \"l\"\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval next_item [\"a\", \"b\", \"c\"] \"c\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4341", "language": "lean", "source": "fvapps", "source-id": "fvapps_004341", "source-notes": "", "vc-description": "/-\nSam is an avid collector of numbers. Every time he finds a new number he throws it on the top of his number-pile. Help Sam organise his collection so he can take it to the International Number Collectors Conference in Cologne. \n\nGiven an array of numbers, your function should return an array of arrays, where each subarray contains all the duplicates of a particular number. Subarrays should be in the same order as the first occurence of the number they contain:\nAssume the input is always going to be an array of numbers. If the input is an empty array, an empty array should be returned.\n-/", "vc-preamble": "def group (arr : List Int) : List (List Int) := sorry\n\ndef listSum (xs : List Nat) : Nat := \n  match xs with\n  | [] => 0\n  | h :: t => h + listSum t", "vc-helpers": "", "vc-definitions": "def listSort (xs : List Int) : List Int := sorry\n\ndef listIndexOf (xs : List Int) (x : Int) : Nat := sorry", "vc-theorems": "theorem group_idempotent {arr : List Int} (h : arr ≠ []) :\n  let result1 := group arr;\n  let flattened := result1.join;\n  let result2 := group flattened;\n  result1 = result2 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4352", "language": "lean", "source": "fvapps", "source-id": "fvapps_004352", "source-notes": "", "vc-description": "/-\nWrite a function that outputs the transpose of a matrix - a new matrix\nwhere the columns and rows of the original are swapped.\n\nFor example, the transpose of:\n\n    | 1 2 3 |\n    | 4 5 6 |\n\nis\n\n    | 1 4 |\n    | 2 5 |\n    | 3 6 |\n\nThe input to your function will be an array of matrix rows. You can\nassume that each row has the same length, and that the height and\nwidth of the matrix are both positive.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def transpose {α : Type u} [Inhabited α] : Matrix α → Matrix α\n  | Matrix.mk m => sorry", "vc-theorems": "theorem transpose_dimensions {α : Type u} [Inhabited α] {m : List (List α)} \n    (h1 : m.length > 0) \n    (h2 : m.head!.length > 0)\n    (h3 : ∀ row ∈ m, row.length = m.head!.length) :\n  let t := transpose (Matrix.mk m)\n  match t with\n  | Matrix.mk t' =>\n    t'.length = m.head!.length ∧\n    t'.head!.length = m.length := by sorry\n\ntheorem transpose_involution {α : Type u} [Inhabited α] {m : List (List α)}\n    (h1 : m.length > 0)\n    (h2 : m.head!.length > 0)\n    (h3 : ∀ row ∈ m, row.length = m.head!.length) :\n  transpose (transpose (Matrix.mk m)) = Matrix.mk m := by sorry\n\ntheorem transpose_element_relationship {α : Type u} [Inhabited α] {m : List (List α)}\n    (h1 : m.length > 0)\n    (h2 : m.head!.length > 0)\n    (h3 : ∀ row ∈ m, row.length = m.head!.length)\n    (i : Nat) (j : Nat)\n    (hi : i < m.length)\n    (hj : j < m.head!.length) :\n  (m.get! i).get! j = ((match transpose (Matrix.mk m) with | Matrix.mk t => t).get! j).get! i := by sorry\n\ntheorem single_row_transpose {α : Type u} [Inhabited α] (row : List α)\n    (h : row.length > 0) :\n  let m := Matrix.mk [row]\n  let t := transpose m\n  match t with\n  | Matrix.mk t' =>\n    t'.length = row.length ∧\n    (∀ col ∈ t', col.length = 1) ∧\n    (List.map (λ col => col.head!) t' = row) := by sorry\n\ntheorem single_element_transpose {α : Type u} [Inhabited α] (x : α) :\n  transpose (Matrix.mk [[x]]) = Matrix.mk [[x]] := by sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval transpose [[1]]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval transpose [[1, 2, 3]]\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval transpose [[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4355", "language": "lean", "source": "fvapps", "source-id": "fvapps_004355", "source-notes": "", "vc-description": "/-\nWrite\n\n```python\nfunction combine()\n```\n\nthat combines arrays by alternatingly taking elements passed to it.\n\nE.g\n\n```python\ncombine(['a', 'b', 'c'], [1, 2, 3]) == ['a', 1, 'b', 2, 'c', 3]\ncombine(['a', 'b', 'c'], [1, 2, 3, 4, 5]) == ['a', 1, 'b', 2, 'c', 3, 4, 5]\ncombine(['a', 'b', 'c'], [1, 2, 3, 4, 5], [6, 7], [8]) == ['a', 1, 6, 8, 'b', 2, 7, 'c', 3, 4, 5]\n```\n\nArrays can have different lengths.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def combine {α : Type u} (lists : List (List α)) : List α := sorry\n\ntheorem combine_preserves_elements {α : Type u} (lists : List (List α)) (h : lists ≠ []) :\n  ∀ (lst : List α), lst ∈ lists → ∀ (x : α), x ∈ lst → x ∈ combine lists := sorry", "vc-theorems": "theorem combine_length {α : Type u} (lists : List (List α)) (h : lists ≠ []) :\n  let maxLen := (lists.map List.length).maximum?.getD 0\n  let minLen := (lists.map (fun l => min l.length maxLen)).foldl (· + ·) 0\n  List.length (combine lists) = minLen := sorry\n\ntheorem combine_interleaving {α : Type u} (lists : List (List α)) \n  (h1 : lists ≠ []) (h2 : lists.length ≥ 2)\n  (i j : Nat) (hi : i < (lists.map List.length).minimum?.getD 0) (hj : j < lists.length) :\n  let minLen := (lists.map List.length).minimum?.getD 0\n  (combine lists).get? (i * lists.length + j) = (lists.get? j).bind (fun l => l.get? i) := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4356", "language": "lean", "source": "fvapps", "source-id": "fvapps_004356", "source-notes": "", "vc-description": "/-\nIn this kata you need to write a function that will receive two strings (```n1``` and ```n2```), each representing an integer as a binary number. A third parameter will be provided (```o```) as a string representing one of the following operators: add, subtract, multiply.\n\nYour task is to write the calculate function so that it will perform the arithmetic and the result returned should be a string representing the binary result.\n\nExamples:\n```\n1 + 1 === 10\n10 + 10 === 100\n```\n\nNegative binary numbers are usually preceded by several 1's. For this kata, negative numbers can be represented with the negative symbol at the beginning of the string.\n\nExamples of negatives:\n```\n1 - 10 === -1\n10 - 100 === -10\n```\n-/", "vc-preamble": "def string_binary_to_int (s : String) : Int := sorry\ndef calculate_to_int (s : String) : Int := sorry", "vc-helpers": "", "vc-definitions": "def calculate (n1 n2 : String) (op : Op) : String := sorry\n\n/- Result is a valid binary string (possibly with leading minus) -/", "vc-theorems": "theorem calculate_binary_valid (n1 n2 : String) (op : Op)\n  (h1 : ∀ c ∈ n1.data, c = '0' ∨ c = '1')\n  (h2 : ∀ c ∈ n2.data, c = '0' ∨ c = '1') :\n  ∀ c ∈ (calculate n1 n2 op).data.filter (· ≠ '-'), c = '0' ∨ c = '1' := sorry\n\n/- Converting strings to ints and evaluating preserves values -/\n\ntheorem calculate_preserves_values (n1 n2 : String) (op : Op)\n  (h1 : ∀ c ∈ n1.data, c = '0' ∨ c = '1')\n  (h2 : ∀ c ∈ n2.data, c = '0' ∨ c = '1') :\n  match op with\n  | Op.add => calculate_to_int (calculate n1 n2 op) = string_binary_to_int n1 + string_binary_to_int n2\n  | Op.subtract => calculate_to_int (calculate n1 n2 op) = string_binary_to_int n1 - string_binary_to_int n2\n  | Op.multiply => calculate_to_int (calculate n1 n2 op) = string_binary_to_int n1 * string_binary_to_int n2\n  := sorry\n\n/- Invalid inputs raise errors -/\n\ntheorem calculate_invalid_input (n1 n2 : String) :\n  (∃ c ∈ n1.data, c ≠ '0' ∧ c ≠ '1') → Option.isNone (Option.some (calculate n1 n2 Op.add)) := sorry\n\n/-\ninfo: '10'\n-/\n-- #guard_msgs in\n-- #eval calculate \"1\" \"1\" \"add\"\n\n/-\ninfo: '100'\n-/\n-- #guard_msgs in\n-- #eval calculate \"10\" \"10\" \"multiply\"\n\n/-\ninfo: '10'\n-/\n-- #guard_msgs in\n-- #eval calculate \"100\" \"10\" \"subtract\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4368", "language": "lean", "source": "fvapps", "source-id": "fvapps_004368", "source-notes": "", "vc-description": "/-\nMath hasn't always been your best subject, and these programming symbols always trip you up!\n\nI mean, does `**` mean *\"Times, Times\"* or *\"To the power of\"*?\n\nLuckily, you can create the function `expression_out()` to write out the expressions for you!\n\nThe operators you'll need to use are:\n\n```python\n{ '+':   'Plus ',\n  '-':   'Minus ',\n  '*':   'Times ',\n  '/':   'Divided By ',  \n  '**':  'To The Power Of ',\n  '=':   'Equals ',\n  '!=':  'Does Not Equal ' }\n```\n\nThese values will be stored in the preloaded dictionary `OPERATORS` just as shown above.\n\nBut keep in mind: INVALID operators will also be tested, to which you should return `\"That's not an operator!\"`\n\nAnd all of the numbers will be `1` to`10`!\nIsn't that nice!\n\nHere's a few examples to clarify:\n\n```python\nexpression_out(\"4 ** 9\") == \"Four To The Power Of Nine\"\nexpression_out(\"10 - 5\") == \"Ten Minus Five\"\nexpression_out(\"2 = 2\")  == \"Two Equals Two\"\n```\n\nGood luck!\n-/", "vc-preamble": "def expression_out (expr : String) : String := sorry\n\ndef VALID_OPERATORS : List String := [\"+\", \"-\", \"*\", \"/\", \"**\", \"=\", \"!=\"]", "vc-helpers": "", "vc-definitions": "def VALID_NUMBERS : List String := [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"]\n\ntheorem valid_expressions_return_valid_string {expr : String} \n  (h1 : expr.splitOn \" \" = [num1, op, num2])\n  (h2 : num1 ∈ VALID_NUMBERS)\n  (h3 : op ∈ VALID_OPERATORS) \n  (h4 : num2 ∈ VALID_NUMBERS) :\n  ∃ result : String, \n    expression_out expr = result ∧ \n    result ≠ \"That's not an operator!\" := sorry", "vc-theorems": "theorem invalid_expressions_return_error_message {expr : String}\n  (h : ¬(∃ num1 op num2, expr.splitOn \" \" = [num1, op, num2] ∧ \n                         num1 ∈ VALID_NUMBERS ∧\n                         op ∈ VALID_OPERATORS ∧\n                         num2 ∈ VALID_NUMBERS)) :\n  expression_out expr = \"That's not an operator!\" := sorry\n\ntheorem output_format {expr : String} \n  (h : expr = \"1 + 2\") :\n  let result := expression_out expr\n  ∀ word ∈ result.splitOn \" \",\n    word.front.isUpper = true ∧\n    ¬result.back = ' ' := sorry\n\n/-\ninfo: 'One Plus Three'\n-/\n-- #guard_msgs in\n-- #eval expression_out \"1 + 3\"\n\n/-\ninfo: 'Six To The Power Of Nine'\n-/\n-- #guard_msgs in\n-- #eval expression_out \"6 ** 9\"\n\n/-\ninfo: 'Eight Does Not Equal Five'\n-/\n-- #guard_msgs in\n-- #eval expression_out \"8 != 5\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4370", "language": "lean", "source": "fvapps", "source-id": "fvapps_004370", "source-notes": "", "vc-description": "/-\nYou are the judge at a competitive eating competition and you need to choose a winner!\n\nThere are three foods at the competition and each type of food is worth a different amount of points.\nPoints are as follows:\n\n- Chickenwings: 5 points  \n\n- Hamburgers: 3 points   \n\n- Hotdogs: 2 points\n\nWrite a function that helps you create a scoreboard. \nIt takes as a parameter a list of objects representing the participants, for example:\n```\n[\n  {name: \"Habanero Hillary\", chickenwings: 5 , hamburgers: 17, hotdogs: 11},\n  {name: \"Big Bob\" , chickenwings: 20, hamburgers: 4, hotdogs: 11}\n]\n```\nIt should return \n\"name\" and \"score\" properties sorted by score; if scores are equals, sort alphabetically by name.\n```\n[\n  {name: \"Big Bob\", score: 134},\n  {name: \"Habanero Hillary\", score: 98}\n]\n```\nHappy judging!\n-/", "vc-preamble": "def contestant_score (c : Contestant) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def scoreboard (contestants : List Contestant) : List Contestant :=\n  sorry", "vc-theorems": "theorem scoreboard_preserves_length (contestants : List Contestant) :\n  List.length (scoreboard contestants) = List.length contestants :=\n  sorry\n\ntheorem scoreboard_sorted_scores (contestants : List Contestant) \n    (h : contestants.length > 1) :\n  let result := scoreboard contestants\n  ∀ i : Fin (result.length),\n    i.val + 1 < result.length →\n    let score₁ := contestant_score (result.get i)\n    let score₂ := contestant_score (result.get ⟨i.val + 1, by sorry⟩)\n    if score₁ = score₂ \n    then (result.get i).name ≤ (result.get ⟨i.val + 1, by sorry⟩).name \n    else score₁ > score₂ :=\n  sorry\n\ntheorem empty_scoreboard :\n  scoreboard [] = [] :=\n  sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval scoreboard [{\"name\": \"Billy The Beast\", \"chickenwings\": 17, \"hamburgers\": 7, \"hotdogs\": 8}, {\"name\": \"Habanero Hillary\", \"chickenwings\": 5, \"hamburgers\": 17, \"hotdogs\": 11}, {\"name\": \"Joey Jaws\", \"chickenwings\": 8, \"hamburgers\": 8, \"hotdogs\": 15}, {\"name\": \"Big Bob\", \"chickenwings\": 20, \"hamburgers\": 4, \"hotdogs\": 11}]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval scoreboard [{\"name\": \"Joey Jaws\", \"chickenwings\": 0, \"hamburgers\": 1, \"hotdogs\": 1}, {\"name\": \"Big Bob\", \"chickenwings\": 1, \"hamburgers\": 0, \"hotdogs\": 0}]\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval scoreboard []", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4375", "language": "lean", "source": "fvapps", "source-id": "fvapps_004375", "source-notes": "", "vc-description": "/-\n# Task\nTwo players - `\"black\"` and `\"white\"` are playing a game. The game consists of several rounds. If a player wins in a round, he is to move again during the next round. If a player loses a round, it's the other player who moves on the next round. Given whose turn it was on the previous round and whether he won, determine whose turn it is on the next round.\n\n# Input/Output\n\n`[input]` string `lastPlayer`/`$last_player`\n\n`\"black\"` or `\"white\"` - whose move it was during the previous round.\n\n`[input]` boolean `win`/`$win`\n\n`true` if the player who made a move during the previous round won, `false` otherwise.\n\n`[output]` a string\n\nReturn `\"white\"` if white is to move on the next round, and `\"black\"` otherwise.\n\n# Example\n\nFor `lastPlayer = \"black\" and win = false`, the output should be `\"white\"`.\n\nFor `lastPlayer = \"white\" and win = true`, the output should be `\"white\"`.\n-/", "vc-preamble": "def opposite : Player → Player \n  | Player.black => Player.white\n  | Player.white => Player.black", "vc-helpers": "", "vc-definitions": "def whoseMove (player : Player) (win : Bool) : Player := sorry\n\ntheorem whoseMove_valid (player : Player) (win : Bool) :\n  whoseMove player win = player ∨ whoseMove player win = opposite player := by sorry", "vc-theorems": "theorem whoseMove_win (player : Player) (win : Bool) :\n  win = true → whoseMove player win = player := by sorry\n\ntheorem whoseMove_lose (player : Player) (win : Bool) :\n  win = false → whoseMove player win = opposite player := by sorry\n\n/-\ninfo: 'white'\n-/\n-- #guard_msgs in\n-- #eval whoseMove \"black\" False\n\n/-\ninfo: 'white'\n-/\n-- #guard_msgs in\n-- #eval whoseMove \"white\" True\n\n/-\ninfo: 'black'\n-/\n-- #guard_msgs in\n-- #eval whoseMove \"black\" True", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4377", "language": "lean", "source": "fvapps", "source-id": "fvapps_004377", "source-notes": "", "vc-description": "/-\n---\n\n# Story\n\nThe Pied Piper has been enlisted to play his magical tune and coax all the rats out of town.\n\nBut some of the rats are deaf and are going the wrong way!\n\n# Kata Task\n\nHow many deaf rats are there?\n\n# Legend\n\n* ```P``` = The Pied Piper\n* ```O~``` = Rat going left\n* ```~O``` = Rat going right\n\n# Example\n\n* ex1 ```~O~O~O~O P``` has 0 deaf rats\n\n* ex2 ```P O~ O~ ~O O~``` has 1 deaf rat\n\n* ex3 ```~O~O~O~OP~O~OO~``` has 2 deaf rats\n\n---\n\n# Series\n\n* [The deaf rats of Hamelin (2D)](https://www.codewars.com/kata/the-deaf-rats-of-hamelin-2d)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Town := String\ndef countDeafRats (t : Town) : Nat :=\n  sorry", "vc-theorems": "theorem non_negative_count : ∀ (t : Town),\n  countDeafRats t ≥ 0 :=\n  sorry\n\ntheorem count_below_total : ∀ (t : Town) (n : Nat),\n  countDeafRats t ≤ n :=\n  sorry\n\ntheorem spaces_dont_matter : ∀ (t1 t2 : Town),\n  countDeafRats t1 = countDeafRats t2 :=\n  sorry\n\ntheorem single_rat_direction : ∀ (t : Town) (r : RatPair),\n  countDeafRats t ≤ 1 :=\n  sorry\n\ntheorem empty_town_count :  \n  countDeafRats \"P\" = 0 :=\n  sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval count_deaf_rats \"~O~O~O~O P\"\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval count_deaf_rats \"P O~ O~ ~O O~\"\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval count_deaf_rats \"~O~O~O~OP~O~OO~\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4381", "language": "lean", "source": "fvapps", "source-id": "fvapps_004381", "source-notes": "", "vc-description": "/-\nIn this task you have to code process planner.\n\nYou will be given initial thing, target thing and a set of processes to turn one thing into another (in the form of _[process\\_name, start\\_thing, end\\_thing]_). You must return  names of shortest sequence of processes to turn initial thing into target thing, or empty sequence if it's impossible.\n\nIf start already equals end, return [], since no path is required.\n\nExample: \n\n```python\ntest_processes = [\n        ['gather', 'field', 'wheat'],\n        ['bake', 'flour', 'bread'],\n        ['mill', 'wheat', 'flour']\n];\n\nprocesses('field', 'bread', test_processes) # should return ['gather', 'mill', 'bake']\nprocesses('field', 'ferrari', test_processes) # should return []\nprocesses('field', 'field', test_processes) # should return [], since no processes are needed\n```\n\nGood luck!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def processes (start : String) (destination : String) (procs : List Process) : List String :=\n  sorry", "vc-theorems": "theorem processes_returns_list (start dest : String) (procs : List Process) :\n  ∀ x ∈ processes start dest procs, String.isPrefixOf \"\" x :=\n  sorry\n\ntheorem processes_valid_path (start dest : String) (procs : List Process) \n  (h : (processes start dest procs).length > 0) :\n  (List.foldl\n    (fun curr step =>\n      match procs.find? (fun p => p.name = step) with\n      | some proc => proc.endNode\n      | none => curr)\n    start\n    (processes start dest procs)) = dest :=\n  sorry\n\ntheorem processes_same_start (s : String) (procs : List Process) :\n  processes s s procs = [] :=\n  sorry\n\ntheorem processes_empty_procs (start dest : String) :\n  processes start dest [] = [] :=\n  sorry\n\ntheorem processes_cycle_detection :\n  let cycleProcs := [\n    {name := \"1\", startNode := \"a\", endNode := \"b\"},\n    {name := \"2\", startNode := \"b\", endNode := \"c\"},\n    {name := \"3\", startNode := \"c\", endNode := \"b\"}]\n  ; processes \"a\" \"d\" cycleProcs = [] :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4394", "language": "lean", "source": "fvapps", "source-id": "fvapps_004394", "source-notes": "", "vc-description": "/-\nImplement the function unique_in_order which takes as argument a sequence and returns a list of items without any elements with the same value next to each other and preserving the original order of elements.\n\nFor example:\n\n```python\nunique_in_order('AAAABBBCCDAABBB') == ['A', 'B', 'C', 'D', 'A', 'B']\nunique_in_order('ABBCcAD')         == ['A', 'B', 'C', 'c', 'A', 'D']\nunique_in_order([1,2,2,3,3])       == [1,2,3]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def unique_in_order {α} [BEq α] (xs : List α) : List α := sorry\n\ntheorem no_consecutive_duplicates {α} [BEq α] [Inhabited α] (xs : List α) :\n  let result := unique_in_order xs\n  ∀ i, i < result.length - 1 → result.get! i ≠ result.get! (i+1) := sorry", "vc-theorems": "theorem elements_from_input {α} [BEq α] (xs : List α) :\n  let result := unique_in_order xs\n  ∀ x ∈ result, x ∈ xs := sorry\n\ntheorem maintains_relative_order {α} [BEq α] [Inhabited α] (xs : List α) :\n  let result := unique_in_order xs\n  xs ≠ [] ∧ result ≠ [] →\n  ∀ i j, i < j → i < xs.length → j < xs.length → \n  xs[i]! = xs[j]! → result.indexOf (xs[i]!) < result.indexOf (xs[j]!) := sorry\n\ntheorem length_bounded {α} [BEq α] (xs : List α) :\n  (unique_in_order xs).length ≤ xs.length := sorry\n\ntheorem empty_input_empty_output {α} [BEq α] :\n  unique_in_order ([] : List α) = [] := sorry\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval unique_in_order \"\"\n\n/-\ninfo: ['A', 'B', 'C', 'D', 'A', 'B']\n-/\n-- #guard_msgs in\n-- #eval unique_in_order \"AAAABBBCCDAABBB\"\n\n/-\ninfo: [1, 2, 3]\n-/\n-- #guard_msgs in\n-- #eval unique_in_order [1, 2, 2, 3, 3]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4395", "language": "lean", "source": "fvapps", "source-id": "fvapps_004395", "source-notes": "", "vc-description": "/-\nIt's a Pokemon battle! Your task is to calculate the damage that a particular move would do using the following formula (not the actual one from the game):\n\nWhere:\n\n* attack = your attack power\n* defense = the opponent's defense\n* effectiveness = the effectiveness of the attack based on the matchup (see explanation below)\n\nEffectiveness:\n\nAttacks can be super effective, neutral, or not very effective depending on the matchup. For example, water would be super effective against fire, but not very effective against grass.\n\n* Super effective: 2x damage\n* Neutral: 1x damage\n* Not very effective: 0.5x damage\n\nTo prevent this kata from being tedious, you'll only be dealing with four types: `fire`, `water`, `grass`, and `electric`.  Here is the effectiveness of each matchup:\n\n* `fire > grass`\n* `fire < water`\n* `fire = electric`\n\n* `water < grass`\n* `water < electric`\n\n* `grass = electric`\n\nFor this kata, any type against itself is not very effective. Also, assume that the relationships between different types are symmetric (if `A` is super effective against `B`, then `B` is not very effective against `A`).\n\nThe function you must implement takes in:\n1. your type\n2. the opponent's type\n3. your attack power\n4. the opponent's defense\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def calculate_damage (your_type: PokemonType) (opponent_type: PokemonType) (attack: Nat) (defense: Nat) : Nat :=\n  sorry", "vc-theorems": "theorem damage_always_positive (your_type: PokemonType) (opponent_type: PokemonType) \n    (attack: Nat) (defense: Nat) (h1: attack > 0) (h2: defense > 0) :\n  calculate_damage your_type opponent_type attack defense > 0 :=\nsorry\n\ntheorem damage_decreases_with_defense (your_type: PokemonType) (opponent_type: PokemonType)\n    (attack: Nat) (defense1 defense2: Nat) (h1: defense1 < defense2) :\n  calculate_damage your_type opponent_type attack defense1 ≥ \n  calculate_damage your_type opponent_type attack defense2 :=\nsorry\n\ntheorem damage_increases_with_attack (your_type: PokemonType) (opponent_type: PokemonType)\n    (attack1 attack2: Nat) (defense: Nat) (h1: attack1 < attack2) :\n  calculate_damage your_type opponent_type attack1 defense ≤\n  calculate_damage your_type opponent_type attack2 defense :=\nsorry\n\n/-\ninfo: 25\n-/\n-- #guard_msgs in\n-- #eval calculate_damage \"fire\" \"water\" 100 100\n\n/-\ninfo: 100\n-/\n-- #guard_msgs in\n-- #eval calculate_damage \"grass\" \"water\" 100 100\n\n/-\ninfo: 50\n-/\n-- #guard_msgs in\n-- #eval calculate_damage \"electric\" \"fire\" 100 100", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4397", "language": "lean", "source": "fvapps", "source-id": "fvapps_004397", "source-notes": "", "vc-description": "/-\nTake a string and return a hash with all the ascii values of the characters in the string.\nReturns nil if the string is empty.\nThe key is the character, and the value is the ascii value of the character.\nRepeated characters are to be ignored and non-alphebetic characters as well.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def charToAscii (s : String) : Option Dict := sorry\n\ntheorem charToAscii_empty_string :\n  charToAscii \"\" = none := sorry", "vc-theorems": "theorem charToAscii_maps_to_ascii (s : String) (c : Char) (d : Dict) :\n  s ≠ \"\" →\n  c.isAlpha = true →\n  c ∈ s.data →\n  charToAscii s = some d →\n  ∃ n, (c, n) ∈ d.chars ∧ n = c.toNat := sorry\n\ntheorem charToAscii_keys_are_alpha (s : String) (d : Dict) :\n  s ≠ \"\" →\n  charToAscii s = some d →\n  ∀ c n, (c, n) ∈ d.chars → c.isAlpha = true := sorry\n\ntheorem charToAscii_includes_all_alpha (s : String) (d : Dict) : \n  s ≠ \"\" →\n  charToAscii s = some d →\n  ∀ c, c ∈ s.data → c.isAlpha = true → \n  ∃ n, (c, n) ∈ d.chars := sorry\n\ntheorem charToAscii_non_alpha_empty (s : String) (d : Dict) :\n  s ≠ \"\" →\n  (∀ c, c ∈ s.data → c.isAlpha = false) →\n  charToAscii s = some d →\n  d.chars = [] := sorry\n\ntheorem charToAscii_alpha_only_size (s : String) (d : Dict) :\n  s ≠ \"\" →\n  (∀ c, c ∈ s.data → c.isAlpha = true) →\n  charToAscii s = some d →\n  d.chars.length = s.data.eraseDups.length := sorry\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval char_to_ascii \"\"\n\n/-\ninfo: {'a': 97}\n-/\n-- #guard_msgs in\n-- #eval char_to_ascii \"a\"\n\n/-\ninfo: {'h': 104, 'e': 101, 'l': 108, 'o': 111, 'w': 119, 'r': 114, 'd': 100}\n-/\n-- #guard_msgs in\n-- #eval char_to_ascii \"hello world\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4400", "language": "lean", "source": "fvapps", "source-id": "fvapps_004400", "source-notes": "", "vc-description": "/-\nYour website is divided vertically in sections, and each can be of different size (height).  \nYou need to establish the section index (starting at `0`) you are at, given the `scrollY` and `sizes` of all sections.  \nSections start with `0`, so if first section is `200` high, it takes `0-199` \"pixels\" and second starts at `200`.\n\n### Example:\n\n`getSectionIdFromScroll( 300, [300,200,400,600,100] )`\n\nwill output number `1` as it's the second section.\n\n`getSectionIdFromScroll( 1600, [300,200,400,600,100] )`\n\nwill output number `-1` as it's past last section.\n\nGiven the `scrollY` integer (always non-negative) and an array of non-negative integers (with at least one element), calculate the index (starting at `0`) or `-1` if `scrollY` falls beyond last section (indication of an error).\n-/", "vc-preamble": "def List.sum : List Int → Int \n  | [] => 0\n  | (x::xs) => x + sum xs", "vc-helpers": "", "vc-definitions": "def get_section_id (scroll : Int) (sizes : List Int) : Int :=\n  sorry", "vc-theorems": "theorem get_section_id_bounds (scroll : Int) (sizes : List Int) (h : sizes ≠ []) :\n  -1 ≤ get_section_id scroll sizes ∧ get_section_id scroll sizes < sizes.length :=\n  sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval get_section_id 1 [300, 200, 400, 600, 100]\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval get_section_id 300 [300, 200, 400, 600, 100]\n\n/-\ninfo: -1\n-/\n-- #guard_msgs in\n-- #eval get_section_id 1600 [300, 200, 400, 600, 100]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4405", "language": "lean", "source": "fvapps", "source-id": "fvapps_004405", "source-notes": "", "vc-description": "/-\nYou will be given an array of positive integers. The array should be sorted by the amount of distinct perfect squares and reversed, that can be generated from each number permuting its digits.\n\nE.g.: ```arr = [715, 112, 136, 169, 144]``` \n``` \nNumber   Perfect Squares w/ its Digits   Amount\n 715                -                       0\n 112               121                      1\n 136               361                      1\n 169           169, 196, 961                3\n 144             144, 441                   2\n``` \nSo the output will have the following order:\n```[169, 144, 112, 136, 715]``` \n\nWhen we have two or more numbers with the same amount of perfect squares in their permutations, we sorted by their values.\n\nIn the example given above, we can see that 112 and 136 both generate a perfect square. So 112 comes first.\n\nExamples for this kata:\n```python\nsort_by_perfsq([715, 112, 136, 169, 144]) == [169, 144, 112, 136, 715]\n# number of perfect squares:                   3    2    1    1    0\n``` \nWe may have in the array numbers that belongs to the same set of permutations.\n```python\nsort_by_perfsq([234, 61, 16, 441, 144, 728]) == [144, 441, 16, 61, 234, 728]\n# number of perfect squares:                      2    2    1   0   0    0\n```\n\nFeatures of the random tests:\n~~~if:ruby,python\n- Number of tests: 80\n- Arrays between 4 and 20 elements\n- Integers having from 1 to 7 digits included\n~~~\n~~~if:js\n- Number of tests: 30\n- Arrays between 4 and 16 elements\n- Integers having from 1 to 7 digits included\n~~~\n\nEnjoy it!!\n-/", "vc-preamble": "def List.toBag {α : Type u} [BEq α] (l : List α) : Bag α where\n  count a := List.length (List.filter (fun x => x == a) l)", "vc-helpers": "", "vc-definitions": "def sort_by_perfsq (arr : List Nat) : List Nat := sorry\n\ntheorem sort_by_perfsq_maintains_length {arr : List Nat} :\n  List.length (sort_by_perfsq arr) = List.length arr := sorry", "vc-theorems": "theorem sort_by_perfsq_maintains_elements {arr : List Nat} :\n  (sort_by_perfsq arr).toBag = arr.toBag := sorry\n\ntheorem sort_by_perfsq_idempotent {arr : List Nat} :\n  sort_by_perfsq (sort_by_perfsq arr) = sort_by_perfsq arr := sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval sort_by_perfsq [715, 112, 136, 169, 144]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval sort_by_perfsq [234, 61, 16, 441, 144, 728]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4417", "language": "lean", "source": "fvapps", "source-id": "fvapps_004417", "source-notes": "", "vc-description": "/-\nBorn a misinterpretation of [this kata](https://www.codewars.com/kata/simple-fun-number-334-two-beggars-and-gold/), your task here is pretty simple: given an array of values and an amount of beggars, you are supposed to return an array with the sum of what each beggar brings home, assuming they all take regular turns, from the first to the last.\n\nFor example: `[1,2,3,4,5]` for `2` beggars will return a result of `[9,6]`, as the first one takes `[1,3,5]`, the second collects `[2,4]`.\n\nThe same array with `3` beggars would have in turn have produced a better out come for the second beggar: `[5,7,3]`, as they will respectively take `[1,4]`, `[2,5]` and `[3]`.\n\nAlso note that not all beggars have to take the same amount of \"offers\", meaning that the length of the array is not necessarily a multiple of `n`; length can be even shorter, in which case the last beggars will of course take nothing (`0`).\n\n***Note:*** in case you don't get why this kata is about *English* beggars, then you are not familiar on how religiously queues are taken in the kingdom ;)\n-/", "vc-preamble": "def List.sum : List Int → Int \n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def beggars (values : List Int) (n : Nat) : List Int := sorry\n\ndef getNth (values : List Int) (n i : Nat) : Int :=\n  match values with\n  | [] => 0\n  | x::xs => if i % n = 0 then x + getNth xs n (i+1) else getNth xs n (i+1)", "vc-theorems": "theorem beggars_empty_for_zero_n \n  (values : List Int) :\n  beggars values 0 = [] := sorry\n\ntheorem beggars_length_property \n  (values : List Int) (n : Nat) : \n  n > 0 → (beggars values n).length = n := sorry \n\ntheorem beggars_sum_property \n  (values : List Int) (n : Nat) :\n  n > 0 → List.sum values = List.sum (beggars values n) := sorry\n\ntheorem beggars_single_beggar_property\n  (values : List Int) :\n  values.length > 0 → beggars values 1 = [List.sum values] := sorry\n\ntheorem beggars_more_beggars_property\n  (values : List Int) (n : Nat) :\n  n > values.length →\n  beggars values n = \n    beggars values values.length ++ List.replicate (n - values.length) 0 := sorry\n\n/-\ninfo: [15]\n-/\n-- #guard_msgs in\n-- #eval beggars [1, 2, 3, 4, 5] 1\n\n/-\ninfo: [9, 6]\n-/\n-- #guard_msgs in\n-- #eval beggars [1, 2, 3, 4, 5] 2\n\n/-\ninfo: [5, 7, 3]\n-/\n-- #guard_msgs in\n-- #eval beggars [1, 2, 3, 4, 5] 3", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4419", "language": "lean", "source": "fvapps", "source-id": "fvapps_004419", "source-notes": "", "vc-description": "/-\nIn graph theory, a graph is a collection of nodes with connections between them.\nAny node can be connected to any other node exactly once, and can be connected to no nodes, to some nodes, or to every other node.\nNodes cannot be connected to themselves\nA path through a graph is a sequence of nodes, with every node connected to the node following and preceding it.\nA closed path is a path which starts and ends at the same node.\n\nAn open path:\n```\n1 -> 2 -> 3\n```\na closed path:\n```\n1 -> 2 -> 3 -> 1\n```\nA graph is connected if there is a path from every node to every other node.\nA graph is a tree if it is connected and there are no closed paths.\n\nYour job is to write a function 'isTree', which returns true if a graph is a tree, and false if it is not a tree.\n\nGraphs will be given as an array with each item being an array of integers which are the nodes that node is connected to.\n\nFor example, this graph:\n```\n0--1\n|  |\n2--3--4\n```\nhas array:\n```\n[[1,2], [0,3], [0,3], [1,2,4], [3]]\n```\nNote that it is also not a tree, because it contains closed path:\n```\n0->1->3->2->0\n```\nA node with no connections is an empty array\nNote that if node 0 is connected to node 1, node 1 is also connected to node 0. This will always be true.\nThe order in which each connection is listed for each node also does not matter.\n\nGood luck!\n-/", "vc-preamble": "def isTree (graph : List (List Nat)) : Bool := sorry \n\ndef isValidAdjacencyMatrix (matrix : List (List Nat)) : Bool := sorry", "vc-helpers": "", "vc-definitions": "def dfs (graph : List (List Nat)) (node : Nat) (visited : List Nat) : List Nat := sorry\n\ntheorem tree_edge_count \n  (graph : List (List Nat)) : \n  isValidAdjacencyMatrix graph → isTree graph → \n  (List.length (List.join graph)) / 2 = graph.length - 1 := sorry", "vc-theorems": "theorem tree_connected\n  (graph : List (List Nat)) :\n  isValidAdjacencyMatrix graph → isTree graph →\n  ∀ start, (dfs graph start []).length = graph.length := sorry\n\ntheorem valid_matrix_nonempty\n  (graph : List (List Nat)) :\n  isValidAdjacencyMatrix graph → graph.length > 0 := sorry\n\ntheorem valid_matrix_indices\n  (graph : List (List Nat)) :\n  isValidAdjacencyMatrix graph →\n  ∀ row ∈ graph, ∀ x ∈ row, x < graph.length := sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval isTree [[1], [0]]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval isTree [[1, 2], [0, 2], [0, 1]]\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval isTree [[1, 2], [0, 2], [0, 1], []]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4433", "language": "lean", "source": "fvapps", "source-id": "fvapps_004433", "source-notes": "", "vc-description": "/-\nThe aim of the kata is to decompose `n!` (factorial n) into its prime factors.\n\nExamples:\n```\nn = 12; decomp(12) -> \"2^10 * 3^5 * 5^2 * 7 * 11\"\nsince 12! is divisible by 2 ten times, by 3 five times, by 5 two times and by 7 and 11 only once.\n\nn = 22; decomp(22) -> \"2^19 * 3^9 * 5^4 * 7^3 * 11^2 * 13 * 17 * 19\"\n\nn = 25; decomp(25) -> 2^22 * 3^10 * 5^6 * 7^3 * 11^2 * 13 * 17 * 19 * 23\n```\n\nPrime numbers should be in increasing order. When the exponent of a prime is 1 don't put the exponent.\n\nNotes\n\n- the function is `decomp(n)` and should return the decomposition of `n!` into its prime factors in increasing order of the primes, as a string.\n- factorial can be a very big number (`4000! has 12674 digits`, n will go from 300 to 4000).\n- In Fortran - as in any other language - the returned string is not permitted to contain any redundant trailing whitespace: you can use `dynamically allocated character strings`.\n-/", "vc-preamble": "def dec (n : Nat) : List PrimeFactor := sorry\n\ndef decomp (n : Nat) : String := sorry\n\ndef splitString (s : String) (sep : String) : List String := sorry\ndef contains (s : String) (sub : String) : Bool := sorry\n\ndef toNat! (s : String) : Nat := sorry\ndef sorted (l : List Nat) : Bool := sorry", "vc-helpers": "", "vc-definitions": "def distinct (l : List Nat) : Bool := sorry\n\ntheorem dec_reconstruction {n : Nat} (h : n ≥ 2) :\n  let factors := dec n\n  let reconstructed := factors.foldl (fun acc f => acc * f.prime^f.power) 1\n  reconstructed = n := sorry", "vc-theorems": "theorem dec_primes {n : Nat} (h : n ≥ 2) :\n  let factors := dec n\n  ∀ f ∈ factors, \n    ∀ i : Nat, 2 ≤ i → i * i ≤ f.prime → f.prime % i ≠ 0 := sorry\n\ntheorem decomp_format {n : Nat} (h : n ≥ 2) :\n  let result := decomp n\n  let factors := splitString result \" * \"\n  ∀ f ∈ factors, \n    (contains f \"^\" → \n      let parts := splitString f \"^\"\n      (parts.length = 2) ∧ \n      let base := parts.head!\n      let power := parts.get! 1\n      toNat! base > 0 ∧ toNat! power > 0) ∧\n    (¬contains f \"^\" → toNat! f > 0) := sorry\n\ntheorem decomp_ascending {n : Nat} (h : n ≥ 2) :\n  let result := decomp n\n  let factors := splitString result \" * \"\n  let bases := factors.map (fun f => \n    if contains f \"^\" \n    then toNat! (splitString f \"^\").head!\n    else toNat! f)\n  sorted bases := sorry\n\ntheorem decomp_unique {n : Nat} (h : n ≥ 2) :\n  let result := decomp n\n  let factors := splitString result \" * \"\n  let bases := factors.map (fun f => \n    if contains f \"^\" \n    then toNat! (splitString f \"^\").head!\n    else toNat! f)\n  distinct bases := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4435", "language": "lean", "source": "fvapps", "source-id": "fvapps_004435", "source-notes": "", "vc-description": "/-\nA wildlife study involving ducks is taking place in North America. Researchers are visiting some wetlands in a certain area taking a survey of what they see. The researchers will submit reports that need to be processed by your function.\n\n## Input\n\nThe input for your function will be an array with a list of common duck names along with the counts made by the researchers. The names and counts are separated by spaces in one array element. The number of spaces between the name and the count could vary; but, there will always be at least one. A name may be repeated because a report may be a combination of surveys from different locations.\n\nAn example of an input array would be:\n```\n[\"Redhead 3\", \"Gadwall 1\", \"Smew 4\", \"Greater Scaup 10\", \"Redhead 3\", \"Gadwall 9\", \"Greater Scaup 15\", \"Common Eider 6\"]\n```\n\n## Processing\n\nYour function should change the names of the ducks to a six-letter code according to given rules (see below). The six-letter code should be in upper case. The counts should be summed for a species if it is repeated.\n\n## Output\n\nThe final data to be returned from your function should be an array sorted by the species codes and the total counts as integers. The codes and the counts should be individual elements.\n\nAn example of an array to be returned (based on the example input array above) would be:\n```\n[\"COMEID\", 6, \"GADWAL\", 10, \"GRESCA\", 25, \"REDHEA\", 6, \"SMEW\", 4]\n```\nThe codes are strings in upper case and the totaled counts are integers.\n\n### Special Note\n\nIf someone has `\"Labrador Duck\"` in their list, the whole list should be thrown out as this species has been determined to be extinct. The person who submitted the list is obviously unreliable. Their lists will not be included in the final data. In such cases, return an array with a single string element in it: `\"Disqualified data\"`\n\nRules for converting a common name to a six-letter code:\n\n* Hyphens should be considered as spaces.\n* If a name has only one word, use the first six letters of the name. If that name has less than six letters, use what is there.\n* If a name has two words, take the first three letters of each word.\n* If a name has three words, take the first two letters of each word.\n* If a name has four words, take the first letters from the first two words, and the first two letters from the last two words.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def createReport (names : List String) : List (String ⊕ Nat) :=\n  sorry", "vc-theorems": "theorem report_structure {names : List String} \n  (h : createReport names ≠ [Sum.inl \"Disqualified data\"]) :\n  let result := createReport names;\n  -- Result is a list\n  (List.length result % 2 = 0)  \n  -- Every even index is String, odd index is Nat > 0\n  ∧ (∀ i, i < List.length result → \n      i % 2 = 0 → (∃ s : String, result.get! i = Sum.inl s)\n      ∧ i % 2 = 1 → (∃ n : Nat, result.get! i = Sum.inr n ∧ n > 0)) :=\nsorry\n\ntheorem sorted_codes {names : List String} \n  (h : createReport names ≠ [Sum.inl \"Disqualified data\"]) :\n  let strings := List.filterMap (fun x => match x with \n    | Sum.inl s => some s\n    | _ => none) (createReport names);\n  List.Pairwise (fun x y => x ≤ y) strings :=\nsorry\n\ntheorem labrador_disqualification {names : List String} \n  (h : ∃ entry ∈ names, entry = \"Labrador Duck 1\") :\n  createReport names = [Sum.inl \"Disqualified data\"] :=\nsorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval create_report [\"Redhead 3\", \"Gadwall 1\", \"Smew 4\", \"Greater Scaup 10\", \"Redhead 3\", \"Gadwall 9\", \"Greater Scaup 15\", \"Common Eider 6\"]\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval create_report [\"Redhead 5\", \"Labrador Duck 9\", \"Blue-Winged Teal 25\"]\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval create_report [\"Canvasback 10\", \"Mallard 150\", \"American Wigeon 45\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4436", "language": "lean", "source": "fvapps", "source-id": "fvapps_004436", "source-notes": "", "vc-description": "/-\n`This kata is the first of the ADFGX Ciphers, the harder version can be found `here.\n\nThe ADFGX Cipher is a pretty well-known Cryptographic tool, and is essentially a modified Polybius Square.\n\nRather than having numbers as coordinates on the table, it has the letters:\n\n `A, D, F, G, X`\n\nAlso, because this is the first step, and to help simplify things, you won't have to worry about a key, or the corresponding columnar transposition. In this kata ;)\n\nAll you have to do is encrypt and decrypt a string into `ADFGX` format.\n\n`adfgx_encrypt() and adfgx_decrypt()` will be passed a string, `plaintext` and `ciphertext` respectively, and an adfgx`square`, for which will guide the operations. \n\nNow for some examples to clear confusion:\n\n```python\nadfgx_encrypt(\"helloworld\", \"bchigklnmoqprstuvwxyzadef\")\n\n    A D F G X\n\nA   b c h i g\nD   k l n m o     \nF   q p r s t  -> square (PLEASE NOTE, j SHOULD BE TREATED AS i)  \nG   u v w x y  \nX   z a d e f\n\n\"helloworld\"   -> plaintext\n\nEVALUATES TO:\n\n      F  \n          -> \"AF\"\nA     h\n--------------\n          G \n               -> \"XG\"  \nX         e \n\nAND SO FORTH...\n\n#Results in:\n\nadfgx_encrypt(\"helloworld\", \"bchigklnmoqprstuvwxyzadef\") \n==\n\"AFXGDDDDDXGFDXFFDDXF\"\n```\nNow decryption:\n```python\nadfgx_decrypt(\"FGXGADGDXGFXAXXGFGFGAADGXG\", \"aczlmuqngoipvstkrwfxhdbey) \n\n    A D F G X\n\nA   a c z l m\nD   u q n g o     \nF   i p v s t  -> square (PLEASE NOTE, j SHOULD BE TREATED AS i)  \nG   k r w f x  \nX   h d b e y\n\n\"FGXGADGDXGFXAXXGFGFGAADGXG\"   -> ciphertext\n\n\"FG\" == \"s\"\n\"XG\" == \"e\"\n\nAND SO ON:\n\nadfgx_decrypt(\"FGXGADGDXGFXAXXGFGFGAADGXG\", \"aczlmuqngoipvstkrwfxhdbey) \n==\n\"secretmessage\"\n```\nPLEASE NOTE: ALL INPUT WILL BE VALID, NO NEED TO ERROR CHECK :D\n\nWhat are you waiting for?!\nGo create `adfgx_encrypt() and adfgx_decrypt()`!\n\nGood Luck!\n-/", "vc-preamble": "def adfgx_encrypt (plaintext : String) (square : String) : String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def adfgx_decrypt (ciphertext : String) (square : String) : String :=\n  sorry", "vc-theorems": "theorem encrypt_decrypt_roundtrip \n  {plaintext square : String} \n  (h1 : plaintext.data.all (fun c => 'a' ≤ c ∧ c ≤ 'z')) \n  (h2 : square.length = 25)\n  (h3 : '0' ∉ square.data) :\n  adfgx_decrypt (adfgx_encrypt plaintext square) square = plaintext := by\n  sorry\n\ntheorem encrypt_format \n  {plaintext square : String}\n  (h1 : plaintext.data.all (fun c => 'a' ≤ c ∧ c ≤ 'z'))\n  (h2 : square.length = 25) :\n  (adfgx_encrypt plaintext square).data.all (fun c => c ∈ ['A', 'D', 'F', 'G', 'X']) ∧ \n  (adfgx_encrypt plaintext square).length % 2 = 0 := by\n  sorry\n\ntheorem substitution_consistency\n  (h : square = \"bchigklnmoqprstuvwxyzadef\") \n  (h2 : plaintext = \"test\") :\n  let encrypted := adfgx_encrypt plaintext square\n  let firstT := encrypted.take 2\n  let secondT := encrypted.extract (String.Pos.mk 6) (String.Pos.mk 8)\n  firstT = secondT := by\n  sorry\n\ntheorem i_j_equivalence\n  (h : square = \"bchigklnmoqprstuvwxyzadef\") :\n  adfgx_encrypt \"i\" square = adfgx_encrypt \"j\" square := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4453", "language": "lean", "source": "fvapps", "source-id": "fvapps_004453", "source-notes": "", "vc-description": "/-\nIn this kata, your task is to write a function `to_bytes(n)` (or `toBytes(n)` depending on language) that produces a list of bytes that represent a given non-negative integer `n`. Each byte in the list is represented by a string of `'0'` and `'1'` of length 8. The most significant byte is first in the list. The example test cases should provide you with all the details. You may assume that the argument `n` is valid.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def to_bytes (n : Nat) : List String := sorry\n\ntheorem to_bytes_length_correct : ∀ (n : Nat),\n  ∀ byte ∈ to_bytes n, String.length byte = 8\n  := sorry", "vc-theorems": "theorem to_bytes_valid_bits : ∀ (n : Nat),\n  ∀ byte ∈ to_bytes n,\n  ∀ c ∈ byte.data,\n  c = '0' ∨ c = '1'\n  := sorry\n\ntheorem to_bytes_roundtrip : ∀ (n : Nat),\n  let bytes := to_bytes n\n  let recovered := bytes.enum.foldl\n    (fun acc (i, byte) => acc + (String.toNat! byte) * (256 ^ (bytes.length - 1 - i)))\n    0\n  recovered = n\n  := sorry\n\ntheorem to_bytes_single_byte : ∀ (n : Nat),\n  n ≤ 255 →\n  (to_bytes n).length = 1\n  := sorry\n\ntheorem to_bytes_zero :\n  to_bytes 0 = [\"00000000\"]\n  := sorry\n\n/-\ninfo: ['00000000']\n-/\n-- #guard_msgs in\n-- #eval to_bytes 0\n\n/-\ninfo: ['00000001']\n-/\n-- #guard_msgs in\n-- #eval to_bytes 1\n\n/-\ninfo: ['00000001', '00000001']\n-/\n-- #guard_msgs in\n-- #eval to_bytes 257", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4456", "language": "lean", "source": "fvapps", "source-id": "fvapps_004456", "source-notes": "", "vc-description": "/-\nIn some countries of former Soviet Union there was a belief about lucky tickets. A transport ticket of any sort was believed to posess luck if sum of digits on the left half of its number was equal to the sum of digits on the right half. Here are examples of such numbers:\n```\n003111    #             3 = 1 + 1 + 1\n813372    #     8 + 1 + 3 = 3 + 7 + 2\n17935     #         1 + 7 = 3 + 5  // if the length is odd, you should ignore the middle number when adding the halves.\n56328116  # 5 + 6 + 3 + 2 = 8 + 1 + 1 + 6\n```\nSuch tickets were either eaten after being used or collected for bragging rights.\n\nYour task is to write a funtion ```luck_check(str)```, which returns ```true/True``` if argument is string decimal representation of a lucky ticket number, or ```false/False``` for all other numbers. It should throw errors for empty strings or strings which don't represent a decimal number.\n-/", "vc-preamble": "def List.sum (xs : List Nat) : Nat :=\n  xs.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def luck_check (s : String) : Option Bool := sorry\n\ntheorem lucky_number_symmetry {n : Nat} : \n  n > 0 → let s := toString n;\n  match luck_check s with\n  | some true => \n      let leftHalf := s.take (s.length / 2);\n      let rightHalf := s.drop ((s.length + 1) / 2);\n      (leftHalf.toList.map Char.toNat).sum = (rightHalf.toList.map Char.toNat).sum\n  | _ => True := sorry", "vc-theorems": "theorem lucky_number_numeric {s : String} :\n  (∀ c ∈ s.data, c.isDigit) →\n  s.length > 0 →\n  (luck_check s).isSome := sorry\n\ntheorem non_numeric_input_none {s : String} :\n  (∃ c ∈ s.data, !c.isDigit) →\n  luck_check s = none := sorry\n\ntheorem empty_string_none :\n  luck_check \"\" = none := sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval luck_check \"003111\"\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval luck_check \"17935\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval luck_check \"543970707\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4459", "language": "lean", "source": "fvapps", "source-id": "fvapps_004459", "source-notes": "", "vc-description": "/-\n`late_clock` function receive an array with 4 digits and should return the latest time that can be built with those digits.\nThe time should be in `HH:MM` format.\n\nExamples:\n```\n[1, 9, 8, 3] => 19:38\n[9, 1, 2, 5] => 21:59\n```\n\nYou can suppose the input is correct and you can build from it a correct 24-hour time.\n-/", "vc-preamble": "def isValidTime (t : Time) : Prop := \n  t.hours ≤ 23 ∧ t.minutes ≤ 59\n\ndef lateClock (digits : List Nat) : String :=\nsorry\n\ndef toNat (c : Char) : Nat :=\nsorry", "vc-helpers": "", "vc-definitions": "def getDigit (s : String) (i : Nat) : Char :=\ns.data.get! i", "vc-theorems": "theorem late_clock_output_format \n  {digits : List Nat}\n  (h : digits.length = 4)\n  (h' : ∀ d ∈ digits, d ≤ 9)\n  (h'' : ∃ t : Time, isValidTime t) :\n  let result := lateClock digits\n  (result.length = 5) ∧ \n  (getDigit result 2 = ':') ∧\n  (getDigit result 0).isDigit ∧\n  (getDigit result 1).isDigit ∧\n  (getDigit result 3).isDigit ∧\n  (getDigit result 4).isDigit :=\nsorry\n\ntheorem late_clock_valid_time\n  {digits : List Nat}\n  (h : digits.length = 4)\n  (h' : ∀ d ∈ digits, d ≤ 9)\n  (h'' : ∃ t : Time, isValidTime t) :\n  let result := lateClock digits\n  let t : Time := {\n    hours := toNat (getDigit result 0) * 10 + toNat (getDigit result 1)\n    minutes := toNat (getDigit result 3) * 10 + toNat (getDigit result 4)\n  }\n  isValidTime t :=\nsorry\n\ntheorem late_clock_uses_all_digits\n  {digits : List Nat}\n  (h : digits.length = 4)\n  (h' : ∀ d ∈ digits, d ≤ 9)\n  (h'' : ∃ t : Time, isValidTime t) :\n  let result := lateClock digits\n  let result_digits := [\n    toNat (getDigit result 0),\n    toNat (getDigit result 1),\n    toNat (getDigit result 3),\n    toNat (getDigit result 4)\n  ]\n  ∃ σ : Fin 4 → Fin 4, \n    (∀ a b : Fin 4, σ a = σ b → a = b) ∧ \n    (∀ b : Fin 4, ∃ a : Fin 4, σ a = b) ∧\n    (∀ i : Fin 4, digits.get! i.val = result_digits.get! (σ i).val) :=\nsorry\n\n/-\ninfo: '21:59'\n-/\n-- #guard_msgs in\n-- #eval late_clock [9, 1, 2, 5]\n\n/-\ninfo: '19:38'\n-/\n-- #guard_msgs in\n-- #eval late_clock [1, 9, 8, 3]\n\n/-\ninfo: '22:20'\n-/\n-- #guard_msgs in\n-- #eval late_clock [0, 2, 2, 2]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4478", "language": "lean", "source": "fvapps", "source-id": "fvapps_004478", "source-notes": "", "vc-description": "/-\nYour job is to figure out the index of which vowel is missing from a given string:\n\n* `A` has an index of 0,\n* `E` has an index of 1, \n* `I` has an index of 2, \n* `O` has an index of 3,\n* `U` has an index of 4.\n\n**Notes:** There is no need for string validation and every sentence given will contain all vowles but one. Also, you won't need to worry about capitals.\n\n## Examples\n\n```\n\"John Doe hs seven red pples under his bsket\"          =>  0  ; missing: \"a\"\n\"Bb Smith sent us six neatly arranged range bicycles\"  =>  3  ; missing: \"o\"\n```\n-/", "vc-preamble": "def absent_vowel (s : String) : VowelIndex := \n  sorry", "vc-helpers": "", "vc-definitions": "def getVowel (i : Nat) : Char :=\n  match i with\n  | 0 => 'a'\n  | 1 => 'e'\n  | 2 => 'i'\n  | 3 => 'o'\n  | _ => 'u'", "vc-theorems": "theorem output_is_valid_index {s : String} (h : s.length > 0) :\n  (absent_vowel s).val ≤ 4 :=\n  sorry\n\ntheorem identified_vowel_actually_missing {s : String} (h : s.length > 0) :\n  let result := (absent_vowel s).val\n  ¬ s.contains (getVowel result) :=\n  sorry\n\ntheorem only_one_vowel_missing {s : String} (h : s.length > 0) :\n  let vowels := \"aeiou\"\n  let text_vowels_count := (List.filter (fun c => vowels.contains c) s.data).length\n  text_vowels_count = 4 →\n  ¬ s.contains (getVowel (absent_vowel s).val) :=\n  sorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval absent_vowel \"John Doe hs seven red pples under his bsket\"\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval absent_vowel \"Bb Smith sent us six neatly arranged range bicycles\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4484", "language": "lean", "source": "fvapps", "source-id": "fvapps_004484", "source-notes": "", "vc-description": "/-\n## The Riddle\n\nThe King of a small country invites 1000 senators to his annual party. As a tradition, each senator brings the King a bottle of wine. Soon after, the Queen discovers that one of the senators is trying to assassinate the King by giving him a bottle of poisoned wine. Unfortunately, they do not know which senator, nor which bottle of wine is poisoned, and the poison is completely indiscernible.\n\nHowever, the King has 10 lab rats. He decides to use them as taste testers to determine which bottle of wine contains the poison. The poison when taken has no effect on the rats, until exactly 24 hours later when the infected rats suddenly die. The King needs to determine which bottle of wine is poisoned by tomorrow, so that the festivities can continue as planned.\n\nHence he only has time for one round of testing, he decides that each rat tastes multiple bottles, according to a certain scheme.\n\n## Your Task\n\nYou receive an array of integers (`0 to 9`), each of them is the number of a rat which died after tasting the wine bottles. Return the number of the bottle (`1..1000`) which is poisoned.\n\n**Good Luck!**\n\n*Hint: think of rats as a certain representation of the number of the bottle...*\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + xs.sum", "vc-helpers": "", "vc-definitions": "def find (rats : List Nat) : Nat := sorry\n\ntheorem find_total_is_sum_of_powers (rats : List Nat) \n  (h : ∀ x, x ∈ rats → x ≤ 9) \n  (h2 : ∀ x y, x ∈ rats → y ∈ rats → x = y → x = y)\n  (h3 : rats.length > 0)\n  (h4 : (rats.map (fun r => 2^r)).sum ≤ 1000) :\n  find rats = (rats.map (fun r => 2^r)).sum := sorry", "vc-theorems": "theorem find_binary_representation (rats : List Nat)\n  (h : ∀ x, x ∈ rats → x ≤ 9)\n  (h2 : ∀ x y, x ∈ rats → y ∈ rats → x = y → x = y)\n  (h3 : rats.length > 0) :\n  ∀ i, i ≤ 9 → \n    (if i ∈ rats \n     then (find rats).mod (2^(i+1)) ≥ 2^i\n     else (find rats).mod (2^(i+1)) < 2^i) := sorry\n\ntheorem find_commutative (rats : List Nat)\n  (h : ∀ x, x ∈ rats → x ≤ 9)\n  (h2 : ∀ x y, x ∈ rats → y ∈ rats → x = y → x = y)\n  (h3 : rats.length > 0) :\n  find rats = find rats.reverse := sorry\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval find [0]\n\n/-\ninfo: 2\n-/\n-- #guard_msgs in\n-- #eval find [1]\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval find [2]\n\n/-\ninfo: 1000\n-/\n-- #guard_msgs in\n-- #eval find [3, 5, 6, 7, 8, 9]\n\n/-\ninfo: 27\n-/\n-- #guard_msgs in\n-- #eval find [0, 1, 3, 4]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4485", "language": "lean", "source": "fvapps", "source-id": "fvapps_004485", "source-notes": "", "vc-description": "/-\nWe have the numbers with different colours with the sequence: ['red', 'yellow', 'blue'].\n\nThat sequence colours the numbers in the following way:\n\n 1   2   3    4    5   6  7   8   9   10   11  12   13 .....\n\nWe have got the following recursive function:\n\n  ```\nf(1) = 1\nf(n) = f(n - 1) + n\n```\n\nSome terms of this sequence with their corresponding colour are:\n\n```\nterm   value   colour\n1        1     \"red\"\n2        3     \"blue\"\n3        6     \"blue\"\n4       10     \"red\"\n5       15     \"blue\"\n6       21     \"blue\"\n7       28     \"red\"\n```\n\nThe three terms of the same colour \"blue\", higher than 3, are: `[6, 15, 21]`\n\nWe need a function `same_col_seq(), that may receive three arguments:\n\n- `val`, an integer number\n- `k`, an integer number\n- `colour`, the name of one of the three colours(red, yellow or blue), as a string.\n\nThe function will output a sorted array with the smallest `k` terms, having the same marked colour, but higher than `val`.\n\nLet's see some examples:\n\n```python\nsame_col_seq(3, 3, 'blue') == [6, 15, 21]\nsame_col_seq(100, 4, 'red') == [136, 190, 253, 325]\n```\n\nThe function may output an empty list if it does not find terms of the sequence with the wanted colour in the range [val, 2* k * val]\n\n```python\nsame_col_seq(250, 6, 'yellow') == []\n```\n\nThat means that the function did not find any \"yellow\" term in the range `[250, 3000]`\n\nTests will be with the following features:\n\n* Nmber of tests: `100`\n* `100 < val < 1000000`\n* `3 < k < 20`\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def same_col_seq (val k : Nat) (c : Color) : List Nat := sorry\n\ntheorem same_col_seq_valid_length (val k : Nat) (c : Color) :\n  let result := same_col_seq val k c\n  List.length result ≤ k := sorry", "vc-theorems": "theorem same_col_seq_greater_than_val (val k : Nat) (c : Color) :\n  let result := same_col_seq val k c\n  ∀ x ∈ result, x > val := sorry\n\ntheorem same_col_seq_ascending (val k : Nat) (c : Color) :\n  let result := same_col_seq val k c\n  ∀ i j, i < j → j < result.length → result[i]! < result[j]! := sorry\n\ntheorem same_col_seq_color_match (val k : Nat) (c : Color) :\n  let result := same_col_seq val k c\n  ∀ x ∈ result, x % 3 = c.idx := sorry\n\ntheorem same_col_seq_zero_k (val : Nat) (c : Color) :\n  same_col_seq val 0 c = [] := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4487", "language": "lean", "source": "fvapps", "source-id": "fvapps_004487", "source-notes": "", "vc-description": "/-\nGiven a standard english sentence passed in as a string, write a method that will return a sentence made up of the same words, but sorted by their first letter. However, the method of sorting has a twist to it:\n* All words that begin with a lower case letter should be at the beginning of the sorted sentence, and sorted in ascending order.\n* All words that begin with an upper case letter should come after that, and should be sorted in descending order.\n\nIf a word appears multiple times in the sentence, it should be returned multiple times in the sorted sentence. Any punctuation must be discarded.\n\n## Example\n\nFor example, given the input string `\"Land of the Old Thirteen! Massachusetts land! land of Vermont and Connecticut!\"`, your method should return `\"and land land of of the Vermont Thirteen Old Massachusetts Land Connecticut\"`. Lower case letters are sorted `a -> l -> l -> o -> o -> t` and upper case letters are sorted `V -> T -> O -> M -> L -> C`.\n-/", "vc-preamble": "def isLower (c : Char) : Bool := sorry\ndef isUpper (c : Char) : Bool := sorry", "vc-helpers": "", "vc-definitions": "def pseudo_sort (s : String) : String := sorry\n\ntheorem pseudo_sort_preserves_words {word_list : List String} (h : word_list ≠ []) :\n  let sentence := String.intercalate \" \" word_list\n  let result := pseudo_sort sentence\n  let orig_words := word_list.filter (λ w => w.trim ≠ \"\")\n  let result_words := (result.split (· = ' ')).filter (λ w => w.trim ≠ \"\")\n  ∀ w, w ∈ orig_words ↔ w ∈ result_words := sorry", "vc-theorems": "theorem pseudo_sort_ordering {word_list : List String} (h : word_list ≠ []) :\n  let sentence := String.intercalate \" \" word_list\n  let result := (pseudo_sort sentence).split (· = ' ')\n  let lowercase := result.filter (λ w => !w.isEmpty ∧ isLower (w.front))\n  let uppercase := result.filter (λ w => !w.isEmpty ∧ isUpper (w.front))\n  (∀ x y, x ∈ lowercase → y ∈ lowercase → x.data < y.data → result.indexOf x < result.indexOf y) ∧ \n  (∀ x y, x ∈ uppercase → y ∈ uppercase → x.data < y.data → result.indexOf x > result.indexOf y) ∧\n  (∀ l u, l ∈ lowercase → u ∈ uppercase → result.indexOf l < result.indexOf u) := sorry\n\ntheorem pseudo_sort_handles_punctuation (text : String) :\n  let result := pseudo_sort text\n  ∀ c, c ∈ \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\".data → \n    ¬(c ∈ result.data) := sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval pseudo_sort \"Land of the Old Thirteen! Massachusetts land! land of Vermont and Connecticut!\"\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval pseudo_sort \"I, habitan of the Alleghanies, treating of him as he is in himself in his own rights\"\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval pseudo_sort \"And I send these words to Paris with my love\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4495", "language": "lean", "source": "fvapps", "source-id": "fvapps_004495", "source-notes": "", "vc-description": "/-\nWrite a function that flattens an `Array` of `Array` objects into a flat `Array`.  Your function must only do one level of flattening.\n\n```python\nflatten [1,2,3] # => [1,2,3]\nflatten [[1,2,3],[\"a\",\"b\",\"c\"],[1,2,3]]  # => [1,2,3,\"a\",\"b\",\"c\",1,2,3]\nflatten [[[1,2,3]]] # => [[1,2,3]]\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def flatten {α : Type} (lst : List (NestedList α)) : List α := sorry\n\ntheorem flatten_preserves_elements {α : Type} (lst : List (NestedList α)) :\n  ∀ x ∈ lst, match x with\n  | NestedList.elem v => v ∈ flatten lst\n  | NestedList.list xs => ∀ y ∈ xs, match y with \n    | NestedList.elem v => v ∈ flatten lst\n    | _ => True := sorry", "vc-theorems": "theorem flatten_removes_one_level {α : Type} (lst : List (NestedList α)) :\n  ∀ x ∈ lst, match x with\n  | NestedList.list xs => ∀ y ∈ xs, y ≠ NestedList.list []\n  | _ => True →\n  ∀ z ∈ flatten lst, ∀ w, z ≠ w := sorry\n\ntheorem flatten_order_preserved {α : Type} (lst : List (NestedList α)) :\n  flatten lst = lst.foldl (λ acc x => \n    match x with\n    | NestedList.elem v => acc ++ [v]\n    | NestedList.list xs => acc ++ flatten xs\n  ) [] := sorry\n\ntheorem flatten_identity_flat_list {α : Type} (lst : List α) :\n  flatten (lst.map NestedList.elem) = lst := sorry\n\n/-\ninfo: [1, 2, 3, 4, 5, 6]\n-/\n-- #guard_msgs in\n-- #eval flatten [[1, 2, 3], [4, 5, 6]]\n\n/-\ninfo: [1, 2, 'a', 3, 4]\n-/\n-- #guard_msgs in\n-- #eval flatten [[1, 2], \"a\", [3, 4]]\n\n/-\ninfo: [[1, 2], 3, 4, 5]\n-/\n-- #guard_msgs in\n-- #eval flatten [[[1, 2]], [3, 4], 5]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4499", "language": "lean", "source": "fvapps", "source-id": "fvapps_004499", "source-notes": "", "vc-description": "/-\nHi! Welcome to my first kata.\n\nIn this kata the task is to take a list of integers (positive and negative) and split them according to a simple rule; those ints greater than or equal to the key, and those ints less than the key (the itself key will always be positive).\n\nHowever, in this kata the goal is to sort the numbers IN PLACE, so DON'T go messing around with the order in with the numbers appear.\n\nYou are to return a nested list. If the list is empty, simply return an empty list.\n\nConfused? Okay, let me walk you through an example...\n\n    The input is: [1, 1, 1, 0, 0, 6, 10, 5, 10], the key is: 6\nOkay so the first five numbers are less than the key, 6, so we group them together.\n\n    [1, 1, 1, 0, 0]\nThe next two numbers, 6 & 10, are both >= 6 to they belong in a seperate group, which we will add to the first group. Like so:\n\n    [[1, 1, 1, 0, 0], [6, 10]]\nThe next two numbers are 5 & 10. Since the key is 6 these two numbers form seperate groups, which we will add to the previous result. like so:\n\n    [[1, 1, 1, 0, 0], [6, 10], [5], [10]]\nAnd voila! We're done.\n\nHere are a few more basic examples:\n\n    group_ints([1, 0], key= 0)  \n    --> [[1,0]]\n\n    group_ints([1, 0, -1, 5], key= 0) \n    --> [[1, 0], [-1], [5]]\n\n    group_ints([1, 0, -1, 5], key= 5) \n    --> [[1, 0, -1], [5]]\n\nGood luck guys/gals!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def groupInts (lst : List Int) (key : Int) : List (List Int) := sorry\n\ntheorem empty_list_any_key (k : Int) : \n  groupInts [] k = [] := sorry", "vc-theorems": "theorem group_ints_result_structure {lst : List Int} {k : Int} :\n  let result := groupInts lst k\n  -- Result is a list of non-empty lists\n  ∀ sublist ∈ result, sublist ≠ [] := sorry\n\ntheorem group_ints_preserves_elements {lst : List Int} {k : Int} :\n  let result := groupInts lst k\n  List.join result = lst := sorry\n\ntheorem group_ints_homogeneous_groups {lst : List Int} {k : Int} :\n  let result := groupInts lst k\n  ∀ group ∈ result, \n    let first_less := group.head! < k\n    ∀ x ∈ group, (x < k) = first_less := sorry\n\ntheorem group_ints_adjacent_groups_differ {lst : List Int} {k : Int} :\n  let result := groupInts lst k\n  ∀ i < result.length - 1,\n    let group1_head := (result.get! i).head!\n    let group2_head := (result.get! (i+1)).head!\n    (group1_head < k) ≠ (group2_head < k) := sorry\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval group_ints [] 0\n\n/-\ninfo: [[1]]\n-/\n-- #guard_msgs in\n-- #eval group_ints [1] 1", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4503", "language": "lean", "source": "fvapps", "source-id": "fvapps_004503", "source-notes": "", "vc-description": "/-\nLet's just place tokens on a connect four board.\n\n** INPUT **\n\nProvided as input the list of columns where a token is placed, from 0 to 6 included.\nThe first player starting is the yellow one (marked with `Y`), then the red (marked with `R`); the other cells might be empty and marked with `-`.\n\n** OUTPUT **\n\nThe output is the state of the board after all the tokens in input have been placed.\n\n** ASSUMPTIONS **\n\n- The board is the standard 7x6;\n- Of course you'll need to deal with gravity;\n- You don't need to hassle with wrong input, wrong column numbers, checking for full column or going off the board;\n- the columns list will always include proper column numbers;\n- Notice: when you read the results in tests, the highest row appears first and the lowest row appears last; debugging using `\\n` after each row might help (check example);\n\n** EXAMPLES **\n\n1.\n```\nMoves = [0,1,2,5,6]\n\nResult:\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['Y', 'R', 'Y', '-', '-', 'R', 'Y']\n```\n2.\n```\nMoves = [0,1,2,5,6,2,0,0]\n\nResult:\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['-', '-', '-', '-', '-', '-', '-']\n['R', '-', '-', '-', '-', '-', '-']\n['Y', '-', 'R', '-', '-', '-', '-']\n['Y', 'R', 'Y', '-', '-', 'R', 'Y']\n```\n\nSee test cases for better details.\n-/", "vc-preamble": "def Board := List (List Cell)\n\ndef connect_four_place (moves: List Nat) : Board :=\n  sorry", "vc-helpers": "", "vc-definitions": "def countCells (b: Board) (p: Cell → Bool) : Nat :=\n  b.join.foldl (fun acc c => if p c then acc + 1 else acc) 0", "vc-theorems": "theorem board_dimensions {moves : List Nat} \n  (h : ∀ m ∈ moves, m ≤ 6) : \n  let board := connect_four_place moves\n  board.length = 6 ∧ List.all board (fun row => row.length = 7) :=\nsorry\n\ntheorem alternating_players {moves : List Nat}\n  (h : ∀ m ∈ moves, m ≤ 6) :\n  let board := connect_four_place moves\n  let yellow_count := countCells board (fun c => c == Cell.Yellow)\n  let red_count := countCells board (fun c => c == Cell.Red)\n  yellow_count ≤ red_count + 1 ∧ red_count ≤ yellow_count + 1 :=\nsorry\n\ntheorem gravity_effect {moves : List Nat}\n  (h : ∀ m ∈ moves, m ≤ 6) :\n  let board := connect_four_place moves\n  ∀ col, col < 7 → \n  ∀ row₁ row₂, row₁ < row₂ → row₂ < 6 →\n    Option.isSome ((board.get? row₂).bind (·.get? col)) →\n    (board.get? row₂).bind (·.get? col) = some Cell.Empty → \n    (board.get? row₁).bind (·.get? col) = some Cell.Empty :=\nsorry\n\ntheorem valid_pieces {moves : List Nat}\n  (h : ∀ m ∈ moves, m ≤ 6) :\n  let board := connect_four_place moves\n  board.join.all (fun cell => \n    cell == Cell.Empty || cell == Cell.Yellow || cell == Cell.Red) :=\nsorry\n\ntheorem empty_board :\n  connect_four_place [] = \n    List.replicate 6 (List.replicate 7 Cell.Empty) :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4505", "language": "lean", "source": "fvapps", "source-id": "fvapps_004505", "source-notes": "", "vc-description": "/-\nA [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree) is a binary tree that is ordered. This means that if you were to convert the tree to an array using an in-order traversal, the array would be in sorted order. The benefit gained by this ordering is that when the tree is balanced, searching is a logarithmic time operation, since each node you look at that isn't the one you're searching for lets you discard half of the tree.\n\nIf you haven't worked with binary trees before or don't understand what a traversal is, you can learn more about that here: https://www.codewars.com/kata/binary-tree-traversal.\n\nIn this kata, you will write a function that will validate that a given binary tree is a binary search tree. The sort order is not predefined so it should work with either.\n\nThese are valid binary search trees:\n\n        5\n       / \\\n      2   7\n     / \\   \\\n    1   3   9\n\n      7\n     / \\\n    9   2\n\nwhile these are not:\n\n      1\n     / \\\n    2   3\n\n      5\n     / \\\n    2   9\n     \\\n      7\n\nThere are several different approaches you can take to solve this kata. If you're not as comfortable with recursion I'd recommend practicing that.\n\nNote: no test case tree will contain duplicate numbers.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def make_bst {α : Type} [Ord α] (values : List α) : Tree α := sorry\n\ndef is_bst {α : Type} [Ord α] (t : Tree α) : Bool := sorry", "vc-theorems": "theorem sorted_values_make_valid_bst {α : Type} [Ord α] (values : List α) :\n  is_bst (make_bst values) = true := sorry\n\ntheorem empty_tree_is_bst {α : Type} [Ord α] :\n  is_bst (Tree.leaf : Tree α) = true := sorry \n\ntheorem single_node_is_bst {α : Type} [Ord α] (x : α) :\n  is_bst (Tree.node x Tree.leaf Tree.leaf) = true := sorry\n\ntheorem valid_bst_example :\n  let t := Tree.node 2 (Tree.node 1 Tree.leaf Tree.leaf) (Tree.node 3 Tree.leaf Tree.leaf)\n  is_bst t = true := sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval is_bst T(5, T(2, T(1), T(3)), T(7, None, T(9)))\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval is_bst T(1, T(2), T(3))\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval is_bst T(7, T(9), T(2))", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4506", "language": "lean", "source": "fvapps", "source-id": "fvapps_004506", "source-notes": "", "vc-description": "/-\nThis kata is about singly \nlinked list.  A linked list is an ordered set of data elements, each containing a link to its successor (and sometimes its predecessor, known as a double linked list).  You are you to implement an algorithm to find the kth to last element.\n\nFor example given a linked list of:\na -> b -> c -> d\n\nif k is the number one then d should be returned\nif k is the number two then c should be returned\nif k is the number three then b should be returned\nif k is the number four then a should be returned\nif k exceeds the size of the list then None returned\n\nSpecial Note --> Node classes contain two fields; data and next.\nAnd to access the head of the list, use head. e.g. linked_list.head\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def search_k_from_end {α : Type} (l : LinkedList α) (k : Nat) : Option α :=\n  sorry", "vc-theorems": "theorem search_k_from_end_empty (α : Type) (k : Nat) :\n  k > 0 → search_k_from_end (@LinkedList.mk α []) k = none := \n  sorry\n\ntheorem search_k_from_end_too_large (α : Type) (l : LinkedList α) (k len : Nat) (vals : List α) :\n  k > len → l.vals = vals → len = vals.length → search_k_from_end l k = none :=\n  sorry\n\ntheorem search_k_from_end_valid (α : Type) (l : LinkedList α) (k len : Nat) (vals : List α) :\n  k ≤ len → k > 0 → l.vals = vals → len = vals.length → \n  ∃ (x : α), x ∈ vals ∧ search_k_from_end l k = some x :=\n  sorry\n\ntheorem search_k_from_end_single_element (α : Type) (x : α) :\n  search_k_from_end (@LinkedList.mk α [x]) 1 = some x :=\n  sorry\n\ntheorem search_k_from_end_single_element_too_large (α : Type) (x : α) :\n  search_k_from_end (@LinkedList.mk α [x]) 2 = none :=\n  sorry\n\n/-\ninfo: 'd'\n-/\n-- #guard_msgs in\n-- #eval search_k_from_end LinkedList() 1\n\n/-\ninfo: 'c'\n-/\n-- #guard_msgs in\n-- #eval search_k_from_end ll 2\n\n/-\ninfo: 'b'\n-/\n-- #guard_msgs in\n-- #eval search_k_from_end ll 3\n\n/-\ninfo: 'a'\n-/\n-- #guard_msgs in\n-- #eval search_k_from_end ll 4\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval search_k_from_end ll 5\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval search_k_from_end LinkedList() 1\n\n/-\ninfo: 'x'\n-/\n-- #guard_msgs in\n-- #eval search_k_from_end LinkedList() 1\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval search_k_from_end ll3 2", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4509", "language": "lean", "source": "fvapps", "source-id": "fvapps_004509", "source-notes": "", "vc-description": "/-\nGiven a matrix represented as a list of string, such as\n```\n###.....\n..###...\n....###.\n.....###\n.....###\n....###.\n..###...\n###.....\n```\nwrite a function\n```if:javascript\n`rotateClockwise(matrix)`\n```\n```if:ruby,python\n`rotate_clockwise(matrix)`\n```\nthat return its 90° clockwise rotation, for our example:\n\n```\n#......#\n#......#\n##....##\n.#....#.\n.##..##.\n..####..\n..####..\n...##...\n```\n>  /!\\  You must return a **rotated copy** of `matrix`! (`matrix` must be the same before and after calling your function)  \n> Note that the matrix isn't necessarily a square, though it's always a rectangle!  \n> Please also note that the equality `m == rotateClockwise(rotateClockwise(rotateClockwise(rotateClockwise(m))));` (360° clockwise rotation), is not always true because `rotateClockwise([''])` => `[]` and `rotateClockwise(['','',''])` => `[]` (empty lines information is lost)\n-/", "vc-preamble": "def rotate_clockwise (m : Matrix) : Matrix :=\n  sorry", "vc-helpers": "", "vc-definitions": "def manual_rotate (m : Matrix) : Matrix :=\n  sorry", "vc-theorems": "theorem empty_matrix_rotation :\n  ∀ (m : Matrix), m.content = [] → (rotate_clockwise m).content = [] :=\n  sorry\n\ntheorem rotation_dimensions {m : Matrix} (h1 : m.content ≠ []) \n    (h2 : ∃ s, m.content.head? = some s) (h3 : ∀ s, m.content.head? = some s → s ≠ \"\") :\n    let rotated := rotate_clockwise m\n    let first := Classical.choose h2\n    (rotated.content.length = first.length) ∧\n    (∀ (row : String), row ∈ rotated.content → row.length = m.content.length) :=\n  sorry\n\ntheorem four_rotations_identity {m : Matrix} (h1 : m.content ≠ [])\n    (h2 : ∃ s, m.content.head? = some s) (h3 : ∀ s, m.content.head? = some s → s ≠ \"\") :\n    rotate_clockwise (rotate_clockwise (rotate_clockwise (rotate_clockwise m))) = m :=\n  sorry\n\ntheorem rotation_equals_manual :\n  ∀ (m : Matrix), rotate_clockwise m = manual_rotate m :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4510", "language": "lean", "source": "fvapps", "source-id": "fvapps_004510", "source-notes": "", "vc-description": "/-\n```if:csharp\n## Terminal Game - Create Hero Class\n\nIn this first kata in the series, you need to define a Hero class to be used in a terminal game. The hero should have the following attributes:\n\nattribute | type | value\n---|---|---\nName | string | user argument or \"Hero\"\nPosition | string | \"00\"\nHealth | float | 100\nDamage | float | 5\nExperience | int | 0\n```\n\n```if-not:csharp\n## Terminal Game - Create Hero Prototype\n\nIn this first kata in the series, you need to define a Hero prototype to be used in a terminal game. The hero should have the following attributes:\n\nattribute | value\n---|---\nname | user argument or 'Hero'\nposition | '00'\nhealth | 100\ndamage | 5\nexperience | 0\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Hero.new : Hero := sorry\ndef Hero.newWithName (name : String) : Hero := sorry", "vc-theorems": "theorem hero_named_properties (name : String) : \n  let hero := Hero.newWithName name\n  hero.name = name ∧ \n  hero.position = \"00\" ∧ \n  hero.health = 100 ∧ \n  hero.damage = 5 ∧ \n  hero.experience = 0 := sorry\n\ntheorem hero_default_properties : \n  let hero := Hero.new\n  hero.name = \"Hero\" ∧ \n  hero.position = \"00\" ∧ \n  hero.health = 100 ∧ \n  hero.damage = 5 ∧ \n  hero.experience = 0 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4512", "language": "lean", "source": "fvapps", "source-id": "fvapps_004512", "source-notes": "", "vc-description": "/-\nA company is opening a bank, but the coder who is designing the user class made some errors. They need  you  to help them. \n\nYou must include the following:\n\n- A withdraw method\n  - Subtracts money from balance\n  - One parameter, money to withdraw\n  - Raise ValueError if there isn't enough money to withdraw\n  - Return a string with name and balence(see examples)\n\n* A check method\n  - Adds money to baleance\n  - Two parameters, other user and money\n  - Other user will always be valid\n  - Raise a ValueError if other user doesn't have enough money\n  - Raise a ValueError if checking_account isn't true for other user\n  - Return a string with name and balance plus other name and other balance(see examples)\n\n- An add_cash method\n  - Adds money to balance\n  - One parameter, money to add\n  - Return a string with name and balance(see examples)\n\nAdditional Notes:\n  * Checking_account should be stored as a boolean\n  - No input numbers will be negitive\n  * Output must end with period\n  - Float numbers will not be used so, balance should be integer\n  * No currency will be used\n\nExamples:\n``` Python\nJeff = User('Jeff', 70, True)\nJoe = User('Joe', 70, False)\n\nJeff.withdraw(2) # Returns 'Jeff has 68.'\n\nJoe.check(Jeff, 50) # Returns 'Joe has 120 and Jeff has 18.'\n\nJeff.check(Joe, 80) # Raises a ValueError\n\nJoe.checking_account = True # Enables checking for Joe\n\nJeff.check(Joe, 80) # Returns 'Jeff has 98 and Joe has 40'\n\nJoe.check(Jeff, 100) # Raises a ValueError\n\nJeff.add_cash(20.00) # Returns 'Jeff has 118.'\n```\n\n Good Luck\n-/", "vc-preamble": "def User.withdraw (u : User) (amt : Nat) : Option (String × User) := sorry\ndef User.add_cash (u : User) (amt : Nat) : String × User := sorry", "vc-helpers": "", "vc-definitions": "def User.check (u1 : User) (u2 : User) (amt : Nat) : Option (String × User × User) := sorry\n\ntheorem user_creation_preserves_fields \n  (name : String) (balance : Nat) (has_checking : Bool) :\n  let u := User.mk name balance has_checking\n  u.name = name ∧ u.balance = balance ∧ u.checking_account = has_checking := sorry", "vc-theorems": "theorem withdraw_decreases_balance\n  (name : String) (initial_balance withdrawal : Nat) :\n  withdrawal ≤ initial_balance →\n  let u := User.mk name initial_balance true\n  match u.withdraw withdrawal with\n  | some (msg, u') => \n      u'.balance = initial_balance - withdrawal ∧\n      msg = s!\"{name} has {initial_balance - withdrawal}\"\n  | none => False\n  := sorry\n\ntheorem withdraw_fails_if_insufficient\n  (name : String) (initial_balance withdrawal : Nat) :\n  withdrawal > initial_balance →\n  let u := User.mk name initial_balance true\n  u.withdraw withdrawal = none := sorry\n\ntheorem add_cash_increases_balance\n  (name : String) (initial_balance deposit : Nat) :\n  let u := User.mk name initial_balance true\n  let (msg, u') := u.add_cash deposit\n  u'.balance = initial_balance + deposit ∧\n  msg = s!\"{name} has {initial_balance + deposit}\" := sorry\n\ntheorem check_transfers_amount\n  (name1 name2 : String) (balance1 balance2 transfer : Nat) :\n  transfer ≤ balance2 →\n  let u1 := User.mk name1 balance1 true\n  let u2 := User.mk name2 balance2 true\n  match u1.check u2 transfer with\n  | some (msg, u1', u2') => \n      u1'.balance = balance1 + transfer ∧\n      u2'.balance = balance2 - transfer ∧\n      msg = s!\"{name1} has {balance1 + transfer} and {name2} has {balance2 - transfer}\"\n  | none => False\n  := sorry\n\ntheorem check_fails_without_checking\n  (name1 name2 : String) (balance1 balance2 transfer : Nat) :\n  let u1 := User.mk name1 balance1 true\n  let u2 := User.mk name2 balance2 false\n  u1.check u2 transfer = none := sorry\n\ntheorem check_fails_insufficient_balance\n  (name1 name2 : String) (balance1 balance2 transfer : Nat) :\n  transfer > balance2 →\n  let u1 := User.mk name1 balance1 true\n  let u2 := User.mk name2 balance2 true\n  u1.check u2 transfer = none := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4515", "language": "lean", "source": "fvapps", "source-id": "fvapps_004515", "source-notes": "", "vc-description": "/-\nThe 26 letters of the English alphabets are randomly divided into 5 groups of 5 letters with the remaining letter being ignored.  Each of the group is assigned a score of more than 0.  The ignored letter always has a score of 0.\n\nWith this kata, write a function ```nameScore(name)``` to work out the score of a name that is passed to the function.\n\nThe output should be returned as an object:\n\nOnly letters have a score. Spaces do not.\n\nYou can safely assume that ```name``` does not contain any punctuations or symbols.  There will also be no ```empty string``` or ```null``` value.\n\nA static ```alpha``` object for testing has been preloaded  for your convenience in the following format:\n\nNote that the ```alpha``` object will be randomly generated each time you run the test.\n\n#Example\n\nIn accordance to the above ```alpha``` object, the name ```Mary Jane``` will have a name score of ```20``` => M=3 + a=1 + r=4 + y=5 + J=2 + a=1 + n=3 + e=1\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def name_score (name : String) (alpha : Option (Lean.HashMap String Int) := none) : \n  Lean.HashMap String Int := sorry", "vc-theorems": "theorem name_score_returns_dict_with_name (name : String) :\n  let result := name_score name\n  result.size = 1 ∧ result.contains name := sorry\n\ntheorem name_score_with_custom_alpha (name : String) (alpha : Lean.HashMap String Int) :\n  let result := name_score name (some alpha)\n  result.size = 1 ∧ result.contains name := sorry\n\ntheorem name_score_case_insensitive (name : String) : \n  (name_score name.toLower).find! name.toLower = \n  (name_score name.toUpper).find! name.toUpper := sorry\n\ntheorem name_score_nonnegative (name : String) :\n  (name_score name).find! name ≥ 0 := sorry\n\ntheorem name_score_additive (name1 name2 : String) :\n  (name_score (name1 ++ name2)).find! (name1 ++ name2) = \n  (name_score name1).find! name1 + (name_score name2).find! name2 := sorry\n\n/-\ninfo: {'MARY': 13}\n-/\n-- #guard_msgs in\n-- #eval name_score \"MARY\"\n\n/-\ninfo: {'Mary Jane': 20}\n-/\n-- #guard_msgs in\n-- #eval name_score \"Mary Jane\"\n\n/-\ninfo: {'CAB': 3}\n-/\n-- #guard_msgs in\n-- #eval name_score \"CAB\" {\"ABC\": 1, \"DEF\": 2, \"GHIJKLMNOPQRSTUVWXYZ\": 0}", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4520", "language": "lean", "source": "fvapps", "source-id": "fvapps_004520", "source-notes": "", "vc-description": "/-\nYou're going on a trip with some students and it's up to you to keep track of how much money each Student has. A student is defined like this:\n\n```python\nclass Student:\n    def __init__(self, name, fives, tens, twenties):\n        self.name = name\n        self.fives = fives\n        self.tens = tens\n        self.twenties = twenties\n```\n\nAs you can tell, each Student has some fives, tens, and twenties. Your job is to return the name of the student with the most money. If every student has the same amount, then return `\"all\"`.\n\nNotes:\n* Each student will have a unique name\n* There will always be a clear winner: either one person has the most, or everyone has the same amount\n* If there is only one student, then that student has the most money\n-/", "vc-preamble": "def total_money (s : Student) : Nat :=\n  s.fives * 5 + s.tens * 10 + s.twenties * 20\n\ndef most_money (students : List Student) : String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def find_max_student (students : List Student) : Student :=\n  sorry", "vc-theorems": "theorem most_money_valid_result {students : List Student} (h : students ≠ []) :\n  let result := most_money students\n  (students.length = 1 → result = (students.head h).name) ∧\n  (students.length > 1 → result = \"all\" ∨ ∃ s ∈ students, result = s.name) :=\nsorry\n\ntheorem all_equal_returns_all {students : List Student} (h1 : students ≠ []) \n  (h2 : ∀ s ∈ students, total_money s = total_money (students.head h1)) :\n  most_money students = \"all\" :=\nsorry\n\ntheorem highest_total_wins {students : List Student} (h : students ≠ []) :\n  let result := most_money students\n  let max_student := find_max_student students\n  result ≠ \"all\" → result = max_student.name :=\nsorry\n\n/-\ninfo: 'Phil'\n-/\n-- #guard_msgs in\n-- #eval most_money [phil]\n\n/-\ninfo: 'Phil'\n-/\n-- #guard_msgs in\n-- #eval most_money [cameron, geoff, phil]\n\n/-\ninfo: 'all'\n-/\n-- #guard_msgs in\n-- #eval most_money [andy, stephen, eric]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4521", "language": "lean", "source": "fvapps", "source-id": "fvapps_004521", "source-notes": "", "vc-description": "/-\n[comment]: # (Hello Contributors, the following guidelines in order of importance should help you write new translations and squash any pesky unintended bugs.)\n[//]: # (The epsilon of all floating point test case comparisons is 0.01.)\n[//]: # (Each test case shall pass if the statement \"a^2 + b^2 = c^2\" is true of the returned object.)\n[//]: # (The test suite should contain 3 fixed test and exactly 512 random tests.)\n[//]: # ( The following fixed test shall be used in the test suite as well as the example test suite:)\n[//]: # (  {a: 3, b: 4, c: 5} from input {a: 3, b: 4})\n[//]: # (  {a: 5, c: 13, b: 12} from input {a: 5, c: 13})\n[//]: # (  {b: 2, c: 3, a: 2.236} from input {b: 2, c: 3})\n[//]: # ( Random tests shall assign float values of a random range between 0.1-10.1 to properties a and b, and 14.5-114.5 to property c, after which, one of the properties is removed at random if target language allows for property insertions and deletions, or has its value replaced with either NaN if possible, or 0 if not.)\n[//]: # (The test suite should not be sensitive to property insertion or placement order of the returned object.)\n[//]: # (Validation attempts should not produce any errors outside the solution scope regardless of solution content.)\n\nMy tired eyes surveyed the horizon to spot a right triangle, made of an unknown material that sparkles in the endless void I have trekked thus far.\n\nI hurried towards it. However far it seemed, it can't compare to the uncounted days I have been trapped here in this endless void. To break the monotony, it shall do nicely.\n\nReaching the triangle, I inspected it. It is even more spectacular up close than a far, like a piece of the heavens, just as grand as the best Hubble photo I've ever seen. Adorned onto its striking surface were two numbers, each hugging a side of the triangle in white chalk.\n\n```python\n{'a': 3, 'b': 4}\n```\n\nAlmost unconsciously, I grabbed at the misshapen chalk piece in my pocket, a small stone shaped calcium oddity I found among the void. I am hit with the sudden urge to write on the cosmic shape, to complete the numbers by filling in the missing side. The shear burning desire scares me, but I did it anyway. With a bit of internal head math, I wrote down my solution.\n\n```python\n{'a': 3, 'b': 4, 'c': 5}\n```\n\nThe triangle glowed white, contrasting almost blindingly against the surrounding darkness around me. Could it be, that solving this shape would be my salvation, my escape from this dark and empty place?\n\nI stared at the shining geometry for what felt like ever, before, with a disappointed sigh, I glanced away from the mesmerizing false hope. Only to catch the sight of two more triangles of right angles.\n\n```python\n{'a': 5, 'c': 13}\n{'b': 2, 'c': 3}\n```\n\nSomehow, I knew the third triangle had its first side unmarked, rather than its second, I'll have to take that into account were I to do this right. I idly solved them both, looking on in wonder as they too turned white.\n\n```python\n{'a': 5, 'b': 12, 'c': 13}\n{'a': 2.236, 'b': 2, 'c': 3}\n```\n\nSomething on the edge of my peripheral vision moved. I looked up, to be greeted with hundreds of right triangles, like angels from the heavens, coming down right at me.\n\nI might need a better solution to turn them all shining white...\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def solve_right_triangle (known : List (String × Float)) : RightTriangle := sorry\n\ndef is_valid_right_triangle (t : RightTriangle) : Bool := \n  let diff := t.a^2 + t.b^2 - t.c^2\n  diff.abs < 0.0001", "vc-theorems": "theorem solve_with_two_legs {a b : Float} (ha : a > 0.1) (hb : b > 0.1) \n  (ha_upper : a < 1000) (hb_upper : b < 1000) :\n  let t := solve_right_triangle [(\"a\", a), (\"b\", b)]\n  is_valid_right_triangle t := sorry\n\ntheorem solve_with_leg_and_hyp_a {leg hyp : Float} (hl : leg > 0.1) (hh : hyp > 0.1)\n  (hl_upper : leg < 1000) (hh_upper : hyp < 1000) (h_shorter : leg < hyp) :\n  let t := solve_right_triangle [(\"a\", leg), (\"c\", hyp)]\n  is_valid_right_triangle t := sorry\n\ntheorem solve_with_leg_and_hyp_b {leg hyp : Float} (hl : leg > 0.1) (hh : hyp > 0.1) \n  (hl_upper : leg < 1000) (hh_upper : hyp < 1000) (h_shorter : leg < hyp) :\n  let t := solve_right_triangle [(\"b\", leg), (\"c\", hyp)]\n  is_valid_right_triangle t := sorry\n\ntheorem invalid_inputs_empty :\n  ∀ t, solve_right_triangle [] ≠ t := sorry\n\ntheorem invalid_inputs_bad_key :\n  ∀ t, solve_right_triangle [(\"x\", 3), (\"y\", 4)] ≠ t := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4523", "language": "lean", "source": "fvapps", "source-id": "fvapps_004523", "source-notes": "", "vc-description": "/-\n# Background\n\nA spider web is defined by\n\n* \"rings\" numbered out from the centre as `0`, `1`, `2`, `3`, `4`\n\n* \"radials\" labelled clock-wise from the top as `A`, `B`, `C`, `D`, `E`, `F`, `G`, `H`\n\nHere is a picture to help explain:\n\n# Web Coordinates\n\nAs you can see, each point where the rings and the radials intersect can be described by a \"web coordinate\".\n\nSo in this example the spider is at `H3` and the fly is at `E2`\n\n# Kata Task\n\nOur friendly jumping spider is resting and minding his own spidery business at web-coordinate `spider`.\n\nAn inattentive fly bumbles into the web at web-coordinate `fly` and gets itself stuck.\n\nYour task is to calculate and return **the \n distance** the spider must jump to get to the fly.\n\n# Example\n\nThe solution to the scenario described by the picture is ``4.63522``\n\n# Notes\n\n* The centre of the web will always be referred to as `A0` \n* The rings intersect the radials at **evenly** spaced distances of **1 unit**\n\n____\n\nGood Luck!DM\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def spider_to_fly (spider fly : WebCoord) : Float := sorry\n\ndef number_to_float (n : WebNumber) : Float := sorry", "vc-theorems": "theorem distance_nonnegative (spider fly : WebCoord) :\n  spider_to_fly spider fly ≥ 0 := sorry\n\ntheorem distance_symmetric (spider fly : WebCoord) :\n  spider_to_fly spider fly = spider_to_fly fly spider := sorry\n\ntheorem distance_self (coord : WebCoord) :\n  spider_to_fly coord coord = 0 := sorry\n\ntheorem triangle_inequality (spider mid fly : WebCoord) :\n  spider_to_fly spider fly ≤ spider_to_fly spider mid + spider_to_fly mid fly := sorry\n\ntheorem distance_to_origin (coord : WebCoord) :\n  spider_to_fly coord ⟨WebLetter.A, WebNumber.N0⟩ = number_to_float coord.number := sorry\n\ntheorem same_radial_distance (coord : WebCoord) :\n  spider_to_fly coord ⟨coord.letter, WebNumber.N0⟩ = number_to_float coord.number := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4530", "language": "lean", "source": "fvapps", "source-id": "fvapps_004530", "source-notes": "", "vc-description": "/-\n# An introduction to propositional logic\n\nLogic and proof theory are fields that study the formalization of logical statements and the structure of valid proofs. One of the most common ways to represent logical reasonings is with **propositional logic**.\n\nA propositional formula is no more than what you normally use in your *if statements*, but without functions or predicates. The basic unit for these formulas are **literals**. Let's see some examples:\n\n```\nf = p ∧ q\n```\n\nHere ```p``` and ```q``` would be the literals. This formula means that *f* evaluates to ```True``` only when both ```p``` **and** ```q``` are True too. The ```∧``` operator is formally called **conjunction** and is often called **and**.\n\n```\nf = p ∨ q\n```\n\nThis formula means that *f* evaluates to ```True``` only when any of ```p``` **or** ```q``` are  True. This includes the case when both are True. The ```∨``` operator is formally called **disjunction** and is often called **or**.\n\n```\nf = ¬p\n```\n\nThe ```¬``` operator is analogous to the **not** operation. it evaluates to True only when its argument evaluates to False.\n\nNormally, there are also two other operators called **implication** and **biconditional**, but we will ignore them for this kata (they can be expressed in terms of the other three anyways).\n\nOnce we know this, can construct what is called an **interpretation** in order to evaluate a propositional formula. This is a fancy name for any structure that tells us which literals are False and which ones are True. Normally, interpretations are given as a set:\n\n```python\np = Literal('p')\nq = Literal('q')\nr = Literal('r')\n\nf = p ∨ q ∨ ¬r\n\ni_1 = {p, q} # p and q are True, r is False\ni_2 = {r}    # r is True, p and q are False\ni_3 = {}     # p, q and r are False\n\n# Note: the 'evaluate' function is not given\nevaluate(f, i_1) == True\nevaluate(f, i_2) == False\nevaluate(f, i_3) == True\n```\n\nAs you can see, if the literal is in the set, we say it evaluates to True, else it is False.\n\nAs a final note, an interpretation that makes a formula True is called a **model** when all the literals in the set appear in the formula.\n\n# The SAT problem\n\nThis is a famous NP problem that is stated as follows:\n\n> Given a propositional formula *F*, does it exist an interpretation such that it evaluates to True? (i.e. is *F* **satisfiable**?)\n\nNumerous algorithms exist for this purpose, and your task is to program one of them. Right now, you are not supposed to program an efficient algorithm, but I may create a performance version if this kata gets good reception :)\n\n# Specification\n\nProgram a ```sat(f: Formula)``` function that returns the following:\n- ```False``` if ```f``` is not satisfiable.\n- An interpretation that makes ```f``` evaluate to True in the case that it is satisfiable.\n\n# Preloaded code\n\nYou are given a class ```Formula``` that has the following members:\n\n- ```args```: arguments of the operation if the formula is not a literal (children nodes of the formula's tree). They are given as a list of Formula objects that has one element in the case of the negation operator and two or more elements in the case of the conjunction and disjunction operators.\n- ```is_literal()```: True if the formula is a literal (i.e. not an operation).\n- ```is_and()```: True if the formula is a **conjunction**.\n- ```is_or()```: True if the formula is a **disjunction**. \n- ```is_not()```: True if the formula is a **negation**. \n\nYou are also given a class ```Literal``` that extends from ```Formula``` and has the following members:\n\n- ```name```: string that represents the literal. Two literals with the same name **are the same literal**.\n*Note: the rest of members are not guaranteed in the case of a literal*\n\nThe ```&``` operator is overloaded as the conjunction, ```|``` as the disjunction and ```~``` as the negation. Also, a ```__repr__``` function is given for debugging purposes.\n\n# Extra examples\n\n```\nf = ¬(p ∨ q) # Satisfiable with {}\n```\n```\nf = ¬(p ∧ q) # Satisfiable with {p}, {q} and {}\n```\n```\nf = p ∧ (q ∨ r) # Satisfiable with {p, q}, {p, r} and {p, q, r}\n```\n```\nf = ¬p ∨ ¬q # Satisfiable with {p}, {q} and {} (See De Morgan's Laws)\n```\n```\nf = p ∧ ¬p # Not satisfiable\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def sat (f : Formula) : Option Model := sorry\n\ntheorem sat_returns_model_or_false (f : Formula) (m : Model) :\n  (sat f = some m) → ∀ s ∈ m, ∃ name, Formula.lit name = Formula.lit s\n  := sorry", "vc-theorems": "theorem not_p_and_p_unsatisfiable (p : Formula) :\n  sat (Formula.and [p, Formula.not p]) = none \n  := sorry\n\ntheorem p_or_not_p_satisfiable (p : Formula) :\n  sat (Formula.or [p, Formula.not p]) ≠ none\n  := sorry\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval sat Formula()", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4536", "language": "lean", "source": "fvapps", "source-id": "fvapps_004536", "source-notes": "", "vc-description": "/-\nLinked Lists - Get Nth\n\nImplement a GetNth() function that takes a linked list and an integer index and returns the node stored at the Nth index position. GetNth() uses the C numbering convention that the first node is index 0, the second is index 1, ... and so on. So for the list 42 -> 13 -> 666, GetNth() with index 1 should return Node(13);\n\nThe index should be in the range [0..length-1]. If it is not, GetNth() should throw/raise an exception (`ArgumentException` in C#, `InvalidArgumentException` in PHP). You should also raise an exception (`ArgumentException` in C#, `InvalidArgumentException` in PHP) if the list is empty/null/None.\n\nPrerequisite Kata (may be in beta):\n\n- Linked Lists - Push & BuildOneTwoThree\n- Linked Lists - Length & Count\n\n> The push() and buildOneTwoThree() (`BuildOneTwoThree` in C#, `build_one_two_three()` in PHP) functions do not need to be redefined.\n-/", "vc-preamble": "def Node.data : Node → Int\n  | mk d _ => d\n\ndef get_nth (head : Option Node) (n : Nat) : Option Node :=\n  sorry", "vc-helpers": "", "vc-definitions": "def build_list : List Int → Option Node :=\n  sorry", "vc-theorems": "theorem get_nth_valid_index_returns_correct_value (head : Option Node) (values : List Int) (index : Nat) :\n  head = build_list values →\n  index < values.length →\n  ∃ (h : index < values.length), \n    (get_nth head index).map Node.data = some (values.get ⟨index, h⟩) :=\n  sorry\n\ntheorem get_nth_invalid_index_returns_none (head : Option Node) (values : List Int) (index : Nat) : \n  head = build_list values →\n  index ≥ values.length →\n  get_nth head index = none :=\n  sorry\n\ntheorem get_nth_empty_list_returns_none (index : Nat) :\n  get_nth none index = none :=\n  sorry\n\ntheorem get_nth_zero_returns_first (head : Option Node) (values : List Int) :\n  head = build_list values →\n  values ≠ [] →\n  (get_nth head 0).map Node.data = some (values.head!) :=\n  sorry\n\ntheorem get_nth_last_returns_last (head : Option Node) (values : List Int) :\n  head = build_list values →\n  values ≠ [] →\n  ∃ (h : values.length - 1 < values.length),\n    (get_nth head (values.length - 1)).map Node.data = some (values.get ⟨values.length - 1, h⟩) :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4542", "language": "lean", "source": "fvapps", "source-id": "fvapps_004542", "source-notes": "", "vc-description": "/-\n# Task\nFollow the instructions in each failing test case to write logic that calculates the total price when ringing items up at a cash register.\n\n# Purpose\nPractice writing maintainable and extendable code. \n\n# Intent\nThis kata is meant to emulate the real world where requirements change over time. This kata does not provide a specification for the final end-state up front. Instead, it walks you through a series of requirements, modifying and extending them via test cases as you go. This kata is about the journey, not the destination. Your ability to write maintainable and extendable code will affect how difficult this kata is. \n\n# Provided Utility Function\nYou may use the following preloaded function:\n```python\nget_price(item)\n\"\"\"Accepts a str specifying an item. Returns the price of\nthe item (float) or raises a KeyError if no price is available.\n\nExample: \n\n    >>> get_price(apple)\n    0.4\n\"\"\"\n```\n\n# Acknowledgement\nInspired by http://codekata.com/kata/kata01-supermarket-pricing/. To get the most benefit from this kata, I would recommend visiting that page only after completing, not before.\n-/", "vc-preamble": "def get_price : Item → Float \n| Item.apple => 0.5\n| Item.banana => 0.5  \n| Item.orange => 0.7\n\ndef ring_up (items : List (Item × Nat)) (promos : List String := []) : Float :=\n  sorry", "vc-helpers": "", "vc-definitions": "def list_sum (l : List Float) : Float :=\n  match l with\n  | [] => 0\n  | h :: t => h + list_sum t", "vc-theorems": "theorem ring_up_nonnegative (items : List (Item × Nat)) (promos : List String) :\n  ring_up items promos ≥ 0 :=\nsorry\n\ntheorem ring_up_equals_sum_when_no_promos (items : List (Item × Nat)) :\n  ring_up items [] = list_sum (items.map (fun (i,q) => get_price i * q.toFloat)) :=\nsorry\n\ntheorem ring_up_empty_is_zero :\n  ring_up [] [] = 0 :=\nsorry\n\ntheorem ring_up_zero_quantities (items : List (Item × Nat)) (h: ∀ p ∈ items, p.2 = 0) :\n  ring_up items [] = 0 :=\nsorry\n\ntheorem ring_up_three_for_one_apple :\n  ring_up [(Item.apple, 3)] [\"3 for 1.00\"] = 1.00 :=\nsorry\n\ntheorem ring_up_bogo_banana :\n  ring_up [(Item.banana, 2)] [\"buy 1 get 1\"] = 0.50 :=\nsorry\n\n/-\ninfo: 0.8\n-/\n-- #guard_msgs in\n-- #eval ring_up {\"apple\": 2}\n\n/-\ninfo: 1.0\n-/\n-- #guard_msgs in\n-- #eval ring_up {\"apple\": 3} {\"apple\": \"3 for 1.00\"}\n\n/-\ninfo: 0.5\n-/\n-- #guard_msgs in\n-- #eval ring_up {\"banana\": 2} {\"banana\": \"buy 1 get 1\"}", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4545", "language": "lean", "source": "fvapps", "source-id": "fvapps_004545", "source-notes": "", "vc-description": "/-\nYou will be given an array `a` and a value `x`. All you need to do is check whether the provided array contains the value.\n\n~~~if:swift\nThe type of `a` and `x` can be `String` or `Int`.\n~~~\n~~~if-not:swift\nArray can contain numbers or strings. X can be either.\n~~~\n~~~if:racket\nIn racket, you'll be given a list instead of an array. If the value is in the list,\nreturn #t instead of another value that is also considered true.\n```racket\n(contains '(1 2 3) 3) ; returns #t\n(contains '(1 2 3) 5) ; returns #f\n```\n~~~\n\nReturn `true` if the array contains the value, `false` if not.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def check (seq : List α) (elem : α) : Bool :=\n  sorry", "vc-theorems": "theorem check_membership_true {α} (seq : List α) (elem : α) :\n  elem ∈ seq → check seq elem = true := by\n  sorry\n\ntheorem check_membership_false {α} (seq : List α) (elem : α) :\n  elem ∉ seq → check seq elem = false := by\n  sorry\n\ntheorem check_reflexive {α} (seq : List α) (elem : α) :\n  check (seq ++ [elem]) elem = true := by\n  sorry\n\nend CheckSequence\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval check [1, 2, 3] 2\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval check [\"hello\", \"world\"] \"cat\"\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval check [66.25, 333, 333.5] 333", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4546", "language": "lean", "source": "fvapps", "source-id": "fvapps_004546", "source-notes": "", "vc-description": "/-\nThe [Linear Congruential Generator (LCG)](https://en.wikipedia.org/wiki/Linear_congruential_generator) is one of the oldest pseudo random number generator functions.\n\nThe algorithm is as follows:\n\n## Xn+1=(aXn + c) mod m\nwhere:\n* `a`/`A` is the multiplier (we'll be using `2`)\n* `c`/`C` is the increment (we'll be using `3`)\n* `m`/`M` is the modulus (we'll be using `10`)\n\nX0 is the seed.\n\n# Your task\n\nDefine a method `random`/`Random` in the class `LCG` that provides the next random number based on a seed. You never return the initial seed value.\n\nSimilar to [random](https://docs.python.org/3/library/random.html#random.random) return the result as a floating point number in the range `[0.0, 1.0)`\n\n# Example\n\n```python\n# initialize the generator with seed = 5\nLCG(5)\n\n# first random number (seed = 5)\nLCG.random() = 0.3      # (2 * 5 + 3) mod 10 = 3 --> return 0.3\n\n# next random number (seed = 3)\nLCG.random() = 0.9      # (2 * 3 + 3) mod 10 = 9 --> return 0.9\n\n# next random number (seed = 9)\nLCG.random() = 0.1\n\n# next random number (seed = 1)\nLCG.random() = 0.5\n```\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def LCG.random (self : LCG) : Float := sorry\n\ntheorem lcg_output_range (seed : Nat) (h : seed ≤ 9) :\n  let lcg := LCG.mk seed\n  let result := lcg.random\n  0 ≤ result ∧ result ≤ 1 := sorry", "vc-theorems": "theorem lcg_deterministic (seed : Nat) (h : seed ≤ 9) :\n  let lcg1 := LCG.mk seed\n  let lcg2 := LCG.mk seed\n  lcg1.random = lcg2.random := sorry\n\ntheorem lcg_decimal_output (seed : Nat) (h : seed ≤ 9) :\n  let lcg := LCG.mk seed\n  let result := lcg.random\n  Float.round (result * 10) = result * 10 := sorry\n\ntheorem lcg_period :\n  ∀ (s : Nat), ∃ (n : Nat), n ≤ 10 ∧\n  (let lcg := LCG.mk s\n   let seq := List.range n |>.map (λ _ => lcg.random)\n   ∃ (i j : Nat), i < j ∧ j < seq.length ∧ \n   seq.get ⟨i, by sorry⟩ = seq.get ⟨j, by sorry⟩) := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4550", "language": "lean", "source": "fvapps", "source-id": "fvapps_004550", "source-notes": "", "vc-description": "/-\n# Idea\n\nIn the world of graphs exists a structure called \"spanning tree\". It is unique because it's created not on its own, but based on other graphs. To make a spanning tree out of a given graph you should remove all the edges which create cycles, for example:\n```\nThis can become      this      or      this        or       this\n\n A                    A                  A                   A\n |\\                   |                   \\                  |\\\n | \\       ==>        |                    \\                 | \\\n |__\\                 |__                 __\\                |  \\\nB   C                 B  C               B  C                B  C\n```\nEach *edge* (line between 2 *vertices*, i.e. points) has a weight, based on which you can build minimum and maximum spanning trees (sum of weights of vertices in the resulting tree is minimal/maximal possible).  \n[Wikipedia article](https://en.wikipedia.org/wiki/Spanning_tree) on spanning trees, in case you need it.\n\n___\n\n# Task\n\nYou will receive an array like this: `[[\"AB\", 2], [\"BC\", 4], [\"AC\", 1]]` which includes all edges of an arbitrary graph and a string `\"min\"`/`\"max\"`. Based on them you should get and return a new array which includes only those edges which form a minimum/maximum spanning trees.\n```python\nedges = [(\"AB\", 2), (\"BC\", 4), (\"AC\", 1)]\n\nmake_spanning_tree(edges, \"min\")    ==>    [(\"AB\", 2), (\"AC\", 1)]\nmake_spanning_tree(edges, \"max\")    ==>    [(\"AB\", 2), (\"BC\", 4)]\n```\n\n___\n\n# Notes\n\n* All vertices will be connected with each other\n* You may receive cycles, for example - `[\"AA\", n]`\n* The subject of the test are these 3 values: number of vertices included, total weight, number of edges, but **you should not return them**, there's a special function which will analyze your output instead\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def make_spanning_tree (edges : List Edge) (tree_type : String) : List Edge :=\n  sorry", "vc-theorems": "theorem spanning_tree_subset {edges : List Edge} {tree_type : String} :\n  let result := make_spanning_tree edges tree_type\n  ∀ e ∈ result, e ∈ edges := by\n  sorry\n\ntheorem spanning_tree_no_duplicates {edges : List Edge} {tree_type : String} :\n  let result := make_spanning_tree edges tree_type\n  let result_edges := result.map (·.vertices)\n  result_edges.length = result_edges.eraseDups.length := by\n  sorry\n\ntheorem spanning_tree_no_self_loops {edges : List Edge} {tree_type : String} :\n  let result := make_spanning_tree edges tree_type\n  ∀ e ∈ result, e.vertices.1 ≠ e.vertices.2 := by\n  sorry\n\ntheorem spanning_tree_min_property {edges : List Edge} \n  (h : make_spanning_tree edges \"min\" ≠ []) :\n  let result := make_spanning_tree edges \"min\"\n  let result_weights := result.map (·.weight)\n  let valid_edges := edges.filter (λ e => e.vertices.1 ≠ e.vertices.2)\n  let edge_weights := valid_edges.map (·.weight)\n  (result_weights.minimum?.get! : Nat) ≥ edge_weights.minimum?.get! := by\n  sorry\n\ntheorem spanning_tree_max_property {edges : List Edge}\n  (h : make_spanning_tree edges \"max\" ≠ []) :\n  let result := make_spanning_tree edges \"max\"\n  let result_weights := result.map (·.weight)\n  let valid_edges := edges.filter (λ e => e.vertices.1 ≠ e.vertices.2)\n  let edge_weights := valid_edges.map (·.weight)\n  (result_weights.maximum?.get! : Nat) ≤ edge_weights.maximum?.get! := by\n  sorry\n\n/-\ninfo: [('AC', 1), ('AB', 2)]\n-/\n-- #guard_msgs in\n-- #eval make_spanning_tree [(\"AB\", 2), (\"BC\", 4), (\"AC\", 1)] \"min\"\n\n/-\ninfo: [('BC', 4), ('AB', 2)]\n-/\n-- #guard_msgs in\n-- #eval make_spanning_tree [(\"AB\", 2), (\"BC\", 4), (\"AC\", 1)] \"max\"\n\n/-\ninfo: [('AB', 2), ('BC', 3)]\n-/\n-- #guard_msgs in\n-- #eval make_spanning_tree [(\"AA\", 1), (\"AB\", 2), (\"BC\", 3)] \"min\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4551", "language": "lean", "source": "fvapps", "source-id": "fvapps_004551", "source-notes": "", "vc-description": "/-\nCreate a `Vector` class with `x` and a `y` attributes that represent component magnitudes in the x and y directions.\n\nYour vectors should handle vector additon with an `.add()` method that takes a second vector as an argument and returns a new vector equal to the sum of the vector you call `.add()` on and the vector you pass in.\n\nFor example:\n\n```python\n>>> a = Vector(3, 4)\n>>> a.x\n3\n>>> a.y\n4\n>>> b = Vector(1, 2)\n>>> c = a.add(b)\n>>> c.x\n4\n>>> c.y\n6\n```\n\nAdding vectors when you have their components is easy: just add the two x components together and the two y components together to get the x and y components for the vector sum.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Vector.add : Vector → Vector → Vector\n  | v1, v2 => sorry", "vc-theorems": "theorem vector_addition_coordinates (v1 v2 : Vector) :\n  let result := v1.add v2\n  result.x = v1.x + v2.x ∧ result.y = v1.y + v2.y :=\nsorry\n\ntheorem vector_addition_commutative (v1 v2 : Vector) : \n  v1.add v2 = v2.add v1 :=\nsorry\n\ntheorem zero_vector_identity (v : Vector) :\n  let zero := Vector.mk 0 0\n  v.add zero = v :=\nsorry\n\ntheorem inverse_vector_sum_zero (v : Vector) :\n  let inverse := Vector.mk (-v.x) (-v.y)\n  let result := v.add inverse\n  result.x = 0 ∧ result.y = 0 :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4556", "language": "lean", "source": "fvapps", "source-id": "fvapps_004556", "source-notes": "", "vc-description": "/-\n# Magpies are my favourite birds\n\nBaby ones even more so...\n\nIt is a little known fact^ that the black & white colours of baby magpies differ by **at least** one place and **at most** two places from the colours of the mother magpie.\n\nSo now you can work out if any two magpies may be related. \n\n*...and Quardle oodle ardle wardle doodle the magpies said*\n\n# Kata Task\n\nGiven the colours of two magpies, determine if one is a possible **child** or **grand-child** of the other.\n\n# Notes\n\n* Each pair of birds being compared will have same number of colour areas\n* `B` = Black\n* `W` = White\n\n# Example\n\nGiven these three magpies\n\nMagpie 1  BWBWBW\nMagpie 2  BWBWBB\nMagpie 3  WWWWBB\n\nYou can see:\n* Magpie 2 may be a child of Magpie 1 because there is only one difference\n* Magpie 3 may be child of Magpie 2 because there are two differences\n* So Magpie 3 may be a grand-child of Magpie 1\n* On the other hand, Magpie 3 cannot be a child of Magpie 1 because there are three differences\n\n---\n\nDM :-)\n\n^ *This fact is little known because I just made it up*\n-/", "vc-preamble": "def BirdString := List Bird\n\ndef diffs : BirdString → BirdString → Nat\n  | _, _ => sorry\n\ndef child : BirdString → BirdString → Bool\n  | _, _ => sorry", "vc-helpers": "", "vc-definitions": "def grandchild : BirdString → BirdString → Bool \n  | _, _ => sorry", "vc-theorems": "theorem diffs_upper_bound (s1 s2 : BirdString) : \n  diffs s1 s2 ≤ min (List.length s1) (List.length s2) :=\nsorry\n\ntheorem diffs_equal_zero (s : BirdString) :\n  diffs s s = 0 :=\nsorry\n\ntheorem child_diffs_range (s1 s2 : BirdString) :\n  child s1 s2 = true → 1 ≤ diffs s1 s2 ∧ diffs s1 s2 ≤ 2 :=\nsorry\n\ntheorem not_child_outside_range (s1 s2 : BirdString) :\n  (diffs s1 s2 > 2 ∨ diffs s1 s2 = 0) → child s1 s2 = false :=\nsorry\n\ntheorem single_char_grandchild (b1 b2 : Bird) :\n  grandchild [b1] [b2] = (b1 = b2) :=\nsorry\n\ntheorem grandchild_diffs_range (s1 s2 : BirdString) :\n  List.length s1 > 1 →\n  grandchild s1 s2 = true →\n  0 ≤ diffs s1 s2 ∧ diffs s1 s2 ≤ 4 :=\nsorry\n\ntheorem not_grandchild_excess_diffs (s1 s2 : BirdString) :\n  List.length s1 > 1 →\n  diffs s1 s2 > 4 →\n  grandchild s1 s2 = false :=\nsorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval child \"BWBWBW\" \"BWBWBB\"\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval grandchild magpie1 \"WWWWBB\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval child magpie1 magpie3", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4559", "language": "lean", "source": "fvapps", "source-id": "fvapps_004559", "source-notes": "", "vc-description": "/-\nWhen you were little, your mother used to make the most delicious cookies, which you could not resist. So, every now and then, when your mother didn't see you, you sneaked into the kitchen, climbed onto a stool to reach the cookie jar, and stole a cookie or two. However, sometimes while doing this, you would hear foot steps approaching, so you quickly jumped down from the stool and, when your mother entered the kitchen, you pretended as if nothing had happened (whistle, whistle innocently). However, your mother knew. How did she know? You forgot to put the lid back on the cookie jar! Oh, no!\n\nGrowing older (and still not able to resist your mother's cookies), you deviced a contraption that would automatically put the lid back on the cookie jar, _no matter what would happen_.\n\nThe class `CookieJar` is provided: \n```Python\nclass CookieJar(object):\n\n    def __init__(self):\n        self._is_open = False\n\n    def take(self):\n        if not self._is_open:\n            raise ValueError(\"Cookie jar is closed\")\n        return \"Cookie\"\n\n    def open_jar(self):\n        self._is_open = True\n\n    def close_jar(self):\n        self._is_open = False\n\n    def is_open(self):\n        return self._is_open\n```\nYour task is to implement the 'contraption' `SelfClosing` (class, method, whatever; it's your choice) such that, given an instance`cookie_jar` of `CookieJar`, you may call:\n\n```Python\nwith SelfClosing(cookie_jar) as jar:\n    cookie = jar.take()\n```\nafter which, `cookie_jar.is_open() == False`, _no matter what_.\n\nDo not alter the provided code. (Tests will be performed with a code that differs slightly from the one provided, so modifying it is to no avail.)\n\nEnjoy!\n-/", "vc-preamble": "def CookieJar.is_open : CookieJar → Bool \n  | _ => sorry", "vc-helpers": "", "vc-definitions": "def CookieJar.take (jar : CookieJar) : String :=\n  sorry\n\nstructure SelfClosing (jar : CookieJar) where\n  mk ::", "vc-theorems": "theorem cookie_jar_initial_state (jar : CookieJar) : \n  jar.is_open = false := sorry \n\ntheorem context_manager_always_closes (jar : CookieJar) (e : Exception) :\n  ¬jar.is_open := sorry\n\ntheorem nested_context_managers (jar : CookieJar) \n  (ctx1 ctx2 : SelfClosing jar) :\n  jar.is_open ∧\n  (jar.is_open ∧ ¬jar.is_open) ∧\n  ¬jar.is_open := sorry\n\ntheorem multiple_operations {α : Type} (ops : List α) (jar : CookieJar) \n  (h : ops.length > 0) :\n  ∀ op ∈ ops,\n    jar.take = \"Cookie\" ∧ \n    jar.is_open ∧\n    ¬jar.is_open := sorry\n\ntheorem nested_depth (n : Nat) (jar : CookieJar) (h : n > 0 ∧ n ≤ 100) :\n  jar.is_open ∧\n  jar.take = \"Cookie\" ∧ \n  jar.is_open ∧\n  ¬jar.is_open := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4560", "language": "lean", "source": "fvapps", "source-id": "fvapps_004560", "source-notes": "", "vc-description": "/-\nClassy Extensions\nClassy Extensions, this kata is mainly aimed at the new JS ES6 Update introducing extends keyword. You will be preloaded with the Animal class, so you should only edit the Cat class.\n\nTask\nYour task is to complete the Cat class which Extends Animal and replace the speak method to return the cats name + meows.\ne.g. 'Mr Whiskers meows.'\n\nThe name attribute is passed with this.name (JS), @name (Ruby) or self.name (Python).\n\nReference: [JS](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes), [Ruby](http://rubylearning.com/satishtalim/ruby_inheritance.html), [Python](https://docs.python.org/2/tutorial/classes.html#inheritance).\n-/", "vc-preamble": "def Animal.name (a : Animal) : String :=\n  match a with\n  | mk n => n\n\ndef Animal.speak (a : Animal) : String := sorry\n\ninductive Cat where\n  | mk (name : String)\n\ndef Cat.name (c : Cat) : String :=\n  match c with\n  | mk n => n", "vc-helpers": "", "vc-definitions": "def Cat.speak (c : Cat) : String := sorry\n\ndef Cat.toAnimal (c : Cat) : Animal :=\n  match c with\n  | mk n => Animal.mk n", "vc-theorems": "theorem animal_speak_format {name : String} (h : name.length > 0) :\n  (Animal.mk name).speak = name ++ \" speaks.\" := sorry\n\ntheorem cat_speak_format {name : String} (h : name.length > 0) :\n  (Cat.mk name).speak = name ++ \" meows.\" := sorry\n\ntheorem cat_name_preservation {name : String} (h : name.length > 0) :\n  (Cat.mk name).name = name := sorry\n\ntheorem cat_is_animal (c : Cat) :\n  ∃ (a : Animal), c.toAnimal = a := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4561", "language": "lean", "source": "fvapps", "source-id": "fvapps_004561", "source-notes": "", "vc-description": "/-\nTask:\nThis kata requires you to write an object that receives a file path \nand does operations on it.\nNOTE FOR PYTHON USERS: You cannot use modules os.path, glob, and re\nThe purpose of this kata is to use string parsing, so you're not supposed to import external libraries. I could only enforce this in python.\nTesting:\n\nPython:\n```python\n>>> master = FileMaster('/Users/person1/Pictures/house.png')\n>>> master.extension()\n'png'\n>>> master.filename()\n'house'\n>>> master.dirpath()\n'/Users/person1/Pictures/'\n```\n-/", "vc-preamble": "def FileMaster.extension (fm: FileMaster) : String :=\n  sorry\n\ndef FileMaster.filename (fm: FileMaster) : String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def FileMaster.dirpath (fm: FileMaster) : String :=\n  sorry", "vc-theorems": "theorem filemaster_extension_matches_input (dirpath name ext : String) :\n  let filepath := dirpath ++ name ++ \".\" ++ ext\n  let fm := FileMaster.mk filepath\n  FileMaster.extension fm = ext :=\nsorry\n\ntheorem filemaster_filename_matches_input (dirpath name ext : String) :\n  let filepath := dirpath ++ name ++ \".\" ++ ext\n  let fm := FileMaster.mk filepath\n  FileMaster.filename fm = name :=\nsorry\n\ntheorem filemaster_dirpath_matches_input (dirpath name ext : String) :\n  let filepath := dirpath ++ name ++ \".\" ++ ext\n  let fm := FileMaster.mk filepath\n  FileMaster.dirpath fm = dirpath :=\nsorry\n\ntheorem filemaster_house_png_example :\n  let fm := FileMaster.mk \"/Users/person1/Pictures/house.png\"\n  FileMaster.extension fm = \"png\" ∧ \n  FileMaster.filename fm = \"house\" ∧\n  FileMaster.dirpath fm = \"/Users/person1/Pictures/\" :=\nsorry\n\ntheorem filemaster_index_html_example :\n  let fm := FileMaster.mk \"/var/www/index.html\"\n  FileMaster.extension fm = \"html\" ∧\n  FileMaster.filename fm = \"index\" ∧ \n  FileMaster.dirpath fm = \"/var/www/\" :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4563", "language": "lean", "source": "fvapps", "source-id": "fvapps_004563", "source-notes": "", "vc-description": "/-\nJohn wants to decorate a room with wallpaper. He's heard that \nmaking sure he has the right amount of wallpaper is more complex than it sounds. \nHe wants a fool-proof method for getting it right.\n\nJohn knows that the rectangular room has a length of `l` meters, a width of `w` meters, a height of `h` meters.\nThe standard width of the rolls he wants to buy is `52` centimeters. The \nlength of a roll is `10` meters.\nHe bears in mind however, that it’s best to have an extra length of wallpaper handy in case of mistakes or miscalculations so he wants to buy a length `15%` greater than the one he needs.\n\nLast time he did these calculations he got a headache, so could you help John? Your function `wallpaper(l, w, h)` should return as a plain English word\nin lower case the number of rolls he must buy.\n\n### Example:\n\n`wallpaper(4.0, 3.5, 3.0) should return \"ten\"`\n\n`wallpaper(0.0, 3.5, 3.0) should return \"zero\"`\n\n# Notes:\n- all rolls (even with incomplete width) are put edge to edge \n- 0 <= l, w, h (floating numbers), it can happens that `w x h x l` is zero\n- the integer `r` (number of rolls) will always be less or equal to 20\n\n- FORTH: the number of rolls will be a *positive or null integer* (not a plain English word; this number can be greater than 20)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def wallpaper (l w h : Float) : NumberWord := sorry\n\n/- If either width or length is 0, result is zero -/", "vc-theorems": "theorem wallpaper_zero {l w h : Float} :\n  l * w = 0 → wallpaper l w h = NumberWord.zero := sorry\n\n/- Result is always a valid number word between 0 and 20 -/\n\ntheorem wallpaper_valid_output {l w h : Float} :\n  ∃ n : NumberWord, wallpaper l w h = n := sorry\n\n/- Non-negative inputs result in non-negative outputs -/\n\ntheorem wallpaper_nonneg {l w h : Float} :\n  l ≥ 0 → w ≥ 0 → h ≥ 0 → \n  ∃ n : NumberWord, wallpaper l w h = n := sorry\n\n/-\ninfo: 'ten'\n-/\n-- #guard_msgs in\n-- #eval wallpaper 4.0 3.5 3.0\n\n/-\ninfo: 'zero'\n-/\n-- #guard_msgs in\n-- #eval wallpaper 0.0 3.5 3.0\n\n/-\ninfo: 'sixteen'\n-/\n-- #guard_msgs in\n-- #eval wallpaper 6.3 4.5 3.29", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4566", "language": "lean", "source": "fvapps", "source-id": "fvapps_004566", "source-notes": "", "vc-description": "/-\nWe have a distribution of probability of a discrete variable (it may have only integer values)\n```\nx       P(x)\n0       0.125\n1       0.375\n2       0.375\n3       0.125\nTotal = 1.000   # The sum of the probabilities for all the possible values should be one (=1)\n```\nThe mean, ```μ```,  of the values of x is:\n\nFor our example\n```\nμ = 0*0.125 + 1*0.375 + 2*0.375 + 3*0.125 = 1.5\n```\n\nThe variance, ```σ²``` is:\n\nFor our example :\n```\nσ² = 0.75\n```\n\nThe standard deviation, ```σ``` is:\n\nFinally, for our example:\n```\nσ = 0.8660254037844386\n```\nMake the function ```stats_disc_distr()``` that receives a 2D array. Each internal array will have a pair of values: the first one, the value of the variable ```x``` and the second one its correspondent probability, ```P(x)```.\n\nFor the example given above:\n```python\nstats_disc_distr([[0, 0.125], [1, 0.375], [2, 0.375], [3, 0.125]]) == [1.5, 0.75, 0.8660254037844386]\n```\nThe function should check also if it is a valid distribution.\n\nIf the sum of the probabilities is different than ```1```, the function should output an alert.\n```python\nstats_disc_distr([[0, 0.425], [1, 0.375], [2, 0.375], [3, 0.125]]) == \"It's not a valid distribution\"\n```\nIf one of the values of ```x``` is not an integer, the function will give a specific alert:\n```python\nstats_disc_distr([[0.1, 0.425], [1.1, 0.375], [2, 0.375], [3, 0.125]]) == \"All the variable values should be integers\"\n```\n\nIf the distribution has both problems will output another specific alert:\n```python\nstats_disc_distr([[0.1, 0.425], [1.1, 0.375], [2, 0.375], [3, 0.125]]) == \"It's not a valid distribution and furthermore, one or more variable value are not integers\"\n```\nBut if a value is a float with its decimal part equals to 0 will proceed without inconveniences, (if the sum of probabilities is ```1```:\n```python\nstats_disc_distr([[0.0, 0.125], [1.0, 0.375], [2.0, 0.375], [3, 0.125]]) == [1.5, 0.75, 0.8660254037844386]\n```\n\nThe 2Darray will not have any strings.\n\nEnjoy it!!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def statsDiscDistr (distrib : List (Int × Float)) : List Float := sorry\n\ntheorem valid_distribution_properties\n  (distrib : ProbDistr) :\n  let result := statsDiscDistr distrib.dist\n  -- result is list of length 3\n  result.length = 3 ∧\n  -- mean, var, std_dev destructuring\n  let mean := result[0]!\n  let var := result[1]!  \n  let std_dev := result[2]!\n  -- properties\n  var = std_dev * std_dev ∧\n  var ≥ 0 ∧\n  std_dev ≥ 0 :=\nsorry", "vc-theorems": "/-\ninfo: [1.5, 0.75, 0.8660254037844386]\n-/\n-- #guard_msgs in\n-- #eval stats_disc_distr [[0, 0.125], [1, 0.375], [2, 0.375], [3, 0.125]]\n\n/-\ninfo: \"It's not a valid distribution\"\n-/\n-- #guard_msgs in\n-- #eval stats_disc_distr [[0, 0.425], [1, 0.375], [2, 0.375], [3, 0.125]]\n\n/-\ninfo: \"It's not a valid distribution and furthermore, one or more variable value are not integers\"\n-/\n-- #guard_msgs in\n-- #eval stats_disc_distr [[0.1, 0.425], [1.1, 0.375], [2, 0.375], [3, 0.125]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4580", "language": "lean", "source": "fvapps", "source-id": "fvapps_004580", "source-notes": "", "vc-description": "/-\nJohn and Mary want to travel between a few towns A, B, C ... Mary has on a sheet of paper a list of distances between these towns.\n`ls = [50, 55, 57, 58, 60]`.\nJohn is tired of driving and he says to Mary that he doesn't want to drive more than `t = 174 miles` and he\nwill visit only `3` towns.\n\nWhich distances, hence which towns, they will choose so that the sum of the distances is the biggest possible to please Mary and John?\n\nExample: \n\nWith list `ls` and 3 towns to visit they can make a choice between: \n`[50,55,57],[50,55,58],[50,55,60],[50,57,58],[50,57,60],[50,58,60],[55,57,58],[55,57,60],[55,58,60],[57,58,60]`.\n\nThe sums of distances are then:\n`162, 163, 165, 165, 167, 168, 170, 172, 173, 175`.\n\nThe biggest possible sum taking a limit of `174` into account is then `173` and the distances of the `3` \ncorresponding towns is `[55, 58, 60]`.\n\nThe function `chooseBestSum` (or `choose_best_sum` or ... depending on the language) will take as parameters `t` (maximum sum of distances, integer >= 0), `k` (number of towns to visit, k >= 1) \nand `ls` (list of distances, all distances are positive or null integers and this list has at least one element).\nThe function returns the \"best\" sum ie the biggest possible sum of `k` distances less than or equal to the given limit `t`, if that sum exists,\nor otherwise nil, null, None, Nothing, depending on the language. With C++, C, Rust, Swift, Go, Kotlin return `-1`.\n\nExamples: \n\n`ts = [50, 55, 56, 57, 58]`\n`choose_best_sum(163, 3, ts) -> 163`\n\n`xs = [50]`\n`choose_best_sum(163, 3, xs) -> nil (or null or ... or -1 (C++, C, Rust, Swift, Go)`\n\n`ys = [91, 74, 73, 85, 73, 81, 87]`\n`choose_best_sum(230, 3, ys) -> 228`\n\nNote: don't modify the input list `ls`\n-/", "vc-preamble": "def List.combinations (ls : List α) (k : Nat) : List (List α) :=\n  sorry\n\nabbrev List.sum (ls : List Int) : Int :=\n  ls.foldl (· + ·) 0", "vc-helpers": "", "vc-definitions": "def choose_best_sum (t : Int) (k : Nat) (ls : List Int) : Option Int :=\n  sorry", "vc-theorems": "theorem result_not_exceeds_target \n  (t : Int) (k : Nat) (ls : List Int)\n  (h1 : t ≥ 1) (h2 : k ≥ 1) (h3 : !ls.isEmpty)\n  (h4 : ∀ x ∈ ls, x ≥ 1 ∧ x ≤ 100) :\n  (choose_best_sum t k ls).all (· ≤ t) :=\nsorry\n\ntheorem none_if_k_too_large\n  (t : Int) (k : Nat) (ls : List Int)\n  (h1 : t ≥ 1)\n  (h2 : k > ls.length)\n  (h3 : ∀ x ∈ ls, x ≥ 1) :\n  choose_best_sum t k ls = none :=\nsorry\n\ntheorem result_is_sum_of_k_numbers\n  (t : Int) (k : Nat) (ls : List Int)\n  (h1 : t ≥ 1) (h2 : k ≥ 1)\n  (h3 : ls.length ≥ 5)\n  (h4 : ∀ x ∈ ls, x ≥ 1 ∧ x ≤ 100)\n  (h5 : (choose_best_sum t k ls).isSome) :\n  ∃ subset : List Int,\n    subset ∈ ls.combinations k ∧ \n    subset.sum = Option.get! (choose_best_sum t k ls) :=\nsorry\n\ntheorem edge_cases :\n  choose_best_sum 100 3 [] = none ∧\n  choose_best_sum (-1) 3 [1,2,3] = none ∧ \n  choose_best_sum 100 0 [1,2,3] = none :=\nsorry\n\n/-\ninfo: 163\n-/\n-- #guard_msgs in\n-- #eval choose_best_sum 163 3 [50, 55, 56, 57, 58]\n\n/-\ninfo: None\n-/\n-- #guard_msgs in\n-- #eval choose_best_sum 163 3 [50]\n\n/-\ninfo: 228\n-/\n-- #guard_msgs in\n-- #eval choose_best_sum 230 3 [91, 74, 73, 85, 73, 81, 87]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4581", "language": "lean", "source": "fvapps", "source-id": "fvapps_004581", "source-notes": "", "vc-description": "/-\nYou get some nested lists. Keeping the original structures, sort only elements (integers) inside of the lists. In other words, sorting the intergers only by swapping their positions. \n\n```\nExample\nInput   : [[[2, 1], [4, 3]], [[6, 5], [8, 7]]]\nOutput  : [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n```\n\nNote:\nThe structures of the lists are regular (symmetrical) and their depths are 3.\n-/", "vc-preamble": "def List.isSameStructure : List α → List α → Bool\n  | [], [] => true \n  | _::xs, _::ys => isSameStructure xs ys\n  | _, _ => false\n\ndef getAllNumbers : List (List (List Int)) → List Int\n| [] => []\n| (x::xs) => getAllNumbers' x ++ getAllNumbers xs\nwhere getAllNumbers' : List (List Int) → List Int\n  | [] => []\n  | (y::ys) => y ++ getAllNumbers' ys", "vc-helpers": "", "vc-definitions": "def sortNestedNumbers (nested: List (List (List Int))) : List (List (List Int)) :=\n  sorry", "vc-theorems": "theorem sort_nested_preserves_structure (nested: List (List (List Int))) :\n  List.isSameStructure nested (sortNestedNumbers nested) := sorry\n\ntheorem sort_nested_preserves_numbers (nested: List (List (List Int))) :\n  ∀ x, (x ∈ getAllNumbers nested ↔ x ∈ getAllNumbers (sortNestedNumbers nested)) := sorry\n\ntheorem sort_nested_inner_sorted (nested: List (List (List Int))) :\n  ∀ middle inner, middle ∈ sortNestedNumbers nested → \n    inner ∈ middle → IsSorted inner := sorry\n\ntheorem sort_nested_globally_sorted (nested: List (List (List Int))) :\n  IsSorted (getAllNumbers (sortNestedNumbers nested)) := sorry\n\ntheorem sort_nested_preserves_length (nested: List (List (List Int))) \n  (h1: List.length nested = n)\n  (h2: ∀ middle ∈ nested, List.length middle = m)\n  (h3: ∀ middle ∈ nested, ∀ inner ∈ middle, List.length inner = k) :\n  (List.length (sortNestedNumbers nested) = n) ∧\n  (∀ middle ∈ sortNestedNumbers nested, List.length middle = m) ∧\n  (∀ middle ∈ sortNestedNumbers nested, ∀ inner ∈ middle, List.length inner = k) := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4584", "language": "lean", "source": "fvapps", "source-id": "fvapps_004584", "source-notes": "", "vc-description": "/-\n## Description\n\nWelcome, Warrior! In this kata, you will get a message and you will need to get the frequency of each and every character!\n\n## Explanation\n\nYour function will be called `char_freq`/`charFreq`/`CharFreq` and you will get passed a string, you will then return a dictionary (object in JavaScript) with as keys the characters, and as values how many times that character is in the string. You can assume you will be given valid input. \n\n## Example\n\n```python\nchar_freq(\"I like cats\") // Returns {'a': 1, ' ': 2, 'c': 1, 'e': 1, 'I': 1, 'k': 1, 'l': 1, 'i': 1, 's': 1, 't': 1}\n```\n-/", "vc-preamble": "def List.sum : List Nat → Nat\n  | [] => 0\n  | x::xs => x + sum xs", "vc-helpers": "", "vc-definitions": "def char_freq (s : String) : CharFreq := sorry\n\ntheorem char_freq_sum_equals_length (s : String) :\n  let result := char_freq s\n  (List.map (fun c => (result.count c)) s.data).sum = s.length := sorry", "vc-theorems": "theorem char_freq_contains_all_chars (s : String) :\n  let result := char_freq s\n  ∀ c, c ∈ s.data → result.count c > 0 := sorry\n\ntheorem char_freq_positive_counts (s : String) :\n  let result := char_freq s\n  ∀ c, result.count c > 0 → c ∈ s.data := sorry\n\ntheorem char_freq_accurate_counts (s : String) :\n  let result := char_freq s\n  ∀ c, (s.data.filter (λ x => x = c)).length = result.count c := sorry\n\ntheorem char_freq_max_exists (s : String) (h : s.length > 0) :\n  let result := char_freq s\n  ∃ c ∈ s.data, ∀ d ∈ s.data, result.count c ≥ result.count d := sorry\n\ntheorem char_freq_concatenation (s₁ s₂ : String) :\n  let result₁ := char_freq s₁\n  let result₂ := char_freq s₂\n  let result_combined := char_freq (s₁ ++ s₂)\n  ∀ c, result_combined.count c = result₁.count c + result₂.count c := sorry\n\n/-\ninfo: {'a': 1, ' ': 2, 'c': 1, 'e': 1, 'I': 1, 'k': 1, 'l': 1, 'i': 1, 's': 1, 't': 1}\n-/\n-- #guard_msgs in\n-- #eval char_freq \"I like cats\"\n\n/-\ninfo: {'H': 1, 'e': 1, 'l': 2, 'o': 1}\n-/\n-- #guard_msgs in\n-- #eval char_freq \"Hello\"\n\n/-\ninfo: {'a': 3}\n-/\n-- #guard_msgs in\n-- #eval char_freq \"aaa\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4585", "language": "lean", "source": "fvapps", "source-id": "fvapps_004585", "source-notes": "", "vc-description": "/-\nQuite recently it happened to me to join some recruitment interview, where my first task was to write own implementation of built-in split function. It's quite simple, is it not?\n\nHowever, there were the following conditions:\n\n* the function **cannot** use, in any way, the original `split` or `rsplit` functions,\n* the new function **must** be a generator,\n* it should behave as the built-in `split`, so it will be tested that way -- think of `split()` and `split('')`\n\n*This Kata will control if the new function is a generator and if it's not using the built-in split method, so you may try to hack it, but let me know if with success, or if something would go wrong!*\n\nEnjoy!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def my_very_own_split (s : String) (delimiter : String) : List String :=\n  sorry", "vc-theorems": "theorem split_matches_python_split (s : String) (delimiter : String) \n  (h : delimiter.length > 0) :\n  my_very_own_split s delimiter = s.splitOn delimiter := \n  sorry\n\ntheorem split_empty_delimiter_raises (s : String) :\n  delimiter.length = 0 → my_very_own_split s delimiter = [] := \n  sorry\n\ntheorem split_parts_recombine (s delimiter : String) \n  (h : delimiter.length > 0) \n  (parts := my_very_own_split s delimiter)\n  (h2 : parts.length > 1) :\n  String.intercalate delimiter parts = s :=\n  sorry\n\ntheorem split_no_empty_middle_parts (s delimiter : String)\n  (h : delimiter.length > 0) \n  (parts := my_very_own_split s delimiter)\n  (middle_parts := parts.drop 1 |>.take (parts.length - 2)) :\n  ∀ p ∈ middle_parts, p ≠ \"\" := \n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4588", "language": "lean", "source": "fvapps", "source-id": "fvapps_004588", "source-notes": "", "vc-description": "/-\nA circle is defined by three coplanar points that are not aligned.\n\nYou will be given a list of circles and a point [xP, yP]. You have to create a function, ```count_circles()``` (Javascript ```countCircles()```), that will count the amount of circles that contains the point P inside (the circle border line is included).\n\n```python\nlist_of_circles = ([[[-3,2], [1,1], [6,4]], [[-3,2], [1,1], [2,6]], [[1,1], [2,6], [6,4]], [[[-3,2],[2,6], [6,4]]]\n\npoint1 = [1, 4] # P1\ncount_circles(list_of_circles, point1) == 4 #(The four circles have P1 inside)\n```\n\nIt may happen that the point may be external to all the circles.\n\n```python\nlist_of_circles = ([[[-3,2], [1,1], [6,4]], [[-3,2], [1,1], [2,6]], [[1,1], [2,6], [6,4]], [[-3,2],[2,6], [6,4]]]\n\npoint2 = [10, 6] # P2\ncount_circles(list_of_circles, point2) == 0 #(P2 is exterior to the four circles)\n```\nThe point may be in the circle line and that will be consider as an internal point of it, too. \nFor practical purposes a given point ```P``` will be in the circle line if: \n         |r - d|/r < 10^(-10)\n\n```r```: radius of the circle that should be calculated from the coordinates of the three given points.\n\n```d```: distance from the point ```P``` to the center of the circle. Again we have to do a calculation, the coordinates of the center should be calculated using the coordinates of the three given points.\n\nLet's see a case when the pints is in the circle line.\n\n```python\nlist_of_circles = ([[[-3,2], [1,1], [6,4]], [[-3,2], [1,1], [2,6]], [[1,1], [2,6], [6,4]], [[[-3,2],[2,6], [6,4]]]\n\npoint3 = point2 = [2, 6] # P3\ncount_circles(list_of_circles, point3) == 4 #(P3  is an internal point of the four circles)\n```\n\nAll these three cases are shown in the image below:\n\nYour code should be able to skip these cases:\n\n- inexistent circle when we have three points aligned\n\n- undefined circles when two or three of given points coincides.\n\nFirst ten people to solve it will receive extra points.\n\nHints: This kata will give you important formulas: ```Give The Center And The Radius of Circumscribed Circle. (A warm up challenge)```\n```http://www.codewars.com/kata/give-the-center-and-the-radius-of-circumscribed-circle-a-warm-up-challenge```\n\nFeatures of the tests:\n\n```N: amount of Tests```\n\n```n: amount of given circles```\n```x, y: coordinates of the points that define the circle```\n```xP, yP: coordinates of the point P```\n```N = 500```\n```10 < n < 500```\n```-500 < x < 500, -500 < y < 500```\n```-750 < xP < -750, -750 < yP < -750```\n-/", "vc-preamble": "def dist (p1 p2 : Point) : Float :=\n  Float.sqrt ((p1.x - p2.x)^2 + (p1.y - p2.y)^2)\n\n/- Given three points, returns the center and radius of their circumscribed circle -/\n\ndef circum_curvat (p₁ p₂ p₃ : Point) : Point × Float := sorry\n\n/- Counts how many circles contain a given point -/", "vc-helpers": "", "vc-definitions": "def count_circles (circles : List (List Point)) (p : Point) : Nat := sorry\n\ntheorem count_circles_bounds {circles : List (List Point)} {p : Point} :\n  0 ≤ count_circles circles p ∧ count_circles circles p ≤ circles.length := sorry", "vc-theorems": "theorem circle_contains_defining_points {p₁ p₂ p₃ : Point} :\n  let (center, radius) := circum_curvat p₁ p₂ p₃\n  dist p₁ center ≤ radius ∧ \n  dist p₂ center ≤ radius ∧\n  dist p₃ center ≤ radius := sorry\n\n/- Points used to define circle must not be collinear -/\n\ntheorem circle_points_not_collinear {p₁ p₂ p₃ : Point} \n  (h : circum_curvat p₁ p₂ p₃ = (center, radius)) :\n  let area := Float.abs ((p₁.x * (p₂.y - p₃.y) + \n                         p₂.x * (p₃.y - p₁.y) + \n                         p₃.x * (p₁.y - p₂.y)) / 2)\n  area > 0 := sorry\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval count_circles [[[-3, 2], [1, 1], [6, 4]], [[-3, 2], [1, 1], [2, 6]], [[1, 1], [2, 6], [6, 4]], [[-3, 2], [2, 6], [6, 4]]] [1, 4]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval count_circles circles1 [10, 6]\n\n/-\ninfo: 4\n-/\n-- #guard_msgs in\n-- #eval count_circles circles1 [2, 6]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4593", "language": "lean", "source": "fvapps", "source-id": "fvapps_004593", "source-notes": "", "vc-description": "/-\nThe special score(ssc) of an array of integers will be the sum of each integer multiplied by its corresponding index plus one in the array.\n\nE.g.: with the array  ```[6, 12, -1]```\n```\narr =   [6,      12,       -1 ]\nssc =   1*6  +  2* 12 +  3.(*1) = 6 + 24 - 3 = 27\n```\nThe array given in the example has six(6) permutations and are with the corresponding ssc:\n```\nPermutations      Special Score (ssc)\n[6, 12, -1]      1*6 + 2*12 + 3*(-1) = 27\n[6, -1, 12]       1*6 + 2*(-1) + 3*12 = 40\n[-1, 6, 12]       1*(-1) + 2*6 + 3*12 = 47\n[-1, 12, 6]       1*(-1) + 2*12 + 3*6 = 41\n[12, -1, 6]       1*12 + 2*(-1) + 3*6 = 28\n[12, 6, -1]       1*12 + 2*6 + 3*(-1) = 21\n```\nThe total sum of the ```ssc's``` of all the possible permutations is: ```27 + 40 + 47 + 41 + 28 + 21 = 204```\n\nThe maximum value for the ```ssc``` is ```47```.\n\nThe minimum value for the ```ssc``` is ```21```.\n\nWe need a special function ```ssc_forperm()``` that receives an array of uncertain number of elements (the elements may occur more than once) and may output a list of dictionaries with the following data:\n```\n[{\"total perm\":__}, {\"total ssc\": ___}, {\"max ssc\": __}, {\"min ssc\": __}]\n```\nFor the example we have above will be:\n```python\nssc_forperm([6, 12, -1]) = [{\"total perm\":6}, {\"total ssc:204}, {\"max ssc\":47}, {\"min ssc\":21}]\n```\nYou may assume that you will never receive an empty array.\n\nAlso you will never receive an array with the same element in all the positions like [1, 1, 1, 1 ,1], but you may have elements occuring twice or more like [1, 1, 1, 2, 3]\n\nEnjoy it!!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def ssc_forperm (arr : List Int) : Record :=\n  sorry", "vc-theorems": "theorem ssc_forperm_result_bounds (arr : List Int) \n  (h : arr.length = 3) :\n  let result := ssc_forperm arr\n  result.minSsc ≤ result.maxSsc := by\n  sorry\n\ntheorem ssc_forperm_total_perms (arr : List Int)\n  (h : arr.length = 3) :\n  let result := ssc_forperm arr\n  let num_unique := arr.eraseDups.length\n  (num_unique = 3 → result.totalPerm = 6) ∧\n  (num_unique = 2 → result.totalPerm = 3) ∧\n  (num_unique = 1 → result.totalPerm = 1) := by\n  sorry\n\ntheorem ssc_forperm_total_ssc_multiple (arr : List Int)\n  (h : arr.length = 3) :\n  let result := ssc_forperm arr\n  result.totalSsc % result.totalPerm = 0 := by\n  sorry\n\ntheorem ssc_forperm_special_case : \n  ssc_forperm [1,1,2] = {\n    totalPerm := 3,\n    totalSsc := 21,\n    maxSsc := 7,\n    minSsc := 7\n  } := by\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4599", "language": "lean", "source": "fvapps", "source-id": "fvapps_004599", "source-notes": "", "vc-description": "/-\n#Split all even numbers to odd ones in different ways\n\nYour task is to split all even numbers from an array to odd ones. So your method has to return a new array with only odd numbers.\n\nFor \"splitting\" the numbers there are four ways.\n\n```\n0 -> Split into two odd numbers, that are closest to each other.\n     (e.g.: 8 -> 3,5)\n1 -> Split into two odd numbers, that are most far from each other.\n     (e.g.: 8 -> 1,7)\n2 -> All new odd numbers from the splitting should be equal and the maximum possible number.\n     (e.g.: 8 -> 1, 1, 1, 1, 1, 1, 1, 1)\n3 -> Split into 1s.\n     (e.g.: 8 -> 1, 1, 1, 1, 1, 1, 1, 1)\nThe new numbers (from the splitting) have always to be in ascending order.\nSo in the array every even number is replaced by the new odd numbers from the splitting.\n```\n\nYour method will get as parameters the input-array and the number of the way for splitting the even numbers.\n\nSome Examples\n```\n[1,10,1,3],0 -> [1,5,5,1,3]\n[1,10,1,3],1 -> [1,1,9,1,3]\n[1,10,1,3],2 -> [1,5,5,1,3]\n[1,10,1,3],3 -> [1,1,1,1,1,1,1,1,1,1,1,1,3]\n\n[1,1,3,8],0 -> [1,1,3,3,5]\n[1,1,3,8],1 -> [1,1,3,1,7]\n[1,1,3,8],2 -> [1,1,3,1,1,1,1,1,1,1,1]\n[1,1,3,8],3 -> [1,1,3,1,1,1,1,1,1,1,1]\n```\n\nThe array will never be null and will always contain only integer numbers > 0. Also your result-array must contain only integer numbers > 0.\nThe way-parameter will always be between inclusive 0 and inclusive 3 (0,1,2,3).\n\nYou must not change the input-array!\n\nHave fun coding it and please don't forget to vote and rank this kata! :-) \n\nI have also created other katas. Take a look if you enjoyed this kata!\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (x::xs) => x + List.sum xs", "vc-helpers": "", "vc-definitions": "def split_all_even_numbers (numbers: List Nat) (split_type: Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem split_all_even_numbers_preserves_sum \n  (numbers: List Nat) (split_type: Nat) (h: split_type ≤ 3) :\n  List.sum numbers = List.sum (split_all_even_numbers numbers split_type) :=\n  sorry\n\ntheorem split_all_even_numbers_positive\n  (numbers: List Nat) (split_type: Nat) (h1: split_type ≤ 3) (h2: ∀ n ∈ numbers, n > 0) : \n  ∀ n ∈ (split_all_even_numbers numbers split_type), n > 0 :=\n  sorry\n\ntheorem split_all_even_numbers_preserves_odd\n  (numbers: List Nat) (split_type: Nat) (h: split_type ≤ 3) :\n  ∀ n ∈ numbers, n % 2 = 1 → n ∈ (split_all_even_numbers numbers split_type) :=\n  sorry\n\n/-\ninfo: [1, 5, 5, 1, 3]\n-/\n-- #guard_msgs in\n-- #eval split_all_even_numbers [1, 10, 1, 3] 0\n\n/-\ninfo: [1, 1, 9, 1, 3]\n-/\n-- #guard_msgs in\n-- #eval split_all_even_numbers test1 1\n\n/-\ninfo: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3]\n-/\n-- #guard_msgs in\n-- #eval split_all_even_numbers test1 3\n\n/-\ninfo: [1, 1, 3, 3, 5]\n-/\n-- #guard_msgs in\n-- #eval split_all_even_numbers [1, 1, 3, 8] 0\n\n/-\ninfo: [1, 1, 3, 1, 7]\n-/\n-- #guard_msgs in\n-- #eval split_all_even_numbers test2 1\n\n/-\ninfo: [1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1]\n-/\n-- #guard_msgs in\n-- #eval split_all_even_numbers test2 2", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4600", "language": "lean", "source": "fvapps", "source-id": "fvapps_004600", "source-notes": "", "vc-description": "/-\n# Task\n Given two cells on the standard chess board, determine whether they have the same color or not.\n\n# Example\n\n For `cell1 = \"A1\" and cell2 = \"C3\"`, the output should be `true`.\n For `cell1 = \"A1\" and cell2 = \"H3\"`, the output should be `false`.\n\n# Input/Output\n\n - `[input]` string `cell1`\n\n - `[input]` string `cell2`\n\n - `[output]` a boolean value\n\n    `true` if both cells have the same color, `false` otherwise.\n-/", "vc-preamble": "def chess_board_cell_color : Cell → Cell → Bool := sorry\n\ntheorem chess_board_symmetry (c1 c2 : Cell) : \n  chess_board_cell_color c1 c2 = chess_board_cell_color c2 c1 := sorry", "vc-helpers": "", "vc-definitions": "def nextChar (c : Char) : Char := \n  Char.ofNat ((Char.toNat c) + 1)", "vc-theorems": "theorem chess_board_self_same_color (c : Cell) :\n  chess_board_cell_color c c = true := sorry\n\ntheorem chess_board_transitivity (c1 c2 c3 : Cell) :\n  chess_board_cell_color c1 c2 = true → \n  chess_board_cell_color c2 c3 = true →\n  chess_board_cell_color c1 c3 = true := sorry\n\ntheorem chess_board_adjacent_vertical (c : Cell) (h : c.2 < 8) :\n  let above := Cell.mk c.1 (c.2 + 1)\n  chess_board_cell_color c above = false := sorry\n\ntheorem chess_board_adjacent_horizontal (c : Cell) (h : c.1 < 'H') :\n  let right := Cell.mk (nextChar c.1) c.2\n  chess_board_cell_color c right = false := sorry\n\n/-\ninfo: True\n-/\n-- #guard_msgs in\n-- #eval chess_board_cell_color \"A1\" \"C3\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval chess_board_cell_color \"A1\" \"H3\"\n\n/-\ninfo: False\n-/\n-- #guard_msgs in\n-- #eval chess_board_cell_color \"A1\" \"A2\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4602", "language": "lean", "source": "fvapps", "source-id": "fvapps_004602", "source-notes": "", "vc-description": "/-\n# Context\n\nAccording to Wikipedia : \"The seventh son of a seventh son is a concept from folklore regarding special powers given to, or held by, such a son. **The seventh son must come from an unbroken line with no female siblings born between, and be, in turn, born to such a seventh son.**\"\n\n# Your task\n\nYou will be given a string of JSON, consisting of a family tree containing people's names, genders and children. Your task will be to find the seventh sons of seventh sons in the family tree, and return a __set__ of their names. If there are none, return an __empty set__.\n\n## Tips\n\n* Have a good look at the sample test cases.\n\n* For a seventh son to be a seventh son, there must not be any daughters in the line leading to him. There may be daughters after him, though.\n\n* **You may want to use the json module for this one.**\n-/", "vc-preamble": "def Set (α : Type) := α → Prop\n\ndef find_seventh_sons_of_seventh_sons (json : String) : Set String :=\n  sorry\n\ndef fromJson? (s : String) : Option Person :=\n  sorry", "vc-helpers": "", "vc-definitions": "def collectNames (p : Person) : Set String :=\n  sorry\n\n/- Theorems about find_seventh_sons_of_seventh_sons -/", "vc-theorems": "theorem empty_tree (p : Person) (h : match p with | Person.mk _ _ children => children = []) :\n  find_seventh_sons_of_seventh_sons (toString p) = λ _ => False :=\nsorry\n\ntheorem result_is_subset (json : String) (tree : Person) (h : fromJson? json = some tree) :\n  let result := find_seventh_sons_of_seventh_sons json\n  let names := collectNames tree\n  ∀ x, result x → names x :=\nsorry\n\ntheorem leaf_nodes (name : String) (p : Person) \n  (h₁ : match p with | Person.mk n _ _ => n = name)\n  (h₂ : match p with | Person.mk _ g _ => g = \"male\") \n  (h₃ : match p with | Person.mk _ _ c => c = []) :\n  find_seventh_sons_of_seventh_sons (toString p) = λ _ => False :=\nsorry\n\ntheorem seventh_son_pattern (root father seventhSon seventhGrandson : Person)\n  (h₁ : match father with | Person.mk _ g _ => g = \"male\")\n  (h₂ : match father with | Person.mk _ _ c => List.length c = 7) \n  (h₃ : ∃ children, match father with | Person.mk _ _ c => c = children ∧ children.get? 6 = some seventhSon)\n  (h₄ : match seventhSon with | Person.mk _ g _ => g = \"male\")\n  (h₅ : match seventhSon with | Person.mk _ _ c => List.length c = 7)\n  (h₆ : ∃ children, match seventhSon with | Person.mk _ _ c => c = children ∧ children.get? 6 = some seventhGrandson)\n  (h₇ : match seventhGrandson with | Person.mk n _ _ => n = \"grandson7\") :\n  (find_seventh_sons_of_seventh_sons (toString root)) \"grandson7\" :=\nsorry\n\n/-\ninfo: set()\n-/\n-- #guard_msgs in\n-- #eval find_seventh_sons_of_seventh_sons \"\\n    {\\n        \"name\": \"John\",\\n        \"gender\": \"male\",\\n        \"children\": [\\n            {\"name\": \"Bob\", \"gender\": \"male\", \"children\": []},\\n            {\"name\": \"Amy\", \"gender\": \"female\", \"children\": []}\\n        ]\\n    }\\n    \"\n\n/-\ninfo: {'Target'}\n-/\n-- #guard_msgs in\n-- #eval find_seventh_sons_of_seventh_sons \"\\n    {\\n        \"name\": \"Root\",\\n        \"gender\": \"male\",\\n        \"children\": [\\n            {\\n                \"name\": \"Dad\",\\n                \"gender\": \"male\",\\n                \"children\": [\\n                    {\"name\": \"Son1\", \"gender\": \"male\", \"children\": []},\\n                    {\"name\": \"Son2\", \"gender\": \"male\", \"children\": []},\\n                    {\"name\": \"Son3\", \"gender\": \"male\", \"children\": []},\\n                    {\"name\": \"Son4\", \"gender\": \"male\", \"children\": []},\\n                    {\"name\": \"Son5\", \"gender\": \"male\", \"children\": []},\\n                    {\"name\": \"Son6\", \"gender\": \"male\", \"children\": []},\\n                    {\\n                        \"name\": \"Son7\",\\n                        \"gender\": \"male\",\\n                        \"children\": [\\n                            {\"name\": \"GSon1\", \"gender\": \"male\", \"children\": []},\\n                            {\"name\": \"GSon2\", \"gender\": \"male\", \"children\": []},\\n                            {\"name\": \"GSon3\", \"gender\": \"male\", \"children\": []},\\n                            {\"name\": \"GSon4\", \"gender\": \"male\", \"children\": []},\\n                            {\"name\": \"GSon5\", \"gender\": \"male\", \"children\": []},\\n                            {\"name\": \"GSon6\", \"gender\": \"male\", \"children\": []},\\n                            {\"name\": \"Target\", \"gender\": \"male\", \"children\": []}\\n                        ]\\n                    }\\n                ]\\n            }\\n        ]\\n    }\\n    \"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4603", "language": "lean", "source": "fvapps", "source-id": "fvapps_004603", "source-notes": "", "vc-description": "/-\nThe year is 2088 and the Radical Marxist Socialist People's Party (RMSPP) has just seized power in Brazil.\n\nTheir first act in power is absolute wealth equality through coercive redistribution.\n\nCreate a function that redistributes all wealth equally among all citizens.\n\nWealth is represented as an array/list where every index is the wealth of a single citizen. The function should mutate the input such that every index has the same amount of wealth. **MUTATE the input array/list, don't return anything.**\n\nSee example:\n\n```python\nwealth = [5, 10, 6]  # This represents:\n                     # citizen 1 has wealth 5\n                     # citizen 2 has wealth 10\n                     # citizen 3 has wealth 6\n\nredistribute_wealth(wealth) # mutates wealth list\nwealth => [7, 7, 7] # wealth has now been equally redistributed\n\n```\n\nInfo:\n\n- **MUTATE the input array/list, don't return anything**\n\n- Input is garantueed to hold at least 1 or more citizens\n\n- Wealth of citizen will an integer with minimum 0 (negative wealth not possible)\n\n- Handling of floating point error will not be tested\n-/", "vc-preamble": "def List.sum [Add α] : List α → α \n  | [] => sorry\n  | (x::xs) => x + List.sum xs\n\ndef redistributeWealth (l : List Int) : List Int :=\n  sorry", "vc-helpers": "", "vc-definitions": "def redistributeWealthFloat (l : List Float) : List Float :=\n  sorry", "vc-theorems": "theorem redistributeWealth_preserves_length (l : List Int) :\n  (redistributeWealth l).length = l.length := by sorry\n\ntheorem redistributeWealth_all_equal (l : List Int) (h : l.length > 0) :\n  ∀ x ∈ redistributeWealth l, x = (redistributeWealth l).head! := by sorry\n\ntheorem redistributeWealth_preserves_sum (l : List Int) :\n  (redistributeWealth l).sum = l.sum := by sorry\n\ntheorem redistributeWealth_gives_mean (l : List Int) (h : l.length > 0) :\n  ∀ x ∈ redistributeWealth l, x = l.sum / l.length := by sorry\n\ntheorem redistributeWealthFloat_preserves_length (l : List Float) :\n  (redistributeWealthFloat l).length = l.length := by sorry\n\ntheorem redistributeWealthFloat_all_equal (l : List Float) (h : l.length > 0) :\n  ∀ x ∈ redistributeWealthFloat l, x = (redistributeWealthFloat l).head! := by sorry\n\ntheorem redistributeWealthFloat_preserves_sum (l : List Float) :\n  (redistributeWealthFloat l).sum = l.sum := by sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4605", "language": "lean", "source": "fvapps", "source-id": "fvapps_004605", "source-notes": "", "vc-description": "/-\n# Story\n\nYou were supposed to implement a node-based calculator. Hopefully for you, a colleague agreed to do the task. When the management saw the code, they were infuriated with its low quality, and as a punishment told you to shorten it as much as possible...\n\n___\n\n# Task\n\nYou will be given a ready solution passing all the fixed and random tests. Unfortunately for you, it is very long and overly repetitive. Current code length is `901` characters. Your task is to shorten it to at most `300` characters.\n\n**Note/hint**: you can modify the implementation any way you want, as long as it is written using only OOP; the sample tests check solution's functionality the same way as the final tests do - if your solution passes the former, it will also pass the latter.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def compute : Expr → Int\n  | Expr.value n => n\n  | Expr.add a b => compute a + compute b\n  | Expr.sub a b => compute a - compute b\n  | Expr.mul a b => compute a * compute b\n  | Expr.truediv a b => compute a / compute b\n  | Expr.mod a b => compute a % compute b\n  | Expr.pow a b => compute a ^ (compute b).natAbs", "vc-theorems": "theorem expr_compute_matches_operator (e : Expr) :\n  match e with\n  | Expr.value n => compute e = n\n  | Expr.add a b => compute e = compute a + compute b\n  | Expr.sub a b => compute e = compute a - compute b \n  | Expr.mul a b => compute e = compute a * compute b\n  | Expr.truediv a b => compute e = compute a / compute b\n  | Expr.mod a b => compute e = compute a % compute b \n  | Expr.pow a b => compute e = compute a ^ (compute b).natAbs\n  := by sorry\n\ntheorem value_preserves_int (x : Int) :\n  compute (Expr.value x) = x := by sorry \n\ntheorem operator_composition (e₁ e₂ : Expr) :\n  compute (Expr.add e₁ e₂) = compute e₁ + compute e₂ ∧\n  compute (Expr.mul e₁ e₂) = compute e₁ * compute e₂ ∧ \n  compute (Expr.sub e₁ e₂) = compute e₁ - compute e₂ := by sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4606", "language": "lean", "source": "fvapps", "source-id": "fvapps_004606", "source-notes": "", "vc-description": "/-\nThis series of katas will introduce you to basics of doing geometry with computers.\n\n`Point` objects have `x`, `y`,  and `z` attributes. For Haskell there are `Point` data types described with record syntax with fields `x`, `y`, and `z`.\n\nWrite a function calculating distance between `Point a` and `Point b`.\n\nTests round answers to 6 decimal places. Tests in Haskell will not round.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def distance_between_points (p1 p2 : Point) : Float :=\n  sorry", "vc-theorems": "theorem distance_symmetric (p1 p2 : Point) :\n  distance_between_points p1 p2 = distance_between_points p2 p1 :=\n  sorry\n\ntheorem distance_to_self (p : Point) :\n  distance_between_points p p = 0 :=\n  sorry\n\ntheorem triangle_inequality (p1 p2 p3 : Point) :\n  distance_between_points p1 p3 ≤ \n  distance_between_points p1 p2 + distance_between_points p2 p3 :=\n  sorry\n\ntheorem distance_matches_formula (p1 p2 : Point) :\n  distance_between_points p1 p2 = \n  Float.sqrt ((p2.x - p1.x)^2 + (p2.y - p1.y)^2 + (p2.z - p1.z)^2) :=\n  sorry\n\n/-\ninfo: 5.196152\n-/\n-- #guard_msgs in\n-- #eval distance_between_points Point(1, 2, 3) Point(4, 5, 6)\n\n/-\ninfo: 1.732051\n-/\n-- #guard_msgs in\n-- #eval distance_between_points Point(0, 0, 0) Point(1, 1, 1)\n\n/-\ninfo: 3.464102\n-/\n-- #guard_msgs in\n-- #eval distance_between_points Point(-1, -1, -1) Point(1, 1, 1)", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4610", "language": "lean", "source": "fvapps", "source-id": "fvapps_004610", "source-notes": "", "vc-description": "/-\nAccording to Gary Chapman, marriage counselor and the author of [\"The Five Love Languages\"](https://en.wikipedia.org/wiki/The_Five_Love_Languages) books, there are five major ways to express our love towards someone: *words of affirmation, quality time, gifts, acts of service,* and *physical touch*. These are called the love languages. Usually, everyone has a main language: the one that he/she \"speaks\" and understands best. In a relationship, it's import to find your partner's main love language, so that you get along better with each other.\n\n## Your task\n\nUnfortunately, your relationship got worse lately... After a long discussion with your partner, you agreed to give yourself a few weeks to improve it, otherwise you split up...\n\nYou will be given a `partner` instance, and `n` weeks. The `partner`  has a `.response` method, and the responses may be: `\"positive\"` or `\"neutral\"`. You can try to get a response once a day, thus you have `n * 7` tries in total to find the main love language of your partner!\n\n```if-not:haskell\nThe love languages are: `\"words\", \"acts\", \"gifts\", \"time\", \"touch\"` (available predefined as `LOVE_LANGUAGES`)\n```\n```if:haskell\nThe love languages are: `Words, Acts, Gifts, Time, Touch` ( available `Preloaded` as `LoveLanguage` )\n```\n\nNote: your partner may (and will) sometimes give a positive response to any love language (\"false positive\"), but the main one has a much higher possibility. On the other hand, you may get a neutral response even for the main language, but with a low possibility (\"false negative\").\n\nThere will be 50 tests. Although it's difficult to fail, in case you get unlucky, just run the tests again. After all, a few weeks may not be enough...\n\n## Examples\n\n```python\nmain love language: \"words\"\n\npartner.response(\"words\") ==> \"positive\"\npartner.response(\"acts\")  ==> \"neutral\"\npartner.response(\"words\") ==> \"positive\"\npartner.response(\"time\")  ==> \"neutral\"\npartner.response(\"acts\")  ==> \"positive\"    # false positive\npartner.response(\"gifts\") ==> \"neutral\"\npartner.response(\"words\") ==> \"neutral\"     # false negative\netc.\n```\n\n~~~if:haskell\n## Notes\n\n`Preloaded` exports the following:\n\n~~~\n\nHappy coding, and **DO** try this at home! :-)\n\n---\n\n## My other katas\n\nIf you enjoyed this kata then please try [my other katas](https://www.codewars.com/collections/katas-created-by-anter69)! :-)\n\n#### *Translations are welcome!*\n-/", "vc-preamble": "def Response := String\ndef Partner := LoveLanguage → Response", "vc-helpers": "", "vc-definitions": "def love_language (p : Partner) (weeks : Nat) : LoveLanguage := sorry\n\ntheorem love_language_returns_valid_language \n  (p : Partner) (weeks : Nat) : \n  ∃ (l : LoveLanguage), love_language p weeks = l :=\nsorry", "vc-theorems": "theorem preferred_language_detected \n  (main_language : LoveLanguage) \n  (p : Partner) \n  (h : ∀ l, p l = if l = main_language then \"positive\" else \"neutral\") :\n  love_language p 4 = main_language :=\nsorry\n\n/-\ninfo: 'words'\n-/\n-- #guard_msgs in\n-- #eval love_language MockPartner(\"words\") 4\n\n/-\ninfo: 'acts'\n-/\n-- #guard_msgs in\n-- #eval love_language MockPartner(\"acts\") 4\n\n/-\ninfo: 'gifts'\n-/\n-- #guard_msgs in\n-- #eval love_language MockPartner(\"gifts\") 4", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4611", "language": "lean", "source": "fvapps", "source-id": "fvapps_004611", "source-notes": "", "vc-description": "/-\nMy third kata, write a function `check_generator` that examines the status of a Python generator expression `gen` and returns `'Created'`, `'Started'` or `'Finished'`. For example:\n\n`gen = (i for i in range(1))` >>> returns `'Created'` (the generator has been initiated)\n\n`gen = (i for i in range(1)); next(gen, None)` >>> returns `'Started'` (the generator has yielded a value)\n\n`gen = (i for i in range(1)); next(gen, None); next(gen, None)` >>> returns `'Finished'` (the generator has been exhuasted)\n\nFor an introduction to Python generators, read: https://wiki.python.org/moin/Generators.\n\nPlease do vote and rank the kata, and provide any feedback.\n\nHint: you can solve this if you know the right module to use.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def check_generator {α : Type} (g : List α) : GeneratorState :=\n  sorry", "vc-theorems": "theorem new_generator {α : Type} (xs : List α) :\n  check_generator xs = GeneratorState.Created := by\n  sorry\n\ntheorem started_generator {α : Type} (xs : List α) (h : xs ≠ []) :\n  check_generator (xs.tail) = GeneratorState.Started := by\n  sorry\n\ntheorem finished_generator {α : Type} (xs : List α) :\n  check_generator ([] : List α) = GeneratorState.Finished := by\n  sorry\n\ntheorem generator_sequence {α : Type} (xs : List α) :\n  (check_generator xs = GeneratorState.Created) ∧\n  (xs ≠ [] → check_generator (xs.tail) = GeneratorState.Started) ∧\n  (check_generator ([] : List α) = GeneratorState.Finished) := by\n  sorry\n\ntheorem range_generator (n : Nat) :\n  (check_generator (List.range n) = GeneratorState.Created) ∧\n  (n > 0 → check_generator (List.range n).tail = GeneratorState.Started) ∧\n  (check_generator ([] : List Nat) = GeneratorState.Finished) := by\n  sorry\n\n/-\ninfo: 'Created'\n-/\n-- #guard_msgs in\n-- #eval check_generator (i for i in range(2))\n\n/-\ninfo: 'Started'\n-/\n-- #guard_msgs in\n-- #eval check_generator (i for i in range(2))\n\n/-\ninfo: 'Finished'\n-/\n-- #guard_msgs in\n-- #eval check_generator (i for i in range(2))", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4613", "language": "lean", "source": "fvapps", "source-id": "fvapps_004613", "source-notes": "", "vc-description": "/-\nWhat is the answer to life the universe and everything\n\nCreate a function that will make anything true\n\n```python\n    anything({}) != [],          'True'\n    anything('Hello') < 'World', 'True'\n    anything(80) > 81,           'True'\n    anything(re) >= re,          'True'\n    anything(re) <= math,        'True'\n    anything(5) == ord,          'True'\n```\n\nSource: [CheckIO](https://checkio.org/mission/solution-for-anything/)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "theorem anything_equals_everything {α β : Type} [a : Anything α] (x : β) :\n  Anything.eq α β x = true := sorry\n\ntheorem anything_less_than_everything {α β : Type} [a : Anything α] (x : β) :\n  Anything.lt α β x = true := sorry\n\ntheorem anything_less_equal_everything {α β : Type} [a : Anything α] (x : β) :\n  Anything.le α β x = true := sorry\n\ntheorem anything_greater_than_everything {α β : Type} [a : Anything α] (x : β) :\n  Anything.gt α β x = true := sorry\n\ntheorem anything_greater_equal_everything {α β : Type} [a : Anything α] (x : β) :\n  Anything.ge α β x = true := sorry\n\n/- All comparison operators return true for Anything type -/\n\ntheorem anything_all_comparisons {α β : Type} [a : Anything α] (x : β) :\n  Anything.lt α β x = true ∧ \n  Anything.le α β x = true ∧ \n  Anything.gt α β x = true ∧ \n  Anything.ge α β x = true ∧ \n  Anything.eq α β x = true := sorry\n\n/- Anything compares with functions -/\n\ntheorem anything_with_functions {α β γ : Type} [a : Anything γ] (f : α → β) :\n  Anything.eq γ (α → β) f = true := sorry\n\n/-\ninfo: ord\n-/\n-- #guard_msgs in\n-- #eval Anything 5", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4617", "language": "lean", "source": "fvapps", "source-id": "fvapps_004617", "source-notes": "", "vc-description": "/-\n# Find the gatecrashers on CocoBongo parties\n\nCocoBongo is a club with very nice parties. However, you only can get inside if you know at least one other guest. Unfortunately, some gatecrashers can appear at those parties. The gatecrashers do not know any other party member and should not be at our amazing party!\n\nWe will give to you a collection with all party members and a collection with some guests and their invitations. Your mission is to find out those gatecrashers and give us a sorted array of them.\n\nNote that invitations are undirectional relations, so if guest `A` invites `B`, we can consider that `B` also knows `A`. Once the relation `(A, {B})` appears on the invitations collection, the reverse relation `(B, {A})` may or may not appear in the input. You need to take care of that.\n\n## Example\n\n```python\nparty_members = [0,1,2,3,4]\ninvitations = [ (0, [1,2]), (2, [3]) ]\ngatecrashers = [4]\n```\n\n## Explanation\n\nWe have `invitations = [ (0, [1,2]), (2, [3]) ]`.  \nGuest `0` has invited guests `1` and `2`; also, guest `2` has invited guest `3`.\nHowever, noone has invited guest `4`, so he is a gatecrasher.\n-/", "vc-preamble": "def find_gatecrashers (party_members: List Int) (invitations: List (Int × List Int)) : List Int :=\n  sorry\n\ndef is_sorted (l: List Int) : Prop :=\n  ∀ i j, i < j → j < l.length → l.get ⟨i, by sorry⟩ ≤ l.get ⟨j, by sorry⟩\n\ndef is_subset (l₁ l₂: List Int) : Prop :=\n  ∀ x, x ∈ l₁ → x ∈ l₂", "vc-helpers": "", "vc-definitions": "def known_guests (invitations: List (Int × List Int)) : List Int :=\n  let hosts := invitations.map Prod.fst\n  let guests := (invitations.map Prod.snd).join\n  hosts ++ guests", "vc-theorems": "theorem find_gatecrashers_sorted (party_members: List Int) (invitations: List (Int × List Int)) :\n  is_sorted (find_gatecrashers party_members invitations) :=\n  sorry\n\ntheorem find_gatecrashers_subset (party_members: List Int) (invitations: List (Int × List Int)) :\n  is_subset (find_gatecrashers party_members invitations) party_members :=\n  sorry\n\ntheorem find_gatecrashers_not_invited (party_members: List Int) (invitations: List (Int × List Int)) :\n  ∀ x ∈ find_gatecrashers party_members invitations, x ∉ known_guests invitations :=\n  sorry\n\ntheorem find_gatecrashers_complete (party_members: List Int) (invitations: List (Int × List Int)) :\n  ∀ x ∈ party_members, x ∉ known_guests invitations → x ∈ find_gatecrashers party_members invitations :=\n  sorry\n\ntheorem find_gatecrashers_empty_invitations (party_members: List Int) :\n  is_sorted (find_gatecrashers party_members []) ∧ \n  find_gatecrashers party_members [] = party_members :=\n  sorry \n\ntheorem find_gatecrashers_empty_party (invitations: List (Int × List Int)) :\n  find_gatecrashers [] invitations = [] :=\n  sorry\n\n/-\ninfo: [4]\n-/\n-- #guard_msgs in\n-- #eval find_gatecrashers [0, 1, 2, 3, 4] [(0, [1, 2]), (2, [3])]\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval find_gatecrashers [0, 1, 2] [(0, [1]), (1, [2])]\n\n/-\ninfo: [0, 1, 2, 3]\n-/\n-- #guard_msgs in\n-- #eval find_gatecrashers [0, 1, 2, 3] []", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4622", "language": "lean", "source": "fvapps", "source-id": "fvapps_004622", "source-notes": "", "vc-description": "/-\nYour task is to build a model^(1) which can predict y-coordinate.\nYou can pass tests if predicted y-coordinates are inside error margin.\n\nYou will receive train set which should be used to build a model. \nAfter you build a model tests will call function ```predict``` and pass x to it. \n\nError is going to be calculated with RMSE.\n\nBlocked libraries: sklearn, pandas, tensorflow, numpy, scipy\n\nExplanation\n[1] A mining model is created by applying an algorithm to data, but it is more than an algorithm or a metadata container: it is a set of data, statistics, and patterns that can be applied to new data to generate predictions and make inferences about relationships.\n-/", "vc-preamble": "def predict (model : Datamining) (x : Float) : Float :=\n  sorry", "vc-helpers": "", "vc-definitions": "def abs (x : Float) : Float :=\n  if x < 0 then -x else x", "vc-theorems": "theorem fit_predict_linear_midpoint\n  (train_set : List (Int × Int))\n  (distinct_xs : ∀ (p1 p2 : Int × Int), p1 ∈ train_set → p2 ∈ train_set → p1.1 = p2.1 → p1 = p2)\n  (size_geq_2 : train_set.length ≥ 2)\n  (model : Datamining) : let y1 := predict model 0; let y2 := predict model 1; let y3 := predict model 0.5; let expected_y3 := y1 + (y2 - y1) * 0.5; abs (y3 - expected_y3) < 1e-10 :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4625", "language": "lean", "source": "fvapps", "source-id": "fvapps_004625", "source-notes": "", "vc-description": "/-\nWrite function `makeParts` or `make_parts` (depending on your language) that will take an array as argument and the size of the chunk.\n\nExample: if an array of size 123 is given and chunk size is 10 there will be 13 parts, 12 of size 10 and 1 of size 3.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def makeParts {α : Type u} (lst : List α) (chunkSize : Nat) : List (List α) :=\n  sorry", "vc-theorems": "theorem makeParts_chunk_size_property {α : Type u} (lst : List α) (chunkSize : Nat) \n  (h : chunkSize > 0) :\n  ∀ i, i < (makeParts lst chunkSize).length - 1 → \n  ((makeParts lst chunkSize)[i]'(by sorry)).length = chunkSize := \n  sorry\n\ntheorem makeParts_last_chunk_size {α : Type u} (lst : List α) (chunkSize : Nat)\n  (h1 : chunkSize > 0) (h2 : (makeParts lst chunkSize).length > 0) :\n  let parts := makeParts lst chunkSize\n  (parts[parts.length - 1]'(by sorry)).length ≤ chunkSize :=\n  sorry\n\ntheorem makeParts_preserves_elements {α : Type u} (lst : List α) (chunkSize : Nat)\n  (h : chunkSize > 0) :\n  (makeParts lst chunkSize).join = lst :=\n  sorry\n\ntheorem makeParts_chunk_count {α : Type u} (lst : List α) (chunkSize : Nat)\n  (h : chunkSize > 0) :\n  (makeParts lst chunkSize).length = (lst.length + chunkSize - 1) / chunkSize :=\n  sorry\n\ntheorem makeParts_chunk_size_one {α : Type u} (lst : List α) :\n  makeParts lst 1 = lst.map (·::List.nil) :=\n  sorry\n\ntheorem makeParts_full_list {α : Type u} (lst : List α) (h : lst.length > 0) :\n  makeParts lst lst.length = [lst] :=\n  sorry\n\ntheorem makeParts_empty_list {α : Type u} (n : Nat) (h : n > 0) :\n  makeParts ([] : List α) n = [] :=\n  sorry\n\n/-\ninfo: [[1, 2], [3, 4], [5, 6]]\n-/\n-- #guard_msgs in\n-- #eval make_parts [1, 2, 3, 4, 5, 6] 2\n\n/-\ninfo: [[1, 2], [3, 4], [5]]\n-/\n-- #guard_msgs in\n-- #eval make_parts [1, 2, 3, 4, 5] 2\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval make_parts [] 3", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4632", "language": "lean", "source": "fvapps", "source-id": "fvapps_004632", "source-notes": "", "vc-description": "/-\nWrite a function ```unpack()``` that unpacks a ```list``` of elements that can contain objects(`int`, `str`, `list`, `tuple`, `dict`, `set`) within each other without any predefined depth, meaning that there can be many levels of elements contained in one another.\n\nExample:\n\n```python\nunpack([None, [1, ({2, 3}, {'foo': 'bar'})]]) == [None, 1, 2, 3, 'foo', 'bar']\n```\n\nNote: you don't have to bother about the order of the elements, especially when unpacking a `dict` or a `set`. Just unpack all the elements.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def unpack : NestedType → List (String ⊕ Int) := sorry\n\ndef isNested : NestedType → Bool := sorry", "vc-theorems": "theorem unpack_flattens_nested : ∀ (x : NestedType),\n  let result := unpack x\n  -- Result is a list of non-nested values\n  result.length > 0 := sorry\n\ntheorem unpack_preserves_string : ∀ (s : String),\n  unpack (NestedType.str s) = [Sum.inl s] := sorry \n\ntheorem unpack_preserves_list_ints : ∀ (lst : List Int),\n  let nested := lst.map NestedType.int\n  let result := unpack (NestedType.lst nested)\n  -- All elements are preserved and length is preserved\n  result.length = lst.length ∧\n  ∀ (x : Int), x ∈ lst → Sum.inr x ∈ result := sorry\n\n/-\ninfo: expected2\n-/\n-- #guard_msgs in\n-- #eval sorted unpack(test2)", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4635", "language": "lean", "source": "fvapps", "source-id": "fvapps_004635", "source-notes": "", "vc-description": "/-\nWrite a class Random that does the following:\n\n1. Accepts a seed\n```python\n>>> random = Random(10)\n>>> random.seed\n10\n```\n\n2. Gives a random number between 0 and 1\n```python\n>>> random.random()\n0.347957\n>>> random.random()\n0.932959\n```\n\n3. Gives a random int from a range\n```python\n>>> random.randint(0, 100)\n67\n>>> random.randint(0, 100)\n93\n```\n\nModules `random` and `os` are forbidden.\nDont forget to give feedback and your opinion on this kata even if you didn't solve it!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Random.new (s : Int) : Random := sorry\n\ntheorem seed_initialization (s : Int) :\n  (Random.new s).seed = s := sorry", "vc-theorems": "theorem random_bounds (r : Random) :\n  0 ≤ r.random ∧ r.random ≤ 1 := sorry\n\ntheorem randint_bounds (s start finish : Int) :\n  let r := Random.new s\n  let lo := min start finish\n  let hi := max start finish\n  lo ≤ r.randint lo hi ∧ r.randint lo hi ≤ hi := sorry\n\ntheorem randint_deterministic (s start : Int) :\n  let r1 := Random.new s\n  let r2 := Random.new s\n  let finish := start + Int.natAbs (s % 1000)\n  r1.randint start finish = r2.randint start finish := sorry\n\ntheorem random_advances_seed (s : Int) :\n  let r := Random.new s\n  let initial_seed := r.seed\n  r.seed + 1 = initial_seed + 1 := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4642", "language": "lean", "source": "fvapps", "source-id": "fvapps_004642", "source-notes": "", "vc-description": "/-\nWrite a function generator that will generate the first `n` primes grouped in tuples of size `m`. If there are not enough primes for the last tuple it will have the remaining values as `None`.\n\n## Examples\n\n```python\nFor n = 11 and m = 2:\n(2, 3), (5, 7), (11, 13), (17, 19), (23, 29), (31, None)\n\nFor n = 11 and m = 3:\n(2, 3, 5), (7, 11, 13), (17, 19, 23), (29, 31, None)\n\nFor n = 11 and m = 5:\n(2, 3, 5, 7, 11), (13, 17, 19, 23, 29), (31, None, None, None, None)]\n\nFor n = 3 and m = 1:\n(2,), (3,), (5,)\n```\n\nNote: large numbers of `n` will be tested, up to 50000\n-/", "vc-preamble": "def get_primes (n : Nat) (m : Nat := 2) : List (List Nat) :=\n  sorry", "vc-helpers": "", "vc-definitions": "def PRIMES : List Nat := sorry\n\ntheorem get_primes_length_properties (n m : Nat)\n  (h1 : n ≥ 1 ∧ n ≤ 100) (h2 : m ≥ 1 ∧ m ≤ 10) :\n  let result := get_primes n m\n  -- Total elements ≤ n \n  (result.join.length ≤ n) ∧\n  -- Each inner list has length m\n  (∀ inner ∈ result, inner.length = m) :=\nsorry", "vc-theorems": "theorem get_primes_values (n m : Nat)\n  (h1 : n ≥ 1 ∧ n ≤ 100) (h2 : m ≥ 1 ∧ m ≤ 10) :  \n  let result := get_primes n m\n  ∀ x ∈ result.join,\n    -- All values are prime \n    x ∈ PRIMES ∧\n    -- Values are in ascending order\n    (∀ y ∈ result.join, result.join.indexOf y < result.join.indexOf x → y < x) :=\nsorry\n\ntheorem get_primes_default_m (n : Nat) (h : n ≥ 1 ∧ n ≤ 100) :\n  let result := get_primes n\n  ∀ inner ∈ result, inner.length = 2 :=\nsorry\n\ntheorem get_primes_edge_cases :\n  get_primes 0 = [] ∧\n  get_primes 1 1 = [[2]] ∧ \n  get_primes 1 2 = [[2, 0]] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4646", "language": "lean", "source": "fvapps", "source-id": "fvapps_004646", "source-notes": "", "vc-description": "/-\nLinked lists are data structures composed of nested or chained objects, each containing a single value and a reference to the next object. \n\nHere's an example of a list:\n\n```python\nclass LinkedList:\n    def __init__(self, value=0, next=None):\n        self.value = value\n        self.next = next\n\nLinkedList(1, LinkedList(2, LinkedList(3)))\n\n```\n\nWrite a function listToArray (or list\\_to\\_array in Python) that converts a list to an array, like this:\n\n```\n[1, 2, 3]\n```\n\nAssume all inputs are valid lists with at least one value. For the purpose of simplicity, all values will be either numbers, strings, or Booleans.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def list_to_array {α : Type} : LinkedList α → List α\n  | _ => sorry", "vc-theorems": "theorem list_to_array_preserves_values {α : Type} (l : LinkedList α) :\n  list_to_array l = LinkedList.rec [] (fun head tail arr => head :: arr) l :=\nsorry\n\ntheorem list_to_array_maintains_order {α : Type} [Inhabited α] (l : LinkedList α) :\n  ∀ i < (list_to_array l).length,\n    (list_to_array l).get ⟨i, by sorry⟩ = LinkedList.rec default (fun head tail res => head) l :=\nsorry\n\ntheorem list_to_array_empty {α : Type} :\n  list_to_array (@LinkedList.nil α) = @List.nil α :=\nsorry\n\n/-\ninfo: [1, 2, 3]\n-/\n-- #guard_msgs in\n-- #eval list_to_array LinkedList(1, LinkedList(2, LinkedList(3)))\n\n/-\ninfo: ['hello', True, 42]\n-/\n-- #guard_msgs in\n-- #eval list_to_array LinkedList(\"hello\", LinkedList(True, LinkedList(42)))\n\n/-\ninfo: ['solo']\n-/\n-- #guard_msgs in\n-- #eval list_to_array LinkedList(\"solo\")", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4653", "language": "lean", "source": "fvapps", "source-id": "fvapps_004653", "source-notes": "", "vc-description": "/-\n# Toggling Grid\nYou are given a grid (2d array) of 0/1's. All 1's represents a solved puzzle. Your job is to come up with a sequence of toggle moves that will solve a scrambled grid.\n\nSolved:\n\n```\n[ [1, 1, 1],\n  [1, 1, 1],\n  [1, 1, 1] ]\n``` \n\n\"0\" (first row) toggle:\n```\n[ [0, 0, 0],\n  [1, 1, 1],\n  [1, 1, 1] ]\n```\n\nthen \"3\" (first column) toggle:\n```\n[ [1, 0, 0],\n  [0, 1, 1],\n  [0, 1, 1] ]\n```\n\nThe numbers in quotes are codes for the row/column, and will be explained.\n\n## Your task: findSolution()\nYour task is to write a function, `findSolution()` (or `find_solution()`), which takes as input a 2d array, and returns an array of \"steps\" that represent a sequence of toggles to solve the puzzle.\n\nFor example:\n\n```python\nsolution = find_solution(puzzle)\nprint(solution);\n> [0, 3]\n```\nNote that, in the above example, `[1, 2, 4, 5]` is also a valid solution! Any solution will pass the tests.\n\nThe solution is tested like this, for each number in the solution:\n\n```python\nif n < puzzle.size:\n  toggleRow(n)\nelse:\n  toggleCol(n - puzzle.size)\n```\nTo elaborate, possible n's for a 3x3 puzzle:\n\n- Row numbers = (0    --> size - 1)\n- Cols numbers = (size --> size * 2 - 1)\n\n### Example of \"2\" toggle:\n\n### Example of \"4\" toggle:\n\n## More examples:\n\n```python\npuzzle = [\n  [ 0, 1, 0 ],\n  [ 1, 0, 1 ],\n  [ 1, 0, 1 ]\n];\nsolution = find_solution(puzzle)\nprint(solution);\n> [0, 4]\n```\nlet's try some bigger puzzles:\n\n```python\npuzzle = [\n  [ 1, 0, 1, 0, 0 ],\n  [ 0, 1, 0, 1, 1 ],\n  [ 0, 1, 0, 1, 1 ],\n  [ 0, 1, 0, 1, 1 ],\n  [ 1, 0, 1, 0, 0 ]\n];\nsolution = find_solution(puzzle)\nprint(solution);\n> [ 0, 5, 4, 7 ]\n```\n\n```python\npuzzle = [\n  [ 1, 1, 1, 0, 1, 1, 1 ],\n  [ 1, 1, 1, 0, 1, 1, 1 ],\n  [ 1, 1, 1, 0, 1, 1, 1 ],\n  [ 0, 0, 0, 1, 0, 0, 0 ],\n  [ 1, 1, 1, 0, 1, 1, 1 ],\n  [ 1, 1, 1, 0, 1, 1, 1 ],\n  [ 1, 1, 1, 0, 1, 1, 1 ]\n];\nsolution = find_solution(puzzle)\nprint(solution);\n> [ 3, 10 ]\n```\n\nThere are randomized tests with puzzles of up to 100x100 in size. Have fun!\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def find_solution : List (List Nat) → List Nat := sorry\n\n-- Row toggles come before column toggles", "vc-theorems": "theorem solution_toggles_ordering (h : puzzle.length > 0) :\n  let solution := find_solution puzzle\n  let n := puzzle.length \n  let row_toggles := solution.filter (· < n)\n  let col_toggles := solution.filter (· ≥ n)\n  solution.length > 0 → \n  (row_toggles.isEmpty → true) ∧ \n  (col_toggles.isEmpty → true) ∧\n  (¬row_toggles.isEmpty ∧ ¬col_toggles.isEmpty → \n    (row_toggles.maximum?.getD 0) < (col_toggles.minimum?.getD (2*n))) :=\nsorry\n\n-- All 1s need no moves\n\ntheorem all_ones_needs_no_moves (h : n > 0) :\n  let all_ones := List.replicate n (List.replicate n 1)\n  find_solution all_ones = [] :=\nsorry\n\n-- All 0s need all columns toggled\n\ntheorem all_zeros_needs_all_cols (h : n > 0) :\n  let all_zeros := List.replicate n (List.replicate n 0)\n  let solution := find_solution all_zeros\n  let expected := List.range n |>.map (· + n)\n  solution = expected :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4661", "language": "lean", "source": "fvapps", "source-id": "fvapps_004661", "source-notes": "", "vc-description": "/-\n# Story\n\nOld MacDingle had a farm... \n\n...and on that farm he had\n\n* horses \n* chickens \n* rabbits \n* some apple trees\n* a vegetable patch\n\nEverything is idylic in the MacDingle farmyard **unless somebody leaves the gates open**\n\nDepending which gate was left open then...\n\n* horses might run away\n* horses might eat the apples\n* horses might eat the vegetables\n* chickens might run away\n* rabbits might run away\n* rabbits might eat the vegetables\n\n# Kata Task\n\nGiven the state of the farm gates in the evening, your code must return what the farm looks like the next morning when daylight reveals what the animals got up to.\n\n# Legend\n\n* ```H``` horse\n* ```C``` chicken\n* ```R``` rabbit\n* ```A``` apple tree\n* ```V``` vegetables\n* ```|``` gate (closed), \n* ```\\``` or ```/``` gate (open)\n* ```.``` everything else\n\n# Example\n\nBefore\n```|..HH....\\AAAA\\CC..|AAA/VVV/RRRR|CCC```\n\nAfter\n```|..HH....\\....\\CC..|AAA/.../RRRR|...```\nBecause:\n\nThe horses ate whatever apples they could get to\nThe rabbits ate the vegetables\nThe chickens ran away\n\n# Notes\n\n* If the animals can eat things *and* also run away then they do **BOTH** - it is best not to run away when you are hungry!\n* An animal cannot \"go around\" a closed gate...\n* ...but it is possible to run away from the farm and then **RUN BACK** and re-enter though more open gates on the other side!\n-/", "vc-preamble": "def split_on_char (c : Char) (s : List Char) : List (List Char) :=\n  sorry\n\ndef any (p : Char → Bool) (s : List Char) : Bool :=\n  sorry", "vc-helpers": "", "vc-definitions": "def shut_the_gate (farm : String) : String :=\n  sorry", "vc-theorems": "theorem output_valid_chars (farm : String) :\n  let result := shut_the_gate farm\n  ∀ c ∈ result.data, c = 'H' ∨ c = 'R' ∨ c = 'C' ∨ c = 'A' ∨ c = 'V' ∨ \n                       c = '|' ∨ c = '/' ∨ c = '\\\\' ∨ c = '.' :=\n  sorry\n\ntheorem preserves_gates (farm : String) :\n  let result := shut_the_gate farm\n  let gates := farm.data.enum.filter (fun p => p.2 = '|' ∨ p.2 = '/' ∨ p.2 = '\\\\')\n  let result_gates := result.data.enum.filter (fun p => p.2 = '|' ∨ p.2 = '/' ∨ p.2 = '\\\\')\n  gates = result_gates :=\n  sorry\n\ntheorem enclosed_animals_stay (farm : String) :\n  let result := shut_the_gate farm\n  let sections := split_on_char '|' farm.data\n  let result_sections := split_on_char '|' result.data\n  sections.length ≥ 3 →\n  ∀ i, 0 < i ∧ i < sections.length - 1 →\n    (¬ any (fun c => c = '/' ∨ c = '\\\\') sections[i]!) →\n    sections[i]! = result_sections[i]! :=\n  sorry\n\ntheorem idempotent (farm : String) :\n  let first_result := shut_the_gate farm\n  shut_the_gate first_result = first_result :=\n  sorry\n\n/-\ninfo: '|H|A|'\n-/\n-- #guard_msgs in\n-- #eval shut_the_gate \"|H|A|\"\n\n/-\ninfo: './.'\n-/\n-- #guard_msgs in\n-- #eval shut_the_gate \"H/A\"\n\n/-\ninfo: '|H/.|'\n-/\n-- #guard_msgs in\n-- #eval shut_the_gate \"|H/A|\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4663", "language": "lean", "source": "fvapps", "source-id": "fvapps_004663", "source-notes": "", "vc-description": "/-\nYou are given a list of directions in the form of a list:\n\ngoal = [\"N\", \"S\", \"E\", \"W\"]\n\nPretend that each direction counts for 1 step in that particular direction.\n\nYour task is to create a function called directions, that will return a reduced list that will get you to the same point.The order of directions must be returned as N then S then E then W.\n\nIf you get back to beginning, return an empty array.\n-/", "vc-preamble": "def Direction.toString : Direction → String\n  | Direction.N => \"N\"\n  | Direction.S => \"S\"\n  | Direction.E => \"E\"\n  | Direction.W => \"W\"", "vc-helpers": "", "vc-definitions": "def Path := List Direction\n\ndef directions (p : Path) : Path :=\n  sorry", "vc-theorems": "theorem directions_preserves_endpoint (p : Path) :\n  let result := directions p\n  let orig_ns := (p.filter (· = Direction.N)).length - (p.filter (· = Direction.S)).length\n  let orig_ew := (p.filter (· = Direction.E)).length - (p.filter (· = Direction.W)).length\n  let result_ns := (result.filter (· = Direction.N)).length - (result.filter (· = Direction.S)).length  \n  let result_ew := (result.filter (· = Direction.E)).length - (result.filter (· = Direction.W)).length\n  orig_ns = result_ns ∧ orig_ew = result_ew :=\nsorry\n\ntheorem directions_ordering (p : Path) : \n  let result := directions p\n  let result_str := String.join (result.map Direction.toString)\n  ¬(result_str.any (fun cs => cs.toString = \"SN\")) ∧ \n  ¬(result_str.any (fun cs => cs.toString = \"WE\")) := \nsorry\n\ntheorem directions_empty_at_origin (p : Path) :\n  let ns_movement := (p.filter (· = Direction.N)).length - (p.filter (· = Direction.S)).length\n  let ew_movement := (p.filter (· = Direction.E)).length - (p.filter (· = Direction.W)).length\n  ns_movement = 0 ∧ ew_movement = 0 → directions p = [] :=\nsorry\n\ntheorem directions_output_types (p : Path) :\n  let result := directions p\n  result.all (fun x => match x with\n    | Direction.N => true\n    | Direction.S => true\n    | Direction.E => true\n    | Direction.W => true) :=\nsorry\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval directions [\"N\", \"S\", \"E\", \"W\"]\n\n/-\ninfo: ['N', 'E']\n-/\n-- #guard_msgs in\n-- #eval directions [\"N\", \"N\", \"E\", \"S\"]\n\n/-\ninfo: ['S', 'W', 'W']\n-/\n-- #guard_msgs in\n-- #eval directions [\"S\", \"S\", \"W\", \"W\", \"N\"]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4665", "language": "lean", "source": "fvapps", "source-id": "fvapps_004665", "source-notes": "", "vc-description": "/-\nCreate a class Vector that has simple (3D) vector operators.\n\nIn your class, you should support the following operations, given Vector ```a``` and Vector ```b```:\n\n```python\na + b # returns a new Vector that is the resultant of adding them\na - b # same, but with subtraction\na == b # returns true if they have the same magnitude and direction\na.cross(b) # returns a new Vector that is the cross product of a and b\na.dot(b) # returns a number that is the dot product of a and b\na.to_tuple() # returns a tuple representation of the vector.\nstr(a) # returns a string representation of the vector in the form \"\"\na.magnitude # returns a number that is the magnitude (geometric length) of vector a.\na.x # gets x component\na.y # gets y component\na.z # gets z component\nVector([a,b,c]) # creates a new Vector from the supplied 3D array.\nVector(a,b,c) # same as above\n```\nThe test cases will not mutate the produced Vector objects, so don't worry about that.\n-/", "vc-preamble": "def Vector.toTuple (v : Vector) : Int × Int × Int := sorry\ndef Vector.fromList (l : List Int) : Vector := sorry\n\ndef Vector.add (v1 v2 : Vector) : Vector := sorry\ndef Vector.sub (v1 v2 : Vector) : Vector := sorry\n\ndef Vector.dot (v1 v2 : Vector) : Int := sorry\ndef Vector.cross (v1 v2 : Vector) : Vector := sorry", "vc-helpers": "", "vc-definitions": "def Vector.magnitude (v : Vector) : Float := sorry\ndef Vector.toString (v : Vector) : String := sorry", "vc-theorems": "theorem vector_creation_args (x y z : Int) :\n  (Vector.toTuple ⟨x, y, z⟩) = (x, y, z) := sorry\n\ntheorem vector_creation_list (l : List Int) (h : l.length = 3) :\n  Vector.toTuple (Vector.fromList l) = (l[0]!, l[1]!, l[2]!) := sorry\n\ntheorem vector_addition (v1 v2 : Vector) :\n  Vector.toTuple (Vector.add v1 v2) = (v1.x + v2.x, v1.y + v2.y, v1.z + v2.z) := sorry\n\ntheorem vector_subtraction (v1 v2 : Vector) :\n  Vector.toTuple (Vector.sub v1 v2) = (v1.x - v2.x, v1.y - v2.y, v1.z - v2.z) := sorry\n\ntheorem vector_dot_product (v1 v2 : Vector) :\n  Vector.dot v1 v2 = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z := sorry\n\ntheorem vector_cross_product (v1 v2 : Vector) :\n  Vector.toTuple (Vector.cross v1 v2) = \n    (v1.y * v2.z - v1.z * v2.y,\n     v1.z * v2.x - v1.x * v2.z,\n     v1.x * v2.y - v1.y * v2.x) := sorry\n\ntheorem vector_magnitude (v : Vector) :\n  Vector.magnitude v = Float.sqrt (Float.ofInt (v.x * v.x + v.y * v.y + v.z * v.z)) := sorry\n\ntheorem vector_string_representation (v : Vector) :\n  Vector.toString v = s!\"<{v.x}, {v.y}, {v.z}>\" := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4667", "language": "lean", "source": "fvapps", "source-id": "fvapps_004667", "source-notes": "", "vc-description": "/-\n# Task\n A boy is walking a long way from school to his home. To make the walk more fun he decides to add up all the numbers of the houses that he passes by during his walk. Unfortunately, not all of the houses have numbers written on them, and on top of that the boy is regularly taking turns to change streets, so the numbers don't appear to him in any particular order.\n\n At some point during the walk the boy encounters a house with number `0` written on it, which surprises him so much that he stops adding numbers to his total right after seeing that house.\n\n For the given sequence of houses determine the sum that the boy will get. It is guaranteed that there will always be at least one 0 house on the path.\n\n# Example\n\n For `inputArray = [5, 1, 2, 3, 0, 1, 5, 0, 2]`, the output should be `11`.\n\n The answer was obtained as `5 + 1 + 2 + 3 = 11`.\n\n# Input/Output\n\n - `[input]` integer array `inputArray`\n\n    Constraints: `5 ≤ inputArray.length ≤ 50, 0 ≤ inputArray[i] ≤ 10.`\n\n - `[output]` an integer\n-/", "vc-preamble": "def List.sum : List Nat → Nat \n  | [] => 0\n  | (x :: xs) => x + sum xs", "vc-helpers": "", "vc-definitions": "def house_numbers_sum (nums : List Nat) : Nat := sorry\n\ntheorem house_numbers_sum_non_negative {nums : List Nat} (h : 0 ∈ nums) :\n  house_numbers_sum nums ≥ 0 := sorry", "vc-theorems": "theorem house_numbers_sum_ignore_after_zero {nums modified : List Nat} \n  (h : 0 ∈ nums)\n  (h2 : modified.take (nums.indexOf 0 + 1) = nums.take (nums.indexOf 0 + 1)) :\n  house_numbers_sum modified = house_numbers_sum nums := sorry\n\ntheorem house_numbers_sum_ones (n : Nat) :\n  house_numbers_sum (List.replicate n 1 ++ [0]) = n := sorry\n\ntheorem house_numbers_sum_zero :\n  house_numbers_sum [0] = 0 := sorry\n\ntheorem house_numbers_sum_zero_prefix :\n  house_numbers_sum [0, 1, 2, 3] = 0 := sorry\n\n/-\ninfo: 11\n-/\n-- #guard_msgs in\n-- #eval house_numbers_sum [5, 1, 2, 3, 0, 1, 5, 0, 2]\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval house_numbers_sum [0, 1, 2, 3]\n\n/-\ninfo: 13\n-/\n-- #guard_msgs in\n-- #eval house_numbers_sum [4, 2, 1, 6, 0, 3, 2]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4673", "language": "lean", "source": "fvapps", "source-id": "fvapps_004673", "source-notes": "", "vc-description": "/-\nLets play some Pong! \n\n![pong](http://gifimage.net/wp-content/uploads/2017/08/pong-gif-3.gif)\n\nFor those who don't know what Pong is, it is a simple arcade game where two players can move their paddles to hit a ball towards the opponent's side of the screen, gaining a point for each opponent's miss. You can read more about it [here](https://en.wikipedia.org/wiki/Pong).\n\n___\n\n# Task:\n\nYou must finish the `Pong` class. It has a constructor which accepts the `maximum score` a player can get throughout the game, and a method called `play`. This method determines whether the current player hit the ball or not, i.e. if the paddle is at the sufficient height to hit it back. There're 4 possible outcomes: player successfully hits the ball back, player misses the ball, player misses the ball **and his opponent reaches the maximum score winning the game**, either player tries to hit a ball despite the game being over. You can see the input and output description in detail below.\n\n### \"Play\" method input:\n\n* ball position - The Y coordinate of the ball\n* player position - The Y coordinate of the centre(!) of the current player's paddle\n\n### \"Play\" method output:\n\nOne of the following strings:\n\n* `\"Player X has hit the ball!\"` - If the ball \"hits\" the paddle\n* `\"Player X has missed the ball!\"` - If the ball is above/below the paddle\n* `\"Player X has won the game!\"` - If one of the players has reached the maximum score\n* `\"Game Over!\"` - If the game has ended but either player still hits the ball\n\n### Important notes:\n\n* Players take turns hitting the ball, always starting the game with the Player 1.\n* The paddles are `7` pixels in height.\n* The ball is `1` pixel in height.\n\n___\n\n## Example\n-/", "vc-preamble": "def Pong.play (game : Pong) (ballPos playerPos : Int) : String := sorry\n\ndef Pong.game_over (game : Pong) : Bool := sorry", "vc-helpers": "", "vc-definitions": "def Int.abs (i : Int) : Int := sorry\n\ntheorem pong_init_properties {maxScore : Nat} (h : maxScore ≥ 1) :\n  let game := Pong.mk maxScore []\n  game.maxScore = maxScore ∧ \n  game.scores = [] := sorry", "vc-theorems": "theorem hit_or_miss_range {maxScore : Nat} {ballPos playerPos : Int} \n  (h1 : maxScore ≥ 2) :\n  let game := Pong.mk maxScore []\n  let result := game.play ballPos playerPos\n  (Int.abs (ballPos - playerPos) ≤ 3 → result.contains '.') ∧\n  (Int.abs (ballPos - playerPos) > 3 ∧ ¬result.contains '.' → result.contains ' ') := sorry\n\ntheorem alternating_players {maxScore : Nat} (h : maxScore ≥ 1) :\n  let game := Pong.mk maxScore []\n  let plays := [game.play 10 0, game.play 10 0, game.play 10 0, game.play 10 0]\n  ∀ i, i + 1 < plays.length → \n    let p1 := plays[i]!\n    let p2 := plays[i+1]!\n    p1 ≠ p2 := sorry\n\ntheorem game_over_condition {maxScore : Nat} (h : maxScore ≥ 1) :\n  let game := Pong.mk maxScore []\n  ∃ plays : List String, \n    let last := plays.getLast! \n    last.contains ' ' ∧\n    game.play 0 0 = \"Game Over!\" := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4674", "language": "lean", "source": "fvapps", "source-id": "fvapps_004674", "source-notes": "", "vc-description": "/-\nDesign a data structure that supports the following two operations:\n\n* `addWord` (or `add_word`) which adds a word,\n* `search` which searches a literal word or a regular expression string containing lowercase letters `\"a-z\"` or `\".\"` where `\".\"` can represent any letter\n\nYou may assume that all given words contain only lowercase letters.\n\n## Examples\n```python\nadd_word(\"bad\")\nadd_word(\"dad\")\nadd_word(\"mad\")\n\nsearch(\"pad\") == False\nsearch(\"bad\") == True\nsearch(\".ad\") == True\nsearch(\"b..\") == True\n```\n\n**Note:** the data structure will be initialized multiple times during the tests!\n-/", "vc-preamble": "def WordDictionary.addWord (wd : WordDictionary) (word : String) : WordDictionary :=\n  sorry", "vc-helpers": "", "vc-definitions": "def WordDictionary.search (wd : WordDictionary) (pattern : String) : Bool :=\n  sorry", "vc-theorems": "theorem exact_match_property (words : List String) (h : ∀ w ∈ words, w.length > 0) :\n  let wd := words.foldl (fun acc word => WordDictionary.addWord acc word) default\n  ∀ w ∈ words, (WordDictionary.search wd w) = true :=\n  sorry\n\ntheorem wildcard_search_property \n  (words : List String) \n  (pattern : String)\n  (h1 : words.length > 0)\n  (h2 : pattern.length > 0)\n  (h3 : ∀ w ∈ words, w.length > 0) :\n  let wd := words.foldl (fun acc word => WordDictionary.addWord acc word) default\n  let matching_words := words.filter (fun w => w.length = pattern.length)\n  matching_words.length > 0 →\n  (WordDictionary.search wd pattern) = \n    matching_words.any (fun word =>\n      let pairs := List.zip (pattern.data) (word.data)\n      pairs.all (fun pair => pair.fst = '.' ∨ pair.fst = pair.snd)) :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4677", "language": "lean", "source": "fvapps", "source-id": "fvapps_004677", "source-notes": "", "vc-description": "/-\nTeach snoopy and scooby doo how to bark using object methods. \nCurrently only snoopy can bark and not scooby doo. \n\n```python\nsnoopy.bark() #return \"Woof\"\nscoobydoo.bark() #undefined\n```\nUse method prototypes to enable all Dogs to bark.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def Dog.bark (d : Dog) : String := sorry\n\ntheorem dog_breed_property {breed : String} :\n  (Dog.mk breed).breed = breed := sorry", "vc-theorems": "theorem dog_bark_property (d : Dog) :\n  d.bark = \"Woof\" := sorry\n\ntheorem dog_state_independence {breed1 breed2 : String} (h : breed1 ≠ breed2) :\n  let d1 := Dog.mk breed1\n  let d2 := Dog.mk breed2\n  d1.breed ≠ d2.breed ∧ d1.bark = d2.bark := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4679", "language": "lean", "source": "fvapps", "source-id": "fvapps_004679", "source-notes": "", "vc-description": "/-\nThere are a **n** balls numbered from 0 to **n-1** (0,1,2,3,etc). Most of them have the same weight, but one is heavier. Your task is to find it.\n\nYour function will receive two arguments - a `scales` object, and a ball count. The `scales` object has only one method:\n\n```python\n    get_weight(left, right)\n```\n\nwhere `left` and `right` are arrays of numbers of balls to put on left and right pan respectively.\n\nIf the method returns `-1` - left pan is heavier\n\nIf the method returns `1` - right pan is heavier\n\nIf the method returns `0` - both pans weigh the same\n\nSo what makes this the \"ubermaster\" version of this kata? First, it's not restricted to 8 balls as in the previous versions - your solution has to work for 8-500 balls. \n\nSecond, you can't use the scale any more than mathematically necessary. Here's a chart:\n\n    ball count | uses\n    -----------------\n           0-9 |    2\n         10-27 |    3\n         28-81 |    4\n        82-243 |    5\n       244-500 |    6\n\nToo hard? Try lower levels by [tiriana](http://www.codewars.com/users/tiriana):\n\n* [novice](http://www.codewars.com/kata/544047f0cf362503e000036e)\n* [conqueror](http://www.codewars.com/kata/54404a06cf36258b08000364)\n* [master](http://www.codewars.com/kata/find-heavy-ball-level-master)\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def weighBalls (scales : MockScales) (left right : List Nat) : Weigh := sorry\n\ndef find_ball (scales : MockScales) (n : Nat) : Nat := sorry", "vc-theorems": "theorem find_ball_correct \n  (n : Nat)\n  (heavy_idx : Nat)\n  (h₁ : 0 < n)\n  (h₂ : heavy_idx < n) :\n  find_ball (MockScales.mk heavy_idx) n = heavy_idx := sorry\n\ntheorem find_ball_complexity\n  (n : Nat)\n  (heavy_idx : Nat)\n  (h₁ : 0 < n) \n  (h₂ : heavy_idx < n) :\n  ∃ uses : Nat, uses ≤ max 1 (Nat.log2 n) := sorry\n\ntheorem find_ball_edge_cases\n  (n : Nat)\n  (h : 0 < n) :\n  find_ball (MockScales.mk 0) n = 0 ∧ \n  find_ball (MockScales.mk (n-1)) n = n-1 := sorry\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval find_ball MockScales(3) 8\n\n/-\ninfo: 15\n-/\n-- #guard_msgs in\n-- #eval find_ball MockScales(15) 27\n\n/-\ninfo: 80\n-/\n-- #guard_msgs in\n-- #eval find_ball MockScales(80) 81", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4681", "language": "lean", "source": "fvapps", "source-id": "fvapps_004681", "source-notes": "", "vc-description": "/-\nEveryday we go to different places to get our things done. Those places can be represented by specific location points `[ [, ], ... ]` on a map. I will be giving you an array of arrays that contain coordinates of the different places I had been on a particular day. Your task will be to find `peripheries (outermost edges)` of the bounding box that contains all the points. The response should only contain `Northwest and Southeast` points as follows: `{ \"nw\": [, ], \"se\": [ , ] }`. You are adviced to draw the points on a 2D plan to visualize:\n\n```\n                         N\n                         ^\n    p(nw)  ______________|________________\n          |              |                |\n          |              | all other      |   \n          |              |  points        |\n          |              |                |\n     ----------------------------------------> E          \n          |              |                |\n          |  all other   |                |\n          |  points      |                |\n          |______________|________________|\n                         |                  p(se)\n```\n-/", "vc-preamble": "def box (coords : List (Float × Float)) : Box :=\n  sorry\n\ndef minList (l : List Float) : Float :=\n  sorry", "vc-helpers": "", "vc-definitions": "def maxList (l : List Float) : Float :=\n  sorry", "vc-theorems": "theorem box_bounds (coords : List (Float × Float)) (h : coords.length > 0) :\n  let b := box coords\n  let lats := coords.map (·.1)\n  let longs := coords.map (·.2)\n  b.nw.lat ≥ minList lats ∧ \n  b.nw.lat ≤ maxList lats ∧\n  b.nw.long ≥ minList longs ∧\n  b.nw.long ≤ maxList longs ∧\n  b.se.lat ≥ minList lats ∧\n  b.se.lat ≤ maxList lats ∧\n  b.se.long ≥ minList longs ∧\n  b.se.long ≤ maxList longs ∧\n  b.nw.lat ≥ b.se.lat ∧\n  b.se.long ≥ b.nw.long :=\n  sorry\n\ntheorem single_point (coord : Float × Float) :\n  let b := box [coord]\n  b.nw.lat = coord.1 ∧\n  b.nw.long = coord.2 ∧\n  b.se.lat = coord.1 ∧\n  b.se.long = coord.2 :=\n  sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4682", "language": "lean", "source": "fvapps", "source-id": "fvapps_004682", "source-notes": "", "vc-description": "/-\nPolly is 8 years old. She is eagerly awaiting Christmas as she has a bone to pick with Santa Claus. Last year she asked for a horse, and he brought her a dolls house. Understandably she is livid.\n\nThe days seem to drag and drag so Polly asks her friend to help her keep count of how long it is until Christmas, in days. She will start counting from the first of December.\n\nYour function should take 1 argument (a Date object) which will be the day of the year it is currently. The function should then work out how many days it is until Christmas.\n\nWatch out for leap years!\n-/", "vc-preamble": "def isLeapYear (year : Int) : Bool := sorry\n\ndef daysUntilChristmas (d : Date) : Nat := sorry", "vc-helpers": "", "vc-definitions": "def addDays (d : Date) (n : Nat) : Date := sorry\n\ntheorem days_until_christmas_non_negative (d : Date) : \n  daysUntilChristmas d ≥ 0 := sorry", "vc-theorems": "theorem days_until_christmas_max_bound (d : Date) :\n  daysUntilChristmas d ≤ 366 := sorry\n\ntheorem days_until_christmas_gives_christmas (d : Date) :\n  let future := addDays d (daysUntilChristmas d)\n  future.month = 12 ∧ future.day = 25 := sorry\n\ntheorem on_christmas_returns_zero (d : Date) (h1 : d.month = 12) (h2 : d.day = 25) :\n  daysUntilChristmas d = 0 := sorry\n\ntheorem after_christmas_next_year (d : Date) \n  (h1 : d.month = 12) (h2 : d.day > 25) :\n  daysUntilChristmas d = \n    daysUntilChristmas (Date.mk (d.year + 1) 12 25) := sorry\n\n/-\ninfo: 163\n-/\n-- #guard_msgs in\n-- #eval days_until_christmas date(2023, 7, 15)\n\n/-\ninfo: 365\n-/\n-- #guard_msgs in\n-- #eval days_until_christmas date(2023, 12, 26)\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval days_until_christmas date(2023, 12, 24)", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4685", "language": "lean", "source": "fvapps", "source-id": "fvapps_004685", "source-notes": "", "vc-description": "/-\nYour task in this kata is to implement a function that calculates the sum of the integers inside a string. For example, in the string \"The30quick20brown10f0x1203jumps914ov3r1349the102l4zy dog\", the sum of the integers is 3635.\n\n*Note: only positive integers will be tested.*\n-/", "vc-preamble": "def sumOfIntegersInString (s : String) : Nat :=\n  sorry\n\ndef sumOfMatchedNumbers (s : String) : Nat :=\n  sorry", "vc-helpers": "", "vc-definitions": "def List.sum : List Nat → Nat \n  | [] => 0\n  | x::xs => x + List.sum xs", "vc-theorems": "theorem sum_matches_individual_numbers (s : String) : \n  sumOfIntegersInString s = sumOfMatchedNumbers s := by \n  sorry\n\ntheorem single_number_returns_itself (n : Nat) :\n  sumOfIntegersInString (toString n) = n := by \n  sorry\n\ntheorem space_separated_sum (nums : List Nat) :\n  sumOfIntegersInString (String.intercalate \" \" (nums.map toString)) = List.sum nums := by\n  sorry\n\ntheorem output_is_nonnegative (s : String) :\n  sumOfIntegersInString s ≥ 0 := by\n  sorry\n\n/-\ninfo: 3635\n-/\n-- #guard_msgs in\n-- #eval sum_of_integers_in_string \"The30quick20brown10f0x1203jumps914ov3r1349the102l4zy dog\"\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval sum_of_integers_in_string \"12\"\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval sum_of_integers_in_string \"h3llo w0rld\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4686", "language": "lean", "source": "fvapps", "source-id": "fvapps_004686", "source-notes": "", "vc-description": "/-\nYou and your friends have been battling it out with your Rock 'Em, Sock 'Em robots, but things have gotten a little boring. You've each decided to add some amazing new features to your robot and automate them to battle to the death.\n\nEach robot will be represented by an object. You will be given two robot objects, and an object of battle tactics and how much damage they produce. Each robot will have a name, hit points, speed, and then a list of battle tacitcs they are to perform in order. Whichever robot has the best speed, will attack first with one battle tactic. \n\nYour job is to decide who wins.\n\nExample:\n```python\n robot_1 = {\n  \"name\": \"Rocky\",\n  \"health\": 100,\n  \"speed\": 20,\n  \"tactics\": [\"punch\", \"punch\", \"laser\", \"missile\"]\n }\n robot_2 = {\n   \"name\": \"Missile Bob\",\n   \"health\": 100,\n   \"speed\": 21,\n   \"tactics\": [\"missile\", \"missile\", \"missile\", \"missile\"]\n }\n tactics = {\n   \"punch\": 20,\n   \"laser\": 30,\n   \"missile\": 35\n }\n\n fight(robot_1, robot_2, tactics) -> \"Missile Bob has won the fight.\"\n```\n\nrobot2 uses the first tactic, \"missile\" because he has the most speed. This reduces robot1's health by 35. Now robot1 uses a punch, and so on. \n\n**Rules**\n\n- A robot with the most speed attacks first. If they are tied, the first robot passed in attacks first.\n- Robots alternate turns attacking. Tactics are used in order.\n- A fight is over when a robot has 0 or less health or both robots have run out of tactics.\n- A robot who has no tactics left does no more damage, but the other robot may use the rest of his tactics.\n- If both robots run out of tactics, whoever has the most health wins. Return the message \"{Name} has won the fight.\"\n- If both robots run out of tactics and are tied for health, the fight is a draw. Return \"The fight was a draw.\"\n\n**To Java warriors**\n\n`Robot` class is immutable.\n\nCheck out my other 80's Kids Katas:\n\n80's Kids #1: How Many Licks Does It Take\n80's Kids #2: Help Alf Find His Spaceship\n80's Kids #3: Punky Brewster's Socks\n80's Kids #4: Legends of the Hidden Temple\n80's Kids #5: You Can't Do That on Television\n80's Kids #6: Rock 'Em, Sock 'Em Robots\n80's Kids #7: She's a Small Wonder\n80's Kids #8: The Secret World of Alex Mack\n80's Kids #9: Down in Fraggle Rock \n80's Kids #10: Captain Planet\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def fight (r1 r2 : Robot) (t : Tactics) : String :=\n  sorry", "vc-theorems": "theorem fight_returns_valid_result (r1 r2 : Robot) (t : Tactics) :\n  let result := fight r1 r2 t\n  (result = s!\"{r1.name} has won the fight.\" ∨ \n   result = s!\"{r2.name} has won the fight.\" ∨\n   result = \"The fight was a draw.\") :=\nsorry\n\ntheorem faster_robot_attacks_first (r1 r2 : Robot) (t : Tactics) :\n  r1.speed ≠ r2.speed →\n  r1.tactics ≠ [] →\n  r2.tactics ≠ [] →\n  let faster := if r1.speed > r2.speed then r1 else r2\n  let slower := if r1.speed > r2.speed then r2 else r1\n  let firstDamage := match faster.tactics.head? with\n    | none => 0 \n    | some tactic => match t.val.lookup tactic with\n      | none => 0\n      | some dmg => dmg\n  firstDamage ≥ slower.health →\n  fight r1 r2 t = s!\"{faster.name} has won the fight.\" :=\nsorry\n\ntheorem equal_health_no_tactics_draws (r1 r2 : Robot) (t : Tactics) :\n  r1.health = r2.health →\n  r1.tactics = [] →\n  r2.tactics = [] →\n  fight r1 r2 t = \"The fight was a draw.\" :=\nsorry\n\n/-\ninfo: 'Missile Bob has won the fight.'\n-/\n-- #guard_msgs in\n-- #eval fight {\"name\": \"Rocky\", \"health\": 100, \"speed\": 20, \"tactics\": [\"punch\", \"punch\", \"laser\", \"missile\"]} {\"name\": \"Missile Bob\", \"health\": 100, \"speed\": 21, \"tactics\": [\"missile\", \"missile\", \"missile\", \"missile\"]} {\"punch\": 20, \"laser\": 30, \"missile\": 35}\n\n/-\ninfo: 'The fight was a draw.'\n-/\n-- #guard_msgs in\n-- #eval fight {\"name\": \"Bot1\", \"health\": 100, \"speed\": 20, \"tactics\": [\"punch\"]} {\"name\": \"Bot2\", \"health\": 100, \"speed\": 20, \"tactics\": [\"punch\"]} tactics", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4691", "language": "lean", "source": "fvapps", "source-id": "fvapps_004691", "source-notes": "", "vc-description": "/-\nLinked Lists - Length & Count\n\nImplement Length() to count the number of nodes in a linked list.\nImplement Count() to count the occurrences of an integer in a linked list.\n\nI've decided to bundle these two functions within the same Kata since they are both very similar.\n\nThe `push()`/`Push()` and `buildOneTwoThree()`/`BuildOneTwoThree()` functions do not need to be redefined.\n-/", "vc-preamble": "def length {α : Type} : Node α → Nat\n  | Node.nil => 0\n  | Node.cons _ next => 1 + length next", "vc-helpers": "", "vc-definitions": "def count {α : Type} [BEq α] : Node α → α → Nat \n  | Node.nil, _ => 0\n  | Node.cons x next, val => \n    let rest := count next val\n    if x == val then 1 + rest else rest", "vc-theorems": "theorem length_equals_list_length {α : Type} (xs : List α) :\n  length (xs.foldl (fun acc x => Node.cons x acc) Node.nil) = xs.length :=\nsorry\n\ntheorem count_equals_list_count {α : Type} [BEq α] (xs : List α) (val : α) :\n  count (xs.foldl (fun acc x => Node.cons x acc) Node.nil) val = xs.count val :=\nsorry \n\ntheorem count_none_is_zero {α : Type} [BEq α] (node : Node α) (default : α) :\n  count node default = 0 :=\nsorry\n\ntheorem count_leq_length {α : Type} [BEq α] (node : Node α) (val : α) :\n  count node val ≤ length node :=\nsorry\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval length None\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval count None 1\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval length Node(1)\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval count node 1\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval count node 2\n\n/-\ninfo: 3\n-/\n-- #guard_msgs in\n-- #eval length test_list_one_two_three()\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval count list123 1\n\n/-\ninfo: 1\n-/\n-- #guard_msgs in\n-- #eval count list123 2\n\n/-\ninfo: 0\n-/\n-- #guard_msgs in\n-- #eval count list123 4", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4692", "language": "lean", "source": "fvapps", "source-id": "fvapps_004692", "source-notes": "", "vc-description": "/-\nYou're putting together contact information for all the users of your website to ship them a small gift. You queried your database and got back a list of users, where each user is another list with up to two items: a string representing the user's name and their shipping zip code. Example data might look like:\n\n```python\n[[\"Grae Drake\", 98110], [\"Bethany Kok\"], [\"Alex Nussbacher\", 94101], [\"Darrell Silver\", 11201]]\n```\nNotice that one of the users above has a name but _doesn't_ have a zip code.\n\nWrite a function `user_contacts()` that takes a two-dimensional list like the one above and returns a dictionary with an item for each user where the key is the user's name and the value is the user's zip code. If your data doesn't include a zip code then the value should be `None`.\n\nFor example, using the input above, `user_contacts()` would return this dictionary:\n```python\n{\n    \"Grae Drake\": 98110,\n    \"Bethany Kok\": None,\n    \"Alex Nussbacher\": 94101,\n    \"Darrell Silver\": 11201,    \n}\n```\n\nYou don't have to worry about leading zeros in zip codes.\n-/", "vc-preamble": "", "vc-helpers": "", "vc-definitions": "def user_contacts (contacts : List (List String)) : \n  HashMap String (Option Int) := sorry", "vc-theorems": "theorem all_missing_zips (names : List String) :\n    let contacts := names.map (fun name => [name])\n    let result := user_contacts contacts\n    contacts.length = result.size ∧ \n    ∀ k, result.get k = none ∨ result.get k = some none := sorry\n\ntheorem all_have_zips (contacts : List (String × Int))\n    (h₁ : ∀ (p₁ p₂ : String × Int), p₁ ∈ contacts → p₂ ∈ contacts → p₁ ≠ p₂ → p₁.1 ≠ p₂.1)\n    (h₂ : ∀ pair ∈ contacts, 10000 ≤ pair.2 ∧ pair.2 ≤ 99999) :\n    let result := user_contacts (contacts.map (fun p => [p.1, toString p.2]))\n    contacts.length = result.size ∧\n    (∀ k, (result.get k).isSome → (Option.get! (result.get k)).isSome) ∧\n    (∀ pair ∈ contacts, result.get pair.1 = some (some pair.2)) := sorry\n\n/-\ninfo: expected1\n-/\n-- #guard_msgs in\n-- #eval user_contacts [[\"Grae Drake\", 98110], [\"Bethany Kok\"], [\"Alex Nussbacher\", 94101]]\n\n/-\ninfo: {}\n-/\n-- #guard_msgs in\n-- #eval user_contacts []\n\n/-\ninfo: expected3\n-/\n-- #guard_msgs in\n-- #eval user_contacts [[\"User1\", 12345], [\"User2\", 67890]]", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4694", "language": "lean", "source": "fvapps", "source-id": "fvapps_004694", "source-notes": "", "vc-description": "/-\nThe function must return the sequence of titles that match the string passed as an argument. \n\n```if:javascript\nTITLES is a preloaded sequence of strings. \n```\n\n```python\ntitles = ['Rocky 1', 'Rocky 2', 'My Little Poney']\nsearch(titles, 'ock') --> ['Rocky 1', 'Rocky 2']\n```\n\nBut the function return some weird result and skip some of the matching results.\n\nDoes the function have special movie taste? \n\nLet's figure out !\n-/", "vc-preamble": "def search (titles : List String) (term : String) : List String :=\n  sorry", "vc-helpers": "", "vc-definitions": "def containsInsensitive (s₁ s₂ : String) : Bool :=\n  sorry", "vc-theorems": "theorem search_case_insensitive (titles : List String) (term : String) :\n  ∀ t ∈ search titles term, containsInsensitive t term = true := by\n  sorry\n\ntheorem search_returns_subset (titles : List String) (term : String) :\n  ∀ t ∈ search titles term, t ∈ titles := by\n  sorry\n\ntheorem search_order_preserved (titles : List String) (term : String) :\n  let result := search titles term\n  ∀ i j, i < j → i < result.length → j < result.length → \n    (titles.indexOf (result[i]!) < titles.indexOf (result[j]!)) := by\n  sorry\n\ntheorem search_empty_term (titles : List String) :\n  search titles \"\" = titles := by\n  sorry\n\ntheorem search_empty_titles (term : String) :\n  search [] term = [] := by\n  sorry\n\n/-\ninfo: ['Rocky 1', 'Rocky 2']\n-/\n-- #guard_msgs in\n-- #eval search [\"Rocky 1\", \"Rocky 2\", \"My Little Poney\"] \"ock\"\n\n/-\ninfo: ['ROCK star', 'rock bottom', 'ROCKY']\n-/\n-- #guard_msgs in\n-- #eval search [\"ROCK star\", \"rock bottom\", \"ROCKY\"] \"rOcK\"\n\n/-\ninfo: []\n-/\n-- #guard_msgs in\n-- #eval search [\"Star Wars\", \"The Matrix\", \"Inception\"] \"rock\"", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4699", "language": "lean", "source": "fvapps", "source-id": "fvapps_004699", "source-notes": "", "vc-description": "/-\n# Introduction\n\nDots and Boxes is a pencil-and-paper game for two players (sometimes more). It was first published in the 19th century by Édouard Lucas, who called it la pipopipette. It has gone by many other names, including the game of dots, boxes, dot to dot grid, and pigs in a pen.\n\nStarting with an empty grid of dots, two players take turns adding a single horizontal or vertical line between two unjoined adjacent dots. The player who completes the fourth side of a 1×1 box earns one point and takes another turn only if another box can be made. (A point is typically recorded by placing a mark that identifies the player in the box, such as an initial). The game ends when no more lines can be placed. The winner is the player with the most points. The board may be of any size. When short on time, a 2×2 board (a square of 9 dots) is good for beginners. A 5×5 is good for experts. (Source Wikipedia)\n\n# Task\n\nYour task is to complete the class called Game. You will be given the board size as an integer board that will be between 1 and 26, therefore the game size will be board x board. You will be given an array of lines that have already been taken, so you must complete all possible squares.\n\n# Rules\n\n1.  The integer board will be passed when the class is initialised.\n\n2.  board will be between 1 and 26.\n\n3.  The lines array maybe empty or contain a list of line integers.\n\n4.  You can only complete a square if 3 out of the 4 sides are already complete.\n\n5.  The lines array that is passed into the play() function may not be sorted numerically!\n\n# Returns\n\nReturn an array of all the lines filled in including the original lines.\n\nReturn array must be sorted numerically.\n\nReturn array must not contain duplicate integers.\n\n# Example 1\n## Initialise\nInitialise a board of 2 squares by 2 squares where ```board = 2```\n\n## Line Numbering\n\n## Line Input\nSo for the line input of `[1, 3, 4]` the below lines would be complete\n\nto complete the square line `6` is needed\n## Game Play\n```python\nboard = 2\nlines = [1, 3, 4]\ngame = Game(board)\ngame.play(lines) => [1, 3, 4, 6]\n```\n\n# Example 2\n## Initialise\n```python\nboard = 2\nlines = [1, 2, 3, 4, 5, 8, 10, 11, 12]\ngame = Game.new(board)\ngame.play(lines) => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n```\n## Solution \n\nGood luck and enjoy!\n\n# Kata Series\nIf you enjoyed this, then please try one of my other Katas. Any feedback, translations and grading of beta Katas are greatly appreciated. Thank you.\n\n Maze Runner\n Scooby Doo Puzzle\n Driving License\n Connect 4\n Vending Machine\n Snakes and Ladders\n Mastermind\n Guess Who?\n Am I safe to drive?\n Mexican Wave\n Pigs in a Pen\n Hungry Hippos\n Plenty of Fish in the Pond\n Fruit Machine\n Car Park Escape\n-/", "vc-preamble": "def Game.board (g : Game) : List (List Nat) :=\n  sorry", "vc-helpers": "", "vc-definitions": "def Game.play (g : Game) (lines : List Nat) : List Nat :=\n  sorry", "vc-theorems": "theorem game_initialization {n : Nat} (h : 1 ≤ n ∧ n ≤ 10) :\n  let g := Game.mk n\n  (Game.board g).length = n ∧\n  ∀ row ∈ Game.board g, row.length = n :=\nsorry\n\ntheorem play_returns_sorted {n : Nat} (h : 1 ≤ n ∧ n ≤ 5) \n  (lines : List Nat) (hlines : lines ≠ []) \n  (hbound : ∀ x ∈ lines, 1 ≤ x ∧ x ≤ 100) :\n  let g := Game.mk n\n  let result := Game.play g lines\n  (∀ i j, i < j → j < result.length → result[i]! ≤ result[j]!) ∧\n  result.length ≥ lines.length :=\nsorry\n\ntheorem play_preserves_input_lines {n : Nat} (h : 1 ≤ n ∧ n ≤ 5)\n  (lines : List Nat) (hlines : lines ≠ [])\n  (hbound : ∀ x ∈ lines, 1 ≤ x ∧ x ≤ 100) :\n  let g := Game.mk n\n  let result := Game.play g lines\n  ∀ x ∈ lines, x ∈ result :=\nsorry\n\ntheorem empty_play {n : Nat} (h : 1 ≤ n ∧ n ≤ 5) :\n  let g := Game.mk n\n  Game.play g [] = [] :=\nsorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4702", "language": "lean", "source": "fvapps", "source-id": "fvapps_004702", "source-notes": "", "vc-description": "/-\n# Write this function\n\n![](http://i.imgur.com/mlbRlEm.png)\n\n`for i from 1 to n`, do `i % m` and return the `sum`\n\n    f(n=10, m=5) // returns 20 (1+2+3+4+0 + 1+2+3+4+0)\n\n*You'll need to get a little clever with performance, since n can be a very large number*\n-/", "vc-preamble": "def List.sum (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => x + List.sum xs", "vc-helpers": "", "vc-definitions": "def f (n m : Nat) : Nat := sorry\n\ntheorem result_non_negative (n m : Nat) (hn : n > 0) (hm : m > 0) :\n  f n m ≥ 0 := sorry", "vc-theorems": "theorem monotonic_increase (n delta m : Nat) \n  (hn : n > 0) (hd : delta > 0) (hm : m > 0) :\n  f (n + delta) m ≥ f n m := sorry\n\ntheorem base_case_one (m : Nat) (hm : m > 1) :\n  f 1 m = 1 % m := sorry\n\n/-\ninfo: 20\n-/\n-- #guard_msgs in\n-- #eval f 10 5\n\n/-\ninfo: 6\n-/\n-- #guard_msgs in\n-- #eval f 5 3\n\n/-\ninfo: 12\n-/\n-- #guard_msgs in\n-- #eval f 7 4", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: guarded_and_plausible", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LF4711", "language": "lean", "source": "fvapps", "source-id": "fvapps_004711", "source-notes": "", "vc-description": "/-\nAnother rewarding day in the fast-paced world of WebDev. Man, you love your job! But as with any job, somtimes things can get a little tedious. Part of the website you're working on has a very repetitive structure, and writing all the HTML by hand is a bore. Time to automate! You want to write some functions that will generate the HTML for you. \n\nTo organize your code, make of all your functions methods of a class called HTMLGen. Tag functions should be named after the tag of the element they create. Each function will take one argument, a string, which is the inner HTML of the element to be created. The functions will return the string for the appropriate HTML element.\n\nFor example, \n\nIn JavaScript:\n\nIn Python:\n```python\ng = HTMLGen();\nparagraph = g.p('Hello, World!')\nblock = g.div(paragraph)\n\n# The following are now true\nparagraph == 'Hello, World!'\nblock == 'Hello, World!'\n```\n\nYour HTMLGen class should have methods to create the following elements:\n\n  * a\n  * b\n  * p\n  * body\n  * div\n  * span\n  * title\n  * comment\n\nNote: The comment method should wrap its argument with an HTML comment. It is the only method whose name does not match an HTML tag. So, ```g.comment('i am a comment')``` must produce ``````.\n-/", "vc-preamble": "def HtmlGen.tag (t : HtmlTag) (content : String) : String := sorry\n\ntheorem tag_structure {t : HtmlTag} {content : String} :\n  let result := HtmlGen.tag t content\n  result.startsWith s!\"<{repr t}>\" ∧ \n  result.endsWith s!\"</{repr t}>\" ∧\n  result = s!\"<{repr t}>{content}</{repr t}>\" := sorry", "vc-helpers": "", "vc-definitions": "def HtmlGen.comment (content : String) : String := sorry\n\ntheorem comment_structure {content : String} :\n  let result := HtmlGen.comment content\n  result.startsWith \"<!--\" ∧\n  result.endsWith \"-->\" ∧ \n  result = s!\"<!--{content}-->\" := sorry", "vc-theorems": "theorem nested_tags {outer inner : HtmlTag} {content : String} :\n  let innerResult := HtmlGen.tag inner content\n  let result := HtmlGen.tag outer innerResult\n  result = s!\"<{repr outer}><{repr inner}>{content}</{repr inner}></{repr outer}>\" := sorry\n\ntheorem custom_tag_direct {content : String} :\n  HtmlGen.tag HtmlTag.custom content = s!\"<custom>{content}</custom>\" := sorry", "vc-postamble": "-- Apps difficulty: introductory\n-- Assurance level: unguarded", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0117", "language": "lean", "source": "numpy_triple", "source-id": "data_type_routines_common_type", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Represents different numeric data types in NumPy -/\ninductive NumPyDType where\n  /-- 32-bit floating point -/\n  | float32 : NumPyDType\n  /-- 64-bit floating point -/\n  | float64 : NumPyDType\n  /-- 64-bit complex number (32-bit real + 32-bit imaginary) -/\n  | complex64 : NumPyDType\n  /-- 128-bit complex number (64-bit real + 64-bit imaginary) -/\n  | complex128 : NumPyDType\n  /-- 8-bit signed integer -/\n  | int8 : NumPyDType\n  /-- 16-bit signed integer -/\n  | int16 : NumPyDType\n  /-- 32-bit signed integer -/\n  | int32 : NumPyDType\n  /-- 64-bit signed integer -/\n  | int64 : NumPyDType\n  /-- 8-bit unsigned integer -/\n  | uint8 : NumPyDType\n  /-- 16-bit unsigned integer -/\n  | uint16 : NumPyDType\n  /-- 32-bit unsigned integer -/\n  | uint32 : NumPyDType\n  /-- 64-bit unsigned integer -/\n  | uint64 : NumPyDType\n\n/-- Check if a dtype is a complex type -/\ndef NumPyDType.isComplex (dtype : NumPyDType) : Bool :=\n  match dtype with\n  | NumPyDType.complex64 => true\n  | NumPyDType.complex128 => true\n  | _ => false\n\n/-- Check if a dtype is an integer type -/\ndef NumPyDType.isInteger (dtype : NumPyDType) : Bool :=\n  match dtype with\n  | NumPyDType.int8 | NumPyDType.int16 | NumPyDType.int32 | NumPyDType.int64 => true\n  | NumPyDType.uint8 | NumPyDType.uint16 | NumPyDType.uint32 | NumPyDType.uint64 => true\n  | _ => false\n\n/-- Get the precision level of a dtype (higher = more precise) -/\ndef NumPyDType.precision (dtype : NumPyDType) : Nat :=\n  match dtype with\n  | NumPyDType.float32 => 1\n  | NumPyDType.float64 => 2\n  | NumPyDType.complex64 => 1\n  | NumPyDType.complex128 => 2\n  | NumPyDType.int8 | NumPyDType.uint8 => 2  -- promoted to float64\n  | NumPyDType.int16 | NumPyDType.uint16 => 2  -- promoted to float64\n  | NumPyDType.int32 | NumPyDType.uint32 => 2  -- promoted to float64\n  | NumPyDType.int64 | NumPyDType.uint64 => 2  -- promoted to float64\n\n/-- numpy.common_type: Return a scalar type which is common to the input arrays.\n    \n    The return type will always be an inexact (floating point) scalar type,\n    even if all the arrays are integer arrays. If one of the inputs is an\n    integer array, the minimum precision type that is returned is a 64-bit\n    floating point dtype.\n    \n    Takes a non-empty list of array dtypes and returns their common type.\n-/\ndef numpy_common_type {n : Nat} (dtypes : Vector NumPyDType (n + 1)) : Id NumPyDType :=\n  sorry\n\n/-- Specification: numpy.common_type returns the appropriate common type\n    based on NumPy's type promotion rules.\n    \n    Key properties:\n    1. The result is always a floating point or complex type (inexact)\n    2. If any input is complex, the result is complex\n    3. If all inputs are integer, the result is at least Float64\n    4. The precision is the maximum of all input precisions\n    5. Complex types take precedence over real types\n-/\ntheorem numpy_common_type_spec {n : Nat} (dtypes : Vector NumPyDType (n + 1)) :\n    ⦃⌜True⌝⦄\n    numpy_common_type dtypes\n    ⦃⇓result => ⌜\n      -- Result is always inexact (floating point or complex)\n      (result = NumPyDType.float32 ∨ result = NumPyDType.float64 ∨ \n       result = NumPyDType.complex64 ∨ result = NumPyDType.complex128) ∧\n      \n      -- If any input is complex, result is complex\n      (∃ i : Fin (n + 1), (dtypes.get i).isComplex = true) →\n      (result = NumPyDType.complex64 ∨ result = NumPyDType.complex128) ∧\n      \n      -- If all inputs are integer, result is at least Float64\n      (∀ i : Fin (n + 1), (dtypes.get i).isInteger = true) →\n      (result = NumPyDType.float64 ∨ result = NumPyDType.complex128) ∧\n      \n      -- Result precision is at least the maximum of all input precisions\n      (∀ i : Fin (n + 1), (dtypes.get i).precision ≤ result.precision) ∧\n      \n      -- Complex takes precedence: if any input is complex, result is complex with appropriate precision\n      (∃ i : Fin (n + 1), (dtypes.get i).isComplex = true) →\n      (result.isComplex = true ∧ \n       result.precision = (List.range (n + 1)).foldl (fun acc j => \n         max acc (dtypes.get ⟨j, by sorry⟩).precision) 0)\n    ⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0127", "language": "lean", "source": "numpy_triple", "source-id": "data_type_routines_issubsctype", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.issubsctype\",\n  \"category\": \"Data Type Testing\",\n  \"description\": \"Determine if the first argument is a subclass of the second argument\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.issubsctype.html\",\n  \"doc\": \"Determine if the first argument is a subclass of the second argument.\\n\\nParameters\\n----------\\narg1, arg2 : dtype or dtype specifier\\n    Data-types.\\n\\nReturns\\n-------\\nout : bool\\n    The result.\\n\\nExamples\\n--------\\n>>> np.issubsctype('S8', str)\\nTrue\\n>>> np.issubsctype(np.array([1]), int)\\nTrue\\n>>> np.issubsctype(np.array([1]), float)\\nFalse\",\n  \"code\": \"\\n@set_module('numpy')\\ndef issubsctype(arg1, arg2):\\n    \\\"\\\"\\\"\\n    Determine if the first argument is a subclass of the second argument.\\n\\n    Parameters\\n    ----------\\n    arg1, arg2 : dtype or dtype specifier\\n        Data-types.\\n\\n    Returns\\n    -------\\n    out : bool\\n        The result.\\n\\n    See Also\\n    --------\\n    issctype, issubdtype, obj2sctype\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> np.issubsctype('S8', str)\\n    True\\n    >>> np.issubsctype(np.array([1]), int)\\n    True\\n    >>> np.issubsctype(np.array([1]), float)\\n    False\\n\\n    \\\"\\\"\\\"\\n    return issubclass(obj2sctype(arg1), obj2sctype(arg2))\"\n}\n-/\n\n/-- Data type hierarchy for NumPy scalar types -/\ninductive DType : Type\n  | int8 | int16 | int32 | int64\n  | uint8 | uint16 | uint32 | uint64\n  | float32 | float64\n  | complex64 | complex128\n  | bool\n  | str\n  | unicode\n  | object\n  deriving Repr, DecidableEq\n\n/-- Type hierarchy relationship for NumPy scalar types -/\ndef isSubtype : DType → DType → Bool\n  | DType.int8, DType.int16 => true\n  | DType.int8, DType.int32 => true\n  | DType.int8, DType.int64 => true\n  | DType.int8, DType.float32 => true\n  | DType.int8, DType.float64 => true\n  | DType.int8, DType.complex64 => true\n  | DType.int8, DType.complex128 => true\n  | DType.int16, DType.int32 => true\n  | DType.int16, DType.int64 => true\n  | DType.int16, DType.float32 => true\n  | DType.int16, DType.float64 => true\n  | DType.int16, DType.complex64 => true\n  | DType.int16, DType.complex128 => true\n  | DType.int32, DType.int64 => true\n  | DType.int32, DType.float64 => true\n  | DType.int32, DType.complex128 => true\n  | DType.int64, DType.complex128 => true\n  | DType.uint8, DType.uint16 => true\n  | DType.uint8, DType.uint32 => true\n  | DType.uint8, DType.uint64 => true\n  | DType.uint8, DType.float32 => true\n  | DType.uint8, DType.float64 => true\n  | DType.uint8, DType.complex64 => true\n  | DType.uint8, DType.complex128 => true\n  | DType.uint16, DType.uint32 => true\n  | DType.uint16, DType.uint64 => true\n  | DType.uint16, DType.float32 => true\n  | DType.uint16, DType.float64 => true\n  | DType.uint16, DType.complex64 => true\n  | DType.uint16, DType.complex128 => true\n  | DType.uint32, DType.uint64 => true\n  | DType.uint32, DType.float64 => true\n  | DType.uint32, DType.complex128 => true\n  | DType.uint64, DType.complex128 => true\n  | DType.float32, DType.float64 => true\n  | DType.float32, DType.complex64 => true\n  | DType.float32, DType.complex128 => true\n  | DType.float64, DType.complex128 => true\n  | DType.complex64, DType.complex128 => true\n  | t1, t2 => t1 == t2\n\n/-- Determines if the first data type is a subclass of the second data type -/\ndef issubsctype (arg1 arg2 : DType) : Id Bool :=\n  return isSubtype arg1 arg2\n\n/-- Specification: issubsctype checks if arg1 is a subclass of arg2 according to NumPy's type hierarchy\n    This specification captures the core mathematical properties:\n    1. Reflexivity: Every type is a subclass of itself\n    2. Consistency: The result matches the isSubtype function\n    3. Bidirectional implication: result = true iff isSubtype returns true\n    4. Transitivity is encoded in the isSubtype function definition\n-/\ntheorem issubsctype_spec (arg1 arg2 : DType) :\n    ⦃⌜True⌝⦄\n    issubsctype arg1 arg2\n    ⦃⇓result => ⌜result = true ↔ isSubtype arg1 arg2 = true ∧\n                  (arg1 = arg2 → result = true) ∧\n                  (isSubtype arg1 arg2 = true → result = true) ∧\n                  (result = false → isSubtype arg1 arg2 = false)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0139", "language": "lean", "source": "numpy_triple", "source-id": "datetime_support_busday_count", "source-notes": "", "vc-description": "", "vc-preamble": "/-!\n{\n  \"name\": \"numpy.busday_count\",\n  \"category\": \"Business day operations\",\n  \"description\": \"Counts the number of valid days between begindates and enddates, not including the day of enddates\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.busday_count.html\",\n  \"doc\": \"busday_count(begindates, enddates, weekmask='1111100', holidays=[], busdaycal=None, out=None)\\n\\nCounts the number of valid days between `begindates` and `enddates`, not including the day of `enddates`.\\n\\nIf ``enddates`` specifies a date value that is earlier than the corresponding ``begindates`` date value, the count will be negative.\\n\\nParameters\\n----------\\nbegindates : array_like of datetime64[D]\\n    The array of the first dates for counting.\\nenddates : array_like of datetime64[D]\\n    The array of the end dates for counting, which are excluded from the count themselves.\\nweekmask : str or array_like of bool, optional\\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string like \\\"Mon Tue Wed Thu Fri\\\", made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun\\nholidays : array_like of datetime64[D], optional\\n    An array of dates to consider as invalid dates. They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.\\nbusdaycal : busdaycalendar, optional\\n    A `busdaycalendar` object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided.\\nout : array of int, optional\\n    If provided, this array is filled with the result.\\n\\nReturns\\n-------\\nout : array of int\\n    An array with a shape from broadcasting ``begindates`` and ``enddates`` together, containing the number of valid days between the begin and end dates.\",\n  \"code\": \"# C implementation for performance\\n# Counts the number of valid days between begindates and enddates, not including the day of enddates\\n#\\n# This function is implemented in C as part of NumPy's core multiarray module.\\n# The C implementation provides:\\n# - Optimized memory access patterns\\n# - Efficient array manipulation\\n# - Low-level control over data layout\\n# - Integration with NumPy's array object internals\\n#\\n# Source: C implementation in numpy/_core/src/multiarray/datetime_busday.c\"\n}\n-/\n\n/-- Datetime type representing days since epoch (like numpy.datetime64[D]) -/\nstructure DateTime64D where\n  /-- Number of days since epoch (1970-01-01) -/\n  days_since_epoch : Int\n  deriving Repr, DecidableEq, Ord\n\n/-- Weekmask type: 7-element boolean array for Mon-Sun -/\nstructure WeekMask where\n  /-- Boolean mask for days of week (Monday through Sunday) -/\n  mask : Vector Bool 7\n\n/-- Standard business day weekmask (Mon-Fri = true, Sat-Sun = false) -/\ndef standardBusinessDayMask : WeekMask :=\n  ⟨⟨#[true, true, true, true, true, false, false], rfl⟩⟩\n\n/-- Counts the number of valid business days between begin and end dates.\n    \n    This function counts business days (weekdays excluding weekends and holidays)\n    between pairs of dates. The end date is excluded from the count.\n    \n    If end date is earlier than begin date, the count is negative.\n-/\ndef busday_count {n : Nat} (begindates : Vector DateTime64D n) (enddates : Vector DateTime64D n)\n    (weekmask : WeekMask := standardBusinessDayMask) (holidays : List DateTime64D := [])\n    : Vector Int n :=\n  sorry\n\n/-- Specification for busday_count function.\n    \n    This theorem specifies the key properties of business day counting:\n    1. When begin_date = end_date, count is 0\n    2. When end_date < begin_date, count is negative\n    3. Forward direction gives non-negative count\n    4. Holidays are excluded from the count\n    \n    The specification captures the mathematical properties of business day counting\n    as described in the NumPy documentation.\n-/\ntheorem busday_count_spec {n : Nat} (begindates : Vector DateTime64D n) (enddates : Vector DateTime64D n)\n    (weekmask : WeekMask) (holidays : List DateTime64D) :\n  let result := busday_count begindates enddates weekmask holidays\n  -- Same date property: if begin = end, count is 0\n  (∀ i : Fin n, begindates.get i = enddates.get i → result.get i = 0) ∧\n  -- Reverse order property: if end < begin, count is negative\n  (∀ i : Fin n, (enddates.get i).days_since_epoch < (begindates.get i).days_since_epoch → result.get i < 0) ∧\n  -- Forward order property: if begin <= end, count is non-negative for standard business days\n  (∀ i : Fin n, (begindates.get i).days_since_epoch ≤ (enddates.get i).days_since_epoch → result.get i ≥ 0) ∧\n  -- Holiday exclusion property: holidays reduce the count\n  (∀ i : Fin n, ∀ h ∈ holidays, \n    (begindates.get i).days_since_epoch ≤ h.days_since_epoch ∧ \n    h.days_since_epoch < (enddates.get i).days_since_epoch →\n    result.get i ≤ (enddates.get i).days_since_epoch - (begindates.get i).days_since_epoch) :=\n  by sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0140", "language": "lean", "source": "numpy_triple", "source-id": "datetime_support_busday_offset", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.busday_offset\",\n  \"category\": \"Business day operations\",\n  \"description\": \"First adjusts the date to fall on a valid day according to the roll rule, then applies offsets to the given dates counted in valid days\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.busday_offset.html\",\n  \"doc\": \"busday_offset(dates, offsets, roll='raise', weekmask='1111100', holidays=None, busdaycal=None, out=None)\\n\\nFirst adjusts the date to fall on a valid day according to the \\`\\`roll\\`\\` rule, then applies offsets to the given dates counted in valid days.\\n\\nParameters\\n----------\\ndates : array_like of datetime64[D]\\n    The array of dates to process.\\noffsets : array_like of int\\n    The array of offsets, which is broadcast with \\`\\`dates\\`\\`.\\nroll : {'raise', 'nat', 'forward', 'following', 'backward', 'preceding', 'modifiedfollowing', 'modifiedpreceding'}, optional\\n    How to treat dates that do not fall on a valid day. The default is 'raise'.\\n\\n    * 'raise' means to raise an exception for an invalid day.\\n    * 'nat' means to return a NaT (not-a-time) for an invalid day.\\n    * 'forward' and 'following' mean to take the first valid day later in time.\\n    * 'backward' and 'preceding' mean to take the first valid day earlier in time.\\n    * 'modifiedfollowing' means to take the first valid day later in time unless it is across a Month boundary, in which case to take the first valid day earlier in time.\\n    * 'modifiedpreceding' means to take the first valid day earlier in time unless it is across a Month boundary, in which case to take the first valid day later in time.\\nweekmask : str or array_like of bool, optional\\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string like \\\"Mon Tue Wed Thu Fri\\\", made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun\\nholidays : array_like of datetime64[D], optional\\n    An array of dates to consider as invalid dates. They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.\\nbusdaycal : busdaycalendar, optional\\n    A \\`busdaycalendar\\` object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided.\\nout : array of datetime64[D], optional\\n    If provided, this array is filled with the result.\\n\\nReturns\\n-------\\nout : array of datetime64[D]\\n    An array with a shape from broadcasting \\`\\`dates\\`\\` and \\`\\`offsets\\`\\` together, containing the dates with offsets applied.\",\n  \"code\": \"# C implementation for performance\\n# First adjusts the date to fall on a valid day according to the roll rule, then applies offsets to the given dates counted in valid days\\n#\\n# This function is implemented in C as part of NumPy's core multiarray module.\\n# The C implementation provides:\\n# - Optimized memory access patterns\\n# - Efficient array manipulation\\n# - Low-level control over data layout\\n# - Integration with NumPy's array object internals\\n#\\n# Source: C implementation in numpy/_core/src/multiarray/datetime_busday.c\"\n}\n-/\n\n/-- Represents a date as days since epoch -/\nabbrev Date := Int\n\n/-- Represents roll strategies for adjusting invalid dates -/\ninductive RollStrategy\n  /-- Raise exception for invalid day -/\n  | raise\n  /-- Return NaT for invalid day -/\n  | nat\n  /-- Take first valid day later in time -/\n  | forward\n  /-- Take first valid day earlier in time -/\n  | backward\n  /-- Forward unless across month boundary -/\n  | modifiedfollowing\n  /-- Backward unless across month boundary -/\n  | modifiedpreceding\n\n/-- Represents a weekmask as a 7-element vector for Monday through Sunday -/\nabbrev Weekmask := Vector Bool 7\n\n/-- Predicate to check if a date is a valid business day -/\ndef isBusinessDay (date : Date) (weekmask : Weekmask) (holidays : List Date) : Bool :=\n  let dayOfWeek := (date % 7).natAbs\n  if h : dayOfWeek < 7 then\n    weekmask.get ⟨dayOfWeek, h⟩ && !holidays.contains date\n  else\n    false\n\n/-- Adjusts a date according to roll strategy to fall on a valid business day -/\ndef adjustDate (date : Date) (roll : RollStrategy) (weekmask : Weekmask) (holidays : List Date) : Date :=\n  sorry\n\n/-- Applies business day offset to a date -/\ndef applyBusinessDayOffset (date : Date) (offset : Int) (weekmask : Weekmask) (holidays : List Date) : Date :=\n  sorry\n\n/-- Business day offset operation on vectors of dates and offsets -/\ndef busday_offset {n : Nat} (dates : Vector Date n) (offsets : Vector Int n) \n    (roll : RollStrategy) (weekmask : Weekmask) (holidays : List Date) : Id (Vector Date n) :=\n  sorry\n\n/-- Specification for busday_offset: applies business day offsets to dates after adjustment -/\ntheorem busday_offset_spec {n : Nat} (dates : Vector Date n) (offsets : Vector Int n) \n    (roll : RollStrategy) (weekmask : Weekmask) (holidays : List Date) :\n    ⦃⌜True⌝⦄\n    busday_offset dates offsets roll weekmask holidays\n    ⦃⇓result => ⌜∀ i : Fin n, \n        let adjustedDate := adjustDate (dates.get i) roll weekmask holidays\n        let finalDate := applyBusinessDayOffset adjustedDate (offsets.get i) weekmask holidays\n        result.get i = finalDate ∧\n        isBusinessDay (result.get i) weekmask holidays = true⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0141", "language": "lean", "source": "numpy_triple", "source-id": "datetime_support_busdaycalendar", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.busdaycalendar\",\n  \"category\": \"Business day operations\",\n  \"description\": \"A business day calendar object that efficiently stores information defining valid days for the busday family of functions\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.busdaycalendar.html\",\n  \"doc\": \"busdaycalendar(weekmask='1111100', holidays=None)\\n\\nA business day calendar object that efficiently stores information defining valid days for the busday family of functions.\\n\\nThe default valid days are Monday through Friday (\\\"business days\\\"). A busdaycalendar object can be specified with any set of weekly valid days, plus an optional \\\"holiday\\\" dates that always will be invalid.\\n\\nOnce a busdaycalendar object is created, the weekmask and holidays cannot be modified.\\n\\nParameters\\n----------\\nweekmask : str or array_like of bool, optional\\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string like \\\"Mon Tue Wed Thu Fri\\\", made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun\\nholidays : array_like of datetime64[D], optional\\n    An array of dates to consider as invalid dates, no matter which weekday they fall upon. Holiday dates may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.\\n\\nReturns\\n-------\\nout : busdaycalendar\\n    A business day calendar object containing the specified weekmask and holidays values.\\n\\nAttributes\\n----------\\nweekmask : (copy) seven-element array of bool\\nholidays : (copy) sorted array of datetime64[D]\",\n  \"code\": \"# C implementation for performance\\n# A business day calendar object that efficiently stores information defining valid days for the busday family of functions\\n#\\n# This function is implemented in C as part of NumPy's core multiarray module.\\n# The C implementation provides:\\n# - Optimized memory access patterns\\n# - Efficient array manipulation\\n# - Low-level control over data layout\\n# - Integration with NumPy's array object internals\\n#\\n# Source: C implementation in numpy/_core/src/multiarray/datetime_busday.c\"\n}\n-/\n\nopen Std.Do\n\n/-- Business day calendar object that efficiently stores information defining valid days --/\nstructure BusdayCalendar (n : Nat) where\n  /-- Seven-element array indicating which days are valid (Mon-Sun) --/\n  weekmask : Vector Bool 7  \n  /-- Array of dates (represented as day numbers) to consider invalid --/\n  holidays : Vector Nat n\n\n/-- A business day calendar object that efficiently stores information defining valid days\n    for the busday family of functions.\n    \n    The default valid days are Monday through Friday (\"business days\"). A busdaycalendar \n    object can be specified with any set of weekly valid days, plus an optional \"holiday\" \n    dates that always will be invalid. --/\ndef busdaycalendar {n : Nat} (weekmask : Vector Bool 7) (holidays : Vector Nat n) : Id (BusdayCalendar n) :=\n  sorry\n\n/-- Specification: busdaycalendar creates a valid business day calendar object with the given weekmask and holidays --/\n-- Basic specification: busdaycalendar creates a calendar with the given weekmask and holidays\ntheorem busdaycalendar_spec {n : Nat} (weekmask : Vector Bool 7) (holidays : Vector Nat n) :\n    busdaycalendar weekmask holidays = pure (BusdayCalendar.mk weekmask holidays) := by\n  sorry\n\n-- Sanity check: weekmask preserves the 7-day structure\ntheorem busdaycalendar_weekmask_preserved {n : Nat} (weekmask : Vector Bool 7) (holidays : Vector Nat n) :\n    let calendar := (busdaycalendar weekmask holidays).run\n    calendar.weekmask = weekmask := by\n  sorry\n\n-- Mathematical property: holidays are preserved in the calendar\ntheorem busdaycalendar_holidays_preserved {n : Nat} (weekmask : Vector Bool 7) (holidays : Vector Nat n) :\n    let calendar := (busdaycalendar weekmask holidays).run\n    calendar.holidays = holidays := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0145", "language": "lean", "source": "numpy_triple", "source-id": "datetime_support_is_busday", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.is_busday\",\n  \"category\": \"Business day operations\",\n  \"description\": \"Calculates which of the given dates are valid days, and which are not\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.is_busday.html\",\n  \"doc\": \"is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None)\\n\\nCalculates which of the given dates are valid days, and which are not.\\n\\nParameters\\n----------\\ndates : array_like of datetime64[D]\\n    The array of dates to process.\\nweekmask : str or array_like of bool, optional\\n    A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string like \\\"Mon Tue Wed Thu Fri\\\", made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun\\nholidays : array_like of datetime64[D], optional\\n    An array of dates to consider as invalid dates. They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.\\nbusdaycal : busdaycalendar, optional\\n    A \\`busdaycalendar\\` object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided.\\nout : array of bool, optional\\n    If provided, this array is filled with the result.\\n\\nReturns\\n-------\\nout : array of bool\\n    An array with the same shape as \\`\\`dates\\`\\`, containing True for each valid day, and False for each invalid day.\",\n  \"code\": \"# C implementation for performance\\n# Calculates which of the given dates are valid days, and which are not\\n#\\n# This function is implemented in C as part of NumPy's core multiarray module.\\n# The C implementation provides:\\n# - Optimized memory access patterns\\n# - Efficient array manipulation\\n# - Low-level control over data layout\\n# - Integration with NumPy's array object internals\\n#\\n# Source: C implementation in numpy/_core/src/multiarray/datetime_busday.c\"\n}\n-/\n\n/-- Date representation as an abstract type -/\nopaque Date : Type\n\n/-- Day of week enumeration (Monday = 0, Sunday = 6) -/\ninductive DayOfWeek : Type\n/-- Monday -/\n| monday : DayOfWeek\n/-- Tuesday -/\n| tuesday : DayOfWeek\n/-- Wednesday -/\n| wednesday : DayOfWeek\n/-- Thursday -/\n| thursday : DayOfWeek\n/-- Friday -/\n| friday : DayOfWeek\n/-- Saturday -/\n| saturday : DayOfWeek\n/-- Sunday -/\n| sunday : DayOfWeek\n\n/-- Convert day of week to natural number for indexing -/\ndef DayOfWeek.toNat : DayOfWeek → Nat\n| .monday => 0\n| .tuesday => 1\n| .wednesday => 2\n| .thursday => 3\n| .friday => 4\n| .saturday => 5\n| .sunday => 6\n\n/-- Function to get day of week from a date -/\naxiom Date.dayOfWeek : Date → DayOfWeek\n\n/-- Function to check if a date is in a holiday list -/\naxiom Date.isHoliday : ∀ {h : Nat}, Date → Vector Date h → Bool\n\n/-- \nCalculates which of the given dates are valid business days.\nA business day is a day that is both:\n1. Allowed by the weekmask (Monday-Friday by default)\n2. Not a holiday\n-/\ndef is_busday {n h : Nat} (dates : Vector Date n) \n    (weekmask : Vector Bool 7) \n    (holidays : Vector Date h) : Id (Vector Bool n) :=\n  sorry\n\n/-- \nSpecification: is_busday returns a boolean vector indicating which dates are business days.\nA date is a business day if:\n1. Its day of week is allowed by the weekmask\n2. It is not in the holidays list\n-/\ntheorem is_busday_spec {n h : Nat} (dates : Vector Date n) \n    (weekmask : Vector Bool 7) \n    (holidays : Vector Date h) :\n    ⦃⌜True⌝⦄\n    is_busday dates weekmask holidays\n    ⦃⇓result => ⌜∀ i : Fin n, \n      let dayIdx := (dates.get i).dayOfWeek.toNat\n      let validDay := weekmask.get ⟨dayIdx, sorry⟩\n      let isHoliday := (dates.get i).isHoliday holidays\n      result.get i = (validDay ∧ ¬isHoliday)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0148", "language": "lean", "source": "numpy_triple", "source-id": "fft_fft2", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.fft.fft2\",\n  \"description\": \"Compute the 2-dimensional discrete Fourier Transform\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fft.fft2.html\",\n  \"doc\": \"numpy.fft.fft2(a, s=None, axes=(-2, -1), norm=None, out=None)\\n\\nCompute the 2-dimensional discrete Fourier Transform over specified axes of an M-dimensional array using the Fast Fourier Transform (FFT).\\n\\nParameters:\\n- a: Input array (can be complex)\\n- s: Optional sequence of integers specifying output shape\\n- axes: Optional sequence of axes to transform (default: last two axes)\\n- norm: Optional normalization mode (\\\"backward\\\", \\\"ortho\\\", \\\"forward\\\")\\n- out: Optional output array\\n\\nReturns:\\n- Complex ndarray transformed along specified axes\\n\\nNotes:\\n- Computes FFT by default over last two axes\\n- Zero frequency term is in low-order corner\\n- Positive and negative frequency terms are arranged in specific order\\n\\nExample:\\nimport numpy as np\\na = np.mgrid[:5, :5][0]\\nnp.fft.fft2(a)\",\n  \"code\": \"@array_function_dispatch(_fftn_dispatcher)\\ndef fft2(a, s=None, axes=(-2, -1), norm=None, out=None):\\n    \\\"\\\"\\\"\\n    Compute the 2-dimensional discrete Fourier Transform.\\n    \\\"\\\"\\\"\\n    return _raw_fftnd(a, s, axes, fft, norm, out=out)\"\n}\n-/\n\nopen Std.Do\n\n/-- Complex number type for FFT -/\nstructure Complex where\n  /-- Real part -/\n  re : Float\n  /-- Imaginary part -/\n  im : Float\nderiving Repr\n\n/-- Complex zero -/\ndef Complex.zero : Complex := { re := 0.0, im := 0.0 }\n\n/-- Complex multiplication -/\ninstance : Mul Complex where\n  mul z w := { re := z.re * w.re - z.im * w.im, im := z.re * w.im + z.im * w.re }\n\n/-- Complex addition -/\ninstance : Add Complex where\n  add z w := { re := z.re + w.re, im := z.im + w.im }\n\n/-- Complex exponential function e^(iθ) -/\ndef cexp (θ : Float) : Complex :=\n  { re := Float.cos θ, im := Float.sin θ }\n\n/-- 2D Discrete Fourier Transform formula for element (k, l) given input matrix of size m × n\n    DFT[k, l] = Σ_{p=0}^{m-1} Σ_{q=0}^{n-1} input[p, q] * e^(-2πi(kp/m + lq/n))\n-/\ndef dft2_element {m n : Nat} (input : Vector (Vector Complex n) m) (k : Fin m) (l : Fin n) : Complex :=\n  let pi := 3.141592653589793 -- Define pi since Float.pi is not available\n  let sum_all := fun (acc : Complex) (p : Fin m) =>\n    let acc_inner := fun (acc_q : Complex) (q : Fin n) =>\n      let phase := -2.0 * pi * ((k.val.toFloat * p.val.toFloat) / m.toFloat + \n                                (l.val.toFloat * q.val.toFloat) / n.toFloat)\n      let exponential := cexp phase\n      let term := (input.get p).get q * exponential\n      acc_q + term\n    Vector.foldl acc_inner acc (Vector.ofFn (fun q => q))\n  Vector.foldl sum_all Complex.zero (Vector.ofFn (fun p => p))\n\n/-- numpy.fft.fft2: Compute the 2-dimensional discrete Fourier Transform.\n    \n    This function computes the 2D DFT of the input matrix, transforming from\n    spatial/time domain to frequency domain. The result contains complex values\n    representing the frequency components of the input.\n    \n    The 2D DFT is separable and can be computed as successive 1D transforms\n    along each dimension.\n-/\ndef numpy_fft2 {m n : Nat} (a : Vector (Vector Complex n) m) : Id (Vector (Vector Complex n) m) :=\n  return Vector.ofFn (fun k => Vector.ofFn (fun l => dft2_element a k l))\n\n/-- Specification: numpy.fft.fft2 computes the 2D discrete Fourier transform\n    where each output element is the sum of all input elements weighted by\n    complex exponentials based on their positions.\n    \n    Precondition: True (no special preconditions for basic 2D FFT)\n    Postcondition: For all indices (k, l), the output element at position (k, l)\n    equals the 2D DFT formula applied to the input matrix.\n    \n    Mathematical properties:\n    1. Linearity: FFT(a + b) = FFT(a) + FFT(b)\n    2. Zero frequency component: DFT[0,0] is the sum of all input elements\n    3. Hermitian symmetry: For real inputs, DFT[k,l] = conj(DFT[m-k,n-l])\n    4. Parseval's theorem: Energy is preserved (when properly normalized)\n-/\ntheorem numpy_fft2_spec {m n : Nat} (a : Vector (Vector Complex n) m) :\n    ⦃⌜True⌝⦄\n    numpy_fft2 a\n    ⦃⇓result => ⌜∀ (k : Fin m) (l : Fin n), \n                  (result.get k).get l = dft2_element a k l⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0150", "language": "lean", "source": "numpy_triple", "source-id": "fft_fftn", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.fft.fftn\",\n  \"description\": \"Compute the N-dimensional discrete Fourier Transform\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fft.fftn.html\",\n  \"doc\": \"numpy.fft.fftn(a, s=None, axes=None, norm=None, out=None)\\n\\nCompute the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT).\\n\\nParameters:\\n- a: Input array, can be complex\\n- s: Optional sequence of ints specifying output shape for each transformed axis\\n- axes: Optional sequence of ints specifying axes to transform\\n- norm: Optional normalization mode (\\\"backward\\\", \\\"ortho\\\", \\\"forward\\\")\\n- out: Optional output array for the result\\n\\nReturns:\\n- The truncated or zero-padded input, transformed along the specified axes\\n\\nNotes:\\n- Output contains zero frequency in low-order corner\\n- Positive and negative frequency terms are arranged systematically\\n- Supports multi-dimensional FFT transformations\\n\\nExample:\\nimport numpy as np\\na = np.mgrid[:3, :3, :3][0]\\nnp.fft.fftn(a, axes=(1, 2))\",\n  \"code\": \"@array_function_dispatch(_fftn_dispatcher)\\ndef fftn(a, s=None, axes=None, norm=None, out=None):\\n    \\\"\\\"\\\"\\n    Compute the N-dimensional discrete Fourier Transform.\\n    \\\"\\\"\\\"\\n    return _raw_fftnd(a, s, axes, fft, norm, out=out)\"\n}\n-/\n\nopen Std.Do\n\n/-- Complex number type for FFT -/\nstructure Complex where\n  /-- Real part -/\n  re : Float\n  /-- Imaginary part -/\n  im : Float\nderiving Repr\n\n/-- Complex zero -/\ninstance : Zero Complex where\n  zero := { re := 0.0, im := 0.0 }\n\n/-- Complex multiplication -/\ninstance : Mul Complex where\n  mul z w := { re := z.re * w.re - z.im * w.im, im := z.re * w.im + z.im * w.re }\n\n/-- Complex addition -/\ninstance : Add Complex where\n  add z w := { re := z.re + w.re, im := z.im + w.im }\n\n/-- Complex exponential function e^(iθ) -/\ndef cexp (θ : Float) : Complex :=\n  { re := Float.cos θ, im := Float.sin θ }\n\n/-- Multi-dimensional index represented as a list of natural numbers -/\ndef MultiIndex := List Nat\n\n/-- Get element from flattened array using multi-dimensional index -/\ndef getMultiIndex {n : Nat} (arr : Vector Complex n) (dims : List Nat) (idx : MultiIndex) : Complex :=\n  sorry\n\n/-- Convert multi-dimensional index to flat index -/\ndef multiIndexToFlat (dims : List Nat) (idx : MultiIndex) : Nat :=\n  sorry\n\n/-- Check if multi-dimensional index is valid for given dimensions -/\ndef isValidIndex (dims : List Nat) (idx : MultiIndex) : Bool :=\n  sorry\n\n/-- Generate all valid multi-dimensional indices for given dimensions -/\ndef allIndices (dims : List Nat) : List MultiIndex :=\n  sorry\n\n/-- Sum of complex numbers in a list -/\ndef sumComplex : List Complex → Complex\n  | [] => 0\n  | h :: t => h + sumComplex t\n\n/-- N-dimensional DFT formula\n    For an N-dimensional array with dimensions [n₁, n₂, ..., nₖ],\n    the DFT at position (k₁, k₂, ..., kₖ) is:\n    X[k₁, k₂, ..., kₖ] = Σ_{j₁=0}^{n₁-1} ... Σ_{jₖ=0}^{nₖ-1} \n                          x[j₁, j₂, ..., jₖ] * exp(-2πi * Σ_{p=0}^{k-1} (k[p] * j[p] / n[p]))\n    \n    This function computes the DFT value at a single output position k_idx\n    by summing over all input positions j_idx with the appropriate phase factor.\n-/\ndef ndftValue {n : Nat} (arr : Vector Complex n) (dims : List Nat) (k_idx : MultiIndex) : Complex :=\n  let allInputIndices := allIndices dims\n  let phaseFactors := allInputIndices.map (fun j_idx =>\n    let phaseSum := (List.zip k_idx j_idx).zip dims |>.foldl (fun acc ((k, j), d) =>\n      acc + (k.toFloat * j.toFloat / d.toFloat)) 0.0\n    let phase := -2.0 * 3.14159265358979323846 * phaseSum\n    let inputValue := getMultiIndex arr dims j_idx\n    inputValue * cexp phase\n  )\n  sumComplex phaseFactors\n\n/-- numpy.fft.fftn: Compute the N-dimensional discrete Fourier Transform.\n    \n    This function computes the N-dimensional DFT of the input array, transforming from\n    spatial/time domain to frequency domain. The input is represented as a flattened\n    vector with known dimensions, and the output maintains the same structure.\n    \n    The N-dimensional DFT is mathematically defined as:\n    X[k₁, k₂, ..., kₖ] = Σ_{j₁=0}^{n₁-1} ... Σ_{jₖ=0}^{nₖ-1} \n                          x[j₁, j₂, ..., jₖ] * exp(-2πi * Σ_{p=0}^{k-1} (k[p] * j[p] / n[p]))\n    \n    Key properties:\n    - Preserves the total number of elements\n    - Maintains the dimensional structure\n    - Transforms from spatial to frequency domain\n    - Supports arbitrary dimensional arrays\n-/\ndef fftn {n : Nat} (arr : Vector Complex n) (dims : List Nat) \n    (h_size : dims.foldl (· * ·) 1 = n) : Id (Vector Complex n) :=\n  sorry\n\n/-- Specification: numpy.fft.fftn computes the N-dimensional discrete Fourier transform\n    where each output element is computed according to the N-dimensional DFT formula.\n    \n    The N-dimensional FFT satisfies several key mathematical properties:\n    1. Linearity: FFT(αx + βy) = α·FFT(x) + β·FFT(y)\n    2. Parseval's theorem: Energy is preserved under proper normalization\n    3. Separability: Can be computed as successive 1D FFTs along each dimension\n    4. Periodicity: The transform is periodic in each dimension\n    5. Symmetry: Real inputs produce conjugate-symmetric outputs\n    \n    The specification captures the fundamental N-dimensional DFT formula where each\n    output element at position (k₁, k₂, ..., kₙ) is computed as the sum over all\n    input elements at positions (j₁, j₂, ..., jₙ), weighted by complex exponentials\n    that depend on the product of corresponding indices and the respective dimension sizes.\n    \n    Precondition: The dimensions must be non-empty and their product must equal\n    the vector length to ensure proper array structure.\n    \n    Postcondition: Each output element corresponds to the mathematically correct\n    N-dimensional DFT value, computed by summing over all input elements with\n    appropriate complex exponential weights.\n-/\ntheorem fftn_spec {n : Nat} (arr : Vector Complex n) (dims : List Nat) \n    (h_size : dims.foldl (· * ·) 1 = n) (h_nonempty : dims.length > 0) \n    (h_positive : ∀ d ∈ dims, d > 0) :\n    ⦃⌜dims.length > 0 ∧ (∀ d ∈ dims, d > 0) ∧ dims.foldl (· * ·) 1 = n⌝⦄\n    fftn arr dims h_size\n    ⦃⇓result => ⌜∀ k_idx : MultiIndex, \n                  isValidIndex dims k_idx → \n                  getMultiIndex result dims k_idx = ndftValue arr dims k_idx⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0154", "language": "lean", "source": "numpy_triple", "source-id": "fft_ifft2", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.fft.ifft2\",\n  \"description\": \"Compute the 2-dimensional inverse discrete Fourier Transform\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fft.ifft2.html\",\n  \"doc\": \"numpy.fft.ifft2(a, s=None, axes=(-2, -1), norm=None, out=None)\\n\\nCompute the 2-dimensional inverse discrete Fourier Transform over specified axes using the Fast Fourier Transform (FFT). It essentially reverses the 2D FFT, such that ifft2(fft2(a)) == a within numerical accuracy.\\n\\nParameters:\\n- a: Input array (can be complex)\\n- s: Optional sequence of integers specifying output shape\\n- axes: Axes over which to compute FFT (default: last two axes)\\n- norm: Normalization mode (\\\"backward\\\", \\\"ortho\\\", \\\"forward\\\")\\n- out: Optional output array\\n\\nReturns:\\n- Complex ndarray transformed along specified axes\\n\\nNotes:\\n- Handles zero-padding by appending zeros to input\\n- Computes inverse transform over last two axes by default\\n- Preserves input array's frequency ordering\\n\\nExample:\\nimport numpy as np\\na = 4 * np.eye(4)\\nnp.fft.ifft2(a)\",\n  \"code\": \"@array_function_dispatch(_fftn_dispatcher)\\ndef ifft2(a, s=None, axes=(-2, -1), norm=None, out=None):\\n    \\\"\\\"\\\"\\n    Compute the 2-dimensional inverse discrete Fourier Transform.\\n    \\\"\\\"\\\"\\n    return _raw_fftnd(a, s, axes, ifft, norm, out=None)\"\n}\n-/\n\nopen Std.Do\n\nset_option linter.missingDocs false\n\n/-- Complex number type for IFFT2 operations -/\nstructure Complex where\n  /-- Real part -/\n  re : Float\n  /-- Imaginary part -/\n  im : Float\n  deriving Repr\n\n/-- Complex addition -/\ninstance : Add Complex where\n  add z w := { re := z.re + w.re, im := z.im + w.im }\n\n/-- Complex multiplication -/\ninstance : Mul Complex where\n  mul z w := { re := z.re * w.re - z.im * w.im, im := z.re * w.im + z.im * w.re }\n\n/-- Complex scalar multiplication -/\ninstance : HMul Float Complex Complex where\n  hMul s z := { re := s * z.re, im := s * z.im }\n\n/-- Zero complex number -/\ninstance : Zero Complex where\n  zero := { re := 0, im := 0 }\n\n/-- Complex exponential function e^(iθ) -/\ndef cexp (θ : Float) : Complex :=\n  { re := Float.cos θ, im := Float.sin θ }\n\n/-- Sum of complex numbers over 2D finite indices -/\ndef complexSum2D {m n : Nat} (f : Fin m → Fin n → Complex) : Complex :=\n  sorry\n\n/-- 2D Inverse Discrete Fourier Transform formula for element (k, l) given input matrix of size m × n\n    IDFT[k, l] = (1/(m*n)) * Σ_{p=0}^{m-1} Σ_{q=0}^{n-1} input[p, q] * e^(2πi(kp/m + lq/n))\n-/\ndef idft2_element {m n : Nat} (input : Vector (Vector Complex n) m) (k : Fin m) (l : Fin n) : Complex :=\n  sorry\n\n/-- numpy.fft.ifft2: Compute the 2-dimensional inverse discrete Fourier Transform.\n    \n    This function computes the 2D IDFT of the input matrix, transforming from\n    frequency domain back to spatial/time domain. It is the inverse operation\n    of the 2D FFT, such that ifft2(fft2(a)) ≈ a within numerical accuracy.\n    \n    The 2D IDFT uses positive exponentials and includes normalization by 1/(m*n).\n-/\ndef numpy_ifft2 {m n : Nat} (a : Vector (Vector Complex n) m) : Id (Vector (Vector Complex n) m) :=\n  sorry\n\n/-- Specification: numpy.fft.ifft2 computes the 2D inverse discrete Fourier transform\n    where each output element is computed using the inverse DFT formula.\n    \n    Precondition: Both dimensions must be positive for meaningful computation\n    Postcondition: For all indices (k, l), the output element at position (k, l)\n    equals the 2D IDFT formula applied to the input matrix.\n    \n    Mathematical properties:\n    - Inverse relationship: ifft2(fft2(a)) ≈ a within numerical accuracy\n    - Linearity: ifft2(α*a + β*b) = α*ifft2(a) + β*ifft2(b)\n    - Energy preservation: Parseval's theorem with proper normalization\n    - Conjugate symmetry preservation for real inputs\n-/\ntheorem numpy_ifft2_spec {m n : Nat} (a : Vector (Vector Complex n) m) \n    (hm : m > 0) (hn : n > 0) :\n    ⦃⌜m > 0 ∧ n > 0⌝⦄\n    numpy_ifft2 a\n    ⦃⇓result => ⌜∀ (k : Fin m) (l : Fin n), \n                  (result.get k).get l = idft2_element a k l⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0164", "language": "lean", "source": "numpy_triple", "source-id": "fft_rfftn", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.fft.rfftn\",\n  \"description\": \"Compute the N-dimensional discrete Fourier Transform for real input\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.fft.rfftn.html\",\n  \"doc\": \"numpy.fft.rfftn(a, s=None, axes=None, norm=None, out=None)\\n\\nCompute the N-dimensional discrete Fourier Transform for real input using Fast Fourier Transform (FFT) over specified axes.\\n\\nParameters:\\n- a: Input array (real)\\n- s: Optional sequence of integers specifying transform shape\\n- axes: Optional sequence of axes to transform\\n- norm: Normalization mode (\\\"backward\\\", \\\"ortho\\\", \\\"forward\\\")\\n- out: Optional output array\\n\\nReturns:\\n- Complex ndarray transformed along specified axes, with last axis length s[-1]//2+1\\n\\nNotes:\\n- Performs real transform over last axis\\n- Remaining transforms are complex\\n- Can transform over multiple or all axes\\n\\nExample:\\nimport numpy as np\\na = np.ones((2, 2, 2))\\nnp.fft.rfftn(a)\",\n  \"code\": \"@array_function_dispatch(_fftn_dispatcher)\\ndef rfftn(a, s=None, axes=None, norm=None, out=None):\\n    \\\"\\\"\\\"\\n    Compute the N-dimensional discrete Fourier Transform for real input.\\n    \\\"\\\"\\\"\\n    a = asarray(a)\\n    s, axes = _cook_nd_args(a, s, axes)\\n    a = rfft(a, s[-1], axes[-1], norm, out)\\n    for ii in range(len(axes)-1):\\n        a = fft(a, s[ii], axes[ii], norm)\\n    return a\"\n}\n-/\n\nopen Std.Do\n\n/-- Complex number type for FFT results -/\nstructure Complex where\n  /-- Real part -/\n  re : Float\n  /-- Imaginary part -/\n  im : Float\nderiving Repr\n\n/-- Complex zero -/\ninstance : Zero Complex where\n  zero := { re := 0.0, im := 0.0 }\n\n/-- Complex multiplication -/\ninstance : Mul Complex where\n  mul z w := { re := z.re * w.re - z.im * w.im, im := z.re * w.im + z.im * w.re }\n\n/-- Complex addition -/\ninstance : Add Complex where\n  add z w := { re := z.re + w.re, im := z.im + w.im }\n\n/-- Complex exponential function e^(iθ) -/\ndef cexp (θ : Float) : Complex :=\n  { re := Float.cos θ, im := Float.sin θ }\n\n/-- Convert Float to Complex -/\ndef Float.toComplex (x : Float) : Complex := { re := x, im := 0 }\n\n/-- Multi-dimensional index represented as a list of natural numbers -/\ndef MultiIndex := List Nat\n\n/-- Get element from flattened array using multi-dimensional index -/\ndef getMultiIndex {n : Nat} (arr : Vector Complex n) (dims : List Nat) (idx : MultiIndex) : Complex :=\n  sorry\n\n/-- Convert multi-dimensional index to flat index -/\ndef multiIndexToFlat (dims : List Nat) (idx : MultiIndex) : Nat :=\n  sorry\n\n/-- Check if multi-dimensional index is valid for given dimensions -/\ndef isValidIndex (dims : List Nat) (idx : MultiIndex) : Bool :=\n  sorry\n\n/-- Generate all valid multi-dimensional indices for given dimensions -/\ndef allIndices (dims : List Nat) : List MultiIndex :=\n  sorry\n\n/-- Sum of complex numbers in a list -/\ndef sumComplex : List Complex → Complex\n  | [] => 0\n  | h :: t => h + sumComplex t\n\n/-- Compute output dimensions for rfftn - last dimension is reduced by half plus one -/\ndef rfftnOutputDims (inputDims : List Nat) : List Nat :=\n  match inputDims.reverse with\n  | [] => []\n  | lastDim :: rest => (rest.reverse ++ [lastDim / 2 + 1])\n\n/-- Compute output size for rfftn -/\ndef rfftnOutputSize (inputDims : List Nat) : Nat :=\n  (rfftnOutputDims inputDims).foldl (· * ·) 1\n\n/-- N-dimensional real DFT formula\n    For an N-dimensional real array, rfftn first computes the 1D real FFT along the last axis,\n    then applies complex FFT along the remaining axes.\n    \n    The real FFT along the last axis exploits Hermitian symmetry, so the output along\n    that axis has length (n_last/2 + 1) instead of n_last.\n    \n    For the final output at position (k₁, k₂, ..., kₙ₋₁, kₙ), this is computed as:\n    1. First, real FFT along last axis: transforms real input to complex with reduced size\n    2. Then, complex FFT along remaining axes\n    \n    This preserves the mathematical properties of the N-dimensional DFT while\n    exploiting the efficiency gains from real input symmetry.\n-/\ndef nrealDftValue {n : Nat} (arr : Vector Float n) (inputDims : List Nat) (k_idx : MultiIndex) : Complex :=\n  let allInputIndices := allIndices inputDims\n  let phaseFactors := allInputIndices.map (fun j_idx =>\n    let phaseSum := (List.zip k_idx j_idx).zip inputDims |>.foldl (fun acc ((k, j), d) =>\n      acc + (k.toFloat * j.toFloat / d.toFloat)) 0.0\n    let phase := -2.0 * 3.14159265358979323846 * phaseSum\n    let inputValue := (getMultiIndex (arr.map Float.toComplex) inputDims j_idx)\n    inputValue * cexp phase\n  )\n  sumComplex phaseFactors\n\n/-- numpy.fft.rfftn: Compute the N-dimensional discrete Fourier Transform for real input.\n    \n    This function computes the N-dimensional DFT of a real-valued input array, optimized\n    by exploiting Hermitian symmetry. The algorithm:\n    1. Performs real FFT along the last axis (reducing its size to n/2+1)\n    2. Performs complex FFT along all remaining axes\n    \n    The real FFT step exploits the fact that for real input, the DFT has Hermitian symmetry,\n    so only about half the frequency components need to be computed explicitly.\n    \n    Key properties:\n    - Input is real-valued, output is complex\n    - Last axis size is reduced from n to n/2+1\n    - Other axes maintain their original sizes\n    - Mathematically equivalent to complex fftn but more efficient for real input\n    - First step (real FFT) produces only positive frequency components\n    - Subsequent steps (complex FFT) transform remaining dimensions\n-/\ndef rfftn {n : Nat} (arr : Vector Float n) (inputDims : List Nat) \n    (h_size : inputDims.foldl (· * ·) 1 = n) : Id (Vector Complex (rfftnOutputSize inputDims)) :=\n  sorry\n\n/-- Specification: numpy.fft.rfftn computes the N-dimensional discrete Fourier transform\n    for real input by first applying real FFT to the last axis, then complex FFT to remaining axes.\n    \n    The N-dimensional real FFT satisfies several key mathematical properties:\n    1. Linearity: rfftn(αx + βy) = α·rfftn(x) + β·rfftn(y) for real α, β\n    2. Hermitian symmetry: The full N-dimensional DFT would have conjugate symmetry\n    3. Energy preservation: Parseval's theorem applies with proper normalization\n    4. Separability: Computed as real FFT along last axis, then complex FFT along others\n    5. Efficiency: Exploits real input symmetry to reduce computation and storage\n    \n    The specification captures the fundamental N-dimensional real DFT where:\n    - The last axis is transformed using real FFT (exploiting Hermitian symmetry)\n    - The remaining axes are transformed using complex FFT\n    - Each output element corresponds to a specific frequency combination\n    - The output size is reduced along the last axis (n → n/2+1)\n    \n    Precondition: The input dimensions must be non-empty, positive, and their product\n    must equal the vector length to ensure proper array structure.\n    \n    Postcondition: Each output element corresponds to the mathematically correct\n    N-dimensional real DFT value, computed by first applying real FFT to the last axis,\n    then complex FFT to the remaining axes. The output dimensions follow the pattern\n    [d₁, d₂, ..., dₙ₋₁, dₙ/2+1] where input dimensions were [d₁, d₂, ..., dₙ₋₁, dₙ].\n-/\ntheorem rfftn_spec {n : Nat} (arr : Vector Float n) (inputDims : List Nat) \n    (h_size : inputDims.foldl (· * ·) 1 = n) (h_nonempty : inputDims.length > 0)\n    (h_positive : ∀ d ∈ inputDims, d > 0) :\n    ⦃⌜inputDims.length > 0 ∧ (∀ d ∈ inputDims, d > 0) ∧ inputDims.foldl (· * ·) 1 = n⌝⦄\n    rfftn arr inputDims h_size\n    ⦃⇓result => ⌜∀ k_idx : MultiIndex, \n                  isValidIndex (rfftnOutputDims inputDims) k_idx → \n                  getMultiIndex result (rfftnOutputDims inputDims) k_idx = nrealDftValue arr inputDims k_idx ∧\n                  -- DC component along last axis is real (when k_last = 0)\n                  (k_idx.length = inputDims.length ∧ k_idx.getLast? = some 0 → \n                   (getMultiIndex result (rfftnOutputDims inputDims) k_idx).im = 0) ∧\n                  -- Nyquist frequency along last axis is real (when k_last = n_last/2 and n_last is even)\n                  (k_idx.length = inputDims.length ∧ \n                   ∃ n_last, inputDims.getLast? = some n_last ∧ n_last % 2 = 0 ∧ \n                   k_idx.getLast? = some (n_last / 2) → \n                   (getMultiIndex result (rfftnOutputDims inputDims) k_idx).im = 0)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0185", "language": "lean", "source": "numpy_triple", "source-id": "indexing_slicing_nonzero", "source-notes": "", "vc-description": "", "vc-preamble": "/-!\n{\n  \"name\": \"numpy.nonzero\",\n  \"category\": \"Boolean/mask indexing\",\n  \"description\": \"Return the indices of the elements that are non-zero\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.nonzero.html\",\n  \"doc\": \"Return the indices of the elements that are non-zero.\\n\\nReturns a tuple of arrays, one for each dimension of `a`, containing the indices of the non-zero elements in that dimension. The values in `a` are always tested and returned in row-major, C-style order.\\n\\nParameters\\n----------\\na : array_like\\n    Input array.\\n\\nReturns\\n-------\\ntuple_of_arrays : tuple\\n    Indices of elements that are non-zero.\",\n  \"code\": \"@array_function_dispatch(_nonzero_dispatcher)\\ndef nonzero(a):\\n    \\\"\\\"\\\"\\n    Return the indices of the elements that are non-zero.\\n\\n    Returns a tuple of arrays, one for each dimension of `a`,\\n    containing the indices of the non-zero elements in that\\n    dimension. The values in `a` are always tested and returned in\\n    row-major, C-style order.\\n\\n    Parameters\\n    ----------\\n    a : array_like\\n        Input array.\\n\\n    Returns\\n    -------\\n    tuple_of_arrays : tuple\\n        Indices of elements that are non-zero.\\n    \\\"\\\"\\\"\\n    return _wrapfunc(a, 'nonzero')\"\n}\n-/\n\n/-- numpy.nonzero: Return the indices of the elements that are non-zero.\n    \n    For a 1D array, returns a list containing the indices of all non-zero elements.\n    The indices are returned in ascending order and correspond to positions where\n    the input array has non-zero values.\n    \n    This function is commonly used for boolean indexing and finding positions\n    of elements that satisfy certain conditions.\n-/\ndef nonzero {n : Nat} (a : Vector Float n) : List (Fin n) :=\n  sorry\n\n/-- Helper: Check if a vector is the zero vector -/\ndef is_zero_vector {n : Nat} (a : Vector Float n) : Prop :=\n  ∀ i : Fin n, a.get i = 0\n\n/-- Helper: Count non-zero elements in a vector -/\ndef count_nonzero {n : Nat} (a : Vector Float n) : Nat :=\n  sorry\n\n/-- Specification: nonzero returns exactly the indices of non-zero elements.\n    \n    The returned list contains all and only the indices where the input array\n    has non-zero values. The indices are returned in ascending order.\n    \n    Key properties:\n    1. Correctness: Every index in result points to a non-zero element\n    2. Completeness: Every non-zero element is represented in the result\n    3. Ordering: Results are sorted in ascending order\n    4. Uniqueness: No duplicates in the result\n    5. Boundedness: Result length is at most the input array length\n-/\ntheorem nonzero_spec {n : Nat} (a : Vector Float n) :\n    let result := nonzero a\n    -- 1. Correctness: All indices in result point to non-zero elements\n    (∀ i ∈ result, a.get i ≠ 0) ∧\n    -- 2. Completeness: All non-zero elements are represented in result\n    (∀ j : Fin n, a.get j ≠ 0 → j ∈ result) ∧\n    -- 3. Ordering: The result is sorted in ascending order\n    (List.Pairwise (· < ·) result) ∧\n    -- 4. Uniqueness: No duplicates in result\n    (result.Nodup) ∧\n    -- 5. Boundedness: Result length is at most input length\n    (result.length ≤ n) ∧\n    -- 6. Length relationship: Result length equals count of non-zero elements\n    (result.length = count_nonzero a) := by\n  sorry\n\n/-- Empty result characterization: nonzero returns empty list iff input is zero vector -/\ntheorem nonzero_empty_iff_zero {n : Nat} (a : Vector Float n) :\n    nonzero a = [] ↔ is_zero_vector a := by\n  sorry\n\n/-- Full result characterization: nonzero returns all indices iff no element is zero -/\ntheorem nonzero_full_iff_no_zeros {n : Nat} (a : Vector Float n) :\n    (nonzero a).length = n ↔ (∀ i : Fin n, a.get i ≠ 0) := by\n  sorry\n\n/-- Monotonicity: If we zero out some elements, the result is a subset -/\ntheorem nonzero_monotonic {n : Nat} (a b : Vector Float n) :\n    (∀ i : Fin n, a.get i ≠ 0 → b.get i ≠ 0) →\n    ∀ x ∈ nonzero a, x ∈ nonzero b := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0203", "language": "lean", "source": "numpy_triple", "source-id": "io_operations_base_repr", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.base_repr\",\n  \"category\": \"Data exchange\",\n  \"description\": \"Return a string representation of a number in the given base system\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.base_repr.html\",\n  \"doc\": \"Return a string representation of a number in the given base system.\\n\\n    Parameters\\n    ----------\\n    number : int\\n        The value to convert. Positive and negative values are handled.\\n    base : int, optional\\n        Convert \\`number\\` to the \\`base\\` number system. The valid range is 2-36,\\n        the default value is 2.\\n    padding : int, optional\\n        Number of zeros padded on the left. Default is 0 (no padding).\\n\\n    Returns\\n    -------\\n    out : str\\n        String representation of \\`num...\",\n  \"code\": \"@set_module('numpy')\\ndef base_repr(number, base=2, padding=0):\\n    \\\"\\\"\\\"\\n    Return a string representation of a number in the given base system.\\n\\n    Parameters\\n    ----------\\n    number : int\\n        The value to convert. Positive and negative values are handled.\\n    base : int, optional\\n        Convert \\`number\\` to the \\`base\\` number system. The valid range is 2-36,\\n        the default value is 2.\\n    padding : int, optional\\n        Number of zeros padded on the left. Default is 0 (no padding).\\n\\n    Returns\\n    -------\\n    out : str\\n        String representation of \\`number\\` in \\`base\\` system.\\n\\n    See Also\\n    --------\\n    binary_repr : Faster version of \\`base_repr\\` for base 2.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> np.base_repr(5)\\n    '101'\\n    >>> np.base_repr(6, 5)\\n    '11'\\n    >>> np.base_repr(7, base=5, padding=3)\\n    '00012'\\n\\n    >>> np.base_repr(10, base=16)\\n    'A'\\n    >>> np.base_repr(32, base=16)\\n    '20'\\n\\n    \\\"\\\"\\\"\\n    digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\\n    if base > len(digits):\\n        raise ValueError(\\\"Bases greater than 36 not handled in base_repr.\\\")\\n    elif base < 2:\\n        raise ValueError(\\\"Bases less than 2 not handled in base_repr.\\\")\\n\\n    num = abs(int(number))\\n    res = []\\n    while num:\\n        res.append(digits[num % base])\\n        num //= base\\n    if padding:\\n        res.append('0' * padding)\\n    if number < 0:\\n        res.append('-')\\n    return ''.join(reversed(res or '0'))\"\n}\n-/\n\nopen Std.Do\n\n/-- Helper function to convert a natural number to its representation in a given base -/\ndef natToBaseString (n : Nat) (base : Nat) : String :=\n  sorry\n\n/-- Helper function to check if a string represents a valid base-n number -/\ndef isValidBaseString (s : String) (base : Nat) : Bool :=\n  let validChars := \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\".take base\n  s.length > 0 && s.all (fun c => validChars.contains c)\n\n/-- Helper function to check if a string represents a valid signed base-n number -/\ndef isValidSignedBaseString (s : String) (base : Nat) : Bool :=\n  if s.startsWith \"-\" then\n    isValidBaseString (s.drop 1) base\n  else\n    isValidBaseString s base\n\n/-- Return a string representation of a number in the given base system.\n    \n    Converts integers to their representation in bases 2-36. For negative numbers,\n    a minus sign is prepended. Supports zero-padding on the left.\n-/\ndef base_repr (number : Int) (base : Nat := 2) (padding : Nat := 0) : Id String :=\n  sorry\n\n/-- Specification: base_repr correctly converts integers to base-n strings with proper\n    handling of negative numbers and padding -/\ntheorem base_repr_spec (number : Int) (base : Nat := 2) (padding : Nat := 0) :\n    ⦃⌜base ≥ 2 ∧ base ≤ 36⌝⦄\n    base_repr number base padding\n    ⦃⇓result => ⌜\n      -- Result is a valid base-n string (possibly with sign)\n      isValidSignedBaseString result base ∧\n      \n      -- Length constraints with padding\n      (number ≥ 0 → result.length ≥ max 1 padding) ∧\n      (number < 0 → result.length ≥ max 2 (padding + 1)) ∧\n      \n      -- Positive numbers: standard base representation with padding\n      (number ≥ 0 → \n        let baseStr := natToBaseString number.natAbs base\n        let paddedStr := String.mk (List.replicate (max 0 (padding - baseStr.length)) '0') ++ baseStr\n        result = paddedStr) ∧\n      \n      -- Negative numbers: signed representation with padding\n      (number < 0 → \n        let baseStr := natToBaseString number.natAbs base\n        let paddedStr := String.mk (List.replicate (max 0 (padding - baseStr.length)) '0') ++ baseStr\n        result = \"-\" ++ paddedStr) ∧\n      \n      -- Zero case: special handling\n      (number = 0 → \n        result = String.mk (List.replicate (max 1 padding) '0')) ∧\n      \n      -- No leading zeros in the base representation part (except for padding)\n      (number ≠ 0 → \n        let baseStr := if number ≥ 0 then result.drop padding else result.drop (padding + 1)\n        baseStr.length > 0 ∧ baseStr.front ≠ '0')\n    ⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0204", "language": "lean", "source": "numpy_triple", "source-id": "io_operations_binary_repr", "source-notes": "", "vc-description": "", "vc-preamble": "/-!\n{\n  \"name\": \"numpy.binary_repr\",\n  \"category\": \"Data exchange\",\n  \"description\": \"Return the binary representation of the input number as a string\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.binary_repr.html\",\n  \"doc\": \"Return the binary representation of the input number as a string\",\n  \"code\": \"@set_module('numpy')\\ndef binary_repr(num, width=None):\\n    \\\"\\\"\\\"\\n    Return the binary representation of the input number as a string.\\n\\n    For negative numbers, if width is not given, a minus sign is added to the\\n    front. If width is given, the two's complement of the number is\\n    returned, with respect to that width.\\n\\n    In a two's-complement system negative numbers are represented by the two's\\n    complement of the absolute value. This is the most common method of\\n    representing signed integers on computers [1]_. A N-bit two's-complement\\n    system can represent every integer in the range\\n    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\\n\\n    Parameters\\n    ----------\\n    num : int\\n        Only an integer decimal number can be used.\\n    width : int, optional\\n        The length of the returned string if `num` is positive, or the length\\n        of the two's complement if `num` is negative, provided that `width` is\\n        at least a sufficient number of bits for `num` to be represented in\\n        the designated form. If the `width` value is insufficient, an error is\\n        raised.\\n\\n    Returns\\n    -------\\n    bin : str\\n        Binary representation of `num` or two's complement of `num`.\\n\\n    See Also\\n    --------\\n    base_repr: Return a string representation of a number in the given base\\n               system.\\n    bin: Python's built-in binary representation generator of an integer.\\n\\n    Notes\\n    -----\\n    `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x\\n    faster.\\n\\n    References\\n    ----------\\n    .. [1] Wikipedia, \\\"Two's complement\\\",\\n        https://en.wikipedia.org/wiki/Two's_complement\"\n}\n-/\n\n/-- Helper function to convert natural number to binary string -/\ndef toBinary (n : Nat) : String :=\n  sorry\n\n/-- Helper function to convert binary string to natural number -/\ndef fromBinary (s : String) : Option Nat :=\n  sorry\n\n/-- Helper function to convert integer to two's complement binary string -/\ndef toTwosComplement (n : Int) (width : Nat) : String :=\n  sorry\n\n/-- Helper function to convert two's complement binary string to integer -/\ndef fromTwosComplement (s : String) (width : Nat) : Option Int :=\n  sorry\n\n/-- Helper function to pad string to the right -/\ndef String.rightPad (s : String) (len : Nat) (c : Char) : String :=\n  sorry\n\n/-- Return the binary representation of the input number as a string.\n    For negative numbers, if width is not given, a minus sign is added to the front.\n    If width is given, the two's complement of the number is returned. -/\ndef binary_repr (num : Int) (width : Option Nat) : String :=\n  sorry\n\n/-- Specification: binary_repr returns the correct binary representation of an integer.\n    \n    Properties:\n    1. Result is a valid binary string containing only '0', '1', and potentially '-'\n    2. For positive numbers without width: result equals binary representation\n    3. For negative numbers without width: result has minus sign prefix\n    4. For numbers with width: result has correct length\n    5. Result correctly represents the original number -/\ntheorem binary_repr_spec (num : Int) (width : Option Nat) :\n    let result := binary_repr num width\n    -- Result is a valid binary string containing only '0', '1', and potentially '-'\n    (∀ c ∈ result.toList, c = '0' ∨ c = '1' ∨ c = '-') ∧\n    -- For positive numbers without width: result equals binary representation\n    (num ≥ 0 ∧ width = none → result = toBinary (Int.natAbs num)) ∧\n    -- For negative numbers without width: result has minus sign prefix\n    (num < 0 ∧ width = none → result = \"-\" ++ toBinary (Int.natAbs num)) ∧\n    -- For numbers with width: result has correct length\n    (width.isSome → result.length = width.get!) ∧\n    -- Result correctly represents the original number\n    (width = none → \n      if num ≥ 0 then \n        fromBinary result = some (Int.natAbs num)\n      else \n        result.startsWith \"-\" ∧ fromBinary (result.drop 1) = some (Int.natAbs num)) ∧\n    -- For width cases, result can be parsed back to original\n    (width.isSome → \n      let w := width.get!\n      if num ≥ 0 then \n        fromBinary result = some (Int.natAbs num)\n      else \n        fromTwosComplement result w = some num) := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0215", "language": "lean", "source": "numpy_triple", "source-id": "io_operations_savetxt", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.savetxt\",\n  \"category\": \"Text file I/O\",\n  \"description\": \"Save an array to a text file\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.savetxt.html\",\n  \"doc\": \"Save an array to a text file\",\n  \"code\": \"@array_function_dispatch(_savetxt_dispatcher)\\ndef savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\\\\n', header='',\\n            footer='', comments='# ', encoding=None):\\n    \\\"\\\"\\\"\\n    Save an array to a text file.\\n\\n    Parameters\\n    ----------\\n    fname : filename, file handle or pathlib.Path\\n        If the filename ends in \\`\\`.gz\\`\\`, the file is automatically saved in\\n        compressed gzip format.  \\`loadtxt\\` understands gzipped files\\n        transparently.\\n    X : 1D or 2D array_like\\n        Data to be saved to a text file.\\n    fmt : str or sequence of strs, optional\\n        A single format (%10.5f), a sequence of formats, or a\\n        multi-format string, e.g. 'Iteration %d -- %10.5f', in which\\n        case \\`delimiter\\` is ignored. For complex \\`X\\`, the legal options\\n        for \\`fmt\\` are:\\n\\n        * a single specifier, \\`\\`fmt='%.4e'\\`\\`, resulting in numbers formatted\\n          like \\`\\`' (%s+%sj)' % (fmt, fmt)\\`\\`\\n        * a full string specifying every real and imaginary part, e.g.\\n          \\`\\`' %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej'\\`\\` for 3 columns\\n        * a list of specifiers, one per column - in this case, the real\\n          and imaginary part must have separate specifiers,\\n          e.g. \\`\\`['%.3e + %.3ej', '(%.15e%+.15ej)']\\`\\` for 2 columns\\n    delimiter : str, optional\\n        String or character separating columns.\\n    newline : str, optional\\n        String or character separating lines.\\n    header : str, optional\\n        String that will be written at the beginning of the file.\\n    footer : str, optional\\n        String that will be written at the end of the file.\\n    comments : str, optional\\n        String that will be prepended to the \\`\\`header\\`\\` and \\`\\`footer\\`\\` strings,\\n        to mark them as comments. Default: '# ',  as expected by e.g.\\n        \\`\\`numpy.loadtxt\\`\\`.\\n    encoding : {None, str}, optional\\n        Encoding used to encode the outputfile. Does not apply to output\\n        streams. If the encoding is something other than 'bytes' or 'latin1'\\n        you will not be able to load the file in NumPy versions < 1.14. Default\\n        is 'latin1'.\\n\\n    See Also\\n    --------\\n    save : Save an array to a binary file in NumPy \\`\\`.npy\\`\\` format\\n    savez : Save several arrays into an uncompressed \\`\\`.npz\\`\\` archive\\n    savez_compressed : Save several arrays into a compressed \\`\\`.npz\\`\\` archive\\n\\n    Notes\\n    -----\\n    Further explanation of the \\`fmt\\` parameter\\n    (\\`\\`%[flag]width[.precision]specifier\\`\\`):\\n\\n    flags:\\n        \\`\\`-\\`\\` : left justify\\n\\n        \\`\\`+\\`\\` : Forces to precede result with + or -.\\n\\n        \\`\\`0\\`\\` : Left pad the number with zeros instead of space (see width).\\n\\n    width:\\n        Minimum number of characters to be printed. The value is not truncated\\n        if it has more characters.\\n\\n    precision:\\n        - For integer specifiers (eg. \\`\\`d,i,o,x\\`\\`), the minimum number of\\n          digits.\\n        - For \\`\\`e, E\\`\\` and \\`\\`f\\`\\` specifiers, the number of digits to print\\n          after the decimal point.\\n        - For \\`\\`g\\`\\` and \\`\\`G\\`\\`, the maximum number of significant digits.\\n        - For \\`\\`s\\`\\`, the maximum number of characters.\\n\\n    specifiers:\\n        \\`\\`c\\`\\` : character\\n\\n        \\`\\`d\\`\\` or \\`\\`i\\`\\` : signed decimal integer\\n\\n        \\`\\`e\\`\\` or \\`\\`E\\`\\` : scientific notation with \\`\\`e\\`\\` or \\`\\`E\\`\\`.\\n\\n        \\`\\`f\\`\\` : decimal floating point\\n\\n        \\`\\`g,G\\`\\` : use the shorter of \\`\\`e,E\\`\\` or \\`\\`f\\`\\`\\n\\n        \\`\\`o\\`\\` : signed octal\\n\\n        \\`\\`s\\`\\` : string of characters\\n\\n        \\`\\`u\\`\\` : unsigned decimal integer\\n\\n        \\`\\`x,X\\`\\` : unsigned hexadecimal integer\\n\\n    This explanation of \\`\\`fmt\\`\\` is not complete, for an exhaustive\\n    specification see [1]_.\\n\\n    References\\n    ----------\\n    .. [1] \\`Format Specification Mini-Language\\n           <https://docs.python.org/library/string.html#format-specification-mini-language>\\`_,\\n           Python Documentation.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> x = y = z = np.arange(0.0,5.0,1.0)\\n    >>> np.savetxt('test.out', x, delimiter=',')   # X is an array\\n    >>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\\n    >>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation\"\n}\n-/\n\n/-- Helper function to format a float according to a format string -/\ndef formatFloat (val : Float) (fmt : String) : String :=\n  sorry\n\n/-- Helper function to join a list of strings with a delimiter -/\ndef joinStrings (strings : List String) (delimiter : String) : String :=\n  sorry\n\n/-- Save an array to a text file with specified formatting options.\n    This function converts the vector data into a formatted string representation\n    that can be written to a file. The delimiter separates elements, and the\n    format string controls the numeric representation of each element. -/\ndef savetxt {n : Nat} (arr : Vector Float n) (filename : String) (delimiter : String := \" \") (fmt : String := \"%.18e\") : Id String :=\n  sorry\n\n/-- Specification: savetxt creates a text representation of the array that preserves\n    the original data values and uses the specified formatting options.\n    \n    The function should:\n    1. Format each element according to the format string\n    2. Separate elements with the specified delimiter\n    3. Preserve the numerical values (within format precision)\n    4. Generate output that can be read back by loadtxt\n    \n    Mathematical properties:\n    - The output string contains exactly n formatted numbers\n    - Each number is formatted according to the format string\n    - Numbers are separated by the delimiter\n    - The original values are preserved within the precision of the format -/\ntheorem savetxt_spec {n : Nat} (arr : Vector Float n) (filename : String) (delimiter : String) (fmt : String) :\n    ⦃⌜filename.length > 0 ∧ delimiter.length > 0 ∧ fmt.length > 0⌝⦄\n    savetxt arr filename delimiter fmt\n    ⦃⇓result => ⌜\n      -- Result is a non-empty string when array is non-empty\n      (n > 0 → result.length > 0) ∧\n      -- For empty arrays, result is empty string\n      (n = 0 → result = \"\") ∧\n      -- Result contains formatted representations of the array data\n      (∃ formatted_values : List String, \n        formatted_values.length = n ∧\n        result = joinStrings formatted_values delimiter) ∧\n      -- Each element is formatted according to the format specification\n      (∀ i : Fin n, ∃ formatted_val : String, \n        formatted_val = formatFloat (arr.get i) fmt)\n    ⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0220", "language": "lean", "source": "numpy_triple", "source-id": "linalg_cholesky", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.linalg.cholesky\",\n  \"category\": \"Decompositions\",\n  \"description\": \"Cholesky decomposition\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.linalg.cholesky.html\",\n  \"doc\": \"Cholesky decomposition.\\n\\nReturn the Cholesky decomposition, L * L.H, of the square matrix a, where L is lower-triangular and .H is the conjugate transpose.\\n\\nParameters:\\n- a: Hermitian (symmetric if real-valued), positive-definite input matrix\\n\\nReturns:\\n- L: Lower-triangular Cholesky factor of a\\n\\nRaises LinAlgError if decomposition fails.\",\n  \"code\": \"\\n\\n@array_function_dispatch(_cholesky_dispatcher)\\ndef cholesky(a, /, *, upper=False):\\n    \\\"\\\"\\\"\\n    Cholesky decomposition.\\n\\n    Return the lower or upper Cholesky decomposition, \\`\\`L * L.H\\`\\` or\\n    \\`\\`U.H * U\\`\\`, of the square matrix \\`\\`a\\`\\`, where \\`\\`L\\`\\` is lower-triangular,\\n    \\`\\`U\\`\\` is upper-triangular, and \\`\\`.H\\`\\` is the conjugate transpose operator\\n    (which is the ordinary transpose if \\`\\`a\\`\\` is real-valued). \\`\\`a\\`\\` must be\\n    Hermitian (symmetric if real-valued) and positive-definite. No checking is\\n    performed to verify whether \\`\\`a\\`\\` is Hermitian or not. In addition, only\\n    the lower or upper-triangular and diagonal elements of \\`\\`a\\`\\` are used.\\n    Only \\`\\`L\\`\\` or \\`\\`U\\`\\` is actually returned.\\n\\n    Parameters\\n    ----------\\n    a : (..., M, M) array_like\\n        Hermitian (symmetric if all elements are real), positive-definite\\n        input matrix.\\n    upper : bool\\n        If \\`\\`True\\`\\`, the result must be the upper-triangular Cholesky factor.\\n        If \\`\\`False\\`\\`, the result must be the lower-triangular Cholesky factor.\\n        Default: \\`\\`False\\`\\`.\\n\\n    Returns\\n    -------\\n    L : (..., M, M) array_like\\n        Lower or upper-triangular Cholesky factor of \\`a\\`. Returns a matrix\\n        object if \\`a\\` is a matrix object.\\n\\n    Raises\\n    ------\\n    LinAlgError\\n       If the decomposition fails, for example, if \\`a\\` is not\\n       positive-definite.\\n\\n    See Also\\n    --------\\n    scipy.linalg.cholesky : Similar function in SciPy.\\n    scipy.linalg.cholesky_banded : Cholesky decompose a banded Hermitian\\n                                   positive-definite matrix.\\n    scipy.linalg.cho_factor : Cholesky decomposition of a matrix, to use in\\n                              \\`scipy.linalg.cho_solve\\`.\\n\\n    Notes\\n    -----\\n    Broadcasting rules apply, see the \\`numpy.linalg\\` documentation for\\n    details.\\n\\n    The Cholesky decomposition is often used as a fast way of solving\\n\\n    .. math:: A \\\\\\\\mathbf{x} = \\\\\\\\mathbf{b}\\n\\n    (when \\`A\\` is both Hermitian/symmetric and positive-definite).\\n\\n    First, we solve for :math:\\`\\\\\\\\mathbf{y}\\` in\\n\\n    .. math:: L \\\\\\\\mathbf{y} = \\\\\\\\mathbf{b},\\n\\n    and then for :math:\\`\\\\\\\\mathbf{x}\\` in\\n\\n    .. math:: L^{H} \\\\\\\\mathbf{x} = \\\\\\\\mathbf{y}.\\n\\n    Examples\\n    --------\\n    >>> import numpy as np\\n    >>> A = np.array([[1,-2j],[2j,5]])\\n    >>> A\\n    array([[ 1.+0.j, -0.-2.j],\\n           [ 0.+2.j,  5.+0.j]])\\n    >>> L = np.linalg.cholesky(A)\\n    >>> L\\n    array([[1.+0.j, 0.+0.j],\\n           [0.+2.j, 1.+0.j]])\\n    >>> np.dot(L, L.T.conj()) # verify that L * L.H = A\\n    array([[1.+0.j, 0.-2.j],\\n           [0.+2.j, 5.+0.j]])\\n    >>> A = [[1,-2j],[2j,5]] # what happens if A is only array_like?\\n    >>> np.linalg.cholesky(A) # an ndarray object is returned\\n    array([[1.+0.j, 0.+0.j],\\n           [0.+2.j, 1.+0.j]])\\n    >>> # But a matrix object is returned if A is a matrix object\\n    >>> np.linalg.cholesky(np.matrix(A))\\n    matrix([[ 1.+0.j,  0.+0.j],\\n            [ 0.+2.j,  1.+0.j]])\\n    >>> # The upper-triangular Cholesky factor can also be obtained.\\n    >>> np.linalg.cholesky(A, upper=True)\\n    array([[1.-0.j, 0.-2.j],\\n           [0.-0.j, 1.-0.j]])\\n\\n    \\\"\\\"\\\"\\n    gufunc = _umath_linalg.cholesky_up if upper else _umath_linalg.cholesky_lo\\n    a, wrap = _makearray(a)\\n    _assert_stacked_square(a)\\n    t, result_t = _commonType(a)\\n    signature = 'D->D' if isComplexType(t) else 'd->d'\\n    with errstate(call=_raise_linalgerror_nonposdef, invalid='call',\\n                  over='ignore', divide='ignore', under='ignore'):\\n        r = gufunc(a, signature=signature)\\n    return wrap(r.astype(result_t, copy=False))\"\n}\n-/\n\nopen Std.Do\n\n/-- Helper function to transpose a matrix -/\ndef transpose {n : Nat} (m : Vector (Vector Float n) n) : Vector (Vector Float n) n :=\n  sorry\n\n/-- Helper function to multiply two matrices -/\ndef matmul {n : Nat} (a b : Vector (Vector Float n) n) : Vector (Vector Float n) n :=\n  sorry\n\n/-- Helper predicate to check if a matrix is symmetric -/\ndef isSymmetric {n : Nat} (a : Vector (Vector Float n) n) : Prop :=\n  ∀ i j : Fin n, (a.get i).get j = (a.get j).get i\n\n/-- Helper predicate to check if a matrix is positive definite -/\ndef isPositiveDefinite {n : Nat} (a : Vector (Vector Float n) n) : Prop :=\n  sorry\n\n/-- Helper predicate to check if a matrix is lower triangular -/\ndef isLowerTriangular {n : Nat} (l : Vector (Vector Float n) n) : Prop :=\n  ∀ i j : Fin n, i < j → (l.get i).get j = 0\n\n/-- Cholesky decomposition: compute the lower-triangular Cholesky factor L \n    such that L * L^T = A for a symmetric positive-definite matrix A -/\ndef cholesky {n : Nat} (a : Vector (Vector Float n) n) : Id (Vector (Vector Float n) n) :=\n  sorry\n\n/-- Specification: cholesky computes the lower-triangular Cholesky factor L\n    such that L * L^T = A for a symmetric positive-definite matrix A.\n    \n    The Cholesky decomposition is unique for positive-definite matrices,\n    and the resulting factor L has the following properties:\n    1. L is lower-triangular (all entries above the diagonal are zero)\n    2. L * L^T = A (the fundamental decomposition property)\n    3. All diagonal entries of L are positive\n    4. The decomposition is unique when restricted to positive diagonal entries -/\ntheorem cholesky_spec {n : Nat} (a : Vector (Vector Float n) n) \n    (h_symmetric : isSymmetric a) \n    (h_positive_definite : isPositiveDefinite a) :\n    ⦃⌜isSymmetric a ∧ isPositiveDefinite a⌝⦄\n    cholesky a\n    ⦃⇓l => ⌜\n      -- L is lower-triangular\n      isLowerTriangular l ∧\n      -- L * L^T = A (fundamental Cholesky property)\n      matmul l (transpose l) = a ∧\n      -- All diagonal entries are positive\n      (∀ i : Fin n, (l.get i).get i > 0) ∧\n      -- For the 1×1 case, we have the explicit formula\n      (n = 1 → (l.get ⟨0, sorry⟩).get ⟨0, sorry⟩ = \n               Float.sqrt ((a.get ⟨0, sorry⟩).get ⟨0, sorry⟩)) ∧\n      -- For the 2×2 case, we can verify the decomposition structure\n      (n = 2 → \n        let l00 := (l.get ⟨0, sorry⟩).get ⟨0, sorry⟩\n        let l10 := (l.get ⟨1, sorry⟩).get ⟨0, sorry⟩\n        let l11 := (l.get ⟨1, sorry⟩).get ⟨1, sorry⟩\n        let a00 := (a.get ⟨0, sorry⟩).get ⟨0, sorry⟩\n        let a10 := (a.get ⟨1, sorry⟩).get ⟨0, sorry⟩\n        let a11 := (a.get ⟨1, sorry⟩).get ⟨1, sorry⟩\n        -- Upper triangular part should be zero\n        (l.get ⟨0, sorry⟩).get ⟨1, sorry⟩ = 0 ∧\n        -- Cholesky relationships hold\n        l00 = Float.sqrt a00 ∧\n        l10 = a10 / l00 ∧\n        l11 = Float.sqrt (a11 - l10 * l10))\n    ⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0229", "language": "lean", "source": "numpy_triple", "source-id": "linalg_inv", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- numpy.linalg.inv: Compute the (multiplicative) inverse of a matrix.\n\n    Given a square matrix a, return the matrix ainv satisfying:\n    a @ ainv = ainv @ a = eye(a.shape[0])\n    \n    The matrix must be square and invertible (non-singular).\n    If the matrix is singular, the computation would fail in practice.\n    \n    Parameters:\n    - a : (..., M, M) array_like - Matrix to be inverted\n    \n    Returns:\n    - ainv : (..., M, M) ndarray or matrix - Inverse of the matrix a\n    \n    Raises:\n    - LinAlgError if a is not square or inversion fails\n-/\ndef inv {n : Nat} (a : Vector (Vector Float n) n) : Id (Vector (Vector Float n) n) :=\n  sorry\n\n/-- Helper function for matrix multiplication -/\ndef matmul {n : Nat} (a b : Vector (Vector Float n) n) : Vector (Vector Float n) n :=\n  sorry\n\n/-- Helper function for identity matrix -/\ndef eye (n : Nat) : Vector (Vector Float n) n :=\n  sorry\n\n/-- Helper function to check if a matrix is non-singular (has non-zero determinant) -/\ndef isNonSingular {n : Nat} (a : Vector (Vector Float n) n) : Prop :=\n  sorry\n\n/-- Specification: numpy.linalg.inv returns the multiplicative inverse of a square matrix.\n    \n    Precondition: The matrix must be non-singular (invertible)\n    Postcondition: The result ainv satisfies:\n    1. Both left and right inverse property: a @ ainv = I and ainv @ a = I\n    2. Sanity check: the result is also a square matrix of the same size\n    3. Mathematical property: (a⁻¹)⁻¹ = a (inverse is its own inverse)\n    \n    where @ denotes matrix multiplication and I is the n×n identity matrix\n-/\ntheorem inv_spec {n : Nat} (a : Vector (Vector Float n) n) \n    (h_nonsingular : isNonSingular a) :\n    ⦃⌜isNonSingular a⌝⦄\n    inv a\n    ⦃⇓ainv => ⌜matmul a ainv = eye n ∧ \n              matmul ainv a = eye n⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0240", "language": "lean", "source": "numpy_triple", "source-id": "linalg_qr", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- numpy.linalg.qr: Compute the QR factorization of a matrix.\n    \n    Factor the matrix A as Q*R, where Q is orthonormal and R is upper-triangular.\n    This is the 'reduced' mode QR decomposition for rectangular matrices.\n    \n    For a matrix A with shape (m, n) where m >= n, the QR decomposition produces:\n    - Q: orthonormal matrix with shape (m, n) \n    - R: upper-triangular matrix with shape (n, n)\n    \n    The decomposition satisfies: A = Q @ R\n    \n    Parameters:\n    - a: Matrix to be factored, shape (m, n) where m >= n\n    \n    Returns:\n    - (Q, R): tuple where Q is orthonormal and R is upper-triangular\n    \n    Mathematical properties:\n    1. Reconstruction: A = Q @ R\n    2. Q has orthonormal columns: Q^T @ Q = I\n    3. R is upper-triangular: R[i,j] = 0 for i > j\n    4. R has non-negative diagonal elements (by convention)\n-/\ndef qr {m n : Nat} (a : Vector (Vector Float n) m) (h : n ≤ m) : \n    Id (Vector (Vector Float n) m × Vector (Vector Float n) n) :=\n  sorry\n\n/-- Helper function for matrix multiplication -/\ndef matmul_rect {m n k : Nat} (a : Vector (Vector Float k) m) (b : Vector (Vector Float n) k) : \n    Vector (Vector Float n) m :=\n  sorry\n\n/-- Helper function for matrix transpose -/\ndef transpose {m n : Nat} (a : Vector (Vector Float n) m) : Vector (Vector Float m) n :=\n  sorry\n\n/-- Helper function for identity matrix -/\ndef eye (n : Nat) : Vector (Vector Float n) n :=\n  sorry\n\n/-- Helper function to check if a matrix is upper triangular -/\ndef isUpperTriangular {n : Nat} (r : Vector (Vector Float n) n) : Prop :=\n  ∀ i j : Fin n, i.val > j.val → (r.get i).get j = 0\n\n/-- Helper function to check if a matrix has orthonormal columns -/\ndef hasOrthonormalColumns {m n : Nat} (q : Vector (Vector Float n) m) : Prop :=\n  ∀ i j : Fin n, \n    (List.sum (List.map (fun k : Fin m => (q.get k).get i * (q.get k).get j) (List.finRange m))) = \n    if i = j then 1.0 else 0.0\n\n/-- Specification: qr computes the QR factorization of a matrix.\n    \n    Precondition: The matrix must be tall or square (m >= n)\n    Postcondition: Returns matrices Q and R such that:\n    1. A = Q @ R (reconstruction property)\n    2. Q has orthonormal columns (Q^T @ Q = I)\n    3. R is upper-triangular\n    4. R has non-negative diagonal elements\n    \n    The QR decomposition always exists for any matrix and is unique\n    when R has positive diagonal elements.\n-/\ntheorem qr_spec {m n : Nat} (a : Vector (Vector Float n) m) (h : n ≤ m) :\n    ⦃⌜n ≤ m⌝⦄\n    qr a h\n    ⦃⇓result => ⌜let (q, r) := result\n                 -- Property 1: Reconstruction - A = Q @ R\n                 (∀ i : Fin m, ∀ j : Fin n,\n                   (a.get i).get j = \n                   List.sum (List.map (fun k : Fin n =>\n                     (q.get i).get k * (r.get k).get j) \n                     (List.finRange n))) ∧\n                 -- Property 2: Q has orthonormal columns (Q^T @ Q = I)\n                 (hasOrthonormalColumns q) ∧\n                 -- Property 3: R is upper-triangular\n                 (isUpperTriangular r) ∧\n                 -- Property 4: R has non-negative diagonal elements\n                 (∀ i : Fin n, (r.get i).get i ≥ 0) ∧\n                 -- Property 5: Uniqueness condition - if R has positive diagonal elements,\n                 -- then the QR decomposition is unique\n                 (∀ i : Fin n, (r.get i).get i > 0 → \n                   ∀ q' r' : Vector (Vector Float n) m × Vector (Vector Float n) n,\n                     (let (q'', r'') := q'\n                      (∀ i : Fin m, ∀ j : Fin n,\n                        (a.get i).get j = \n                        List.sum (List.map (fun k : Fin n =>\n                          (q''.get i).get k * (r''.get k).get j) \n                          (List.finRange n))) ∧\n                      hasOrthonormalColumns q'' ∧\n                      isUpperTriangular r'' ∧\n                      (∀ i : Fin n, (r''.get i).get i ≥ 0)) →\n                     q' = (q, r)) ∧\n                 -- Property 6: Rank preservation - rank(A) = rank(R)\n                 -- (simplified: number of non-zero diagonal elements in R equals rank of A)\n                 (let nonZeroDiagCount := List.length (List.filter (fun i : Fin n => \n                     (r.get i).get i > 0) (List.finRange n))\n                  -- The rank property is simplified for this specification\n                  True)\n                 ⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0273", "language": "lean", "source": "numpy_triple", "source-id": "logic_functions_isrealobj", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.isrealobj\",\n  \"category\": \"Array type testing\",\n  \"description\": \"Return True if x is a not complex type or an array of complex numbers\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.isrealobj.html\",\n  \"doc\": \"Return True if x is a not complex type or an array of complex numbers.\\n\\nThe type of the input is checked, not the value. So even if the input\\nhas an imaginary part equal to zero, isrealobj evaluates to False\\nif the data type is complex.\\n\\nParameters\\n----------\\nx : any\\n    The input can be of any type and shape.\\n\\nReturns\\n-------\\ny : bool\\n    The return value, False if x is of a complex type.\\n\\nSee Also\\n--------\\niscomplexobj, isreal\\n\\nExamples\\n--------\\n>>> np.isrealobj(1)\\nTrue\\n>>> np.isrealobj(1+0j)\\nFalse\\n>>> np.isrealobj([3, 1+0j, True])\\nFalse\",\n  \"code\": \"def isrealobj(x):\\n    \\\"\\\"\\\"\\n    Return True if x is a not complex type or an array of complex numbers.\\n    \\n    The type of the input is checked, not the value. So even if the input\\n    has an imaginary part equal to zero, \\`isrealobj\\` evaluates to False\\n    if the data type is complex.\\n    \\n    Parameters\\n    ----------\\n    x : any\\n        The input can be of any type and shape.\\n    \\n    Returns\\n    -------\\n    y : bool\\n        The return value, False if \\`x\\` is of a complex type.\\n    \\n    See Also\\n    --------\\n    iscomplexobj, isreal\\n    \\n    Examples\\n    --------\\n    >>> np.isrealobj(1)\\n    True\\n    >>> np.isrealobj(1+0j)\\n    False\\n    >>> np.isrealobj([3, 1+0j, True])\\n    False\\n    \\n    \\\"\\\"\\\"\\n    return not iscomplexobj(x)\"\n}\n-/\n\nopen Std.Do\n\n-- Complex number type in Lean (simplified)\n/-- Complex number with real and imaginary parts -/\nstructure Complex where\n  /-- Real part -/\n  re : Float\n  /-- Imaginary part -/\n  im : Float\n\n/-- Check if a vector contains real-typed elements (not complex type).\n    For real-typed vectors, always returns True.\n    For complex-typed vectors, always returns False regardless of values. -/\ndef isrealobj {n : Nat} (x : Vector Float n) : Id Bool :=\n  sorry\n\n/-- Specification: isrealobj returns True for real-typed vectors, False for complex-typed vectors.\n    The key is that it checks the TYPE, not the values.\n    \n    Key properties:\n    - Always returns true for vectors of real numbers (Float)\n    - Type-based checking: independent of actual values\n    - Zero real numbers are still real objects\n    - Real vectors with any values are real objects\n    \n    Mathematical properties:\n    - Type consistency: all Float vectors are real objects\n    - Value independence: result depends only on type, not values\n    - Complementary to iscomplexobj: real objects are not complex objects -/\ntheorem isrealobj_spec {n : Nat} (x : Vector Float n) :\n    ⦃⌜True⌝⦄\n    isrealobj x\n    ⦃⇓result => ⌜result = true ∧\n      -- Sanity check: real-typed vector should always return true\n      (∀ (y : Vector Float n), result = true) ∧\n      -- Mathematical property: type checking is independent of values\n      (∀ i : Fin n, ∀ (real_val : Float), \n        result = true) ∧\n      -- Type consistency: all real-typed vectors are real objects\n      (∀ (other_vec : Vector Float n), result = true) ∧\n      -- Zero values are still real-typed\n      (let zero_real := 0.0\n       ∀ (vec_of_zeros : Vector Float n), \n        (∀ j : Fin n, vec_of_zeros.get j = zero_real) → \n        result = true) ∧\n      -- Negative values are still real-typed\n      (∀ (negative_vec : Vector Float n), \n        (∀ j : Fin n, negative_vec.get j < 0.0) → \n        result = true) ∧\n      -- Type-based property: real type vectors are never complex\n      (result = true → ¬(∃ (complex_type : Type), complex_type = Complex))⌝⦄ := by\n  sorry\n\n/-- Complementary function: check if a complex vector is NOT a real object -/\ndef isrealobj_complex {n : Nat} (x : Vector Complex n) : Id Bool :=\n  sorry\n\n/-- Specification: isrealobj returns False for complex-typed vectors.\n    This demonstrates the complementary case where the type is complex. -/\ntheorem isrealobj_complex_spec {n : Nat} (x : Vector Complex n) :\n    ⦃⌜True⌝⦄\n    isrealobj_complex x\n    ⦃⇓result => ⌜result = false ∧\n      -- Sanity check: complex-typed vector should always return false\n      (∀ (y : Vector Complex n), result = false) ∧\n      -- Mathematical property: type checking is independent of values\n      (∀ i : Fin n, ∀ (re_val im_val : Float), \n        result = false) ∧\n      -- Type consistency: all complex-typed vectors are NOT real objects\n      (∀ (other_vec : Vector Complex n), result = false) ∧\n      -- Zero imaginary parts are still complex-typed\n      (let zero_complex := Complex.mk 1.0 0.0\n       ∀ (vec_with_zero_im : Vector Complex n), \n        (∀ j : Fin n, (vec_with_zero_im.get j).im = 0.0) → \n        result = false) ∧\n      -- Complementary property: complex objects are not real objects\n      (result = false → ¬(∃ (real_type : Type), real_type = Float))⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0274", "language": "lean", "source": "numpy_triple", "source-id": "logic_functions_less", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.less\",\n  \"category\": \"Comparison\",\n  \"description\": \"Return the truth value of (x1 < x2) element-wise\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.less.html\",\n  \"doc\": \"Return the truth value of (x1 < x2) element-wise.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Input arrays. If x1.shape != x2.shape, they must be\\n    broadcastable to a common shape (which becomes the shape of the output).\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored. If provided, it must have\\n    a shape that the inputs broadcast to. If not provided or None,\\n    a freshly-allocated array is returned. A tuple (possible only as a\\n    keyword argument) must have length equal to the number of outputs.\\nwhere : array_like, optional\\n    This condition is broadcast over the input. At locations where the\\n    condition is True, the out array will be set to the ufunc result.\\n    Elsewhere, the out array will retain its original value.\\n    Note that if an uninitialized out array is created via the default\\n    out=None, locations within it where the condition is False will\\n    remain uninitialized.\\n**kwargs\\n    For other keyword-only arguments, see the\\n    ufunc docs.\\n\\nReturns\\n-------\\nout : ndarray or scalar\\n    Output array, element-wise comparison of x1 and x2.\\n    Typically of type bool, unless dtype=object is passed.\\n    This is a scalar if both x1 and x2 are scalars.\\n\\nSee Also\\n--------\\ngreater, less_equal, greater_equal, equal, not_equal\\n\\nExamples\\n--------\\n>>> np.less([1, 2], [2, 2])\\narray([ True, False])\",\n  \"code\": \"C implementation: ufunc 'less'\"\n}\n-/\n\n/-- numpy.less: Return the truth value of (x1 < x2) element-wise.\n    \n    Performs element-wise comparison between two vectors and returns a boolean\n    vector indicating where elements of x1 are less than corresponding elements\n    of x2.\n    \n    This is a fundamental comparison operation used throughout NumPy for\n    conditional operations and boolean indexing.\n-/\ndef less {n : Nat} (x1 x2 : Vector Float n) : Id (Vector Bool n) :=\n  sorry\n\n/-- Specification: numpy.less returns a boolean vector where each element\n    indicates whether the corresponding element in x1 is less than the\n    corresponding element in x2.\n    \n    Mathematical Properties:\n    1. Element-wise comparison: result[i] = x1[i] < x2[i]\n    2. Strict ordering: For each index i, exactly one of the following holds:\n       - x1[i] < x2[i] (result[i] = true)\n       - x1[i] ≥ x2[i] (result[i] = false)\n    3. Anti-symmetry: If less(x1, x2)[i] = true, then less(x2, x1)[i] = false\n    4. Transitivity property: If less(x1, x2)[i] = true and less(x2, x3)[i] = true,\n       then less(x1, x3)[i] = true\n    5. Special values: NaN comparisons always return false (IEEE 754 standard)\n    6. Irreflexivity: x[i] is never less than itself\n    \n    Precondition: True (no special preconditions for basic comparison)\n    Postcondition: For all indices i, result[i] = true iff x1[i] < x2[i]\n-/\ntheorem less_spec {n : Nat} (x1 x2 : Vector Float n) :\n    ⦃⌜True⌝⦄\n    less x1 x2\n    ⦃⇓result => ⌜∀ i : Fin n, (result.get i = true ↔ x1.get i < x2.get i) ∧ \n                               (result.get i = false ↔ x1.get i ≥ x2.get i) ∧\n                               -- Antisymmetry: if x1[i] < x2[i], then ¬(x2[i] < x1[i])\n                               (result.get i = true → ¬(x2.get i < x1.get i)) ∧\n                               -- Irreflexivity: x[i] is not less than itself\n                               (x1.get i = x2.get i → result.get i = false)⌝⦄ := by\n  sorry\n\n/-- Transitivity property: if less(x1, x2)[i] = true and less(x2, x3)[i] = true,\n    then less(x1, x3)[i] = true -/\ntheorem less_transitivity {n : Nat} (x1 x2 x3 : Vector Float n) :\n    ⦃⌜True⌝⦄\n    do\n      let r12 ← less x1 x2\n      let r23 ← less x2 x3\n      let r13 ← less x1 x3\n      return (r12, r23, r13)\n    ⦃⇓result => ⌜∀ i : Fin n, result.1.get i = true ∧ result.2.1.get i = true → \n                               result.2.2.get i = true⌝⦄ := by\n  sorry\n\n/-- Special handling for NaN values: NaN comparisons always return false\n    according to IEEE 754 standard -/\ntheorem less_nan_handling {n : Nat} (x1 x2 : Vector Float n) :\n    ⦃⌜True⌝⦄\n    less x1 x2\n    ⦃⇓result => ⌜∀ i : Fin n, (x1.get i).isNaN ∨ (x2.get i).isNaN → \n                               result.get i = false⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0303", "language": "lean", "source": "numpy_triple", "source-id": "mathematical_functions_degrees", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.degrees\",\n  \"description\": \"Convert angles from radians to degrees\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.degrees.html\",\n  \"doc\": \"Convert angles from radians to degrees.\\n\\nSignature: numpy.degrees(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True)\\n\\nParameters:\\n  x: array_like - Input array in radians\\n\\nReturns:\\n  y: ndarray - The corresponding degree values\",\n  \"code\": \"Implemented as x * 180 / pi\"\n}\n-/\n\nopen Std.Do\n\n/-- Pi constant approximation for Float calculations -/\ndef pi : Float := 3.141592653589793\n\n/-- Convert angles from radians to degrees by multiplying by 180/π -/\ndef degrees {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  pure (x.map (fun radian => radian * 180.0 / pi))\n\n/-- Specification: degrees converts each element from radians to degrees using the formula: degrees = radians * 180 / π -/\ntheorem degrees_spec {n : Nat} (x : Vector Float n) :\n    ⦃⌜True⌝⦄\n    degrees x\n    ⦃⇓result => ⌜-- Core mathematical property: formula correctness\n                 (∀ i : Fin n, result.get i = x.get i * 180.0 / pi) ∧\n                 -- Sanity check: 0 radians = 0 degrees\n                 (∀ i : Fin n, x.get i = 0.0 → result.get i = 0.0) ∧\n                 -- Sanity check: π radians = 180 degrees (approximately)\n                 (∀ i : Fin n, x.get i = pi → (result.get i - 180.0).abs < 1e-10) ∧\n                 -- Sanity check: 2π radians = 360 degrees (approximately)\n                 (∀ i : Fin n, x.get i = 2.0 * pi → (result.get i - 360.0).abs < 1e-10) ∧\n                 -- Mathematical property: π/2 radians = 90 degrees (approximately)\n                 (∀ i : Fin n, x.get i = pi / 2.0 → (result.get i - 90.0).abs < 1e-10) ∧\n                 -- Mathematical property: linearity - preserves scaling\n                 (∀ i : Fin n, ∀ (k : Float), (k * x.get i) * 180.0 / pi = k * (x.get i * 180.0 / pi)) ∧\n                 -- Mathematical property: conversion preserves sign\n                 (∀ i : Fin n, x.get i < 0.0 → result.get i < 0.0) ∧\n                 (∀ i : Fin n, x.get i > 0.0 → result.get i > 0.0) ∧\n                 -- Mathematical property: conversion preserves ordering\n                 (∀ i j : Fin n, x.get i < x.get j → result.get i < result.get j)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0350", "language": "lean", "source": "numpy_triple", "source-id": "mathematical_functions_rad2deg", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.rad2deg\",\n  \"description\": \"Convert angles from radians to degrees\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.rad2deg.html\",\n  \"doc\": \"Convert angles from radians to degrees.\\n\\nEquivalent to numpy.degrees.\",\n  \"code\": \"Alias for numpy.degrees\"\n}\n-/\n\nopen Std.Do\n\n/-- Pi constant approximation for Float calculations -/\ndef pi : Float := 3.141592653589793\n\n/-- Convert angles from radians to degrees by multiplying by 180/π. This is an alias for degrees function. -/\ndef rad2deg {n : Nat} (x : Vector Float n) : Id (Vector Float n) :=\n  pure (x.map (fun radian => radian * 180.0 / pi))\n\n/-- Specification: rad2deg converts each element from radians to degrees using the formula: degrees = radians * 180 / π -/\ntheorem rad2deg_spec {n : Nat} (x : Vector Float n) :\n    ⦃⌜True⌝⦄\n    rad2deg x\n    ⦃⇓result => ⌜-- Core mathematical property: formula correctness\n                 (∀ i : Fin n, result.get i = x.get i * 180.0 / pi) ∧\n                 -- Sanity check: 0 radians = 0 degrees\n                 (∀ i : Fin n, x.get i = 0.0 → result.get i = 0.0) ∧\n                 -- Sanity check: π radians = 180 degrees (approximately)\n                 (∀ i : Fin n, x.get i = pi → (result.get i - 180.0).abs < 1e-10) ∧\n                 -- Sanity check: 2π radians = 360 degrees (approximately)\n                 (∀ i : Fin n, x.get i = 2.0 * pi → (result.get i - 360.0).abs < 1e-10) ∧\n                 -- Mathematical property: π/2 radians = 90 degrees (approximately)\n                 (∀ i : Fin n, x.get i = pi / 2.0 → (result.get i - 90.0).abs < 1e-10) ∧\n                 -- Mathematical property: linearity - preserves scaling\n                 (∀ i : Fin n, ∀ (k : Float), (k * x.get i) * 180.0 / pi = k * (x.get i * 180.0 / pi)) ∧\n                 -- Mathematical property: conversion preserves sign\n                 (∀ i : Fin n, x.get i < 0.0 → result.get i < 0.0) ∧\n                 (∀ i : Fin n, x.get i > 0.0 → result.get i > 0.0) ∧\n                 -- Mathematical property: conversion preserves ordering\n                 (∀ i j : Fin n, x.get i < x.get j → result.get i < result.get j)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0382", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_chebyshev_chebfit", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.chebyshev.chebfit\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Least squares fit of Chebyshev series to data.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebfit.html\",\n  \"doc\": \"Least squares fit of Chebyshev series to data.\\n\\n    Return the coefficients of a Chebyshev series of degree `deg` that is the\\n    least squares fit to the data values `y` given at points `x`. If `y` is\\n    1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple\\n    fits are done, one for each column of `y`, and the resulting\\n    coefficients are stored in the corresponding columns of a 2-D return.\\n    The fitted polynomial(s) are in the form\\n\\n    .. math::  p(x) = c_0 + c_1 * T_1(x) + ... + c_n * T_n(x),\\n\\n    where `n` is `deg`.\\n\\n    Parameters\\n    ----------\\n    x : array_like, shape (M,)\\n        x-coordinates of the M sample points ``(x[i], y[i])``.\\n    y : array_like, shape (M,) or (M, K)\\n        y-coordinates of the sample points. Several data sets of sample\\n        points sharing the same x-coordinates can be fitted at once by\\n        passing in a 2D-array that contains one dataset per column.\\n    deg : int or 1-D array_like\\n        Degree(s) of the fitting polynomials. If `deg` is a single integer,\\n        all terms up to and including the `deg`'th term are included in the\\n        fit. For NumPy versions >= 1.11.0 a list of integers specifying the\\n        degrees of the terms to include may be used instead.\\n    rcond : float, optional\\n        Relative condition number of the fit. Singular values smaller than\\n        this relative to the largest singular value will be ignored. The\\n        default value is ``len(x)*eps``, where eps is the relative precision of\\n        the float type, about 2e-16 in most cases.\\n    full : bool, optional\\n        Switch determining nature of return value. When it is False (the\\n        default) just the coefficients are returned, when True diagnostic\\n        information from the singular value decomposition is also returned.\\n    w : array_like, shape (`M`,), optional\\n        Weights. If not None, the weight ``w[i]`` applies to the unsquared\\n        residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are\\n        chosen so that the errors of the products ``w[i]*y[i]`` all have the\\n        same variance.  When using inverse-variance weighting, use\\n        ``w[i] = 1/sigma(y[i])``.  The default value is None.\\n\\n    Returns\\n    -------\\n    coef : ndarray, shape (M,) or (M, K)\\n        Chebyshev coefficients ordered from low to high. If `y` was 2-D,\\n        the coefficients for the data in column k  of `y` are in column\\n        `k`.\\n\\n    [residuals, rank, singular_values, rcond] : list\\n        These values are only returned if ``full == True``\\n\\n        - residuals -- sum of squared residuals of the least squares fit\\n        - rank -- the numerical rank of the scaled Vandermonde matrix\\n        - singular_values -- singular values of the scaled Vandermonde matrix\\n        - rcond -- value of `rcond`.\\n\\n        For more details, see `numpy.linalg.lstsq`.\\n\\n    Warns\\n    -----\\n    RankWarning\\n        The rank of the coefficient matrix in the least-squares fit is\\n        deficient. The warning is only raised if ``full == False``.  The\\n        warnings can be turned off by\\n\\n        >>> import warnings\\n        >>> warnings.simplefilter('ignore', np.exceptions.RankWarning)\\n\\n    See Also\\n    --------\\n    numpy.polynomial.polynomial.polyfit\\n    numpy.polynomial.legendre.legfit\\n    numpy.polynomial.laguerre.lagfit\\n    numpy.polynomial.hermite.hermfit\\n    numpy.polynomial.hermite_e.hermefit\\n    chebval : Evaluates a Chebyshev series.\\n    chebvander : Vandermonde matrix of Chebyshev series.\\n    chebweight : Chebyshev weight function.\\n    numpy.linalg.lstsq : Computes a least-squares fit from the matrix.\\n    scipy.interpolate.UnivariateSpline : Computes spline fits.\\n\\n    Notes\\n    -----\\n    The solution is the coefficients of the Chebyshev series `p` that\\n    minimizes the sum of the weighted squared errors\\n\\n    .. math:: E = \\\\sum_j w_j^2 * |y_j - p(x_j)|^2,\\n\\n    where :math:`w_j` are the weights. This problem is solved by setting up\\n    as the (typically) overdetermined matrix equation\\n\\n    .. math:: V(x) * c = w * y,\\n\\n    where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the\\n    coefficients to be solved for, `w` are the weights, and `y` are the\\n    observed values.  This equation is then solved using the singular value\\n    decomposition of `V`.\\n\\n    If some of the singular values of `V` are so small that they are\\n    neglected, then a `~exceptions.RankWarning` will be issued. This means that\\n    the coefficient values may be poorly determined. Using a lower order fit\\n    will usually get rid of the warning.  The `rcond` parameter can also be\\n    set to a value smaller than its default, but the resulting fit may be\\n    spurious and have large contributions from roundoff error.\\n\\n    Fits using Chebyshev series are usually better conditioned than fits\\n    using power series, but much can depend on the distribution of the\\n    sample points and the smoothness of the data. If the quality of the fit\\n    is inadequate splines may be a good alternative.\\n\\n    References\\n    ----------\\n    .. [1] Wikipedia, \\\"Curve fitting\\\",\\n           https://en.wikipedia.org/wiki/Curve_fitting\\n\\n    Examples\\n    --------\",\n  \"code\": \"def chebfit(x, y, deg, rcond=None, full=False, w=None):\\n    \\\"\\\"\\\"\\n    Least squares fit of Chebyshev series to data.\\n\\n    Return the coefficients of a Chebyshev series of degree `deg` that is the\\n    least squares fit to the data values `y` given at points `x`. If `y` is\\n    1-D the returned coefficients will also be 1-D. If `y` is 2-D multiple\\n    fits are done, one for each column of `y`, and the resulting\\n    coefficients are stored in the corresponding columns of a 2-D return.\\n    The fitted polynomial(s) are in the form\\n\\n    .. math::  p(x) = c_0 + c_1 * T_1(x) + ... + c_n * T_n(x),\\n\\n    where `n` is `deg`.\\n\\n    Parameters\\n    ----------\\n    x : array_like, shape (M,)\\n        x-coordinates of the M sample points ``(x[i], y[i])``.\\n    y : array_like, shape (M,) or (M, K)\\n        y-coordinates of the sample points. Several data sets of sample\\n        points sharing the same x-coordinates can be fitted at once by\\n        passing in a 2D-array that contains one dataset per column.\\n    deg : int or 1-D array_like\\n        Degree(s) of the fitting polynomials. If `deg` is a single integer,\\n        all terms up to and including the `deg`'th term are included in the\\n        fit. For NumPy versions >= 1.11.0 a list of integers specifying the\\n        degrees of the terms to include may be used instead.\\n    rcond : float, optional\\n        Relative condition number of the fit. Singular values smaller than\\n        this relative to the largest singular value will be ignored. The\\n        default value is ``len(x)*eps``, where eps is the relative precision of\\n        the float type, about 2e-16 in most cases.\\n    full : bool, optional\\n        Switch determining nature of return value. When it is False (the\\n        default) just the coefficients are returned, when True diagnostic\\n        information from the singular value decomposition is also returned.\\n    w : array_like, shape (`M`,), optional\\n        Weights. If not None, the weight ``w[i]`` applies to the unsquared\\n        residual ``y[i] - y_hat[i]`` at ``x[i]``. Ideally the weights are\\n        chosen so that the errors of the products ``w[i]*y[i]`` all have the\\n        same variance.  When using inverse-variance weighting, use\\n        ``w[i] = 1/sigma(y[i])``.  The default value is None.\\n\\n    Returns\\n    -------\\n    coef : ndarray, shape (M,) or (M, K)\\n        Chebyshev coefficients ordered from low to high. If `y` was 2-D,\\n        the coefficients for the data in column k  of `y` are in column\\n        `k`.\\n\\n    [residuals, rank, singular_values, rcond] : list\\n        These values are only returned if ``full == True``\\n\\n        - residuals -- sum of squared residuals of the least squares fit\\n        - rank -- the numerical rank of the scaled Vandermonde matrix\\n        - singular_values -- singular values of the scaled Vandermonde matrix\\n        - rcond -- value of `rcond`.\\n\\n        For more details, see `numpy.linalg.lstsq`.\\n\\n    Warns\\n    -----\\n    RankWarning\\n        The rank of the coefficient matrix in the least-squares fit is\\n        deficient. The warning is only raised if ``full == False``.  The\\n        warnings can be turned off by\\n\\n        >>> import warnings\\n        >>> warnings.simplefilter('ignore', np.exceptions.RankWarning)\\n\\n    See Also\\n    --------\\n    numpy.polynomial.polynomial.polyfit\\n    numpy.polynomial.legendre.legfit\\n    numpy.polynomial.laguerre.lagfit\\n    numpy.polynomial.hermite.hermfit\\n    numpy.polynomial.hermite_e.hermefit\\n    chebval : Evaluates a Chebyshev series.\\n    chebvander : Vandermonde matrix of Chebyshev series.\\n    chebweight : Chebyshev weight function.\\n    numpy.linalg.lstsq : Computes a least-squares fit from the matrix.\\n    scipy.interpolate.UnivariateSpline : Computes spline fits.\\n\\n    Notes\\n    -----\\n    The solution is the coefficients of the Chebyshev series `p` that\\n    minimizes the sum of the weighted squared errors\\n\\n    .. math:: E = \\\\sum_j w_j^2 * |y_j - p(x_j)|^2,\\n\\n    where :math:`w_j` are the weights. This problem is solved by setting up\\n    as the (typically) overdetermined matrix equation\\n\\n    .. math:: V(x) * c = w * y,\\n\\n    where `V` is the weighted pseudo Vandermonde matrix of `x`, `c` are the\\n    coefficients to be solved for, `w` are the weights, and `y` are the\\n    observed values.  This equation is then solved using the singular value\\n    decomposition of `V`.\\n\\n    If some of the singular values of `V` are so small that they are\\n    neglected, then a `~exceptions.RankWarning` will be issued. This means that\\n    the coefficient values may be poorly determined. Using a lower order fit\\n    will usually get rid of the warning.  The `rcond` parameter can also be\\n    set to a value smaller than its default, but the resulting fit may be\\n    spurious and have large contributions from roundoff error.\\n\\n    Fits using Chebyshev series are usually better conditioned than fits\\n    using power series, but much can depend on the distribution of the\\n    sample points and the smoothness of the data. If the quality of the fit\\n    is inadequate splines may be a good alternative.\\n\\n    References\\n    ----------\\n    .. [1] Wikipedia, \\\"Curve fitting\\\",\\n           https://en.wikipedia.org/wiki/Curve_fitting\\n\\n    Examples\\n    --------\\n\\n    \\\"\\\"\\\"\\n    return pu._fit(chebvander, x, y, deg, rcond, full, w)\"\n}\n-/\n\nopen Std.Do\n\n/-- Helper to compute Chebyshev polynomial T_k at point x using the recurrence relation -/\ndef chebyshevT (k : Nat) (x : Float) : Float :=\n  sorry\n\n/-- Helper to evaluate a Chebyshev series at a given point -/\ndef evalChebSeries (coeffs : Vector Float n) (x : Float) : Float :=\n  sorry\n\n/-- \nComputes the coefficients of a Chebyshev series of degree `deg` that is the\nleast squares fit to the data values `y` given at points `x`.\n\nThe fitted polynomial is in the form:\np(x) = c_0 + c_1 * T_1(x) + ... + c_deg * T_deg(x)\n\nwhere T_k(x) is the k-th Chebyshev polynomial of the first kind.\n-/\ndef chebfit {m : Nat} (x : Vector Float m) (y : Vector Float m) (deg : Nat) : Id (Vector Float (deg + 1)) :=\n  sorry\n\n/-- \nSpecification: chebfit returns coefficients c such that the resulting Chebyshev series\nminimizes the sum of squared errors between the original data points and the fitted polynomial.\n\nThe specification ensures:\n1. The result has deg + 1 coefficients (from degree 0 to deg)\n2. The degree must be less than the number of data points (deg < m) for a well-defined problem\n3. The coefficients produce a Chebyshev polynomial that best fits the data in the least squares sense\n4. The fitting minimizes the sum of squared residuals: Σ(y[i] - p(x[i]))²\n   where p(x) is the Chebyshev polynomial with the computed coefficients\n5. All x-coordinates must be in the interval [-1, 1] for standard Chebyshev polynomials,\n   or the implementation should transform them appropriately\n6. The Chebyshev basis provides better numerical conditioning than power series\n-/\ntheorem chebfit_spec {m : Nat} (x : Vector Float m) (y : Vector Float m) (deg : Nat) (h : m > 0) :\n    ⦃⌜m > 0 ∧ deg < m ∧ \n      -- All x values should be in [-1, 1] for standard Chebyshev polynomials\n      (∀ i : Fin m, -1 ≤ x.get i ∧ x.get i ≤ 1)⌝⦄\n    chebfit x y deg\n    ⦃⇓coef => ⌜\n      -- The result has the correct size\n      coef.toList.length = deg + 1 ∧\n      -- The coefficients form a valid Chebyshev series that minimizes error\n      -- Express the least squares property: the coefficients minimize the sum of squared residuals\n      -- For any other coefficient vector c' of the same size, the sum of squared errors \n      -- using coef is less than or equal to that using c'\n      (∀ (other_coef : Vector Float (deg + 1)),\n        let sumSquaredError (c : Vector Float (deg + 1)) : Float :=\n          -- Sum over all data points\n          let residuals := Vector.ofFn (fun i : Fin m => \n            y.get i - evalChebSeries c (x.get i))\n          -- Compute sum of squares (using a fold since we don't have sum for Float)\n          residuals.toList.foldl (fun acc r => acc + r * r) 0\n        sumSquaredError coef ≤ sumSquaredError other_coef) ∧\n      -- Additional property: the fitting is exact for polynomials of degree ≤ deg\n      -- If y values come from a Chebyshev polynomial of degree ≤ deg, \n      -- then the fit should be exact (up to floating point precision)\n      (∀ (true_coeffs : Vector Float (deg + 1)),\n        (∀ i : Fin m, y.get i = evalChebSeries true_coeffs (x.get i)) →\n        -- The fitted coefficients should match the true coefficients\n        ∀ j : Fin (deg + 1), Float.abs (coef.get j - true_coeffs.get j) < 1e-10)\n    ⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0385", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_chebyshev_chebgrid2d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.chebyshev.chebgrid2d\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebgrid2d.html\",\n  \"doc\": \"Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b) = \\\\\\\\sum_{i,j} c_{i,j} * T_i(a) * T_j(b),\\n\\n    where the points \\`(a, b)\\` consist of all pairs formed by taking\\n    \\`a\\` from \\`x\\` and \\`b\\` from \\`y\\`. The resulting points form a grid with\\n    \\`x\\` in the first dimension and \\`y\\` in the second.\\n\\n    The parameters \\`x\\` and \\`y\\` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars. In either\\n    case, either \\`x\\` and \\`y\\` or their elements must support multiplication\\n    and addition both with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` has fewer than two dimensions, ones are implicitly appended to\\n    its shape to make it 2-D. The shape of the result will be c.shape[2:] +\\n    x.shape + y.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points in the\\n        Cartesian product of \\`x\\` and \\`y\\`.  If \\`x\\` or \\`y\\` is a list or\\n        tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and, if it isn't an ndarray, it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term of\\n        multi-degree i,j is contained in \\`\\`c[i,j]\\`\\`. If \\`c\\` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional Chebyshev series at points in the\\n        Cartesian product of \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    chebval, chebval2d, chebval3d, chebgrid3d\",\n  \"code\": \"def chebgrid2d(x, y, c):\\n    \\\"\\\"\\\"\\n    Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b) = \\\\\\\\sum_{i,j} c_{i,j} * T_i(a) * T_j(b),\\n\\n    where the points \\`(a, b)\\` consist of all pairs formed by taking\\n    \\`a\\` from \\`x\\` and \\`b\\` from \\`y\\`. The resulting points form a grid with\\n    \\`x\\` in the first dimension and \\`y\\` in the second.\\n\\n    The parameters \\`x\\` and \\`y\\` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars. In either\\n    case, either \\`x\\` and \\`y\\` or their elements must support multiplication\\n    and addition both with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` has fewer than two dimensions, ones are implicitly appended to\\n    its shape to make it 2-D. The shape of the result will be c.shape[2:] +\\n    x.shape + y.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points in the\\n        Cartesian product of \\`x\\` and \\`y\\`.  If \\`x\\` or \\`y\\` is a list or\\n        tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and, if it isn't an ndarray, it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term of\\n        multi-degree i,j is contained in \\`\\`c[i,j]\\`\\`. If \\`c\\` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional Chebyshev series at points in the\\n        Cartesian product of \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    chebval, chebval2d, chebval3d, chebgrid3d\\n    \\\"\\\"\\\"\\n    return pu._gridnd(chebval, c, x, y)\"\n}\n-/\n\nopen Std.Do\n\n/-- Helper function to compute the n-th Chebyshev polynomial T_n at point x.\n    T_0(x) = 1, T_1(x) = x, T_n(x) = 2x*T_{n-1}(x) - T_{n-2}(x) for n ≥ 2 -/\ndef chebyshevT (n : Nat) (x : Float) : Float :=\n  sorry\n\n/-- Helper function to compute the sum of a 2D Chebyshev series at a point.\n    Computes Σ_{i=0}^{rows-1} Σ_{j=0}^{cols-1} c[i,j] * T_i(x) * T_j(y) -/\ndef chebSeriesSum {rows cols : Nat} \n    (c : Vector (Vector Float cols) rows) \n    (x y : Float) : Float :=\n  sorry\n\n/-- Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.\n    \n    This function evaluates the sum: p(a,b) = Σ_{i,j} c_{i,j} * T_i(a) * T_j(b)\n    where T_i and T_j are Chebyshev polynomials of the first kind.\n    The result is a 2D grid where result[k,l] = p(x[k], y[l]). -/\ndef chebgrid2d {nx ny rows cols : Nat} \n    (x : Vector Float nx) \n    (y : Vector Float ny) \n    (c : Vector (Vector Float cols) rows) : \n    Id (Vector (Vector Float ny) nx) :=\n  sorry\n\n/-- Specification: chebgrid2d evaluates a 2D Chebyshev series on a grid.\n    \n    The function computes p(x[i], y[j]) = Σ_{k,l} c[k,l] * T_k(x[i]) * T_l(y[j])\n    for all combinations of x[i] and y[j], where T_k and T_l are Chebyshev \n    polynomials of the first kind. The result forms a grid with dimensions \n    nx × ny. -/\ntheorem chebgrid2d_spec {nx ny rows cols : Nat} \n    (x : Vector Float nx) \n    (y : Vector Float ny) \n    (c : Vector (Vector Float cols) rows) :\n    ⦃⌜True⌝⦄\n    chebgrid2d x y c\n    ⦃⇓result => ⌜∀ (i : Fin nx) (j : Fin ny), \n        (result.get i).get j = chebSeriesSum c (x.get i) (y.get j)⌝⦄ := by\n  sorry\n\n/-- Additional property: When coefficient matrix has only c[0,0] = 1 and rest are zero,\n    the result is a constant grid with all values equal to 1 (since T_0(x) = 1) -/\ntheorem chebgrid2d_constant_case {nx ny : Nat} \n    (x : Vector Float nx) \n    (y : Vector Float ny) \n    (hx : nx > 0) (hy : ny > 0) :\n    let c : Vector (Vector Float 1) 1 := ⟨#[⟨#[1.0], sorry⟩], sorry⟩\n    ⦃⌜nx > 0 ∧ ny > 0⌝⦄\n    chebgrid2d x y c\n    ⦃⇓result => ⌜∀ (i : Fin nx) (j : Fin ny), \n        (result.get i).get j = 1.0⌝⦄ := by\n  sorry\n\n/-- Property: The result grid has the correct dimensions -/\ntheorem chebgrid2d_dimensions {nx ny rows cols : Nat} \n    (x : Vector Float nx) \n    (y : Vector Float ny) \n    (c : Vector (Vector Float cols) rows) :\n    ⦃⌜True⌝⦄\n    chebgrid2d x y c\n    ⦃⇓result => ⌜result.size = nx ∧ \n        ∀ (i : Fin nx), (result.get i).size = ny⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0395", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_chebyshev_chebroots", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.chebyshev.chebroots\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Compute the roots of a Chebyshev series.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebroots.html\",\n  \"doc\": \"Compute the roots of a Chebyshev series.\\n\\n    Return the roots (a.k.a. \\\"zeros\\\") of the polynomial\\n\\n    .. math:: p(x) = \\\\\\\\sum_i c[i] * T_i(x).\\n\\n    Parameters\\n    ----------\\n    c : 1-D array_like\\n        1-D array of coefficients.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array of the roots of the series. If all the roots are real,\\n        then \\`out\\` is also real, otherwise it is complex.\\n\\n    See Also\\n    --------\\n    numpy.polynomial.polynomial.polyroots\\n    numpy.polynomial.legendre.legroots\\n    numpy.polynomial.laguerre.lagroots\\n    numpy.polynomial.hermite.hermroots\\n    numpy.polynomial.hermite_e.hermeroots\\n\\n    Notes\\n    -----\\n    The root estimates are obtained as the eigenvalues of the companion\\n    matrix, Roots far from the origin of the complex plane may have large\\n    errors due to the numerical instability of the series for such\\n    values. Roots with multiplicity greater than 1 will also show larger\\n    errors as the value of the series near such points is relatively\\n    insensitive to errors in the roots. Isolated roots near the origin can\\n    be improved by a few iterations of Newton's method.\\n\\n    The Chebyshev series basis polynomials aren't powers of \\`x\\` so the\\n    results of this function may seem unintuitive.\\n\\n    Examples\\n    --------\\n    >>> import numpy.polynomial.chebyshev as cheb\\n    >>> cheb.chebroots((-1, 1,-1, 1)) # T3 - T2 + T1 - T0 has real roots\\n    array([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00]) # may vary\",\n  \"code\": \"def chebroots(c):\\n    \\\"\\\"\\\"\\n    Compute the roots of a Chebyshev series.\\n\\n    Return the roots (a.k.a. \\\"zeros\\\") of the polynomial\\n\\n    .. math:: p(x) = \\\\\\\\sum_i c[i] * T_i(x).\\n\\n    Parameters\\n    ----------\\n    c : 1-D array_like\\n        1-D array of coefficients.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array of the roots of the series. If all the roots are real,\\n        then \\`out\\` is also real, otherwise it is complex.\\n\\n    See Also\\n    --------\\n    numpy.polynomial.polynomial.polyroots\\n    numpy.polynomial.legendre.legroots\\n    numpy.polynomial.laguerre.lagroots\\n    numpy.polynomial.hermite.hermroots\\n    numpy.polynomial.hermite_e.hermeroots\\n\\n    Notes\\n    -----\\n    The root estimates are obtained as the eigenvalues of the companion\\n    matrix, Roots far from the origin of the complex plane may have large\\n    errors due to the numerical instability of the series for such\\n    values. Roots with multiplicity greater than 1 will also show larger\\n    errors as the value of the series near such points is relatively\\n    insensitive to errors in the roots. Isolated roots near the origin can\\n    be improved by a few iterations of Newton's method.\\n\\n    The Chebyshev series basis polynomials aren't powers of \\`x\\` so the\\n    results of this function may seem unintuitive.\\n\\n    Examples\\n    --------\\n    >>> import numpy.polynomial.chebyshev as cheb\\n    >>> cheb.chebroots((-1, 1,-1, 1)) # T3 - T2 + T1 - T0 has real roots\\n    array([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00]) # may vary\\n\\n    \\\"\\\"\\\"\\n    # c is a trimmed copy\\n    [c] = pu.as_series([c])\\n    if len(c) < 2:\\n        return np.array([], dtype=c.dtype)\\n    if len(c) == 2:\\n        return np.array([-c[0] / c[1]])\\n\\n    # rotated companion matrix reduces error\\n    m = chebcompanion(c)[::-1, ::-1]\\n    r = la.eigvals(m)\\n    r.sort()\\n    return r\"\n}\n-/\n\nopen Std.Do\n\n/-- Helper: Compute the value of the n-th Chebyshev polynomial of the first kind at x.\n    T₀(x) = 1, T₁(x) = x, Tₙ₊₂(x) = 2x*Tₙ₊₁(x) - Tₙ(x) -/\ndef chebyshevT (n : Nat) (x : Float) : Float :=\n  sorry\n\n/-- Helper: Evaluate a Chebyshev polynomial series at a point x.\n    p(x) = Σᵢ c[i] * Tᵢ(x) where Tᵢ is the i-th Chebyshev polynomial -/\ndef chebyshevPolynomialValue {n : Nat} (c : Vector Float (n + 1)) (x : Float) : Float :=\n  sorry\n\n/-- Compute the roots of a Chebyshev series.\n    \n    Returns the roots (zeros) of the polynomial p(x) = Σᵢ c[i] * Tᵢ(x),\n    where Tᵢ(x) denotes the i-th Chebyshev polynomial of the first kind.\n    \n    For a polynomial of degree n (with n+1 coefficients), returns n roots.\n    The roots are sorted in ascending order.\n    \n    Note: While roots may be complex in general, this specification focuses on \n    the real case for simplicity. -/\ndef chebroots {n : Nat} (c : Vector Float (n + 1)) : Id (Vector Float n) :=\n  sorry\n\n/-- Specification: chebroots computes all roots of a Chebyshev polynomial series.\n    \n    The roots satisfy:\n    1. Each root r is a zero of the Chebyshev polynomial p(x) = Σᵢ c[i] * Tᵢ(x)\n    2. The number of roots equals the degree of the polynomial (n)\n    3. The roots are sorted in ascending order\n    4. No repeated roots for polynomials with distinct roots (multiplicity 1) -/\ntheorem chebroots_spec {n : Nat} (c : Vector Float (n + 1)) \n    (h_nonzero : c.get ⟨n, by simp⟩ ≠ 0) (h_pos : n > 0) :\n    ⦃⌜c.get ⟨n, by simp⟩ ≠ 0 ∧ n > 0⌝⦄\n    chebroots c\n    ⦃⇓roots => ⌜-- Each root is approximately a zero of the polynomial\n                (∀ i : Fin n, \n                  let r := roots.get i\n                  let p := chebyshevPolynomialValue c r\n                  Float.abs p < 1e-10) ∧\n                -- Roots are sorted in ascending order\n                (∀ i j : Fin n, i < j → roots.get i ≤ roots.get j) ∧\n                -- For polynomials with distinct roots, all roots are different\n                (∀ i j : Fin n, i ≠ j → roots.get i ≠ roots.get j)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0397", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_chebyshev_chebval", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.chebyshev.chebval\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Evaluate a Chebyshev series at points x.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebval.html\",\n  \"doc\": \"Evaluate a Chebyshev series at points x.\\n\\n    If \\`c\\` is of length \\`n + 1\\`, this function returns the value:\\n\\n    .. math:: p(x) = c_0 * T_0(x) + c_1 * T_1(x) + ... + c_n * T_n(x)\\n\\n    The parameter \\`x\\` is converted to an array only if it is a tuple or a\\n    list, otherwise it is treated as a scalar. In either case, either \\`x\\`\\n    or its elements must support multiplication and addition both with\\n    themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array, then \\`\\`p(x)\\`\\` will have the same shape as \\`x\\`.  If\\n    \\`c\\` is multidimensional, then the shape of the result depends on the\\n    value of \\`tensor\\`. If \\`tensor\\` is true the shape will be c.shape[1:] +\\n    x.shape. If \\`tensor\\` is false the shape will be c.shape[1:]. Note that\\n    scalars have shape (,).\\n\\n    Trailing zeros in the coefficients will be used in the evaluation, so\\n    they should be avoided if efficiency is a concern.\\n\\n    Parameters\\n    ----------\\n    x : array_like, compatible object\\n        If \\`x\\` is a list or tuple, it is converted to an ndarray, otherwise\\n        it is left unchanged and treated as a scalar. In either case, \\`x\\`\\n        or its elements must support addition and multiplication with\\n        themselves and with the elements of \\`c\\`.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree n are contained in c[n]. If \\`c\\` is multidimensional the\\n        remaining indices enumerate multiple polynomials. In the two\\n        dimensional case the coefficients may be thought of as stored in\\n        the columns of \\`c\\`.\\n    tensor : boolean, optional\\n        If True, the shape of the coefficient array is extended with ones\\n        on the right, one for each dimension of \\`x\\`. Scalars have dimension 0\\n        for this action. The result is that every column of coefficients in\\n        \\`c\\` is evaluated for every element of \\`x\\`. If False, \\`x\\` is broadcast\\n        over the columns of \\`c\\` for the evaluation.  This keyword is useful\\n        when \\`c\\` is multidimensional. The default value is True.\\n\\n    Returns\\n    -------\\n    values : ndarray, algebra_like\\n        The shape of the return value is described above.\\n\\n    See Also\\n    --------\\n    chebval2d, chebgrid2d, chebval3d, chebgrid3d\\n\\n    Notes\\n    -----\\n    The evaluation uses Clenshaw recursion, aka synthetic division.\",\n  \"code\": \"def chebval(x, c, tensor=True):\\n    \\\"\\\"\\\"\\n    Evaluate a Chebyshev series at points x.\\n\\n    If \\`c\\` is of length \\`n + 1\\`, this function returns the value:\\n\\n    .. math:: p(x) = c_0 * T_0(x) + c_1 * T_1(x) + ... + c_n * T_n(x)\\n\\n    The parameter \\`x\\` is converted to an array only if it is a tuple or a\\n    list, otherwise it is treated as a scalar. In either case, either \\`x\\`\\n    or its elements must support multiplication and addition both with\\n    themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array, then \\`\\`p(x)\\`\\` will have the same shape as \\`x\\`.  If\\n    \\`c\\` is multidimensional, then the shape of the result depends on the\\n    value of \\`tensor\\`. If \\`tensor\\` is true the shape will be c.shape[1:] +\\n    x.shape. If \\`tensor\\` is false the shape will be c.shape[1:]. Note that\\n    scalars have shape (,).\\n\\n    Trailing zeros in the coefficients will be used in the evaluation, so\\n    they should be avoided if efficiency is a concern.\\n\\n    Parameters\\n    ----------\\n    x : array_like, compatible object\\n        If \\`x\\` is a list or tuple, it is converted to an ndarray, otherwise\\n        it is left unchanged and treated as a scalar. In either case, \\`x\\`\\n        or its elements must support addition and multiplication with\\n        themselves and with the elements of \\`c\\`.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree n are contained in c[n]. If \\`c\\` is multidimensional the\\n        remaining indices enumerate multiple polynomials. In the two\\n        dimensional case the coefficients may be thought of as stored in\\n        the columns of \\`c\\`.\\n    tensor : boolean, optional\\n        If True, the shape of the coefficient array is extended with ones\\n        on the right, one for each dimension of \\`x\\`. Scalars have dimension 0\\n        for this action. The result is that every column of coefficients in\\n        \\`c\\` is evaluated for every element of \\`x\\`. If False, \\`x\\` is broadcast\\n        over the columns of \\`c\\` for the evaluation.  This keyword is useful\\n        when \\`c\\` is multidimensional. The default value is True.\\n\\n    Returns\\n    -------\\n    values : ndarray, algebra_like\\n        The shape of the return value is described above.\\n\\n    See Also\\n    --------\\n    chebval2d, chebgrid2d, chebval3d, chebgrid3d\\n\\n    Notes\\n    -----\\n    The evaluation uses Clenshaw recursion, aka synthetic division.\\n\\n    \\\"\\\"\\\"\\n    c = np.array(c, ndmin=1, copy=True)\\n    if c.dtype.char in '?bBhHiIlLqQpP':\\n        c = c.astype(np.double)\\n    if isinstance(x, (tuple, list)):\\n        x = np.asarray(x)\\n    if isinstance(x, np.ndarray) and tensor:\\n        c = c.reshape(c.shape + (1,) * x.ndim)\\n\\n    if len(c) == 1:\\n        c0 = c[0]\\n        c1 = 0\\n    elif len(c) == 2:\\n        c0 = c[0]\\n        c1 = c[1]\\n    else:\\n        x2 = 2 * x\\n        c0 = c[-2]\\n        c1 = c[-1]\\n        for i in range(3, len(c) + 1):\\n            tmp = c0\\n            c0 = c[-i] - c1\\n            c1 = tmp + c1 * x2\\n    return c0 + c1 * x\"\n}\n-/\n\nopen Std.Do\n\n/-- Helper function to compute Chebyshev polynomial T_n(x) recursively -/\ndef chebyshevT (n : Nat) (x : Float) : Float :=\n  match n with\n  | 0 => 1\n  | 1 => x\n  | n + 2 => 2 * x * chebyshevT (n + 1) x - chebyshevT n x\n\n/-- Evaluate a Chebyshev series at points x using coefficients c.\n    For a coefficient vector c of length n+1, this computes:\n    p(x) = c_0 * T_0(x) + c_1 * T_1(x) + ... + c_n * T_n(x)\n    where T_k(x) is the k-th Chebyshev polynomial of the first kind.\n    \n    The implementation uses Clenshaw recursion for numerical stability. -/\ndef chebval {m n : Nat} (x : Vector Float m) (c : Vector Float n) : Id (Vector Float m) :=\n  sorry\n\n/-- Helper function to compute the Chebyshev series sum -/\ndef chebyshevSeriesSum {n : Nat} (c : Vector Float n) (x : Float) : Float :=\n  match n with\n  | 0 => 0\n  | 1 => c.get ⟨0, sorry⟩\n  | n + 1 => \n    let rec loop (k : Nat) (acc : Float) : Float :=\n      if k ≥ n + 1 then acc\n      else loop (k + 1) (acc + c.get ⟨k, sorry⟩ * chebyshevT k x)\n    loop 0 0\n\n/-- Specification: chebval evaluates the Chebyshev series correctly.\n    The result at each point x[i] equals the sum of c[k] * T_k(x[i])\n    for k from 0 to n-1, where T_k is the k-th Chebyshev polynomial.\n    \n    Special cases for numerical stability:\n    - When n = 0, the result is the zero vector\n    - When n = 1, the result is c[0] at each point (constant polynomial)\n    - When n = 2, the result is c[0] + c[1] * x[i] (linear polynomial)\n    \n    The implementation uses Clenshaw recursion for efficient and stable evaluation. -/\ntheorem chebval_spec {m n : Nat} (x : Vector Float m) (c : Vector Float n) :\n    ⦃⌜True⌝⦄\n    chebval x c\n    ⦃⇓result => ⌜(n = 0 → ∀ i : Fin m, result.get i = 0) ∧\n                (n = 1 → ∀ i : Fin m, result.get i = c.get ⟨0, sorry⟩) ∧\n                (n = 2 → ∀ i : Fin m, result.get i = c.get ⟨0, sorry⟩ + c.get ⟨1, sorry⟩ * x.get i) ∧\n                (∀ i : Fin m, result.get i = chebyshevSeriesSum c (x.get i))⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0398", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_chebyshev_chebval2d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.chebyshev.chebval2d\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Evaluate a 2-D Chebyshev series at points (x, y).\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebval2d.html\",\n  \"doc\": \"Evaluate a 2-D Chebyshev series at points (x, y).\\n\\n    This function returns the values:\\n\\n    .. math:: p(x,y) = \\\\sum_{i,j} c_{i,j} * T_i(x) * T_j(y)\\n\\n    The parameters `x` and `y` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars and they\\n    must have the same shape after conversion. In either case, either `x`\\n    and `y` or their elements must support multiplication and addition both\\n    with themselves and with the elements of `c`.\\n\\n    If `c` is a 1-D array a one is implicitly appended to its shape to make\\n    it 2-D. The shape of the result will be c.shape[2:] + x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points ``(x, y)``,\\n        where `x` and `y` must have the same shape. If `x` or `y` is a list\\n        or tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and if it isn't an ndarray it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term\\n        of multi-degree i,j is contained in ``c[i,j]``. If `c` has\\n        dimension greater than 2 the remaining indices enumerate multiple\\n        sets of coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional Chebyshev series at points formed\\n        from pairs of corresponding values from `x` and `y`.\\n\\n    See Also\\n    --------\\n    chebval, chebgrid2d, chebval3d, chebgrid3d\",\n  \"code\": \"def chebval2d(x, y, c):\\n    \\\"\\\"\\\"\\n    Evaluate a 2-D Chebyshev series at points (x, y).\\n\\n    This function returns the values:\\n\\n    .. math:: p(x,y) = \\\\sum_{i,j} c_{i,j} * T_i(x) * T_j(y)\\n\\n    The parameters `x` and `y` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars and they\\n    must have the same shape after conversion. In either case, either `x`\\n    and `y` or their elements must support multiplication and addition both\\n    with themselves and with the elements of `c`.\\n\\n    If `c` is a 1-D array a one is implicitly appended to its shape to make\\n    it 2-D. The shape of the result will be c.shape[2:] + x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points ``(x, y)``,\\n        where `x` and `y` must have the same shape. If `x` or `y` is a list\\n        or tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and if it isn't an ndarray it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term\\n        of multi-degree i,j is contained in ``c[i,j]``. If `c` has\\n        dimension greater than 2 the remaining indices enumerate multiple\\n        sets of coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional Chebyshev series at points formed\\n        from pairs of corresponding values from `x` and `y`.\\n\\n    See Also\\n    --------\\n    chebval, chebgrid2d, chebval3d, chebgrid3d\\n    \\\"\\\"\\\"\\n    return pu._valnd(chebval, c, x, y)\"\n}\n-/\n\nopen Std.Do\n\n/-- Helper function to compute Chebyshev polynomial T_n(x) recursively -/\ndef chebyshevT (n : Nat) (x : Float) : Float :=\n  match n with\n  | 0 => 1\n  | 1 => x\n  | n + 2 => 2 * x * chebyshevT (n + 1) x - chebyshevT n x\n\n/-- Evaluate a 2-D Chebyshev series at points (x, y).\n    \n    For a coefficient matrix c of dimensions rows × cols, this computes:\n    p(x[k], y[k]) = ∑_{i=0}^{rows-1} ∑_{j=0}^{cols-1} c[i,j] * T_i(x[k]) * T_j(y[k])\n    where T_n is the n-th Chebyshev polynomial of the first kind.\n    \n    The x and y vectors must have the same length, and each pair (x[k], y[k])\n    represents a point at which to evaluate the 2D Chebyshev series. -/\ndef chebval2d {n rows cols : Nat} \n    (x : Vector Float n) \n    (y : Vector Float n) \n    (c : Vector (Vector Float cols) rows) : \n    Id (Vector Float n) :=\n  sorry\n\n/-- Specification: chebval2d correctly evaluates the 2D Chebyshev series.\n    \n    The result at each point (x[k], y[k]) equals the double sum:\n    ∑_{i=0}^{rows-1} ∑_{j=0}^{cols-1} c[i,j] * T_i(x[k]) * T_j(y[k])\n    \n    Mathematical properties:\n    1. Empty coefficient matrix: When rows = 0 or cols = 0, returns zero vector\n    2. Constant polynomial: When rows = 1 and cols = 1, returns c[0,0] at all points\n    3. Linear separability: For c[i,j] = a[i] * b[j], result[k] = chebval(x[k], a) * chebval(y[k], b)\n    4. Symmetry: chebval2d(x, y, c) and chebval2d(y, x, c^T) produce related results\n    5. Clenshaw recursion: Implementation should use numerically stable recursion\n    \n    The specification ensures:\n    - Correct evaluation of 2D Chebyshev polynomial series\n    - Numerical stability through appropriate algorithms\n    - Handling of edge cases (empty matrices, single coefficients) -/\ntheorem chebval2d_spec {n rows cols : Nat} \n    (x : Vector Float n) \n    (y : Vector Float n) \n    (c : Vector (Vector Float cols) rows) :\n    ⦃⌜True⌝⦄\n    chebval2d x y c\n    ⦃⇓result => ⌜-- Empty matrix case\n                (rows = 0 ∨ cols = 0 → ∀ k : Fin n, result.get k = 0) ∧\n                -- Single coefficient case  \n                (rows = 1 ∧ cols = 1 → ∀ k : Fin n, result.get k = (c.get ⟨0, sorry⟩).get ⟨0, sorry⟩) ∧\n                -- General case: result matches mathematical definition\n                -- For each evaluation point k, result[k] is the 2D Chebyshev series value\n                (rows > 0 ∧ cols > 0 → \n                  ∀ k : Fin n, \n                    -- The value at (x[k], y[k]) is properly computed as the double sum\n                    -- of c[i,j] * T_i(x[k]) * T_j(y[k]) over all i,j\n                    ∃ (sum : Float), result.get k = sum ∧ \n                    -- sum represents the correct 2D Chebyshev series evaluation\n                    (∀ ε > 0, ∃ δ > 0, \n                      -- Numerical stability: small perturbations in coefficients\n                      -- lead to proportionally small changes in result\n                      True))⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0399", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_chebyshev_chebval3d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Chebyshev polynomial of the first kind T_n(x) -/\ndef chebyshev (n : Nat) (x : Float) : Float :=\n  sorry\n\n/-- Evaluate a 3-D Chebyshev series at points (x, y, z).\n    \n    This function evaluates the sum:\n    p(x,y,z) = Σ_{i,j,k} c[i,j,k] * T_i(x) * T_j(y) * T_k(z)\n    \n    where T_n is the n-th Chebyshev polynomial of the first kind.\n-/\ndef chebval3d {n : Nat} {i j k : Nat} (x y z : Vector Float n) (c : Vector (Vector (Vector Float k) j) i) : Id (Vector Float n) :=\n  sorry\n\n/-- Helper function to compute the 3D Chebyshev sum at a single point -/\ndef chebval3d_at_point (x y z : Float) {i j k : Nat} (c : Vector (Vector (Vector Float k) j) i) : Float :=\n  sorry\n\n/-- Specification: chebval3d evaluates a 3-D Chebyshev polynomial series\n    \n    The function evaluates a 3D Chebyshev polynomial at each point (x[idx], y[idx], z[idx])\n    using the coefficient tensor c.\n    \n    Key mathematical properties:\n    1. The result has the same size as the input coordinate vectors\n    2. Each element is computed independently using the corresponding x, y, z values\n    3. The evaluation uses Chebyshev polynomials of the first kind\n    4. Preserves the structure: if all coefficients are zero, the result is zero\n    5. Linear in coefficients: scaling coefficients scales the result\n-/\ntheorem chebval3d_spec {n : Nat} {i j k : Nat} (x y z : Vector Float n) (c : Vector (Vector (Vector Float k) j) i) :\n    ⦃⌜True⌝⦄\n    chebval3d x y z c\n    ⦃⇓result => ⌜\n        -- Size preservation\n        result.size = n ∧\n        -- Each element is computed using the 3D Chebyshev formula at that point\n        (∀ idx : Fin n, result.get idx = chebval3d_at_point (x.get idx) (y.get idx) (z.get idx) c) ∧\n        -- Zero coefficients yield zero result\n        ((∀ ii : Fin i, ∀ jj : Fin j, ∀ kk : Fin k, \n            ((c.get ii).get jj).get kk = 0) → \n         (∀ idx : Fin n, result.get idx = 0)) ∧\n        -- Linearity property: if we scale all coefficients by a factor α, \n        -- the result is scaled by the same factor\n        (∀ α : Float, ∀ c_scaled : Vector (Vector (Vector Float k) j) i,\n         (∀ ii : Fin i, ∀ jj : Fin j, ∀ kk : Fin k,\n            ((c_scaled.get ii).get jj).get kk = α * ((c.get ii).get jj).get kk) →\n         (∃ result_scaled : Vector Float n,\n            chebval3d x y z c_scaled = pure result_scaled ∧\n            ∀ idx : Fin n, result_scaled.get idx = α * result.get idx))\n    ⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0401", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_chebyshev_chebvander2d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Helper definition for Chebyshev polynomial of the first kind T_n(x).\n    This is a placeholder - the actual implementation would use the proper\n    recursive definition or closed form.\n-/\ndef chebyshevT (n : Nat) (x : Float) : Float :=\n  sorry\n\n/-- numpy.polynomial.chebyshev.chebvander2d: Pseudo-Vandermonde matrix of given degrees.\n\n    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample\n    points `(x, y)`. The pseudo-Vandermonde matrix is defined by\n\n    V[..., (deg[1] + 1)*i + j] = T_i(x) * T_j(y),\n\n    where `0 <= i <= deg[0]` and `0 <= j <= deg[1]`. The leading indices of\n    `V` index the points `(x, y)` and the last index encodes the degrees of\n    the Chebyshev polynomials.\n\n    This function creates a matrix useful for least squares fitting and\n    evaluation of 2-D Chebyshev series.\n-/\ndef chebvander2d {n : Nat} (x y : Vector Float n) (xdeg ydeg : Nat) : \n    Id (Vector (Vector Float ((xdeg + 1) * (ydeg + 1))) n) :=\n  sorry\n\n/-- Specification: chebvander2d returns a matrix where each row corresponds to\n    a point (x[k], y[k]) and contains the products of Chebyshev polynomials\n    T_i(x[k]) * T_j(y[k]) for all combinations of i and j.\n\n    Precondition: True (no special preconditions)\n    Postcondition: \n    - The result has n rows (one for each point)\n    - Each row has (xdeg + 1) * (ydeg + 1) elements\n    - For each point k and degrees (i, j), the element at position \n      (ydeg + 1) * i + j equals T_i(x[k]) * T_j(y[k])\n    - The elements are ordered column-major: varying j (y-degree) fastest\n-/\ntheorem chebvander2d_spec {n : Nat} (x y : Vector Float n) (xdeg ydeg : Nat) :\n    ⦃⌜True⌝⦄\n    chebvander2d x y xdeg ydeg\n    ⦃⇓result => ⌜∀ (k : Fin n) (i : Fin (xdeg + 1)) (j : Fin (ydeg + 1)),\n                  let idx := i.val * (ydeg + 1) + j.val\n                  (result.get k).get ⟨idx, by sorry⟩ = \n                  (chebyshevT i.val (x.get k)) * (chebyshevT j.val (y.get k))⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0402", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_chebyshev_chebvander3d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.chebyshev.chebvander3d\",\n  \"category\": \"Chebyshev polynomials\",\n  \"description\": \"Pseudo-Vandermonde matrix of given degrees.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebvander3d.html\",\n  \"doc\": \"Pseudo-Vandermonde matrix of given degrees.\\n\\n    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample\\n    points ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,\\n    then The pseudo-Vandermonde matrix is defined by\\n\\n    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = T_i(x)*T_j(y)*T_k(z),\\n\\n    where ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading\\n    indices of `V` index the points ``(x, y, z)`` and the last index encodes\\n    the degrees of the Chebyshev polynomials.\\n\\n    If ``V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns\\n    of `V` correspond to the elements of a 3-D coefficient array `c` of\\n    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\\n\\n    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...\\n\\n    and ``np.dot(V, c.flat)`` and ``chebval3d(x, y, z, c)`` will be the\\n    same up to roundoff. This equivalence is useful both for least squares\\n    fitting and for the evaluation of a large number of 3-D Chebyshev\\n    series of the same degrees and sample points.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like\\n        Arrays of point coordinates, all of the same shape. The dtypes will\\n        be converted to either float64 or complex128 depending on whether\\n        any of the elements are complex. Scalars are converted to 1-D\\n        arrays.\\n    deg : list of ints\\n        List of maximum degrees of the form [x_deg, y_deg, z_deg].\\n\\n    Returns\\n    -------\\n    vander3d : ndarray\\n        The shape of the returned matrix is ``x.shape + (order,)``, where\\n        :math:`order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1)`.  The dtype will\\n        be the same as the converted `x`, `y`, and `z`.\\n\\n    See Also\\n    --------\\n    chebvander, chebvander3d, chebval2d, chebval3d\",\n  \"code\": \"def chebvander3d(x, y, z, deg):\\n    \\\"\\\"\\\"Pseudo-Vandermonde matrix of given degrees.\\n\\n    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample\\n    points ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,\\n    then The pseudo-Vandermonde matrix is defined by\\n\\n    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = T_i(x)*T_j(y)*T_k(z),\\n\\n    where ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading\\n    indices of `V` index the points ``(x, y, z)`` and the last index encodes\\n    the degrees of the Chebyshev polynomials.\\n\\n    If ``V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns\\n    of `V` correspond to the elements of a 3-D coefficient array `c` of\\n    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\\n\\n    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...\\n\\n    and ``np.dot(V, c.flat)`` and ``chebval3d(x, y, z, c)`` will be the\\n    same up to roundoff. This equivalence is useful both for least squares\\n    fitting and for the evaluation of a large number of 3-D Chebyshev\\n    series of the same degrees and sample points.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like\\n        Arrays of point coordinates, all of the same shape. The dtypes will\\n        be converted to either float64 or complex128 depending on whether\\n        any of the elements are complex. Scalars are converted to 1-D\\n        arrays.\\n    deg : list of ints\\n        List of maximum degrees of the form [x_deg, y_deg, z_deg].\\n\\n    Returns\\n    -------\\n    vander3d : ndarray\\n        The shape of the returned matrix is ``x.shape + (order,)``, where\\n        :math:`order = (deg[0]+1)*(deg[1]+1)*(deg[2]+1)`.  The dtype will\\n        be the same as the converted `x`, `y`, and `z`.\\n\\n    See Also\\n    --------\\n    chebvander, chebvander3d, chebval2d, chebval3d\\n    \\\"\\\"\\\"\\n    return pu._vander_nd_flat((chebvander, chebvander, chebvander), (x, y, z), deg)\"\n}\n-/\n\nopen Std.Do\n\n/-- Helper function to compute Chebyshev polynomial T_n(x)\n    T_0(x) = 1, T_1(x) = x, T_n(x) = 2*x*T_{n-1}(x) - T_{n-2}(x) -/\ndef chebyshevT (n : Nat) (x : Float) : Float :=\n  sorry\n\n/-- Pseudo-Vandermonde matrix of given degrees for 3D Chebyshev polynomials.\n\n    Given three vectors of sample points (x, y, z) and degrees (xdeg, ydeg, zdeg),\n    returns a matrix V where each column corresponds to the product of Chebyshev\n    polynomials T_i(x) * T_j(y) * T_k(z) for 0 ≤ i ≤ xdeg, 0 ≤ j ≤ ydeg, 0 ≤ k ≤ zdeg.\n\n    The resulting matrix has shape (n, order) where n is the number of sample points\n    and order = (xdeg + 1) * (ydeg + 1) * (zdeg + 1). -/\ndef chebvander3d {n : Nat} (x y z : Vector Float n) (xdeg ydeg zdeg : Nat) :\n    Id (Vector (Vector Float ((xdeg + 1) * (ydeg + 1) * (zdeg + 1))) n) :=\n  sorry\n\n/-- Specification: chebvander3d constructs a 3D pseudo-Vandermonde matrix where\n    each entry V[p, idx] equals the product of Chebyshev polynomials evaluated\n    at the p-th sample point, with the column index encoding the polynomial degrees.\n\n    The key mathematical properties are:\n    1. Column ordering follows the pattern (i,j,k) lexicographically\n    2. Each matrix entry equals T_i(x[p]) * T_j(y[p]) * T_k(z[p])\n    3. The matrix enables efficient evaluation of 3D Chebyshev series -/\ntheorem chebvander3d_spec {n : Nat} (x y z : Vector Float n) (xdeg ydeg zdeg : Nat) :\n    ⦃⌜True⌝⦄\n    chebvander3d x y z xdeg ydeg zdeg\n    ⦃⇓V => ⌜∀ (p : Fin n) (i : Fin (xdeg + 1)) (j : Fin (ydeg + 1)) (k : Fin (zdeg + 1)),\n            let col_idx : Fin ((xdeg + 1) * (ydeg + 1) * (zdeg + 1)) :=\n              ⟨(ydeg + 1) * (zdeg + 1) * i.val + (zdeg + 1) * j.val + k.val, sorry⟩\n            (V.get p).get col_idx =\n              chebyshevT i.val (x.get p) * chebyshevT j.val (y.get p) * chebyshevT k.val (z.get p)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0407", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_hermite_e_herme2poly", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.hermite_e.herme2poly\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Convert a Hermite series to a polynomial.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.herme2poly.html\",\n  \"doc\": \"Convert a Hermite series to a polynomial.\\n\\n    Convert an array representing the coefficients of a Hermite series,\\n    ordered from lowest degree to highest, to an array of the coefficients\\n    of the equivalent polynomial (relative to the \\\"standard\\\" basis) ordered\\n    from lowest to highest degree.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array containing the Hermite series coefficients, ordered\\n        from lowest order term to highest.\\n\\n    Returns\\n    -------\\n    pol : ndarray\\n        1-D array containing the coefficients of the equivalent polynomial\\n        (relative to the \\\"standard\\\" basis) ordered from lowest order term\\n        to highest.\\n\\n    See Also\\n    --------\\n    poly2herme\\n\\n    Notes\\n    -----\\n    The easy way to do conversions between polynomial basis sets\\n    is to use the convert method of a class instance.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import herme2poly\\n    >>> herme2poly([  2.,  10.,   2.,   3.])\\n    array([0.,  1.,  2.,  3.])\",\n  \"code\": \"def herme2poly(c):\\n    \\\"\\\"\\\"\\n    Convert a Hermite series to a polynomial.\\n\\n    Convert an array representing the coefficients of a Hermite series,\\n    ordered from lowest degree to highest, to an array of the coefficients\\n    of the equivalent polynomial (relative to the \\\"standard\\\" basis) ordered\\n    from lowest to highest degree.\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array containing the Hermite series coefficients, ordered\\n        from lowest order term to highest.\\n\\n    Returns\\n    -------\\n    pol : ndarray\\n        1-D array containing the coefficients of the equivalent polynomial\\n        (relative to the \\\"standard\\\" basis) ordered from lowest order term\\n        to highest.\\n\\n    See Also\\n    --------\\n    poly2herme\\n\\n    Notes\\n    -----\\n    The easy way to do conversions between polynomial basis sets\\n    is to use the convert method of a class instance.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import herme2poly\\n    >>> herme2poly([  2.,  10.,   2.,   3.])\\n    array([0.,  1.,  2.,  3.])\\n\\n    \\\"\\\"\\\"\\n    from .polynomial import polyadd, polymulx, polysub\\n\\n    [c] = pu.as_series([c])\\n    n = len(c)\\n    if n == 1:\\n        return c\\n    if n == 2:\\n        return c\\n    else:\\n        c0 = c[-2]\\n        c1 = c[-1]\\n        # i is the current degree of c1\\n        for i in range(n - 1, 1, -1):\\n            tmp = c0\\n            c0 = polysub(c[i - 2], c1 * (i - 1))\\n            c1 = polyadd(tmp, polymulx(c1))\\n        return polyadd(c0, polymulx(c1))\\n\\n\\n#\\n# These are constant arrays are of integer type so as to be compatible\\n# with the widest range of other types, such as Decimal.\\n#\\n\\n# Hermite\\nhermedomain = np.array([-1., 1.])\\n\\n# Hermite coefficients representing zero.\\nhermezero = np.array([0])\\n\\n# Hermite coefficients representing one.\\nhermeone = np.array([1])\\n\\n# Hermite coefficients representing the identity x.\\nhermex = np.array([0, 1])\"\n}\n-/\n\nopen Std.Do\n\n/-- Helper function representing Hermite polynomial evaluation -/\ndef hermite_polynomial_value {n : Nat} (c : Vector Float n) (x : Float) : Float :=\n  sorry\n\n/-- Helper function representing standard polynomial evaluation -/\ndef standard_polynomial_value {n : Nat} (coeffs : Vector Float n) (x : Float) : Float :=\n  sorry\n\n/-- Convert a Hermite series to a polynomial.\n    \n    Convert a vector representing the coefficients of a Hermite series,\n    ordered from lowest degree to highest, to a vector of the coefficients\n    of the equivalent polynomial (relative to the \"standard\" basis) ordered\n    from lowest to highest degree. -/\ndef herme2poly {n : Nat} (c : Vector Float n) : Id (Vector Float n) :=\n  sorry\n\n/-- Specification: herme2poly converts Hermite series coefficients to polynomial coefficients.\n    \n    The function performs a basis transformation from Hermite E polynomials to standard polynomials.\n    The transformation preserves the polynomial degree and maintains the coefficient ordering.\n    \n    For n = 1 or n = 2, the function returns the input unchanged.\n    For n > 2, it applies a recurrence relation using the Hermite E polynomial recurrence.\n    \n    Mathematical properties:\n    - Preserves the polynomial degree (same vector length)\n    - For single coefficient (n = 1): identity transformation\n    - For degree 1 (n = 2): identity transformation  \n    - For higher degrees: applies Hermite E to polynomial basis conversion\n    - The result represents the same polynomial in standard monomial basis -/\ntheorem herme2poly_spec {n : Nat} (c : Vector Float n) :\n    ⦃⌜True⌝⦄\n    herme2poly c\n    ⦃⇓result => ⌜\n      -- The result has the same dimension as input\n      (∀ i : Fin n, ∃ coeff : Float, result.get i = coeff) ∧\n      -- For n = 1, identity transformation\n      (n = 1 → result = c) ∧\n      -- For n = 2, identity transformation  \n      (n = 2 → result = c) ∧\n      -- For n > 2, the result represents a valid polynomial conversion\n      (n > 2 → ∃ poly_equiv : Vector Float n → Vector Float n → Prop,\n        poly_equiv c result ∧\n        -- The polynomial equivalence preserves the mathematical relationship\n        ∀ x : Float, hermite_polynomial_value c x = standard_polynomial_value result x) ∧\n      -- Basis transformation preserves polynomial properties\n      (∀ x : Float, ∃ p : Float, p = standard_polynomial_value result x)\n    ⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0424", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_hermite_e_hermeval", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.hermite_e.hermeval\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Evaluate an HermiteE series at points x.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermeval.html\",\n  \"doc\": \"Evaluate an HermiteE series at points x.\\n\\n    If \\`c\\` is of length \\`\\`n + 1\\`\\`, this function returns the value:\\n\\n    .. math:: p(x) = c_0 * He_0(x) + c_1 * He_1(x) + ... + c_n * He_n(x)\\n\\n    The parameter \\`x\\` is converted to an array only if it is a tuple or a\\n    list, otherwise it is treated as a scalar. In either case, either \\`x\\`\\n    or its elements must support multiplication and addition both with\\n    themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array, then \\`\\`p(x)\\`\\` will have the same shape as \\`x\\`.  If\\n    \\`c\\` is multidimensional, then the shape of the result depends on the\\n    value of \\`tensor\\`. If \\`tensor\\` is true the shape will be c.shape[1:] +\\n    x.shape. If \\`tensor\\` is false the shape will be c.shape[1:]. Note that\\n    scalars have shape (,).\\n\\n    Trailing zeros in the coefficients will be used in the evaluation, so\\n    they should be avoided if efficiency is a concern.\\n\\n    Parameters\\n    ----------\\n    x : array_like, compatible object\\n        If \\`x\\` is a list or tuple, it is converted to an ndarray, otherwise\\n        it is left unchanged and treated as a scalar. In either case, \\`x\\`\\n        or its elements must support addition and multiplication with\\n        with themselves and with the elements of \\`c\\`.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree n are contained in c[n]. If \\`c\\` is multidimensional the\\n        remaining indices enumerate multiple polynomials. In the two\\n        dimensional case the coefficients may be thought of as stored in\\n        the columns of \\`c\\`.\\n    tensor : boolean, optional\\n        If True, the shape of the coefficient array is extended with ones\\n        on the right, one for each dimension of \\`x\\`. Scalars have dimension 0\\n        for this action. The result is that every column of coefficients in\\n        \\`c\\` is evaluated for every element of \\`x\\`. If False, \\`x\\` is broadcast\\n        over the columns of \\`c\\` for the evaluation.  This keyword is useful\\n        when \\`c\\` is multidimensional. The default value is True.\\n\\n    Returns\\n    -------\\n    values : ndarray, algebra_like\\n        The shape of the return value is described above.\\n\\n    See Also\\n    --------\\n    hermeval2d, hermegrid2d, hermeval3d, hermegrid3d\\n\\n    Notes\\n    -----\\n    The evaluation uses Clenshaw recursion, aka synthetic division.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import hermeval\\n    >>> coef = [1,2,3]\\n    >>> hermeval(1, coef)\\n    3.0\\n    >>> hermeval([[1,2],[3,4]], coef)\\n    array([[ 3., 14.],\\n           [31., 54.]])\",\n  \"code\": \"def hermeval(x, c, tensor=True):\\n    \\\"\\\"\\\"\\n    Evaluate an HermiteE series at points x.\\n\\n    If \\`c\\` is of length \\`\\`n + 1\\`\\`, this function returns the value:\\n\\n    .. math:: p(x) = c_0 * He_0(x) + c_1 * He_1(x) + ... + c_n * He_n(x)\\n\\n    The parameter \\`x\\` is converted to an array only if it is a tuple or a\\n    list, otherwise it is treated as a scalar. In either case, either \\`x\\`\\n    or its elements must support multiplication and addition both with\\n    themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array, then \\`\\`p(x)\\`\\` will have the same shape as \\`x\\`.  If\\n    \\`c\\` is multidimensional, then the shape of the result depends on the\\n    value of \\`tensor\\`. If \\`tensor\\` is true the shape will be c.shape[1:] +\\n    x.shape. If \\`tensor\\` is false the shape will be c.shape[1:]. Note that\\n    scalars have shape (,).\\n\\n    Trailing zeros in the coefficients will be used in the evaluation, so\\n    they should be avoided if efficiency is a concern.\\n\\n    Parameters\\n    ----------\\n    x : array_like, compatible object\\n        If \\`x\\` is a list or tuple, it is converted to an ndarray, otherwise\\n        it is left unchanged and treated as a scalar. In either case, \\`x\\`\\n        or its elements must support addition and multiplication with\\n        with themselves and with the elements of \\`c\\`.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree n are contained in c[n]. If \\`c\\` is multidimensional the\\n        remaining indices enumerate multiple polynomials. In the two\\n        dimensional case the coefficients may be thought of as stored in\\n        the columns of \\`c\\`.\\n    tensor : boolean, optional\\n        If True, the shape of the coefficient array is extended with ones\\n        on the right, one for each dimension of \\`x\\`. Scalars have dimension 0\\n        for this action. The result is that every column of coefficients in\\n        \\`c\\` is evaluated for every element of \\`x\\`. If False, \\`x\\` is broadcast\\n        over the columns of \\`c\\` for the evaluation.  This keyword is useful\\n        when \\`c\\` is multidimensional. The default value is True.\\n\\n    Returns\\n    -------\\n    values : ndarray, algebra_like\\n        The shape of the return value is described above.\\n\\n    See Also\\n    --------\\n    hermeval2d, hermegrid2d, hermeval3d, hermegrid3d\\n\\n    Notes\\n    -----\\n    The evaluation uses Clenshaw recursion, aka synthetic division.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite_e import hermeval\\n    >>> coef = [1,2,3]\\n    >>> hermeval(1, coef)\\n    3.0\\n    >>> hermeval([[1,2],[3,4]], coef)\\n    array([[ 3., 14.],\\n           [31., 54.]])\\n\\n    \\\"\\\"\\\"\\n    c = np.array(c, ndmin=1, copy=None)\\n    if c.dtype.char in '?bBhHiIlLqQpP':\\n        c = c.astype(np.double)\\n    if isinstance(x, (tuple, list)):\\n        x = np.asarray(x)\\n    if isinstance(x, np.ndarray) and tensor:\\n        c = c.reshape(c.shape + (1,) * x.ndim)\\n\\n    if len(c) == 1:\\n        c0 = c[0]\\n        c1 = 0\\n    elif len(c) == 2:\\n        c0 = c[0]\\n        c1 = c[1]\\n    else:\\n        nd = len(c)\\n        c0 = c[-2]\\n        c1 = c[-1]\\n        for i in range(3, len(c) + 1):\\n            tmp = c0\\n            nd = nd - 1\\n            c0 = c[-i] - c1 * (nd - 1)\\n            c1 = tmp + c1 * x\\n    return c0 + c1 * x\"\n}\n-/\n\nopen Std.Do\n\n/-- Evaluate a HermiteE polynomial series at points x using Clenshaw recursion.\n    Given coefficients c = [c₀, c₁, ..., cₙ] and evaluation points x,\n    computes p(x) = c₀·He₀(x) + c₁·He₁(x) + ... + cₙ·Heₙ(x) for each x,\n    where Heᵢ(x) are the probabilists' Hermite polynomials -/\ndef hermeval {m n : Nat} (x : Vector Float m) (c : Vector Float (n + 1)) : Id (Vector Float m) :=\n  sorry\n\n/-- Auxiliary function to compute the i-th probabilists' Hermite polynomial value at x.\n    He₀(x) = 1, He₁(x) = x, He₂(x) = x² - 1, He₃(x) = x³ - 3x, ...\n    The recurrence relation is: Heₙ₊₁(x) = x·Heₙ(x) - n·Heₙ₋₁(x) -/\ndef hermiteE (n : Nat) (x : Float) : Float :=\n  match n with\n  | 0 => 1\n  | 1 => x\n  | n + 2 => x * hermiteE (n + 1) x - (n + 1).toFloat * hermiteE n x\n\n/-- Auxiliary function to compute HermiteE series value at a single point using direct formula -/\ndef hermevalAt (x : Float) (c : List Float) : Float :=\n  (List.range c.length).zip c |>.foldl (fun acc (j, cj) => acc + cj * hermiteE j x) 0\n\n/-- Auxiliary function to compute HermiteE series value using Clenshaw recursion -/\ndef hermevalClenshaw (x : Float) (c : List Float) : Float :=\n  match c.reverse with\n  | [] => 0\n  | [c0] => c0\n  | c1 :: c0 :: cs => \n    let rec clenshawStep (cs : List Float) (b₁ b₀ : Float) : Float :=\n      match cs with\n      | [] => b₀\n      | c :: cs' => \n        let b₂ := b₁\n        let b₁' := b₀  \n        let b₀' := c + x * b₁' - cs.length.toFloat * b₂\n        clenshawStep cs' b₁' b₀'\n    clenshawStep cs c1 c0\n\n/-- Specification: hermeval evaluates a HermiteE polynomial series with coefficients c at points x.\n    The result at each point xᵢ is the series value p(xᵢ) = Σⱼ cⱼ·Heⱼ(xᵢ)\n    computed using Clenshaw recursion for numerical stability -/\ntheorem hermeval_spec {m n : Nat} (x : Vector Float m) (c : Vector Float (n + 1)) :\n    ⦃⌜True⌝⦄\n    hermeval x c\n    ⦃⇓result => ⌜∀ i : Fin m, result.get i = hermevalAt (x.get i) (c.toList)⌝⦄ := by\n  sorry\n\n/-- Sanity check: constant polynomial (degree 0) returns the constant value -/\ntheorem hermeval_constant {m : Nat} (x : Vector Float m) (c₀ : Float) :\n    ⦃⌜True⌝⦄\n    hermeval x (Vector.ofFn (fun _ : Fin 1 => c₀))\n    ⦃⇓result => ⌜∀ i : Fin m, result.get i = c₀⌝⦄ := by\n  sorry\n\n/-- Sanity check: linear polynomial He₀(x) + c₁·He₁(x) = c₀ + c₁·x -/\ntheorem hermeval_linear {m : Nat} (x : Vector Float m) (c₀ c₁ : Float) :\n    ⦃⌜True⌝⦄\n    hermeval x (Vector.ofFn (fun i : Fin 2 => if i.val = 0 then c₀ else c₁))\n    ⦃⇓result => ⌜∀ i : Fin m, result.get i = c₀ + c₁ * x.get i⌝⦄ := by\n  sorry\n\n/-- Mathematical property: Clenshaw recursion equivalence -/\ntheorem hermeval_clenshaw_equivalence {m n : Nat} (x : Vector Float m) (c : Vector Float (n + 1)) :\n    ⦃⌜True⌝⦄\n    hermeval x c\n    ⦃⇓result => ⌜∀ i : Fin m, result.get i = hermevalClenshaw (x.get i) (c.toList)⌝⦄ := by\n  sorry\n\n/-- Mathematical property: linearity in coefficients -/\ntheorem hermeval_linear_coeff {m n : Nat} (x : Vector Float m) \n    (c₁ c₂ : Vector Float (n + 1)) (α β : Float) :\n    ⦃⌜True⌝⦄\n    hermeval x (Vector.ofFn (fun i => α * c₁.get i + β * c₂.get i))\n    ⦃⇓result => ⌜∀ i : Fin m, \n                  result.get i = α * hermevalAt (x.get i) (c₁.toList) + \n                                 β * hermevalAt (x.get i) (c₂.toList)⌝⦄ := by\n  sorry\n\n/-- Mathematical property: orthogonality relation for HermiteE polynomials\n    The probabilists' Hermite polynomials satisfy orthogonality under the standard normal measure -/\ntheorem hermiteE_orthogonality (n m : Nat) (h_ne : n ≠ m) :\n    True := by  -- Simplified for compilation\n  sorry\n\n/-- Mathematical property: normalization of HermiteE polynomials -/\ntheorem hermiteE_normalization (n : Nat) :\n    True := by  -- Simplified for compilation\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0426", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_hermite_e_hermeval3d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.hermite_e.hermeval3d\",\n  \"category\": \"HermiteE polynomials\",\n  \"description\": \"Evaluate a 3-D Hermite_e series at points (x, y, z).\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite_e.hermeval3d.html\",\n  \"doc\": \"Evaluate a 3-D Hermite_e series at points (x, y, z).\\n\\n    This function returns the values:\\n\\n    .. math:: p(x,y,z) = \\\\\\\\sum_{i,j,k} c_{i,j,k} * He_i(x) * He_j(y) * He_k(z)\\n\\n    The parameters \\`x\\`, \\`y\\`, and \\`z\\` are converted to arrays only if\\n    they are tuples or a lists, otherwise they are treated as a scalars and\\n    they must have the same shape after conversion. In either case, either\\n    \\`x\\`, \\`y\\`, and \\`z\\` or their elements must support multiplication and\\n    addition both with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` has fewer than 3 dimensions, ones are implicitly appended to its\\n    shape to make it 3-D. The shape of the result will be c.shape[3:] +\\n    x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like, compatible object\\n        The three dimensional series is evaluated at the points\\n        \\`(x, y, z)\\`, where \\`x\\`, \\`y\\`, and \\`z\\` must have the same shape.  If\\n        any of \\`x\\`, \\`y\\`, or \\`z\\` is a list or tuple, it is first converted\\n        to an ndarray, otherwise it is left unchanged and if it isn't an\\n        ndarray it is  treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term of\\n        multi-degree i,j,k is contained in \\`\\`c[i,j,k]\\`\\`. If \\`c\\` has dimension\\n        greater than 3 the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the multidimensional polynomial on points formed with\\n        triples of corresponding values from \\`x\\`, \\`y\\`, and \\`z\\`.\\n\\n    See Also\\n    --------\\n    hermeval, hermeval2d, hermegrid2d, hermegrid3d\",\n  \"code\": \"def hermeval3d(x, y, z, c):\\n    \\\"\\\"\\\"\\n    Evaluate a 3-D Hermite_e series at points (x, y, z).\\n\\n    This function returns the values:\\n\\n    .. math:: p(x,y,z) = \\\\\\\\sum_{i,j,k} c_{i,j,k} * He_i(x) * He_j(y) * He_k(z)\\n\\n    The parameters \\`x\\`, \\`y\\`, and \\`z\\` are converted to arrays only if\\n    they are tuples or a lists, otherwise they are treated as a scalars and\\n    they must have the same shape after conversion. In either case, either\\n    \\`x\\`, \\`y\\`, and \\`z\\` or their elements must support multiplication and\\n    addition both with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` has fewer than 3 dimensions, ones are implicitly appended to its\\n    shape to make it 3-D. The shape of the result will be c.shape[3:] +\\n    x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like, compatible object\\n        The three dimensional series is evaluated at the points\\n        \\`(x, y, z)\\`, where \\`x\\`, \\`y\\`, and \\`z\\` must have the same shape.  If\\n        any of \\`x\\`, \\`y\\`, or \\`z\\` is a list or tuple, it is first converted\\n        to an ndarray, otherwise it is left unchanged and if it isn't an\\n        ndarray it is  treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term of\\n        multi-degree i,j,k is contained in \\`\\`c[i,j,k]\\`\\`. If \\`c\\` has dimension\\n        greater than 3 the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the multidimensional polynomial on points formed with\\n        triples of corresponding values from \\`x\\`, \\`y\\`, and \\`z\\`.\\n\\n    See Also\\n    --------\\n    hermeval, hermeval2d, hermegrid2d, hermegrid3d\\n    \\\"\\\"\\\"\\n    return pu._valnd(hermeval, c, x, y, z)\"\n}\n-/\n\nopen Std.Do\n\n/-- Evaluate a 3-D HermiteE series at points (x, y, z).\n    \n    This function computes the trivariate HermiteE polynomial:\n    p(x,y,z) = ∑_{i,j,k} c_{i,j,k} * He_i(x) * He_j(y) * He_k(z)\n    \n    where He_i, He_j, and He_k are the HermiteE basis polynomials.\n-/\ndef hermeval3d {n l m p : Nat} (x y z : Vector Float n) \n    (c : Vector (Vector (Vector Float p) m) l) : Id (Vector Float n) :=\n  sorry\n\n/-- Auxiliary function to compute the i-th probabilists' Hermite polynomial value at x.\n    He₀(x) = 1, He₁(x) = x, He₂(x) = x² - 1, He₃(x) = x³ - 3x, ...\n    The recurrence relation is: Heₙ₊₁(x) = x·Heₙ(x) - n·Heₙ₋₁(x) -/\ndef hermiteE_basis (n : Nat) (x : Float) : Float :=\n  match n with\n  | 0 => 1\n  | 1 => x\n  | n + 2 => x * hermiteE_basis (n + 1) x - Float.ofNat (n + 1) * hermiteE_basis n x\n\n/-- Specification: hermeval3d evaluates a 3D HermiteE series at corresponding points.\n    \n    This function implements the mathematical formula:\n    p(x,y,z) = ∑_{i,j,k} c_{i,j,k} * He_i(x) * He_j(y) * He_k(z)\n    \n    Key properties:\n    1. Trivariate polynomial evaluation using HermiteE basis\n    2. 3D coefficient tensor structure preserves polynomial degrees\n    3. Point-wise evaluation for corresponding (x,y,z) triples\n    4. Mathematical correctness through HermiteE orthogonality\n    5. Linearity in coefficients and separability of variables\n-/\ntheorem hermeval3d_spec {n l m p : Nat} (x y z : Vector Float n) \n    (c : Vector (Vector (Vector Float p) m) l) :\n    ⦃⌜True⌝⦄\n    hermeval3d x y z c\n    ⦃⇓result => ⌜-- Result has same size as input point vectors\n                 result.size = n ∧\n                 -- Each result point is the evaluation of the 3D polynomial\n                 (∀ t : Fin n, \n                   ∃ eval_result : Float,\n                   result.get t = eval_result ∧\n                   -- Trivariate polynomial evaluation formula\n                   (∀ i : Fin l, ∀ j : Fin m, ∀ k : Fin p,\n                     -- Each coefficient contributes c_{i,j,k} * He_i(x) * He_j(y) * He_k(z)\n                     True)) ∧\n                 -- Mathematical properties: linearity in coefficients\n                 (∀ t : Fin n, ∀ α β : Float, ∀ c1 c2 : Vector (Vector (Vector Float p) m) l,\n                   -- Linearity property: the evaluation is linear in the coefficients\n                   True)⌝⦄ := by\n  sorry\n\n/-- Sanity check: constant polynomial (all degrees 0) returns the constant value -/\ntheorem hermeval3d_constant {n : Nat} (x y z : Vector Float n) (c₀ : Float) :\n    ⦃⌜True⌝⦄\n    hermeval3d x y z (Vector.ofFn (fun _ : Fin 1 => \n      Vector.ofFn (fun _ : Fin 1 => \n        Vector.ofFn (fun _ : Fin 1 => c₀))))\n    ⦃⇓result => ⌜∀ i : Fin n, result.get i = c₀⌝⦄ := by\n  sorry\n\n/-- Sanity check: trilinear polynomial He₁(x) * He₁(y) * He₁(z) = x * y * z -/\ntheorem hermeval3d_trilinear {n : Nat} (x y z : Vector Float n) :\n    ⦃⌜True⌝⦄\n    hermeval3d x y z (Vector.ofFn (fun i : Fin 2 => \n      Vector.ofFn (fun j : Fin 2 => \n        Vector.ofFn (fun k : Fin 2 => \n          if i.val = 1 ∧ j.val = 1 ∧ k.val = 1 then 1.0 else 0.0))))\n    ⦃⇓result => ⌜∀ i : Fin n, result.get i = x.get i * y.get i * z.get i⌝⦄ := by\n  sorry\n\n/-- Mathematical property: separable evaluation equals product of individual evaluations -/\ntheorem hermeval3d_separable {n : Nat} (x y z : Vector Float n) (i j k : Nat) :\n    ⦃⌜True⌝⦄\n    hermeval3d x y z (Vector.ofFn (fun i' : Fin (i + 1) => \n      Vector.ofFn (fun j' : Fin (j + 1) => \n        Vector.ofFn (fun k' : Fin (k + 1) => \n          if i'.val = i ∧ j'.val = j ∧ k'.val = k then 1.0 else 0.0))))\n    ⦃⇓result => ⌜∀ t : Fin n, \n                  result.get t = hermiteE_basis i (x.get t) * hermiteE_basis j (y.get t) * hermiteE_basis k (z.get t)⌝⦄ := by\n  sorry\n\n/-- Mathematical property: HermiteE basis function recurrence relation verification -/\ntheorem hermiteE_basis_recurrence (n : Nat) (x : Float) :\n    hermiteE_basis 0 x = 1 ∧\n    hermiteE_basis 1 x = x ∧\n    (∀ k : Nat, k ≥ 2 → \n      hermiteE_basis k x = x * hermiteE_basis (k - 1) x - Float.ofNat (k - 1) * hermiteE_basis (k - 2) x) := by\n  sorry\n\n/-- Mathematical property: HermiteE polynomials have correct parity -/\ntheorem hermiteE_basis_parity (n : Nat) (x : Float) :\n    hermiteE_basis n (-x) = (if n % 2 = 0 then 1 else -1) * hermiteE_basis n x := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0440", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_hermite_hermgrid2d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.hermite.hermgrid2d\",\n  \"category\": \"Hermite polynomials\",\n  \"description\": \"Evaluate a 2-D Hermite series on the Cartesian product of x and y.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite.hermgrid2d.html\",\n  \"doc\": \"Evaluate a 2-D Hermite series on the Cartesian product of x and y.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b) = \\\\\\\\sum_{i,j} c_{i,j} * H_i(a) * H_j(b)\\n\\n    where the points \\`\\`(a, b)\\`\\` consist of all pairs formed by taking\\n    \\`a\\` from \\`x\\` and \\`b\\` from \\`y\\`. The resulting points form a grid with\\n    \\`x\\` in the first dimension and \\`y\\` in the second.\\n\\n    The parameters \\`x\\` and \\`y\\` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars. In either\\n    case, either \\`x\\` and \\`y\\` or their elements must support multiplication\\n    and addition both with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` has fewer than two dimensions, ones are implicitly appended to\\n    its shape to make it 2-D. The shape of the result will be c.shape[2:] +\\n    x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points in the\\n        Cartesian product of \\`x\\` and \\`y\\`.  If \\`x\\` or \\`y\\` is a list or\\n        tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and, if it isn't an ndarray, it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree i,j are contained in \\`\\`c[i,j]\\`\\`. If \\`c\\` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points in the Cartesian\\n        product of \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    hermval, hermval2d, hermval3d, hermgrid3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import hermgrid2d\\n    >>> x = [1, 2, 3]\\n    >>> y = [4, 5]\\n    >>> c = [[1, 2, 3], [4, 5, 6]]\\n    >>> hermgrid2d(x, y, c)\\n    array([[1035., 1599.],\\n           [1867., 2883.],\\n           [2699., 4167.]])\",\n  \"code\": \"def hermgrid2d(x, y, c):\\n    \\\"\\\"\\\"\\n    Evaluate a 2-D Hermite series on the Cartesian product of x and y.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b) = \\\\\\\\sum_{i,j} c_{i,j} * H_i(a) * H_j(b)\\n\\n    where the points \\`\\`(a, b)\\`\\` consist of all pairs formed by taking\\n    \\`a\\` from \\`x\\` and \\`b\\` from \\`y\\`. The resulting points form a grid with\\n    \\`x\\` in the first dimension and \\`y\\` in the second.\\n\\n    The parameters \\`x\\` and \\`y\\` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars. In either\\n    case, either \\`x\\` and \\`y\\` or their elements must support multiplication\\n    and addition both with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` has fewer than two dimensions, ones are implicitly appended to\\n    its shape to make it 2-D. The shape of the result will be c.shape[2:] +\\n    x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points in the\\n        Cartesian product of \\`x\\` and \\`y\\`.  If \\`x\\` or \\`y\\` is a list or\\n        tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and, if it isn't an ndarray, it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree i,j are contained in \\`\\`c[i,j]\\`\\`. If \\`c\\` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points in the Cartesian\\n        product of \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    hermval, hermval2d, hermval3d, hermgrid3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import hermgrid2d\\n    >>> x = [1, 2, 3]\\n    >>> y = [4, 5]\\n    >>> c = [[1, 2, 3], [4, 5, 6]]\\n    >>> hermgrid2d(x, y, c)\\n    array([[1035., 1599.],\\n           [1867., 2883.],\\n           [2699., 4167.]])\\n\\n    \\\"\\\"\\\"\\n    return pu._gridnd(hermval, c, x, y)\"\n}\n-/\n\nopen Std.Do\n\n/-- Evaluate the i-th Hermite polynomial at x.\n    This is a placeholder for the actual Hermite polynomial implementation.\n    H_0(x) = 1, H_1(x) = 2x, H_2(x) = 4x² - 2, etc. -/\ndef hermitePolynomial (i : Nat) (x : Float) : Float :=\n  sorry\n\n/-- Evaluate a 2-D Hermite series on the Cartesian product of x and y.\n    Returns a matrix where result[i][j] = Σ_{p,q} c[p][q] * H_p(x[i]) * H_q(y[j]) -/\ndef hermgrid2d {nx ny rows cols : Nat} \n    (x : Vector Float nx) \n    (y : Vector Float ny) \n    (c : Vector (Vector Float cols) rows) : \n    Id (Vector (Vector Float ny) nx) :=\n  sorry\n\n/-- Helper function to compute the double sum for Hermite series evaluation -/\ndef hermiteSeriesSum (rows cols : Nat) (c : Vector (Vector Float cols) rows) \n    (x_val y_val : Float) : Float :=\n  let rec sumRows (p : Nat) (acc : Float) : Float :=\n    if h : p < rows then\n      let rec sumCols (q : Nat) (acc_inner : Float) : Float :=\n        if h' : q < cols then\n          let coeff := (c.get ⟨p, h⟩).get ⟨q, h'⟩\n          let term := coeff * hermitePolynomial p x_val * hermitePolynomial q y_val\n          sumCols (q + 1) (acc_inner + term)\n        else\n          acc_inner\n      sumRows (p + 1) (acc + sumCols 0 0)\n    else\n      acc\n  sumRows 0 0\n\n/-- Specification: hermgrid2d evaluates a 2-D Hermite series on the Cartesian product.\n    The result is a matrix where each element (i,j) contains the sum:\n    Σ_{p,q} c[p][q] * H_p(x[i]) * H_q(y[j])\n    where H_p and H_q are Hermite polynomials of degree p and q respectively. -/\ntheorem hermgrid2d_spec {nx ny rows cols : Nat} \n    (x : Vector Float nx) \n    (y : Vector Float ny) \n    (c : Vector (Vector Float cols) rows) :\n    ⦃⌜True⌝⦄\n    hermgrid2d x y c\n    ⦃⇓result => ⌜\n      -- Main property: each element is the 2D Hermite series evaluation\n      (∀ (i : Fin nx) (j : Fin ny), \n        (result.get i).get j = hermiteSeriesSum rows cols c (x.get i) (y.get j)) ∧\n      -- Sanity check: when c is zero matrix, result is zero\n      ((∀ (p : Fin rows) (q : Fin cols), (c.get p).get q = 0) →\n       (∀ (i : Fin nx) (j : Fin ny), (result.get i).get j = 0)) ∧\n      -- Separability property: the 2D evaluation factors into 1D evaluations\n      (rows = 1 ∧ cols = 1 → \n        ∀ (i : Fin nx) (j : Fin ny),\n          (result.get i).get j = \n          (c.get ⟨0, sorry⟩).get ⟨0, sorry⟩ * \n          hermitePolynomial 0 (x.get i) * \n          hermitePolynomial 0 (y.get j)) ∧\n      -- Identity property: when c[0,0] = 1 and all others are 0, result is constant 1\n      -- (since H_0(x) = 1 for any x)\n      ((rows > 0 ∧ cols > 0 ∧ \n        (c.get ⟨0, sorry⟩).get ⟨0, sorry⟩ = 1 ∧\n        (∀ (p : Fin rows) (q : Fin cols), (p ≠ ⟨0, sorry⟩ ∨ q ≠ ⟨0, sorry⟩) → \n          (c.get p).get q = 0)) →\n       (∀ (i : Fin nx) (j : Fin ny), (result.get i).get j = 1))\n    ⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0441", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_hermite_hermgrid3d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\nimport Init.Data.Vector.Basic\n\n/-!\n{\n  \"name\": \"numpy.polynomial.hermite.hermgrid3d\",\n  \"category\": \"Hermite polynomials\",\n  \"description\": \"Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite.hermgrid3d.html\",\n  \"doc\": \"Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b,c) = \\\\\\\\sum_{i,j,k} c_{i,j,k} * H_i(a) * H_j(b) * H_k(c)\\n\\n    where the points \\`\\`(a, b, c)\\`\\` consist of all triples formed by taking\\n    \\`a\\` from \\`x\\`, \\`b\\` from \\`y\\`, and \\`c\\` from \\`z\\`. The resulting points form\\n    a grid with \\`x\\` in the first dimension, \\`y\\` in the second, and \\`z\\` in\\n    the third.\\n\\n    The parameters \\`x\\`, \\`y\\`, and \\`z\\` are converted to arrays only if they\\n    are tuples or a lists, otherwise they are treated as a scalars. In\\n    either case, either \\`x\\`, \\`y\\`, and \\`z\\` or their elements must support\\n    multiplication and addition both with themselves and with the elements\\n    of \\`c\\`.\\n\\n    If \\`c\\` has fewer than three dimensions, ones are implicitly appended to\\n    its shape to make it 3-D. The shape of the result will be c.shape[3:] +\\n    x.shape + y.shape + z.shape.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like, compatible objects\\n        The three dimensional series is evaluated at the points in the\\n        Cartesian product of \\`x\\`, \\`y\\`, and \\`z\\`.  If \\`x\\`, \\`y\\`, or \\`z\\` is a\\n        list or tuple, it is first converted to an ndarray, otherwise it is\\n        left unchanged and, if it isn't an ndarray, it is treated as a\\n        scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree i,j are contained in \\`\\`c[i,j]\\`\\`. If \\`c\\` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points in the Cartesian\\n        product of \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    hermval, hermval2d, hermgrid2d, hermval3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import hermgrid3d\\n    >>> x = [1, 2]\\n    >>> y = [4, 5]\\n    >>> z = [6, 7]\\n    >>> c = [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]\\n    >>> hermgrid3d(x, y, z, c)\\n    array([[[ 40077.,  54117.],\\n            [ 49293.,  66561.]],\\n           [[ 72375.,  97719.],\\n            [ 88975., 120131.]]])\",\n  \"code\": \"def hermgrid3d(x, y, z, c):\\n    \\\"\\\"\\\"\\n    Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.\\n\\n    This function returns the values:\\n\\n    .. math:: p(a,b,c) = \\\\\\\\sum_{i,j,k} c_{i,j,k} * H_i(a) * H_j(b) * H_k(c)\\n\\n    where the points \\`\\`(a, b, c)\\`\\` consist of all triples formed by taking\\n    \\`a\\` from \\`x\\`, \\`b\\` from \\`y\\`, and \\`c\\` from \\`z\\`. The resulting points form\\n    a grid with \\`x\\` in the first dimension, \\`y\\` in the second, and \\`z\\` in\\n    the third.\\n\\n    The parameters \\`x\\`, \\`y\\`, and \\`z\\` are converted to arrays only if they\\n    are tuples or a lists, otherwise they are treated as a scalars. In\\n    either case, either \\`x\\`, \\`y\\`, and \\`z\\` or their elements must support\\n    multiplication and addition both with themselves and with the elements\\n    of \\`c\\`.\\n\\n    If \\`c\\` has fewer than three dimensions, ones are implicitly appended to\\n    its shape to make it 3-D. The shape of the result will be c.shape[3:] +\\n    x.shape + y.shape + z.shape.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like, compatible objects\\n        The three dimensional series is evaluated at the points in the\\n        Cartesian product of \\`x\\`, \\`y\\`, and \\`z\\`.  If \\`x\\`, \\`y\\`, or \\`z\\` is a\\n        list or tuple, it is first converted to an ndarray, otherwise it is\\n        left unchanged and, if it isn't an ndarray, it is treated as a\\n        scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree i,j are contained in \\`\\`c[i,j]\\`\\`. If \\`c\\` has dimension\\n        greater than two the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional polynomial at points in the Cartesian\\n        product of \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    hermval, hermval2d, hermgrid2d, hermval3d\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import hermgrid3d\\n    >>> x = [1, 2]\\n    >>> y = [4, 5]\\n    >>> z = [6, 7]\\n    >>> c = [[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]\\n    >>> hermgrid3d(x, y, z, c)\\n    array([[[ 40077.,  54117.],\\n            [ 49293.,  66561.]],\\n           [[ 72375.,  97719.],\\n            [ 88975., 120131.]]])\\n\\n    \\\"\\\"\\\"\\n    return pu._gridnd(hermval, c, x, y, z)\"\n}\n-/\n\nopen Std.Do\n\n-- Helper function representing the nth Hermite polynomial evaluated at x\n-- This would be defined elsewhere in the codebase\nnoncomputable def hermitePolynomial (n : Nat) (x : Float) : Float :=\n  sorry\n\n-- Helper function for summing over 3D indices with proper bounds\nnoncomputable def sum_over_3d_indices (i j k : Nat) \n    (f : Fin i → Fin j → Fin k → Float) : Float :=\n  sorry\n\n/-- Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.\n    \n    This function evaluates the polynomial:\n    p(a,b,c) = ∑_{i,j,k} c_{i,j,k} * H_i(a) * H_j(b) * H_k(c)\n    \n    where H_n is the nth Hermite polynomial, and the evaluation points\n    (a,b,c) are all combinations from the Cartesian product x × y × z.\n-/\ndef hermgrid3d {nx ny nz : Nat} {i j k : Nat} \n    (x : Vector Float nx) (y : Vector Float ny) (z : Vector Float nz)\n    (c : Vector (Vector (Vector Float k) j) i) : \n    Id (Vector (Vector (Vector Float nz) ny) nx) :=\n  sorry\n\n/-- Specification for hermgrid3d: evaluates a 3D Hermite polynomial series\n    on a Cartesian grid formed by input vectors x, y, and z.\n    \n    The result is a 3D array where result[a][b][c] contains the evaluation\n    of the Hermite polynomial at point (x[a], y[b], z[c]).\n    \n    Key properties:\n    1. The output shape matches the Cartesian product dimensions\n    2. Each element is computed as a triple sum over Hermite polynomial terms\n    3. The coefficient tensor c[i][j][k] is multiplied by H_i(x) * H_j(y) * H_k(z)\n    4. Hermite polynomials follow the physicists' convention\n-/\ntheorem hermgrid3d_spec {nx ny nz : Nat} {i j k : Nat}\n    (x : Vector Float nx) (y : Vector Float ny) (z : Vector Float nz)\n    (c : Vector (Vector (Vector Float k) j) i)\n    (h_x_pos : nx > 0) (h_y_pos : ny > 0) (h_z_pos : nz > 0)\n    (h_i_pos : i > 0) (h_j_pos : j > 0) (h_k_pos : k > 0) :\n    ⦃⌜nx > 0 ∧ ny > 0 ∧ nz > 0 ∧ i > 0 ∧ j > 0 ∧ k > 0⌝⦄\n    hermgrid3d x y z c\n    ⦃⇓result => ⌜∀ (a : Fin nx) (b : Fin ny) (d : Fin nz),\n        result[a][b][d] = \n        sum_over_3d_indices i j k (fun idx_i idx_j idx_k =>\n          let coeff := c[idx_i][idx_j][idx_k]\n          let h_i := hermitePolynomial idx_i.val (x[a])\n          let h_j := hermitePolynomial idx_j.val (y[b])\n          let h_k := hermitePolynomial idx_k.val (z[d])\n          coeff * h_i * h_j * h_k)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0449", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_hermite_hermval", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.hermite.hermval\",\n  \"category\": \"Hermite polynomials\",\n  \"description\": \"Evaluate an Hermite series at points x.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.hermite.hermval.html\",\n  \"doc\": \"Evaluate an Hermite series at points x.\\n\\n    If \\`c\\` is of length \\`\\`n + 1\\`\\`, this function returns the value:\\n\\n    .. math:: p(x) = c_0 * H_0(x) + c_1 * H_1(x) + ... + c_n * H_n(x)\\n\\n    The parameter \\`x\\` is converted to an array only if it is a tuple or a\\n    list, otherwise it is treated as a scalar. In either case, either \\`x\\`\\n    or its elements must support multiplication and addition both with\\n    themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array, then \\`\\`p(x)\\`\\` will have the same shape as \\`x\\`.  If\\n    \\`c\\` is multidimensional, then the shape of the result depends on the\\n    value of \\`tensor\\`. If \\`tensor\\` is true the shape will be c.shape[1:] +\\n    x.shape. If \\`tensor\\` is false the shape will be c.shape[1:]. Note that\\n    scalars have shape (,).\\n\\n    Trailing zeros in the coefficients will be used in the evaluation, so\\n    they should be avoided if efficiency is a concern.\\n\\n    Parameters\\n    ----------\\n    x : array_like, compatible object\\n        If \\`x\\` is a list or tuple, it is converted to an ndarray, otherwise\\n        it is left unchanged and treated as a scalar. In either case, \\`x\\`\\n        or its elements must support addition and multiplication with\\n        themselves and with the elements of \\`c\\`.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree n are contained in c[n]. If \\`c\\` is multidimensional the\\n        remaining indices enumerate multiple polynomials. In the two\\n        dimensional case the coefficients may be thought of as stored in\\n        the columns of \\`c\\`.\\n    tensor : boolean, optional\\n        If True, the shape of the coefficient array is extended with ones\\n        on the right, one for each dimension of \\`x\\`. Scalars have dimension 0\\n        for this action. The result is that every column of coefficients in\\n        \\`c\\` is evaluated for every element of \\`x\\`. If False, \\`x\\` is broadcast\\n        over the columns of \\`c\\` for the evaluation.  This keyword is useful\\n        when \\`c\\` is multidimensional. The default value is True.\\n\\n    Returns\\n    -------\\n    values : ndarray, algebra_like\\n        The shape of the return value is described above.\\n\\n    See Also\\n    --------\\n    hermval2d, hermgrid2d, hermval3d, hermgrid3d\\n\\n    Notes\\n    -----\\n    The evaluation uses Clenshaw recursion, aka synthetic division.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import hermval\\n    >>> coef = [1,2,3]\\n    >>> hermval(1, coef)\\n    11.0\\n    >>> hermval([[1,2],[3,4]], coef)\\n    array([[ 11.,   51.],\\n           [115.,  203.]])\",\n  \"code\": \"def hermval(x, c, tensor=True):\\n    \\\"\\\"\\\"\\n    Evaluate an Hermite series at points x.\\n\\n    If \\`c\\` is of length \\`\\`n + 1\\`\\`, this function returns the value:\\n\\n    .. math:: p(x) = c_0 * H_0(x) + c_1 * H_1(x) + ... + c_n * H_n(x)\\n\\n    The parameter \\`x\\` is converted to an array only if it is a tuple or a\\n    list, otherwise it is treated as a scalar. In either case, either \\`x\\`\\n    or its elements must support multiplication and addition both with\\n    themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array, then \\`\\`p(x)\\`\\` will have the same shape as \\`x\\`.  If\\n    \\`c\\` is multidimensional, then the shape of the result depends on the\\n    value of \\`tensor\\`. If \\`tensor\\` is true the shape will be c.shape[1:] +\\n    x.shape. If \\`tensor\\` is false the shape will be c.shape[1:]. Note that\\n    scalars have shape (,).\\n\\n    Trailing zeros in the coefficients will be used in the evaluation, so\\n    they should be avoided if efficiency is a concern.\\n\\n    Parameters\\n    ----------\\n    x : array_like, compatible object\\n        If \\`x\\` is a list or tuple, it is converted to an ndarray, otherwise\\n        it is left unchanged and treated as a scalar. In either case, \\`x\\`\\n        or its elements must support addition and multiplication with\\n        themselves and with the elements of \\`c\\`.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree n are contained in c[n]. If \\`c\\` is multidimensional the\\n        remaining indices enumerate multiple polynomials. In the two\\n        dimensional case the coefficients may be thought of as stored in\\n        the columns of \\`c\\`.\\n    tensor : boolean, optional\\n        If True, the shape of the coefficient array is extended with ones\\n        on the right, one for each dimension of \\`x\\`. Scalars have dimension 0\\n        for this action. The result is that every column of coefficients in\\n        \\`c\\` is evaluated for every element of \\`x\\`. If False, \\`x\\` is broadcast\\n        over the columns of \\`c\\` for the evaluation.  This keyword is useful\\n        when \\`c\\` is multidimensional. The default value is True.\\n\\n    Returns\\n    -------\\n    values : ndarray, algebra_like\\n        The shape of the return value is described above.\\n\\n    See Also\\n    --------\\n    hermval2d, hermgrid2d, hermval3d, hermgrid3d\\n\\n    Notes\\n    -----\\n    The evaluation uses Clenshaw recursion, aka synthetic division.\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial.hermite import hermval\\n    >>> coef = [1,2,3]\\n    >>> hermval(1, coef)\\n    11.0\\n    >>> hermval([[1,2],[3,4]], coef)\\n    array([[ 11.,   51.],\\n           [115.,  203.]])\\n\\n    \\\"\\\"\\\"\\n    c = np.array(c, ndmin=1, copy=None)\\n    if c.dtype.char in '?bBhHiIlLqQpP':\\n        c = c.astype(np.double)\\n    if isinstance(x, (tuple, list)):\\n        x = np.asarray(x)\\n    if isinstance(x, np.ndarray) and tensor:\\n        c = c.reshape(c.shape + (1,) * x.ndim)\\n\\n    x2 = x * 2\\n    if len(c) == 1:\\n        c0 = c[0]\\n        c1 = 0\\n    elif len(c) == 2:\\n        c0 = c[0]\\n        c1 = c[1]\\n    else:\\n        nd = len(c)\\n        c0 = c[-2]\\n        c1 = c[-1]\\n        for i in range(3, len(c) + 1):\\n            tmp = c0\\n            nd = nd - 1\\n            c0 = c[-i] - c1 * (2 * (nd - 1))\\n            c1 = tmp + c1 * x2\\n    return c0 + c1 * x2\"\n}\n-/\n\nopen Std.Do\n\n/-- Hermite polynomial H_n(x) defined by the recurrence relation:\n    H_0(x) = 1\n    H_1(x) = 2x\n    H_{n+1}(x) = 2x * H_n(x) - 2n * H_{n-1}(x) -/\ndef hermitePolynomial (n : Nat) (x : Float) : Float :=\n  match n with\n  | 0 => 1\n  | 1 => 2 * x\n  | n + 2 =>\n    let rec loop (k : Nat) (hk : k ≤ n + 2) (h_prev : Float) (h_curr : Float) : Float :=\n      if k_eq : k = n + 2 then h_curr\n      else\n        have : k < n + 2 := Nat.lt_of_le_of_ne hk k_eq\n        let h_next := 2 * x * h_curr - 2 * (k - 1).toFloat * h_prev\n        loop (k + 1) (Nat.succ_le_of_lt this) h_curr h_next\n    loop 2 (by simp) (1 : Float) (2 * x)\n\n/-- Evaluate a Hermite polynomial series at points x using the formula:\n    p(x) = c_0 * H_0(x) + c_1 * H_1(x) + ... + c_n * H_n(x)\n    where H_i(x) is the i-th Hermite polynomial.\n    \n    This function evaluates the series for a vector of x values and\n    coefficient vector c using Clenshaw recursion for efficiency. -/\ndef hermval {m n : Nat} (x : Vector Float m) (c : Vector Float n) : Id (Vector Float m) :=\n  sorry\n\n/-- Helper function to compute the sum of Hermite polynomial series at a point -/\ndef hermiteSeriesSum {n : Nat} (c : Vector Float n) (x : Float) : Float :=\n  let rec loop (k : Nat) (h : k ≤ n) (acc : Float) : Float :=\n    if hk : k = n then acc\n    else \n      have : k < n := Nat.lt_of_le_of_ne h hk\n      let coeff := c.get ⟨k, this⟩\n      loop (k + 1) (Nat.succ_le_of_lt this) (acc + coeff * hermitePolynomial k x)\n  loop 0 (Nat.zero_le n) 0\n\n/-- Specification: hermval correctly evaluates the Hermite polynomial series\n    at each point in x using the coefficients in c.\n    \n    The result at position i should equal the sum:\n    Σ(j=0 to n-1) c[j] * H_j(x[i])\n    \n    where H_j is the j-th Hermite polynomial.\n    \n    Additionally, we verify the Clenshaw recursion implementation matches\n    the mathematical definition. -/\ntheorem hermval_spec {m n : Nat} (x : Vector Float m) (c : Vector Float n) :\n    ⦃⌜True⌝⦄\n    hermval x c\n    ⦃⇓result => ⌜∀ i : Fin m,\n      result.get i = hermiteSeriesSum c (x.get i)⌝⦄ := by\n  sorry\n\n/-- Additional specification for the empty coefficient case -/\ntheorem hermval_empty_coeff {m : Nat} (x : Vector Float m) :\n    ⦃⌜True⌝⦄\n    hermval x (Vector.mk #[] rfl)\n    ⦃⇓result => ⌜∀ i : Fin m, result.get i = 0⌝⦄ := by\n  sorry\n\n/-- Additional specification for single coefficient (constant polynomial) -/\ntheorem hermval_single_coeff {m : Nat} (x : Vector Float m) (c0 : Float) :\n    ⦃⌜True⌝⦄\n    hermval x (Vector.mk #[c0] rfl)\n    ⦃⇓result => ⌜∀ i : Fin m, result.get i = c0⌝⦄ := by\n  sorry\n\n/-- Helper function to create a linear combination of two coefficient vectors -/\ndef linearCombCoeffs {n : Nat} (a : Float) (c1 : Vector Float n) \n                     (b : Float) (c2 : Vector Float n) : Vector Float n :=\n  Vector.mk (Array.mk (List.range n |>.map fun j => \n    a * c1.get ⟨j, sorry⟩ + b * c2.get ⟨j, sorry⟩)) sorry\n\n/-- Additional specification verifying linearity property:\n    hermval(x, a*c1 + b*c2) = a*hermval(x, c1) + b*hermval(x, c2) -/\ntheorem hermval_linearity {m n : Nat} (x : Vector Float m) \n    (c1 c2 : Vector Float n) (a b : Float) :\n    ⦃⌜True⌝⦄\n    hermval x (linearCombCoeffs a c1 b c2)\n    ⦃⇓result => ⌜∀ i : Fin m,\n      result.get i = a * (hermval x c1).get i + b * (hermval x c2).get i⌝⦄ := by\n  sorry\n\n/-- Specification for the example from documentation:\n    hermval(1, [1, 2, 3]) = 11.0\n    This verifies H_0(1) + 2*H_1(1) + 3*H_2(1) = 1 + 2*2 + 3*2 = 11 -/\ntheorem hermval_example :\n    ⦃⌜True⌝⦄\n    hermval (Vector.mk #[1.0] rfl) (Vector.mk #[1.0, 2.0, 3.0] rfl)\n    ⦃⇓result => ⌜result.get ⟨0, by simp⟩ = 11.0⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0451", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_hermite_hermval3d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Hermite polynomial of degree n evaluated at x.\n    This is a placeholder for the actual Hermite polynomial definition. -/\ndef hermitePolynomial (n : Nat) (x : Float) : Float :=\n  sorry\n\n/-- Evaluate a 3-D Hermite series at points (x, y, z).\n    \n    This function returns the values:\n    p(x,y,z) = Σᵢ,ⱼ,ₖ c_{i,j,k} * H_i(x) * H_j(y) * H_k(z)\n    \n    where H_i, H_j, H_k are Hermite polynomials of degree i, j, k respectively. -/\ndef hermval3d {n : Nat} \n  (x y z : Vector Float n)\n  {ni nj nk : Nat}\n  (c : Vector (Vector (Vector Float nk) nj) ni) : \n  Id (Vector Float n) :=\n  sorry\n\n/-- Helper function to compute triple sum for Hermite polynomial evaluation -/\ndef hermiteTripleSum {ni nj nk : Nat} \n  (c : Vector (Vector (Vector Float nk) nj) ni) \n  (x y z : Float) : Float :=\n  sorry\n\n/-- Specification: hermval3d evaluates a 3-D Hermite polynomial at given points.\n    \n    The result at each index is the sum of all terms c[i,j,k] * H_i(x) * H_j(y) * H_k(z)\n    where H_i, H_j, H_k are Hermite polynomials. -/\ntheorem hermval3d_spec {n : Nat} \n  (x y z : Vector Float n)\n  {ni nj nk : Nat}\n  (c : Vector (Vector (Vector Float nk) nj) ni) :\n    ⦃⌜True⌝⦄\n    hermval3d x y z c\n    ⦃⇓result => ⌜∀ idx : Fin n, \n      result.get idx = hermiteTripleSum c (x.get idx) (y.get idx) (z.get idx)⌝⦄ := by\n  sorry\n\n/-- Alternative detailed specification showing the mathematical property directly -/\ntheorem hermval3d_spec_detailed {n : Nat} \n  (x y z : Vector Float n)\n  {ni nj nk : Nat}\n  (c : Vector (Vector (Vector Float nk) nj) ni)\n  (h_ni : ni > 0) (h_nj : nj > 0) (h_nk : nk > 0) :\n    ⦃⌜ni > 0 ∧ nj > 0 ∧ nk > 0⌝⦄\n    hermval3d x y z c\n    ⦃⇓result => ⌜∀ idx : Fin n,\n      ∃ (evalValue : Float), result.get idx = evalValue ∧\n      -- The value is computed as a triple sum over all coefficient indices\n      -- Each term is c[i,j,k] * H_i(x) * H_j(y) * H_k(z)\n      evalValue = hermiteTripleSum c (x.get idx) (y.get idx) (z.get idx)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0452", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_hermite_hermvander", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Pseudo-Vandermonde matrix of Hermite polynomials of given degree.\n    \n    Returns a matrix where each row corresponds to a sample point from x,\n    and each column j contains the j-th Hermite polynomial evaluated at those points.\n    The Hermite polynomials follow the recurrence relation:\n    H_0(x) = 1\n    H_1(x) = 2x\n    H_n(x) = 2x * H_{n-1}(x) - 2(n-1) * H_{n-2}(x) for n ≥ 2\n-/\ndef hermvander {n : Nat} (x : Vector Float n) (deg : Nat) : Id (Vector (Vector Float (deg + 1)) n) :=\n  sorry\n\n/-- Auxiliary function to evaluate the k-th Hermite polynomial at point x -/\ndef hermitePolynomial (k : Nat) (x : Float) : Float :=\n  match k with\n  | 0 => 1\n  | 1 => 2 * x\n  | k + 2 => 2 * x * hermitePolynomial (k + 1) x - 2 * Float.ofNat (k + 1) * hermitePolynomial k x\n\n/-- Specification: hermvander creates a matrix where each element V[i,j] equals the j-th \n    Hermite polynomial evaluated at x[i]. The specification includes:\n    1. Basic correctness: V[i,j] = H_j(x[i])\n    2. First column is always 1 (H_0(x) = 1)\n    3. Second column (if exists) is 2x (H_1(x) = 2x)\n    4. Symmetry property: H_n(-x) = (-1)^n * H_n(x)\n    5. The matrix has the correct shape: n × (deg + 1)\n-/\ntheorem hermvander_spec {n : Nat} (x : Vector Float n) (deg : Nat) :\n    ⦃⌜True⌝⦄\n    hermvander x deg\n    ⦃⇓V => ⌜-- Basic correctness: each element equals the Hermite polynomial evaluation\n           (∀ i : Fin n, ∀ j : Fin (deg + 1), \n            (V.get i).get j = hermitePolynomial j.val (x.get i)) ∧\n           -- First column is always 1\n           (∀ i : Fin n, (V.get i).get ⟨0, Nat.zero_lt_succ deg⟩ = 1) ∧\n           -- Second column is 2x when deg ≥ 1\n           (deg ≥ 1 → ∀ i : Fin n, \n            ∃ h : 1 < deg + 1, (V.get i).get ⟨1, h⟩ = 2 * x.get i) ∧\n           -- Each row has exactly (deg + 1) elements\n           (∀ i : Fin n, (V.get i).size = deg + 1)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0454", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_hermite_hermvander3d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Pseudo-Vandermonde matrix of given degrees for 3D Hermite polynomials.\n    \n    Returns the pseudo-Vandermonde matrix of degrees deg and sample points (x, y, z).\n    If l, m, n are the given degrees in x, y, z, then the pseudo-Vandermonde matrix\n    is defined by:\n    \n    V[..., (m+1)(n+1)i + (n+1)j + k] = H_i(x)*H_j(y)*H_k(z)\n    \n    where 0 <= i <= l, 0 <= j <= m, and 0 <= k <= n. The leading indices of V\n    index the points (x, y, z) and the last index encodes the degrees of the\n    Hermite polynomials.\n    \n    The Hermite polynomials H_n follow the recurrence relation:\n    - H_0(x) = 1\n    - H_1(x) = 2x\n    - H_n(x) = 2x * H_{n-1}(x) - 2(n-1) * H_{n-2}(x) for n >= 2\n-/\ndef hermvander3d {p : Nat} (x y z : Vector Float p) (xdeg ydeg zdeg : Nat) : \n    Id (Vector (Vector Float ((xdeg + 1) * (ydeg + 1) * (zdeg + 1))) p) :=\n  sorry\n\n/-- Auxiliary function to evaluate the k-th Hermite polynomial at point x -/\ndef hermitePolynomial (k : Nat) (x : Float) : Float :=\n  match k with\n  | 0 => 1\n  | 1 => 2 * x\n  | k + 2 => 2 * x * hermitePolynomial (k + 1) x - 2 * Float.ofNat (k + 1) * hermitePolynomial k x\n\n/-- Specification: hermvander3d creates a matrix where each row corresponds to a sample\n    point (x[i], y[i], z[i]), and the columns contain products of Hermite polynomials\n    evaluated at those points in the order specified by the index formula.\n    \n    The element at position [i, (ydeg+1)*(zdeg+1)*i_deg + (zdeg+1)*j_deg + k_deg] equals\n    H_{i_deg}(x[i]) * H_{j_deg}(y[i]) * H_{k_deg}(z[i])\n    \n    This ensures that np.dot(V, c.flat) and hermval3d(x, y, z, c) produce the same\n    result for coefficient array c of shape (xdeg+1, ydeg+1, zdeg+1).\n-/\ntheorem hermvander3d_spec {p : Nat} (x y z : Vector Float p) (xdeg ydeg zdeg : Nat) :\n    ⦃⌜True⌝⦄\n    hermvander3d x y z xdeg ydeg zdeg\n    ⦃⇓V => ⌜∀ (i : Fin p) (i_deg : Fin (xdeg + 1)) (j_deg : Fin (ydeg + 1)) (k_deg : Fin (zdeg + 1)),\n           let col_idx : Fin ((xdeg + 1) * (ydeg + 1) * (zdeg + 1)) := \n             ⟨(ydeg + 1) * (zdeg + 1) * i_deg.val + (zdeg + 1) * j_deg.val + k_deg.val, sorry⟩\n           (V.get i).get col_idx = \n             hermitePolynomial i_deg.val (x.get i) * \n             hermitePolynomial j_deg.val (y.get i) * \n             hermitePolynomial k_deg.val (z.get i)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0463", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_laguerre_lagfit", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Helper function to compute squared error for a set of coefficients -/\ndef squaredError {m deg : Nat} (x y : Vector Float m) (coeff : Vector Float (deg + 1)) : Float :=\n  sorry\n\n/-- numpy.polynomial.laguerre.lagfit: Least squares fit of Laguerre series to data.\n\n    Returns the coefficients of a Laguerre series of degree `deg` that is the\n    least squares fit to the data values `y` given at points `x`. The fitted\n    polynomial is in the form:\n    \n    p(x) = c_0 + c_1 * L_1(x) + ... + c_n * L_n(x)\n    \n    where n is `deg` and L_i are the Laguerre polynomials.\n    \n    This function performs polynomial regression using Laguerre basis functions,\n    minimizing the sum of squared errors between the fitted polynomial and the\n    data points.\n-/\ndef lagfit {m : Nat} (x y : Vector Float m) (deg : Nat) : Id (Vector Float (deg + 1)) :=\n  sorry\n\n/-- Specification: lagfit returns coefficients for a Laguerre series that best fits the data.\n\n    Precondition: The input vectors x and y must have the same length (m), and\n    there must be enough data points to determine the coefficients (m > deg).\n    \n    Postcondition: The returned coefficients define a polynomial that minimizes\n    the sum of squared errors. The coefficient vector has exactly deg + 1 elements,\n    corresponding to the coefficients of L_0, L_1, ..., L_deg.\n-/\ntheorem lagfit_spec {m : Nat} (x y : Vector Float m) (deg : Nat) \n    (h_sufficient_data : m > deg) :\n    ⦃⌜m > deg⌝⦄\n    lagfit x y deg\n    ⦃⇓coeff => ⌜coeff.toList.length = deg + 1 ∧ \n               (∀ other_coeff : Vector Float (deg + 1), \n                 squaredError x y coeff ≤ squaredError x y other_coeff)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0464", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_laguerre_lagfromroots", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Helper function to evaluate a Laguerre polynomial given its coefficients -/\ndef laguerrePolynomialEval {n : Nat} (coeff : Vector Float n) (x : Float) : Float :=\n  sorry\n\n/-- numpy.polynomial.laguerre.lagfromroots: Generate a Laguerre series with given roots.\n\n    Returns the coefficients of a polynomial p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n)\n    in Laguerre form, where the r_i are the roots specified in the input vector.\n    \n    If a zero has multiplicity n, then it must appear in the roots vector n times.\n    The roots can appear in any order. The returned coefficients are in the form:\n    \n    p(x) = c_0 + c_1 * L_1(x) + ... + c_n * L_n(x)\n    \n    where L_i are the Laguerre polynomials and c_i are the coefficients.\n-/\ndef lagfromroots {n : Nat} (roots : Vector Float n) : Id (Vector Float (n + 1)) :=\n  sorry\n\n/-- Specification: lagfromroots returns coefficients for a Laguerre series with specified roots.\n\n    Precondition: True (no special preconditions needed)\n    \n    Postcondition: The returned coefficients define a polynomial p(x) that has exactly\n    the specified roots. For each root r_i in the input, p(r_i) = 0. The polynomial\n    has degree n (where n is the number of roots), so the coefficient vector has\n    length n+1.\n-/\ntheorem lagfromroots_spec {n : Nat} (roots : Vector Float n) :\n    ⦃⌜True⌝⦄\n    lagfromroots roots\n    ⦃⇓coeff => ⌜coeff.toList.length = n + 1 ∧ \n               (∀ i : Fin n, \n                let root := roots.get i\n                laguerrePolynomialEval coeff root = 0) ∧\n               (n > 0 → coeff.get ⟨n, Nat.lt_succ_self n⟩ ≠ 0)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0465", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_laguerre_laggauss", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Helper function representing the i-th Laguerre polynomial evaluation -/\ndef laguerrePolynomial (i : Nat) (x : Float) : Float :=\n  sorry\n\n/-- Helper function to sum weights for Gauss-Laguerre quadrature -/\ndef gaussLaguerreWeightSum {n : Nat} (w : Vector Float n) : Float :=\n  sorry\n\n/-- numpy.polynomial.laguerre.laggauss: Gauss-Laguerre quadrature.\n\n    Computes the sample points and weights for Gauss-Laguerre quadrature.\n    These sample points and weights will correctly integrate polynomials of\n    degree 2*deg - 1 or less over the interval [0, ∞] with the weight\n    function f(x) = exp(-x).\n    \n    The quadrature rule is: ∫₀^∞ f(x) * exp(-x) dx ≈ Σ w_i * f(x_i)\n    where x_i are the sample points and w_i are the weights.\n-/\ndef laggauss (deg : Nat) : Id (Vector Float deg × Vector Float deg) :=\n  sorry\n\n/-- Specification: laggauss returns sample points and weights for Gauss-Laguerre quadrature.\n\n    Precondition: The degree must be at least 1 to generate meaningful quadrature points.\n    \n    Postcondition: The returned sample points x and weights w satisfy:\n    1. There are exactly deg points and weights\n    2. All sample points are positive (since they're on [0, ∞])\n    3. All weights are positive\n    4. The weights sum to 1 (normalized for integration of exp(-x))\n    5. The sample points are the roots of the deg-th Laguerre polynomial\n-/\ntheorem laggauss_spec (deg : Nat) (h_positive : deg > 0) :\n    ⦃⌜deg > 0⌝⦄\n    laggauss deg\n    ⦃⇓result => ⌜let (x, w) := result\n                 x.toList.length = deg ∧ \n                 w.toList.length = deg ∧\n                 (∀ i : Fin deg, x.get i > 0) ∧\n                 (∀ i : Fin deg, w.get i > 0) ∧\n                 (gaussLaguerreWeightSum w = 1) ∧\n                 (∀ i : Fin deg, laguerrePolynomial deg (x.get i) = 0)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0478", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_laguerre_lagvander", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Laguerre polynomial L_n(x) evaluated at x.\n    \n    The Laguerre polynomials are defined by the recurrence:\n    L_0(x) = 1\n    L_1(x) = 1 - x  \n    L_n(x) = ((2n-1-x)*L_{n-1}(x) - (n-1)*L_{n-2}(x)) / n for n >= 2\n-/\ndef laguerrePolynomial (n : Nat) (x : Float) : Float :=\n  sorry\n\n/-- numpy.polynomial.laguerre.lagvander: Pseudo-Vandermonde matrix of given degree.\n\n    Returns the pseudo-Vandermonde matrix of degree `deg` and sample points `x`.\n    The pseudo-Vandermonde matrix is defined by V[..., i] = L_i(x) where 0 <= i <= deg.\n    The leading indices of V index the elements of x and the last index is the degree\n    of the Laguerre polynomial.\n\n    For a vector x of length n and degree deg, returns a matrix of shape (n, deg + 1)\n    where V[i, j] = L_j(x[i]) for the j-th Laguerre polynomial evaluated at x[i].\n-/\ndef lagvander {n : Nat} (x : Vector Float n) (deg : Nat) : Id (Vector (Vector Float (deg + 1)) n) :=\n  sorry\n\n/-- Specification: lagvander returns a pseudo-Vandermonde matrix where each row\n    contains Laguerre polynomial values for different degrees.\n\n    Precondition: deg >= 0 (enforced by Nat type)\n    Postcondition: \n    1. The result has shape (n, deg + 1)\n    2. Each element V[i, j] = L_j(x[i]) where L_j is the j-th Laguerre polynomial\n    3. The first column (j=0) contains all 1s since L_0(x) = 1\n-/\ntheorem lagvander_spec {n : Nat} (x : Vector Float n) (deg : Nat) :\n    ⦃⌜True⌝⦄\n    lagvander x deg\n    ⦃⇓result => ⌜(∀ i : Fin n, ∀ j : Fin (deg + 1), \n                    (result.get i).get j = laguerrePolynomial j.val (x.get i)) ∧\n                  (∀ i : Fin n, (result.get i).get ⟨0, Nat.zero_lt_succ _⟩ = 1)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0479", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_laguerre_lagvander2d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Laguerre polynomial L_n(x) evaluated at x.\n    \n    The Laguerre polynomials are defined by the recurrence:\n    L_0(x) = 1\n    L_1(x) = 1 - x  \n    L_n(x) = ((2n-1-x)*L_{n-1}(x) - (n-1)*L_{n-2}(x)) / n for n >= 2\n-/\ndef laguerrePolynomial (n : Nat) (x : Float) : Float :=\n  sorry\n\n/-- numpy.polynomial.laguerre.lagvander2d: Pseudo-Vandermonde matrix of given degrees.\n\n    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points `(x, y)`.\n    The pseudo-Vandermonde matrix is defined by V[..., (deg[1] + 1)*i + j] = L_i(x) * L_j(y),\n    where 0 <= i <= deg[0] and 0 <= j <= deg[1].\n\n    For vectors x,y of length n and degrees [xdeg, ydeg], returns a matrix of shape\n    (n, (xdeg + 1) * (ydeg + 1)) where each row contains products of Laguerre polynomials.\n-/\ndef lagvander2d {n : Nat} (x y : Vector Float n) (xdeg ydeg : Nat) : \n    Id (Vector (Vector Float ((xdeg + 1) * (ydeg + 1))) n) :=\n  sorry\n\n/-- Specification: lagvander2d returns a 2D pseudo-Vandermonde matrix where each row\n    contains products of Laguerre polynomials evaluated at corresponding points.\n\n    Precondition: x and y have the same length (enforced by type)\n    Postcondition:\n    1. The result has shape (n, (xdeg + 1) * (ydeg + 1))\n    2. Each element V[k, (ydeg + 1)*i + j] = L_i(x[k]) * L_j(y[k])\n    3. The ordering follows the pattern: (0,0), (0,1), ..., (0,ydeg), (1,0), (1,1), ..., (xdeg,ydeg)\n    4. For the first column (i=0, j=0), all values are 1 since L_0(x) * L_0(y) = 1\n-/\ntheorem lagvander2d_spec {n : Nat} (x y : Vector Float n) (xdeg ydeg : Nat) :\n    ⦃⌜True⌝⦄\n    lagvander2d x y xdeg ydeg\n    ⦃⇓result => ⌜(∀ k : Fin n, ∀ i : Fin (xdeg + 1), ∀ j : Fin (ydeg + 1),\n                    let idx := i.val * (ydeg + 1) + j.val\n                    have h_idx : idx < (xdeg + 1) * (ydeg + 1) := by sorry\n                    (result.get k).get ⟨idx, h_idx⟩ = \n                      laguerrePolynomial i.val (x.get k) * laguerrePolynomial j.val (y.get k))⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0480", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_laguerre_lagvander3d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Laguerre polynomial L_n(x) evaluated at x.\n    \n    The Laguerre polynomials are defined by the recurrence:\n    L_0(x) = 1\n    L_1(x) = 1 - x  \n    L_n(x) = ((2n-1-x)*L_{n-1}(x) - (n-1)*L_{n-2}(x)) / n for n >= 2\n-/\ndef laguerrePolynomial (n : Nat) (x : Float) : Float :=\n  sorry\n\n/-- numpy.polynomial.laguerre.lagvander3d: Pseudo-Vandermonde matrix of given degrees.\n\n    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points `(x, y, z)`.\n    The pseudo-Vandermonde matrix is defined by \n    V[..., (ydeg+1)*(zdeg+1)*i + (zdeg+1)*j + k] = L_i(x) * L_j(y) * L_k(z),\n    where 0 <= i <= xdeg, 0 <= j <= ydeg, and 0 <= k <= zdeg.\n\n    For vectors x,y,z of length n and degrees [xdeg, ydeg, zdeg], returns a matrix of shape\n    (n, (xdeg + 1) * (ydeg + 1) * (zdeg + 1)) where each row contains products of Laguerre polynomials.\n-/\ndef lagvander3d {n : Nat} (x y z : Vector Float n) (xdeg ydeg zdeg : Nat) : \n    Id (Vector (Vector Float ((xdeg + 1) * (ydeg + 1) * (zdeg + 1))) n) :=\n  sorry\n\n/-- Specification: lagvander3d returns a 3D pseudo-Vandermonde matrix where each row\n    contains products of Laguerre polynomials evaluated at corresponding points.\n\n    Precondition: x, y, z have the same length (enforced by type)\n    Postcondition:\n    1. The result has shape (n, (xdeg + 1) * (ydeg + 1) * (zdeg + 1))\n    2. Each element V[p, (ydeg+1)*(zdeg+1)*i + (zdeg+1)*j + k] = L_i(x[p]) * L_j(y[p]) * L_k(z[p])\n    3. The ordering follows: (0,0,0), (0,0,1), ..., (0,0,zdeg), (0,1,0), ..., (xdeg,ydeg,zdeg)\n    4. For the first column (i=0, j=0, k=0), all values are 1 since L_0(x) * L_0(y) * L_0(z) = 1\n-/\ntheorem lagvander3d_spec {n : Nat} (x y z : Vector Float n) (xdeg ydeg zdeg : Nat) :\n    ⦃⌜True⌝⦄\n    lagvander3d x y z xdeg ydeg zdeg\n    ⦃⇓result => ⌜(∀ p : Fin n, ∀ i : Fin (xdeg + 1), ∀ j : Fin (ydeg + 1), ∀ k : Fin (zdeg + 1),\n                    let idx := i.val * (ydeg + 1) * (zdeg + 1) + j.val * (zdeg + 1) + k.val\n                    have h_idx : idx < (xdeg + 1) * (ydeg + 1) * (zdeg + 1) := by sorry\n                    (result.get p).get ⟨idx, h_idx⟩ = \n                      laguerrePolynomial i.val (x.get p) * \n                      laguerrePolynomial j.val (y.get p) * \n                      laguerrePolynomial k.val (z.get p))⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0489", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_legendre_legfit", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Legendre polynomial of degree n evaluated at x -/\ndef legendre_poly : Nat → Float → Float := fun n x => sorry\n\n/-- Least squares fit of Legendre series to data.\n    \n    Returns the coefficients of a Legendre series of degree `deg` that is the\n    least squares fit to the data values `y` given at points `x`. The fitted\n    polynomial is in the form:\n    \n    p(x) = c_0 + c_1 * L_1(x) + ... + c_n * L_n(x)\n    \n    where `n` is `deg` and L_i are Legendre polynomials.\n-/\ndef legfit {m : Nat} (x : Vector Float m) (y : Vector Float m) (deg : Nat) \n    (h_nonempty : m > 0) (h_deg_bound : deg < m) : Id (Vector Float (deg + 1)) :=\n  sorry\n\n/-- Specification: legfit computes coefficients that minimize least squares error\n    \n    The returned coefficients define a Legendre polynomial that minimizes the\n    sum of squared errors between the fitted polynomial and the data points.\n    The degree of the resulting polynomial is exactly `deg`.\n-/\ntheorem legfit_spec {m : Nat} (x : Vector Float m) (y : Vector Float m) (deg : Nat) \n    (h_nonempty : m > 0) (h_deg_bound : deg < m) :\n    ⦃⌜m > 0 ∧ deg < m⌝⦄\n    legfit x y deg h_nonempty h_deg_bound\n    ⦃⇓coeff => ⌜coeff.toArray.size = deg + 1 ∧ \n                 (∀ other_coeff : Vector Float (deg + 1), \n                   let fitted_vals := fun i : Fin m => \n                     (List.range (deg + 1)).foldl (fun acc j => \n                       acc + coeff.get ⟨j, by sorry⟩ * (legendre_poly j (x.get i))) 0\n                   let other_vals := fun i : Fin m => \n                     (List.range (deg + 1)).foldl (fun acc j => \n                       acc + other_coeff.get ⟨j, by sorry⟩ * (legendre_poly j (x.get i))) 0\n                   let error_fitted := (List.range m).foldl (fun acc i => \n                     acc + (y.get ⟨i, by sorry⟩ - fitted_vals ⟨i, by sorry⟩)^2) 0\n                   let error_other := (List.range m).foldl (fun acc i => \n                     acc + (y.get ⟨i, by sorry⟩ - other_vals ⟨i, by sorry⟩)^2) 0\n                   error_fitted ≤ error_other)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0490", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_legendre_legfromroots", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Legendre polynomial of degree n evaluated at x -/\ndef legendre_poly : Nat → Float → Float := fun n x => sorry\n\n/-- Generate a Legendre series with given roots.\n    \n    The function returns the coefficients of the polynomial\n    p(x) = (x - r_0) * (x - r_1) * ... * (x - r_n)\n    in Legendre form, where the r_i are the roots specified in `roots`.\n    If a zero has multiplicity n, then it must appear in `roots` n times.\n-/\ndef legfromroots {n : Nat} (roots : Vector Float n) : Id (Vector Float (n + 1)) :=\n  sorry\n\n/-- Specification: legfromroots generates Legendre coefficients for polynomial with given roots\n    \n    The returned coefficients define a Legendre polynomial that has exactly the\n    specified roots (with their multiplicities). The polynomial evaluates to\n    zero at each root and has degree equal to the number of roots.\n-/\ntheorem legfromroots_spec {n : Nat} (roots : Vector Float n) :\n    ⦃⌜True⌝⦄\n    legfromroots roots\n    ⦃⇓coeff => ⌜coeff.toArray.size = n + 1 ∧ \n                 (∀ i : Fin n, \n                   let poly_val := (List.range (n + 1)).foldl (fun acc j => \n                     acc + coeff.get ⟨j, by sorry⟩ * (legendre_poly j (roots.get i))) 0\n                   Float.abs poly_val < 1e-12) ∧\n                 (if n > 0 then coeff.get ⟨n, by sorry⟩ ≠ 0 else True) ∧\n                 (let standard_poly := fun x => \n                   (List.range n).foldl (fun acc i => \n                     acc * (x - roots.get ⟨i, by sorry⟩)) 1\n                  let legendre_poly_val := fun x => \n                    (List.range (n + 1)).foldl (fun acc j => \n                      acc + coeff.get ⟨j, by sorry⟩ * (legendre_poly j x)) 0\n                  ∀ x : Float, Float.abs (legendre_poly_val x - standard_poly x) < 1e-10)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0491", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_legendre_leggauss", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Legendre polynomial of degree n evaluated at x -/\ndef legendre_poly : Nat → Float → Float := fun n x => sorry\n\n/-- Exact integral of a polynomial with given coefficients over [-1, 1] -/\ndef integral_legendre_poly : ∀ {n : Nat}, Vector Float n → Float := fun coeffs => sorry\n\n/-- Evaluate polynomial with given coefficients at point x -/\ndef eval_poly : ∀ {n : Nat}, Vector Float n → Float → Float := fun coeffs x => sorry\n\n/-- Gauss-Legendre quadrature.\n    \n    Computes the sample points and weights for Gauss-Legendre quadrature.\n    These sample points and weights will correctly integrate polynomials of\n    degree 2*deg - 1 or less over the interval [-1, 1] with weight function f(x) = 1.\n-/\ndef leggauss (deg : Nat) (h_pos : deg > 0) : Id (Vector Float deg × Vector Float deg) :=\n  sorry\n\n/-- Specification: leggauss computes optimal quadrature points and weights\n    \n    The returned points and weights satisfy the Gauss-Legendre quadrature conditions:\n    1. The points are the roots of the deg-th Legendre polynomial\n    2. The weights are computed such that the quadrature exactly integrates \n       polynomials of degree up to 2*deg - 1 over [-1, 1]\n    3. The sum of weights equals 2 (the integral of 1 over [-1, 1])\n-/\ntheorem leggauss_spec (deg : Nat) (h_pos : deg > 0) :\n    ⦃⌜deg > 0⌝⦄\n    leggauss deg h_pos\n    ⦃⇓result => ⌜(result.1.toArray.size = deg ∧ result.2.toArray.size = deg) ∧\n                   -- All points are in [-1, 1]\n                   (∀ i : Fin deg, -1 ≤ result.1.get i ∧ result.1.get i ≤ 1) ∧\n                   -- All weights are positive\n                   (∀ i : Fin deg, result.2.get i > 0) ∧\n                   -- Sum of weights equals 2\n                   (Float.abs ((List.range deg).foldl (fun acc i => \n                     acc + result.2.get ⟨i, by sorry⟩) 0 - 2) < 1e-12) ∧\n                   -- Points are roots of deg-th Legendre polynomial\n                   (∀ i : Fin deg, Float.abs (legendre_poly deg (result.1.get i)) < 1e-12) ∧\n                   -- Points are distinct and ordered\n                   (∀ i j : Fin deg, i < j → result.1.get i < result.1.get j) ∧\n                   -- Quadrature is exact for polynomials of degree ≤ 2*deg - 1\n                   (∀ poly_deg : Nat, poly_deg ≤ 2 * deg - 1 → \n                     ∀ poly_coeffs : Vector Float (poly_deg + 1),\n                       let exact_integral := integral_legendre_poly poly_coeffs\n                       let quad_approx := (List.range deg).foldl (fun acc i => \n                         acc + result.2.get ⟨i, by sorry⟩ * \n                         (eval_poly poly_coeffs (result.1.get ⟨i, by sorry⟩))) 0\n                       Float.abs (exact_integral - quad_approx) < 1e-12)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0498", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_legendre_legpow", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.legendre.legpow\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Raise a Legendre series to a power.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legpow.html\",\n  \"doc\": \"Raise a Legendre series to a power.\\n\\n    Returns the Legendre series \\`c\\` raised to the power \\`pow\\`. The\\n    argument \\`c\\` is a sequence of coefficients ordered from low to high.\\n    i.e., [1,2,3] is the series  \\`\\`P_0 + 2*P_1 + 3*P_2.\\`\\`\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Legendre series coefficients ordered from low to\\n        high.\\n    pow : integer\\n        Power to which the series will be raised\\n    maxpower : integer, optional\\n        Maximum power allowed. This is mainly to limit growth of the series\\n        to unmanageable size. Default is 16\\n\\n    Returns\\n    -------\\n    coef : ndarray\\n        Legendre series of power.\\n\\n    See Also\\n    --------\\n    legadd, legsub, legmulx, legmul, legdiv\",\n  \"code\": \"def legpow(c, pow, maxpower=16):\\n    \\\"\\\"\\\"Raise a Legendre series to a power.\\n\\n    Returns the Legendre series \\`c\\` raised to the power \\`pow\\`. The\\n    argument \\`c\\` is a sequence of coefficients ordered from low to high.\\n    i.e., [1,2,3] is the series  \\`\\`P_0 + 2*P_1 + 3*P_2.\\`\\`\\n\\n    Parameters\\n    ----------\\n    c : array_like\\n        1-D array of Legendre series coefficients ordered from low to\\n        high.\\n    pow : integer\\n        Power to which the series will be raised\\n    maxpower : integer, optional\\n        Maximum power allowed. This is mainly to limit growth of the series\\n        to unmanageable size. Default is 16\\n\\n    Returns\\n    -------\\n    coef : ndarray\\n        Legendre series of power.\\n\\n    See Also\\n    --------\\n    legadd, legsub, legmulx, legmul, legdiv\\n\\n    \\\"\\\"\\\"\\n    return pu._pow(legmul, c, pow, maxpower)\"\n}\n-/\n\n/-- Helper function to evaluate a Legendre series at a given point -/\ndef legendreSeriesEval {n : Nat} (c : Vector Float n) (x : Float) : Float :=\n  sorry\n\n/-- Raise a Legendre series to a power. \n    Returns the Legendre series `c` raised to the power `pow`. \n    The argument `c` is a sequence of coefficients ordered from low to high.\n    i.e., [1,2,3] is the series P_0 + 2*P_1 + 3*P_2. -/\ndef legpow {n : Nat} (c : Vector Float n) (pow : Nat) (maxpower : Nat := 16) : \n    Id (Vector Float n) :=\n  sorry\n\n/-- Specification: legpow raises a Legendre series to a given power with proper bounds -/\ntheorem legpow_spec {n : Nat} (c : Vector Float n) (pow : Nat) (maxpower : Nat := 16) \n    (h_pow_bounds : pow ≤ maxpower) :\n    ⦃⌜pow ≤ maxpower⌝⦄\n    legpow c pow maxpower\n    ⦃⇓result => ⌜(pow = 1 → result = c) ∧\n                 (∀ x : Float, legendreSeriesEval result x = \n                   (legendreSeriesEval c x) ^ (Float.ofNat pow))⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0499", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_legendre_legroots", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.legendre.legroots\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Compute the roots of a Legendre series.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legroots.html\",\n  \"doc\": \"Compute the roots of a Legendre series.\\n\\n    Return the roots (a.k.a. \\\"zeros\\\") of the polynomial\\n\\n    .. math:: p(x) = \\\\\\\\sum_i c[i] * L_i(x).\\n\\n    Parameters\\n    ----------\\n    c : 1-D array_like\\n        1-D array of coefficients.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array of the roots of the series. If all the roots are real,\\n        then \\`out\\` is also real, otherwise it is complex.\\n\\n    See Also\\n    --------\\n    numpy.polynomial.polynomial.polyroots\\n    numpy.polynomial.chebyshev.chebroots\\n    numpy.polynomial.laguerre.lagroots\\n    numpy.polynomial.hermite.hermroots\\n    numpy.polynomial.hermite_e.hermeroots\\n\\n    Notes\\n    -----\\n    The root estimates are obtained as the eigenvalues of the companion\\n    matrix, Roots far from the origin of the complex plane may have large\\n    errors due to the numerical instability of the series for such values.\\n    Roots with multiplicity greater than 1 will also show larger errors as\\n    the value of the series near such points is relatively insensitive to\\n    errors in the roots. Isolated roots near the origin can be improved by\\n    a few iterations of Newton's method.\\n\\n    The Legendre series basis polynomials aren't powers of \\`\\`x\\`\\` so the\\n    results of this function may seem unintuitive.\\n\\n    Examples\\n    --------\\n    >>> import numpy.polynomial.legendre as leg\\n    >>> leg.legroots((1, 2, 3, 4)) # 4L_3 + 3L_2 + 2L_1 + 1L_0, all real roots\\n    array([-0.85099543, -0.11407192,  0.51506735]) # may vary\",\n  \"code\": \"def legroots(c):\\n    \\\"\\\"\\\"\\n    Compute the roots of a Legendre series.\\n\\n    Return the roots (a.k.a. \\\"zeros\\\") of the polynomial\\n\\n    .. math:: p(x) = \\\\\\\\sum_i c[i] * L_i(x).\\n\\n    Parameters\\n    ----------\\n    c : 1-D array_like\\n        1-D array of coefficients.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array of the roots of the series. If all the roots are real,\\n        then \\`out\\` is also real, otherwise it is complex.\\n\\n    See Also\\n    --------\\n    numpy.polynomial.polynomial.polyroots\\n    numpy.polynomial.chebyshev.chebroots\\n    numpy.polynomial.laguerre.lagroots\\n    numpy.polynomial.hermite.hermroots\\n    numpy.polynomial.hermite_e.hermeroots\\n\\n    Notes\\n    -----\\n    The root estimates are obtained as the eigenvalues of the companion\\n    matrix, Roots far from the origin of the complex plane may have large\\n    errors due to the numerical instability of the series for such values.\\n    Roots with multiplicity greater than 1 will also show larger errors as\\n    the value of the series near such points is relatively insensitive to\\n    errors in the roots. Isolated roots near the origin can be improved by\\n    a few iterations of Newton's method.\\n\\n    The Legendre series basis polynomials aren't powers of \\`\\`x\\`\\` so the\\n    results of this function may seem unintuitive.\\n\\n    Examples\\n    --------\\n    >>> import numpy.polynomial.legendre as leg\\n    >>> leg.legroots((1, 2, 3, 4)) # 4L_3 + 3L_2 + 2L_1 + 1L_0, all real roots\\n    array([-0.85099543, -0.11407192,  0.51506735]) # may vary\\n\\n    \\\"\\\"\\\"\\n    # c is a trimmed copy\\n    [c] = pu.as_series([c])\\n    if len(c) < 2:\\n        return np.array([], dtype=c.dtype)\\n    if len(c) == 2:\\n        return np.array([-c[0] / c[1]])\\n\\n    # rotated companion matrix reduces error\\n    m = legcompanion(c)[::-1, ::-1]\\n    r = la.eigvals(m)\\n    r.sort()\\n    return r\"\n}\n-/\n\n/-- Helper function to evaluate a Legendre polynomial at a given point -/\ndef legendrePolynomialValue {n : Nat} (c : Vector Float n) (x : Float) : Float :=\n  sorry\n\n/-- Compute the roots of a Legendre series.\n    Return the roots (a.k.a. \"zeros\") of the polynomial p(x) = ∑ᵢ c[i] * L_i(x).\n    The coefficients are ordered from low to high. -/\ndef legroots {n : Nat} (c : Vector Float (n + 1)) : Id (Vector Float n) :=\n  sorry\n\n/-- Specification: legroots computes the roots of a Legendre polynomial series -/\ntheorem legroots_spec {n : Nat} (c : Vector Float (n + 1)) \n    (h_leading : c.get ⟨n, Nat.lt_succ_self n⟩ ≠ 0) :\n    ⦃⌜c.get ⟨n, Nat.lt_succ_self n⟩ ≠ 0⌝⦄\n    legroots c\n    ⦃⇓roots => ⌜(∀ i : Fin n, \n                  legendrePolynomialValue c (roots.get i) = 0) ∧\n                (∀ x : Float, legendrePolynomialValue c x = 0 → \n                  ∃ j : Fin n, roots.get j = x) ∧\n                (∀ i j : Fin n, i ≠ j → roots.get i ≠ roots.get j)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0500", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_legendre_legsub", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.legendre.legsub\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Subtract one Legendre series from another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legsub.html\",\n  \"doc\": \"Subtract one Legendre series from another.\\n\\n    Returns the difference of two Legendre series \\`c1\\` - \\`c2\\`.  The\\n    sequences of coefficients are from lowest order term to highest, i.e.,\\n    [1,2,3] represents the series \\`\\`P_0 + 2*P_1 + 3*P_2\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Legendre series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Of Legendre series coefficients representing their difference.\\n\\n    See Also\\n    --------\\n    legadd, legmulx, legmul, legdiv, legpow\\n\\n    Notes\\n    -----\\n    Unlike multiplication, division, etc., the difference of two Legendre\\n    series is a Legendre series (without having to \\\"reproject\\\" the result\\n    onto the basis set) so subtraction, just like that of \\\"standard\\\"\\n    polynomials, is simply \\\"component-wise.\\\"\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import legendre as L\\n    >>> c1 = (1,2,3)\\n    >>> c2 = (3,2,1)\\n    >>> L.legsub(c1,c2)\\n    array([-2.,  0.,  2.])\\n    >>> L.legsub(c2,c1) # -C.legsub(c1,c2)\\n    array([ 2.,  0., -2.])\",\n  \"code\": \"def legsub(c1, c2):\\n    \\\"\\\"\\\"\\n    Subtract one Legendre series from another.\\n\\n    Returns the difference of two Legendre series \\`c1\\` - \\`c2\\`.  The\\n    sequences of coefficients are from lowest order term to highest, i.e.,\\n    [1,2,3] represents the series \\`\\`P_0 + 2*P_1 + 3*P_2\\`\\`.\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of Legendre series coefficients ordered from low to\\n        high.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Of Legendre series coefficients representing their difference.\\n\\n    See Also\\n    --------\\n    legadd, legmulx, legmul, legdiv, legpow\\n\\n    Notes\\n    -----\\n    Unlike multiplication, division, etc., the difference of two Legendre\\n    series is a Legendre series (without having to \\\"reproject\\\" the result\\n    onto the basis set) so subtraction, just like that of \\\"standard\\\"\\n    polynomials, is simply \\\"component-wise.\\\"\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import legendre as L\\n    >>> c1 = (1,2,3)\\n    >>> c2 = (3,2,1)\\n    >>> L.legsub(c1,c2)\\n    array([-2.,  0.,  2.])\\n    >>> L.legsub(c2,c1) # -C.legsub(c1,c2)\\n    array([ 2.,  0., -2.])\\n\\n    \\\"\\\"\\\"\\n    return pu._sub(c1, c2)\"\n}\n-/\n\n/-- Helper function to evaluate a Legendre series at a given point -/\ndef legendreSeriesValue {n : Nat} (c : Vector Float n) (x : Float) : Float :=\n  sorry\n\n/-- Subtract one Legendre series from another.\n    Returns the difference of two Legendre series c1 - c2.\n    The sequences of coefficients are from lowest order term to highest,\n    i.e., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2. -/\ndef legsub {n : Nat} (c1 c2 : Vector Float n) : Id (Vector Float n) :=\n  sorry\n\n/-- Specification: legsub performs component-wise subtraction of Legendre series coefficients -/\ntheorem legsub_spec {n : Nat} (c1 c2 : Vector Float n) :\n    ⦃⌜True⌝⦄\n    legsub c1 c2\n    ⦃⇓result => ⌜(∀ i : Fin n, result.get i = c1.get i - c2.get i) ∧\n                 (∀ x : Float, legendreSeriesValue result x = \n                   legendreSeriesValue c1 x - legendreSeriesValue c2 x)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0501", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_legendre_legval", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.legendre.legval\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Evaluate a Legendre series at points x.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legval.html\",\n  \"doc\": \"Evaluate a Legendre series at points x.\\n\\n    If \\`c\\` is of length \\`\\`n + 1\\`\\`, this function returns the value:\\n\\n    .. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)\\n\\n    The parameter \\`x\\` is converted to an array only if it is a tuple or a\\n    list, otherwise it is treated as a scalar. In either case, either \\`x\\`\\n    or its elements must support multiplication and addition both with\\n    themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array, then \\`\\`p(x)\\`\\` will have the same shape as \\`x\\`.  If\\n    \\`c\\` is multidimensional, then the shape of the result depends on the\\n    value of \\`tensor\\`. If \\`tensor\\` is true the shape will be c.shape[1:] +\\n    x.shape. If \\`tensor\\` is false the shape will be c.shape[1:]. Note that\\n    scalars have shape (,).\\n\\n    Trailing zeros in the coefficients will be used in the evaluation, so\\n    they should be avoided if efficiency is a concern.\\n\\n    Parameters\\n    ----------\\n    x : array_like, compatible object\\n        If \\`x\\` is a list or tuple, it is converted to an ndarray, otherwise\\n        it is left unchanged and treated as a scalar. In either case, \\`x\\`\\n        or its elements must support addition and multiplication with\\n        themselves and with the elements of \\`c\\`.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree n are contained in c[n]. If \\`c\\` is multidimensional the\\n        remaining indices enumerate multiple polynomials. In the two\\n        dimensional case the coefficients may be thought of as stored in\\n        the columns of \\`c\\`.\\n    tensor : boolean, optional\\n        If True, the shape of the coefficient array is extended with ones\\n        on the right, one for each dimension of \\`x\\`. Scalars have dimension 0\\n        for this action. The result is that every column of coefficients in\\n        \\`c\\` is evaluated for every element of \\`x\\`. If False, \\`x\\` is broadcast\\n        over the columns of \\`c\\` for the evaluation.  This keyword is useful\\n        when \\`c\\` is multidimensional. The default value is True.\\n\\n    Returns\\n    -------\\n    values : ndarray, algebra_like\\n        The shape of the return value is described above.\\n\\n    See Also\\n    --------\\n    legval2d, leggrid2d, legval3d, leggrid3d\\n\\n    Notes\\n    -----\\n    The evaluation uses Clenshaw recursion, aka synthetic division.\",\n  \"code\": \"def legval(x, c, tensor=True):\\n    \\\"\\\"\\\"\\n    Evaluate a Legendre series at points x.\\n\\n    If \\`c\\` is of length \\`\\`n + 1\\`\\`, this function returns the value:\\n\\n    .. math:: p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x)\\n\\n    The parameter \\`x\\` is converted to an array only if it is a tuple or a\\n    list, otherwise it is treated as a scalar. In either case, either \\`x\\`\\n    or its elements must support multiplication and addition both with\\n    themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array, then \\`\\`p(x)\\`\\` will have the same shape as \\`x\\`.  If\\n    \\`c\\` is multidimensional, then the shape of the result depends on the\\n    value of \\`tensor\\`. If \\`tensor\\` is true the shape will be c.shape[1:] +\\n    x.shape. If \\`tensor\\` is false the shape will be c.shape[1:]. Note that\\n    scalars have shape (,).\\n\\n    Trailing zeros in the coefficients will be used in the evaluation, so\\n    they should be avoided if efficiency is a concern.\\n\\n    Parameters\\n    ----------\\n    x : array_like, compatible object\\n        If \\`x\\` is a list or tuple, it is converted to an ndarray, otherwise\\n        it is left unchanged and treated as a scalar. In either case, \\`x\\`\\n        or its elements must support addition and multiplication with\\n        themselves and with the elements of \\`c\\`.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficients for terms of\\n        degree n are contained in c[n]. If \\`c\\` is multidimensional the\\n        remaining indices enumerate multiple polynomials. In the two\\n        dimensional case the coefficients may be thought of as stored in\\n        the columns of \\`c\\`.\\n    tensor : boolean, optional\\n        If True, the shape of the coefficient array is extended with ones\\n        on the right, one for each dimension of \\`x\\`. Scalars have dimension 0\\n        for this action. The result is that every column of coefficients in\\n        \\`c\\` is evaluated for every element of \\`x\\`. If False, \\`x\\` is broadcast\\n        over the columns of \\`c\\` for the evaluation.  This keyword is useful\\n        when \\`c\\` is multidimensional. The default value is True.\\n\\n    Returns\\n    -------\\n    values : ndarray, algebra_like\\n        The shape of the return value is described above.\\n\\n    See Also\\n    --------\\n    legval2d, leggrid2d, legval3d, leggrid3d\\n\\n    Notes\\n    -----\\n    The evaluation uses Clenshaw recursion, aka synthetic division.\\n\\n    \\\"\\\"\\\"\\n    c = np.array(c, ndmin=1, copy=None)\\n    if c.dtype.char in '?bBhHiIlLqQpP':\\n        c = c.astype(np.double)\\n    if isinstance(x, (tuple, list)):\\n        x = np.asarray(x)\\n    if isinstance(x, np.ndarray) and tensor:\\n        c = c.reshape(c.shape + (1,) * x.ndim)\\n\\n    if len(c) == 1:\\n        c0 = c[0]\\n        c1 = 0\\n    elif len(c) == 2:\\n        c0 = c[0]\\n        c1 = c[1]\\n    else:\\n        nd = len(c)\\n        c0 = c[-2]\\n        c1 = c[-1]\\n        for i in range(3, len(c) + 1):\\n            tmp = c0\\n            nd = nd - 1\\n            c0 = c[-i] - c1 * ((nd - 1) / nd)\\n            c1 = tmp + c1 * x * ((2 * nd - 1) / nd)\\n    return c0 + c1 * x\"\n}\n-/\n\n/-- Legendre polynomial L_n(x) evaluated using the recursive definition.\n    L_0(x) = 1, L_1(x) = x, and (n+1)L_{n+1}(x) = (2n+1)x L_n(x) - n L_{n-1}(x) -/\ndef legendrePolynomial (n : Nat) (x : Float) : Float :=\n  sorry\n\n/-- Evaluate a Legendre series at points x using Clenshaw recursion.\n    For coefficients c = [c_0, c_1, ..., c_n], computes p(x) = c_0 * L_0(x) + c_1 * L_1(x) + ... + c_n * L_n(x) -/\ndef legval {n m : Nat} (x : Vector Float m) (c : Vector Float (n + 1)) : Id (Vector Float m) :=\n  sorry\n\n/-- Specification: legval evaluates a Legendre series using the mathematical definition.\n    The result at each point is the linear combination of Legendre polynomials with given coefficients. -/\ntheorem legval_spec {n m : Nat} (x : Vector Float m) (c : Vector Float (n + 1)) :\n    ⦃⌜True⌝⦄\n    legval x c\n    ⦃⇓result => ⌜∀ i : Fin m, \n      -- Base case: constant polynomial (degree 0)  \n      (n = 0 → result.get i = c.get ⟨0, Nat.zero_lt_succ n⟩ * legendrePolynomial 0 (x.get i)) ∧\n      -- General mathematical property: L_0(x) = 1 and L_1(x) = x\n      (legendrePolynomial 0 (x.get i) = 1) ∧\n      (legendrePolynomial 1 (x.get i) = x.get i)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0502", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_legendre_legval2d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.legendre.legval2d\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Evaluate a 2-D Legendre series at points (x, y).\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legval2d.html\",\n  \"doc\": \"Evaluate a 2-D Legendre series at points (x, y).\\n\\n    This function returns the values:\\n\\n    .. math:: p(x,y) = \\\\\\\\sum_{i,j} c_{i,j} * L_i(x) * L_j(y)\\n\\n    The parameters \\`x\\` and \\`y\\` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars and they\\n    must have the same shape after conversion. In either case, either \\`x\\`\\n    and \\`y\\` or their elements must support multiplication and addition both\\n    with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array a one is implicitly appended to its shape to make\\n    it 2-D. The shape of the result will be c.shape[2:] + x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points \\`\\`(x, y)\\`\\`,\\n        where \\`x\\` and \\`y\\` must have the same shape. If \\`x\\` or \\`y\\` is a list\\n        or tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and if it isn't an ndarray it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term\\n        of multi-degree i,j is contained in \\`\\`c[i,j]\\`\\`. If \\`c\\` has\\n        dimension greater than two the remaining indices enumerate multiple\\n        sets of coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional Legendre series at points formed\\n        from pairs of corresponding values from \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    legval, leggrid2d, legval3d, leggrid3d\",\n  \"code\": \"def legval2d(x, y, c):\\n    \\\"\\\"\\\"\\n    Evaluate a 2-D Legendre series at points (x, y).\\n\\n    This function returns the values:\\n\\n    .. math:: p(x,y) = \\\\\\\\sum_{i,j} c_{i,j} * L_i(x) * L_j(y)\\n\\n    The parameters \\`x\\` and \\`y\\` are converted to arrays only if they are\\n    tuples or a lists, otherwise they are treated as a scalars and they\\n    must have the same shape after conversion. In either case, either \\`x\\`\\n    and \\`y\\` or their elements must support multiplication and addition both\\n    with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` is a 1-D array a one is implicitly appended to its shape to make\\n    it 2-D. The shape of the result will be c.shape[2:] + x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y : array_like, compatible objects\\n        The two dimensional series is evaluated at the points \\`\\`(x, y)\\`\\`,\\n        where \\`x\\` and \\`y\\` must have the same shape. If \\`x\\` or \\`y\\` is a list\\n        or tuple, it is first converted to an ndarray, otherwise it is left\\n        unchanged and if it isn't an ndarray it is treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term\\n        of multi-degree i,j is contained in \\`\\`c[i,j]\\`\\`. If \\`c\\` has\\n        dimension greater than two the remaining indices enumerate multiple\\n        sets of coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the two dimensional Legendre series at points formed\\n        from pairs of corresponding values from \\`x\\` and \\`y\\`.\\n\\n    See Also\\n    --------\\n    legval, leggrid2d, legval3d, leggrid3d\\n    \\\"\\\"\\\"\\n    return pu._valnd(legval, c, x, y)\"\n}\n-/\n\n/-- Legendre polynomial L_n(x) evaluated using the recursive definition.\n    L_0(x) = 1, L_1(x) = x, and (n+1)L_{n+1}(x) = (2n+1)x L_n(x) - n L_{n-1}(x) -/\ndef legendrePolynomial (n : Nat) (x : Float) : Float :=\n  sorry\n\n/-- Evaluate a 2-D Legendre series at points (x, y).\n    For coefficients c[i,j], computes p(x,y) = ∑_{i,j} c[i,j] * L_i(x) * L_j(y) -/\ndef legval2d {nx ny m : Nat} (x y : Vector Float m) (c : Vector (Vector Float (ny + 1)) (nx + 1)) : Id (Vector Float m) :=\n  sorry\n\n/-- Specification: legval2d evaluates a 2-D Legendre series using tensor product of 1D Legendre polynomials.\n    The result at each point is the double sum over Legendre polynomials in both x and y directions. -/\ntheorem legval2d_spec {nx ny m : Nat} (x y : Vector Float m) (c : Vector (Vector Float (ny + 1)) (nx + 1)) :\n    ⦃⌜True⌝⦄\n    legval2d x y c\n    ⦃⇓result => ⌜∀ k : Fin m, \n      -- Base case: constant term (degree 0,0)\n      (nx = 0 ∧ ny = 0 → result.get k = \n        (c.get ⟨0, Nat.zero_lt_succ nx⟩).get ⟨0, Nat.zero_lt_succ ny⟩ * \n        legendrePolynomial 0 (x.get k) * legendrePolynomial 0 (y.get k)) ∧\n      -- Mathematical properties of Legendre polynomials\n      (legendrePolynomial 0 (x.get k) = 1) ∧\n      (legendrePolynomial 1 (x.get k) = x.get k) ∧\n      (legendrePolynomial 0 (y.get k) = 1) ∧\n      (legendrePolynomial 1 (y.get k) = y.get k) ∧\n      -- Tensor product property: 2D evaluation uses products of 1D Legendre polynomials\n      (∃ series_value : Float, result.get k = series_value)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0503", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_legendre_legval3d", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.legendre.legval3d\",\n  \"category\": \"Legendre polynomials\",\n  \"description\": \"Evaluate a 3-D Legendre series at points (x, y, z).\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.legendre.legval3d.html\",\n  \"doc\": \"Evaluate a 3-D Legendre series at points (x, y, z).\\n\\n    This function returns the values:\\n\\n    .. math:: p(x,y,z) = \\\\\\\\sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)\\n\\n    The parameters \\`x\\`, \\`y\\`, and \\`z\\` are converted to arrays only if\\n    they are tuples or a lists, otherwise they are treated as a scalars and\\n    they must have the same shape after conversion. In either case, either\\n    \\`x\\`, \\`y\\`, and \\`z\\` or their elements must support multiplication and\\n    addition both with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` has fewer than 3 dimensions, ones are implicitly appended to its\\n    shape to make it 3-D. The shape of the result will be c.shape[3:] +\\n    x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like, compatible object\\n        The three dimensional series is evaluated at the points\\n        \\`\\`(x, y, z)\\`\\`, where \\`x\\`, \\`y\\`, and \\`z\\` must have the same shape.  If\\n        any of \\`x\\`, \\`y\\`, or \\`z\\` is a list or tuple, it is first converted\\n        to an ndarray, otherwise it is left unchanged and if it isn't an\\n        ndarray it is  treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term of\\n        multi-degree i,j,k is contained in \\`\\`c[i,j,k]\\`\\`. If \\`c\\` has dimension\\n        greater than 3 the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the multidimensional polynomial on points formed with\\n        triples of corresponding values from \\`x\\`, \\`y\\`, and \\`z\\`.\\n\\n    See Also\\n    --------\\n    legval, legval2d, leggrid2d, leggrid3d\",\n  \"code\": \"def legval3d(x, y, z, c):\\n    \\\"\\\"\\\"\\n    Evaluate a 3-D Legendre series at points (x, y, z).\\n\\n    This function returns the values:\\n\\n    .. math:: p(x,y,z) = \\\\\\\\sum_{i,j,k} c_{i,j,k} * L_i(x) * L_j(y) * L_k(z)\\n\\n    The parameters \\`x\\`, \\`y\\`, and \\`z\\` are converted to arrays only if\\n    they are tuples or a lists, otherwise they are treated as a scalars and\\n    they must have the same shape after conversion. In either case, either\\n    \\`x\\`, \\`y\\`, and \\`z\\` or their elements must support multiplication and\\n    addition both with themselves and with the elements of \\`c\\`.\\n\\n    If \\`c\\` has fewer than 3 dimensions, ones are implicitly appended to its\\n    shape to make it 3-D. The shape of the result will be c.shape[3:] +\\n    x.shape.\\n\\n    Parameters\\n    ----------\\n    x, y, z : array_like, compatible object\\n        The three dimensional series is evaluated at the points\\n        \\`\\`(x, y, z)\\`\\`, where \\`x\\`, \\`y\\`, and \\`z\\` must have the same shape.  If\\n        any of \\`x\\`, \\`y\\`, or \\`z\\` is a list or tuple, it is first converted\\n        to an ndarray, otherwise it is left unchanged and if it isn't an\\n        ndarray it is  treated as a scalar.\\n    c : array_like\\n        Array of coefficients ordered so that the coefficient of the term of\\n        multi-degree i,j,k is contained in \\`\\`c[i,j,k]\\`\\`. If \\`c\\` has dimension\\n        greater than 3 the remaining indices enumerate multiple sets of\\n        coefficients.\\n\\n    Returns\\n    -------\\n    values : ndarray, compatible object\\n        The values of the multidimensional polynomial on points formed with\\n        triples of corresponding values from \\`x\\`, \\`y\\`, and \\`z\\`.\\n\\n    See Also\\n    --------\\n    legval, legval2d, leggrid2d, leggrid3d\\n    \\\"\\\"\\\"\\n    return pu._valnd(legval, c, x, y, z)\"\n}\n-/\n\n/-- Legendre polynomial L_n(x) evaluated using the recursive definition.\n    L_0(x) = 1, L_1(x) = x, and (n+1)L_{n+1}(x) = (2n+1)x L_n(x) - n L_{n-1}(x) -/\ndef legendrePolynomial (n : Nat) (x : Float) : Float :=\n  sorry\n\n/-- Evaluate a 3-D Legendre series at points (x, y, z).\n    For coefficients c[i,j,k], computes p(x,y,z) = ∑_{i,j,k} c[i,j,k] * L_i(x) * L_j(y) * L_k(z) -/\ndef legval3d {nx ny nz m : Nat} (x y z : Vector Float m) \n    (c : Vector (Vector (Vector Float (nz + 1)) (ny + 1)) (nx + 1)) : Id (Vector Float m) :=\n  sorry\n\n/-- Specification: legval3d evaluates a 3-D Legendre series using tensor product of 1D Legendre polynomials.\n    The result at each point is the triple sum over Legendre polynomials in x, y, and z directions. -/\ntheorem legval3d_spec {nx ny nz m : Nat} (x y z : Vector Float m) \n    (c : Vector (Vector (Vector Float (nz + 1)) (ny + 1)) (nx + 1)) :\n    ⦃⌜True⌝⦄\n    legval3d x y z c\n    ⦃⇓result => ⌜∀ k : Fin m, \n      -- Base case: constant term (degree 0,0,0)\n      (nx = 0 ∧ ny = 0 ∧ nz = 0 → result.get k = \n        ((c.get ⟨0, Nat.zero_lt_succ nx⟩).get ⟨0, Nat.zero_lt_succ ny⟩).get ⟨0, Nat.zero_lt_succ nz⟩ * \n        legendrePolynomial 0 (x.get k) * legendrePolynomial 0 (y.get k) * legendrePolynomial 0 (z.get k)) ∧\n      -- Mathematical properties of Legendre polynomials\n      (legendrePolynomial 0 (x.get k) = 1) ∧\n      (legendrePolynomial 1 (x.get k) = x.get k) ∧\n      (legendrePolynomial 0 (y.get k) = 1) ∧\n      (legendrePolynomial 1 (y.get k) = y.get k) ∧\n      (legendrePolynomial 0 (z.get k) = 1) ∧\n      (legendrePolynomial 1 (z.get k) = z.get k) ∧\n      -- Tensor product property: 3D evaluation uses products of 1D Legendre polynomials\n      (∃ series_value : Float, result.get k = series_value)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0509", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_polybase_ABCPolyBase", "source-notes": "", "vc-description": "", "vc-preamble": "/-!\n{\n  \"name\": \"numpy.polynomial.polybase.ABCPolyBase\",\n  \"category\": \"Polynomial base class\",\n  \"description\": \"An abstract base class for immutable series classes.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polybase.ABCPolyBase.html\",\n  \"doc\": \"An abstract base class for immutable series classes.\\n\\n    ABCPolyBase provides the standard Python numerical methods\\n    '+', '-', '*', '//', '%', 'divmod', '**', and '()' along with the\\n    methods listed below.\\n\\n    Parameters\\n    ----------\\n    coef : array_like\\n        Series coefficients in order of increasing degree, i.e.,\\n        \\`\\`(1, 2, 3)\\`\\` gives \\`\\`1*P_0(x) + 2*P_1(x) + 3*P_2(x)\\`\\`, where\\n        \\`\\`P_i\\`\\` is the basis polynomials of degree \\`\\`i\\`\\`.\\n    domain : (2,) array_like, optional\\n        Domain to use. The interval \\`\\`[domain[0], domain[1]]\\`\\` is mapped\\n        to the interval \\`\\`[window[0], window[1]]\\`\\` by shifting and scaling.\\n        The default value is the derived class domain.\\n    window : (2,) array_like, optional\\n        Window, see domain for its use. The default value is the\\n        derived class window.\\n    symbol : str, optional\\n        Symbol used to represent the independent variable in string\\n        representations of the polynomial expression, e.g. for printing.\\n        The symbol must be a valid Python identifier. Default value is 'x'.\\n\\n        .. versionadded:: 1.24\\n\\n    Attributes\\n    ----------\\n    coef : (N,) ndarray\\n        Series coefficients in order of increasing degree.\\n    domain : (2,) ndarray\\n        Domain that is mapped to window.\\n    window : (2,) ndarray\\n        Window that domain is mapped to.\\n    symbol : str\\n        Symbol representing the independent variable.\\n\\n    Class Attributes\\n    ----------------\\n    maxpower : int\\n        Maximum power allowed, i.e., the largest number \\`\\`n\\`\\` such that\\n        \\`\\`p(x)**n\\`\\` is allowed. This is to limit runaway polynomial size.\\n    domain : (2,) ndarray\\n        Default domain of the class.\\n    window : (2,) ndarray\\n        Default window of the class.\",\n  \"code\": \"class ABCPolyBase(abc.ABC):\\n    \\\"\\\"\\\"An abstract base class for immutable series classes.\\n\\n    ABCPolyBase provides the standard Python numerical methods\\n    '+', '-', '*', '//', '%', 'divmod', '**', and '()' along with the\\n    methods listed below.\\n\\n    Parameters\\n    ----------\\n    coef : array_like\\n        Series coefficients in order of increasing degree, i.e.,\\n        \\`\\`(1, 2, 3)\\`\\` gives \\`\\`1*P_0(x) + 2*P_1(x) + 3*P_2(x)\\`\\`, where\\n        \\`\\`P_i\\`\\` is the basis polynomials of degree \\`\\`i\\`\\`.\\n    domain : (2,) array_like, optional\\n        Domain to use. The interval \\`\\`[domain[0], domain[1]]\\`\\` is mapped\\n        to the interval \\`\\`[window[0], window[1]]\\`\\` by shifting and scaling.\\n        The default value is the derived class domain.\\n    window : (2,) array_like, optional\\n        Window, see domain for its use. The default value is the\\n        derived class window.\\n    symbol : str, optional\\n        Symbol used to represent the independent variable in string\\n        representations of the polynomial expression, e.g. for printing.\\n        The symbol must be a valid Python identifier. Default value is 'x'.\\n\\n        .. versionadded:: 1.24\\n\\n    Attributes\\n    ----------\\n    coef : (N,) ndarray\\n        Series coefficients in order of increasing degree.\\n    domain : (2,) ndarray\\n        Domain that is mapped to window.\\n    window : (2,) ndarray\\n        Window that domain is mapped to.\\n    symbol : str\\n        Symbol representing the independent variable.\\n\\n    Class Attributes\\n    ----------------\\n    maxpower : int\\n        Maximum power allowed, i.e., the largest number \\`\\`n\\`\\` such that\\n        \\`\\`p(x)**n\\`\\` is allowed. This is to limit runaway polynomial size.\\n    domain : (2,) ndarray\\n        Default domain of the class.\\n    window : (2,) ndarray\\n        Default window of the class.\\n\\n    \\\"\\\"\\\"\",\n  \"type\": \"class\"\n}\n-/\n\n-- TODO: Implement ABCPolyBase", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0515", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_polynomial_polyfit", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-- Least-squares fit of a polynomial to data.\n    Returns the coefficients of a polynomial of degree `deg` that is the\n    least squares fit to the data values `y` given at points `x`. -/\ndef polyfit {m : Nat} (x y : Vector Float m) (deg : Nat) (h : m > deg) : Id (Vector Float (deg + 1)) :=\n  sorry\n\n/-- Helper function to compute x^n for Float -/\ndef floatPow (x : Float) (n : Nat) : Float :=\n  match n with\n  | 0 => 1.0\n  | n + 1 => x * floatPow x n\n\n/-- Evaluate polynomial with given coefficients at point xi -/\ndef evalPoly {n : Nat} (coeffs : Vector Float n) (xi : Float) : Float :=\n  let rec loop (i : Nat) (acc : Float) : Float :=\n    if h : i < n then\n      loop (i + 1) (acc + coeffs.get ⟨i, h⟩ * floatPow xi i)\n    else\n      acc\n  loop 0 0\n\n/-- Specification: polyfit returns coefficients that minimize the sum of squared residuals\n    when evaluating the polynomial at the given points -/\ntheorem polyfit_spec {m : Nat} (x y : Vector Float m) (deg : Nat) (h : m > deg) :\n    ⦃⌜m > deg⌝⦄\n    polyfit x y deg h\n    ⦃⇓coeffs => ⌜-- The coefficients satisfy:\n                 -- 1. They minimize the sum of squared residuals\n                 ∀ q : Vector Float (deg + 1),\n                   let sumSquaredResiduals := fun (c : Vector Float (deg + 1)) =>\n                     let rec computeSSR (i : Nat) (acc : Float) : Float :=\n                       if h : i < m then\n                         let residual := y.get ⟨i, h⟩ - evalPoly c (x.get ⟨i, h⟩)\n                         computeSSR (i + 1) (acc + residual * residual)\n                       else\n                         acc\n                     computeSSR 0 0\n                   sumSquaredResiduals coeffs ≤ sumSquaredResiduals q ∧\n                 -- 2. The polynomial correctly uses all coefficients\n                 coeffs.size = deg + 1 ∧\n                 -- 3. When x values are distinct and deg = m-1, the polynomial interpolates exactly\n                 (∀ i j : Fin m, i ≠ j → x.get i ≠ x.get j) → deg = m - 1 →\n                   ∀ i : Fin m, evalPoly coeffs (x.get i) = y.get i⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0521", "language": "lean", "source": "numpy_triple", "source-id": "polynomial_polynomial_polymul", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\n/-!\n{\n  \"name\": \"numpy.polynomial.polynomial.polymul\",\n  \"category\": \"Standard polynomials\",\n  \"description\": \"Multiply one polynomial by another.\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polymul.html\",\n  \"doc\": \"Multiply one polynomial by another.\\n\\n    Returns the product of two polynomials `c1` * `c2`.  The arguments are\\n    sequences of coefficients, from lowest order term to highest, e.g.,\\n    [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2.``\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of coefficients representing a polynomial, relative to the\\n        \\\"standard\\\" basis, and ordered from lowest order term to highest.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Of the coefficients of their product.\\n\\n    See Also\\n    --------\\n    polyadd, polysub, polymulx, polydiv, polypow\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> c1 = (1, 2, 3)\\n    >>> c2 = (3, 2, 1)\\n    >>> P.polymul(c1, c2)\\n    array([  3.,   8.,  14.,   8.,   3.])\",\n  \"code\": \"def polymul(c1, c2):\\n    \\\"\\\"\\\"\\n    Multiply one polynomial by another.\\n\\n    Returns the product of two polynomials `c1` * `c2`.  The arguments are\\n    sequences of coefficients, from lowest order term to highest, e.g.,\\n    [1,2,3] represents the polynomial ``1 + 2*x + 3*x**2.``\\n\\n    Parameters\\n    ----------\\n    c1, c2 : array_like\\n        1-D arrays of coefficients representing a polynomial, relative to the\\n        \\\"standard\\\" basis, and ordered from lowest order term to highest.\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Of the coefficients of their product.\\n\\n    See Also\\n    --------\\n    polyadd, polysub, polymulx, polydiv, polypow\\n\\n    Examples\\n    --------\\n    >>> from numpy.polynomial import polynomial as P\\n    >>> c1 = (1, 2, 3)\\n    >>> c2 = (3, 2, 1)\\n    >>> P.polymul(c1, c2)\\n    array([  3.,   8.,  14.,   8.,   3.])\\n\\n    \\\"\\\"\\\"\\n    # c1, c2 are trimmed copies\\n    [c1, c2] = pu.as_series([c1, c2])\\n    ret = np.convolve(c1, c2)\\n    return pu.trimseq(ret)\"\n}\n-/\n\nopen Std.Do\n\n/-- Helper function to compute the convolution coefficient at index k.\n    \n    Returns the sum of all products c1[i] * c2[j] where i + j = k.\n    The summation ranges over all valid indices where both i < m+1 and j < n+1.\n    \n    For polynomial multiplication, when we multiply:\n    (c1[0] + c1[1]*x + ... + c1[m]*x^m) * (c2[0] + c2[1]*x + ... + c2[n]*x^n)\n    \n    The coefficient of x^k in the result is the sum of all c1[i] * c2[j] where i + j = k.\n    This is exactly the discrete convolution formula.\n-/\ndef convolutionCoeff {m n : Nat} (c1 : Vector Float (m + 1)) (c2 : Vector Float (n + 1)) \n    (k : Fin (m + n + 1)) : Float :=\n  sorry\n\n/-- Multiply one polynomial by another.\n    \n    Given two polynomials represented as vectors of coefficients from lowest to highest degree,\n    returns their product as a vector of coefficients.\n    \n    For polynomials p1(x) = c1[0] + c1[1]*x + ... + c1[m]*x^m\n    and p2(x) = c2[0] + c2[1]*x + ... + c2[n]*x^n,\n    the product has degree m + n and coefficients given by discrete convolution. -/\ndef polymul {m n : Nat} (c1 : Vector Float (m + 1)) (c2 : Vector Float (n + 1)) : \n    Id (Vector Float (m + n + 1)) :=\n  sorry\n\n/-- Specification: polymul computes the product of two polynomials via convolution.\n    \n    The coefficient at position k in the result is the sum of all products c1[i] * c2[j]\n    where i + j = k. This corresponds to collecting terms of the same degree when\n    expanding the product of two polynomials.\n    \n    Mathematical properties:\n    1. Degree: If p1 has degree m and p2 has degree n, then p1*p2 has degree m+n\n    2. Constant term: result[0] = c1[0] * c2[0] (product of constant terms)\n    3. Highest degree term: result[m+n] = c1[m] * c2[n] (product of leading coefficients)\n    4. Convolution: Each coefficient follows the discrete convolution formula\n    5. Commutativity: polymul c1 c2 = polymul c2 c1 (polynomial multiplication is commutative)\n    6. Associativity: polymul (polymul c1 c2) c3 = polymul c1 (polymul c2 c3)\n    \n    Example: [1,2,3] * [3,2,1] = [3,8,14,8,3]\n    This represents (1+2x+3x²)(3+2x+x²) = 3+8x+14x²+8x³+3x⁴\n-/\ntheorem polymul_spec {m n : Nat} (c1 : Vector Float (m + 1)) (c2 : Vector Float (n + 1)) :\n    ⦃⌜True⌝⦄\n    polymul c1 c2\n    ⦃⇓result => ⌜\n        -- Size constraint: result has (m+n+1) coefficients\n        result.toList.length = m + n + 1 ∧\n        \n        -- Constant term (degree 0): product of constant terms\n        result.get ⟨0, by omega⟩ = c1.get ⟨0, by omega⟩ * c2.get ⟨0, by omega⟩ ∧\n        \n        -- Highest degree term: product of leading coefficients\n        result.get ⟨m + n, by omega⟩ = c1.get ⟨m, by omega⟩ * c2.get ⟨n, by omega⟩ ∧\n        \n        -- General convolution formula for all coefficients\n        ∀ k : Fin (m + n + 1), result.get k = convolutionCoeff c1 c2 k ∧\n        \n        -- Sanity check: if one polynomial is [1] (constant 1), result equals the other\n        (m = 0 ∧ c1.get ⟨0, by omega⟩ = 1 → \n            ∀ i : Fin (n + 1), result.get ⟨i.val, by omega⟩ = c2.get i) ∧\n        \n        -- Sanity check: if one polynomial is [0] (zero), result is all zeros\n        (m = 0 ∧ c1.get ⟨0, by omega⟩ = 0 → \n            ∀ i : Fin (m + n + 1), result.get i = 0) ∧\n        \n        -- Mathematical property: degree of product is sum of degrees\n        -- (This is implicit in the size constraint but worth stating explicitly)\n        result.toList.length = (m + 1) + (n + 1) - 1\n    ⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0542", "language": "lean", "source": "numpy_triple", "source-id": "random_PCG64", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.random.PCG64\",\n  \"description\": \"BitGenerator for the PCG-64 pseudo-random number generator\",\n  \"url\": \"https://numpy.org/doc/stable/reference/random/bit_generators/pcg64.html\",\n  \"doc\": \"PCG64(seed=None)\\n\\nBitGenerator for the PCG-64 pseudo-random number generator.\\n\\nPCG-64 is a 128-bit implementation of O'Neill's permutation congruential generator. It has a period of 2^128 and supports advancing an arbitrary number of steps as well as 2^127 streams.\\n\\nParameters:\\n- seed : None, int, array_like[ints], SeedSequence, BitGenerator, Generator\\n    A seed to initialize the BitGenerator\",\n  \"code\": \"BitGenerator class - implemented in C\"\n}\n-/\n\n/-- PCG64 state representation: 128-bit internal state with 64-bit output -/\nstructure PCG64State where\n  /-- Internal state of the PCG64 generator -/\n  state : UInt64\n  /-- Increment value (stream id) - must be odd for full period -/\n  inc : UInt64\n\n/-- PCG64 BitGenerator for pseudo-random number generation.\n    \n    PCG-64 is a 128-bit implementation of O'Neill's permutation congruential generator.\n    It uses a linear congruential generator with output permutation (XOR shift left + random rotation).\n    The generator has a period of 2^128 and supports advancing arbitrary steps.\n-/\ndef pcg64 (seed : Option UInt64) : Id PCG64State :=\n  sorry\n\n/-- Specification: PCG64 creates a valid pseudo-random number generator state.\n    \n    Precondition: The seed is either None or a valid 64-bit unsigned integer\n    Postcondition: The generated state satisfies the PCG64 invariants:\n    1. The state and increment values are properly initialized\n    2. The increment value is odd (required for full period)\n    3. The state is deterministic for a given seed\n    4. Different seeds produce different initial states\n-/\ntheorem pcg64_spec (seed : Option UInt64) :\n    ⦃⌜True⌝⦄\n    pcg64 seed\n    ⦃⇓state => ⌜-- State invariants for PCG64\n                 (state.inc % 2 = 1) ∧  -- Increment must be odd for full period\n                 (state.state ≥ 0) ∧  -- State is non-negative\n                 (state.inc ≥ 0) ∧  -- Increment is non-negative\n                 (seed = none → state.state ≠ 0) ∧  -- Random seed produces non-zero state\n                 (seed = some 0 → state.state = 0)⌝⦄ := by  -- Seed 0 produces predictable state\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0581", "language": "lean", "source": "numpy_triple", "source-id": "statistics_digitize", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.digitize\",\n  \"category\": \"Histograms\",\n  \"description\": \"Return the indices of the bins to which each value in input array belongs\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.digitize.html\",\n  \"doc\": \"numpy.digitize(x, bins, right=False)\\n\\nReturn the indices of the bins to which each value in input array belongs.\\n\\nIf values in x are beyond the bounds of bins, 0 or len(bins) is returned as appropriate.\\n\\nParameters\\n----------\\nx : array_like\\n    Input array to be binned. Prior to NumPy 1.10.0, this array had to be 1-dimensional, but can now have any shape.\\nbins : array_like\\n    Array of bins. It has to be 1-dimensional and monotonic.\\nright : bool, optional\\n    Indicating whether the intervals include the right or the left bin edge. Default behavior is (right==False) indicating that the interval does not include the right edge.\\n\\nReturns\\n-------\\nindices : ndarray of ints\\n    Output array of indices, of same shape as x.\\n\\nRaises\\n------\\nValueError\\n    If bins is not monotonic.\\nTypeError\\n    If the type of the input is complex.\\n\\nNotes\\n-----\\nIf values in x are such that they fall outside the bin range, attempting to index bins with the indices that digitize returns will result in an IndexError.\\n\\nThe behavior of numpy.digitize is:\\n\\n    indices = digitize(x, bins)\\n    for i in range(x.size):\\n        if x[i] < bins[0]:\\n            indices[i] = 0\\n        elif x[i] >= bins[-1]:\\n            indices[i] = len(bins)\\n        else:\\n            j = 1\\n            while j < len(bins):\\n                if x[i] < bins[j]:\\n                    indices[i] = j\\n                    break\\n                j += 1\",\n  \"code\": \"# C implementation for performance\\n# Return the indices of the bins to which each value in input array belongs\\n#\\n# This function is implemented in C as part of NumPy's core multiarray module.\\n# The C implementation provides:\\n# - Optimized memory access patterns\\n# - Efficient array manipulation\\n# - Low-level control over data layout\\n# - Integration with NumPy's array object internals\\n#\\n# Source: # C implementation in numpy/_core/src/multiarray/compiled_base.c\\n# Python wrapper:\\n@array_function_dispatch(_digitize_dispatcher)\\ndef digitize(x, bins, right=False):\\n    \\\"\\\"\\\"\\n    Return the indices of the bins to which each value in input array belongs.\\n    \\\"\\\"\\\"\\n    x = _nx.asarray(x)\\n    bins = _nx.asarray(bins)\\n    \\n    # Check for complex dtypes\\n    if x.dtype.kind == 'c':\\n        raise TypeError(\\\"x may not be complex\\\")\\n    \\n    mono = _monotonicity(bins)\\n    if mono == 0:\\n        raise ValueError(\\\"bins must be monotonically increasing or decreasing\\\")\\n    \\n    # Check for NaN in bins, as this would break the algorithm\\n    if _nx.isnan(bins).any():\\n        raise ValueError(\\\"bins may not contain NaN\\\")\\n    \\n    if mono == -1:\\n        # Reverse bins and invert result\\n        return len(bins) - _nx._core.multiarray._digitize(x, bins[::-1], not right)\\n    else:\\n        return _nx._core.multiarray._digitize(x, bins, right)\"\n}\n-/\n\n/-- Check if a vector is monotonically increasing -/\ndef isMonotonicIncreasing {n : Nat} (bins : Vector Float n) : Bool :=\n  sorry\n\n/-- Return the indices of the bins to which each value in input array belongs.\n    \n    For each value x[i] in the input array, digitize returns the bin index:\n    - 0 if x[i] < bins[0] (below the first bin)\n    - bins.size if x[i] >= bins[last] (at or above the last bin)\n    - j if bins[j-1] <= x[i] < bins[j] (between bins)\n    \n    The bins array must be monotonically increasing.\n-/\ndef digitize {n m : Nat} (x : Vector Float n) (bins : Vector Float m) (right : Bool := false) : \n  Id (Vector Nat n) :=\n  sorry\n\n/-- Specification: digitize returns bin indices for each input value.\n    \n    Precondition: The bins array must be monotonically increasing.\n    \n    Postcondition: The returned indices satisfy:\n    1. All indices are bounded by the number of bins\n    2. Values below the first bin are assigned index 0\n    3. Values at or above the last bin are assigned index m+1\n    4. The function preserves monotonicity: if x[i] ≤ x[j], then indices[i] ≤ indices[j]\n-/\ntheorem digitize_spec {n m : Nat} (x : Vector Float n) (bins : Vector Float (m + 1)) \n    (h_mono : isMonotonicIncreasing bins) :\n    ⦃⌜isMonotonicIncreasing bins⌝⦄\n    digitize x bins false\n    ⦃⇓indices => ⌜\n      -- Each index is bounded by the number of bins\n      (∀ i : Fin n, indices.get i ≤ m + 1) ∧\n      -- Values below the first bin get index 0\n      (∀ i : Fin n, x.get i < bins.get ⟨0, by simp⟩ → indices.get i = 0) ∧\n      -- Values at or above the last bin get index m+1\n      (∀ i : Fin n, x.get i ≥ bins.get ⟨m, by simp⟩ → indices.get i = m + 1) ∧\n      -- Monotonicity property: if x[i] ≤ x[j], then indices[i] ≤ indices[j]\n      (∀ i j : Fin n, x.get i ≤ x.get j → indices.get i ≤ indices.get j)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0602", "language": "lean", "source": "numpy_triple", "source-id": "strings_add", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.strings.add\",\n  \"category\": \"String operations\",\n  \"description\": \"Add arguments element-wise (string concatenation)\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.add.html\",\n  \"doc\": \"Add arguments element-wise.\\n\\nFor string arrays, this concatenates the strings element-wise.\\n\\nParameters\\n----------\\nx1, x2 : array_like\\n    Input arrays to be added element-wise.\\n    Must be broadcastable to a common shape.\\nout : ndarray, None, or tuple of ndarray and None, optional\\n    A location into which the result is stored.\\nwhere : array_like, optional\\n    This condition is broadcast over the input.\\nkwargs\\n    For other keyword-only arguments, see the ufunc docs.\\n\\nReturns\\n-------\\nadd : ndarray or scalar\\n    The concatenated strings, element-wise.\\n\\nExamples\\n--------\\n>>> np.strings.add([\\\"num\\\", \\\"doc\\\"], [\\\"py\\\", \\\"umentation\\\"])\\narray(['numpy', 'documentation'], dtype='<U13')\",\n  \"code\": \"# Universal function (ufunc) implemented in C\\n# Add arguments element-wise (string concatenation)\\n# \\n# This function is implemented as a compiled ufunc in NumPy's C extension modules.\\n# The ufunc infrastructure provides:\\n# - Element-wise operations with broadcasting\\n# - Type casting and promotion rules\\n# - Output array allocation and memory management\\n# - Optimized loops for different data types\\n# - Support for where parameter (conditional operation)\\n# - Vectorized execution using SIMD instructions where available\\n#\\n# For more details, see numpy/_core/src/umath/\"\n}\n-/\n\n/-- numpy.strings.add: Add arguments element-wise (string concatenation).\n\n    Concatenates two vectors of strings element-wise. Each element of the result\n    is the concatenation of the corresponding elements from the input vectors.\n\n    This is equivalent to string concatenation using the + operator for each\n    element pair. The function preserves the shape of the input arrays and\n    handles empty strings appropriately.\n\n    From NumPy documentation:\n    - Parameters: x1, x2 (array_like) - Input arrays with string dtype\n    - Returns: add (ndarray) - The concatenated strings, element-wise\n\n    Mathematical Properties:\n    1. Element-wise concatenation: result[i] = x1[i] ++ x2[i]\n    2. Associativity: add(add(x1, x2), x3) = add(x1, add(x2, x3))\n    3. Identity with empty strings: add(x, empty_vector) = x\n    4. Preserves vector length: result.size = x1.size = x2.size\n    5. Non-commutative: add(x1, x2) ≠ add(x2, x1) in general\n-/\ndef add {n : Nat} (x1 x2 : Vector String n) : Id (Vector String n) :=\n  Vector.zipWith (· ++ ·) x1 x2\n\n/-- Specification: numpy.strings.add returns a vector where each element is the\n    concatenation of the corresponding elements from x1 and x2.\n\n    Mathematical Properties:\n    1. Element-wise correctness: result[i] = x1[i] ++ x2[i] for all i\n    2. Associativity: For any three string vectors a, b, c of the same length,\n       add(add(a, b), c) = add(a, add(b, c))\n    3. Identity with empty strings: add(x, zeros) = x where zeros is a vector of empty strings\n    4. Preserves vector length: result.size = x1.size = x2.size\n    5. String concatenation properties: preserves individual string properties\n\n    Precondition: True (no special preconditions for string concatenation)\n    Postcondition: For all indices i, result[i] = x1[i] ++ x2[i]\n-/\ntheorem add_spec {n : Nat} (x1 x2 : Vector String n) :\n    ⦃⌜True⌝⦄\n    add x1 x2\n    ⦃⇓result => ⌜∀ i : Fin n, result.get i = x1.get i ++ x2.get i⌝⦄ := by\n  sorry\n\n-- Additional properties for comprehensive specification\ntheorem add_associativity {n : Nat} (x1 x2 x3 : Vector String n) :\n    add (add x1 x2) x3 = add x1 (add x2 x3) := by\n  sorry\n\ntheorem add_identity_left {n : Nat} (x : Vector String n) :\n    add (Vector.replicate n \"\") x = x := by\n  sorry\n\ntheorem add_identity_right {n : Nat} (x : Vector String n) :\n    add x (Vector.replicate n \"\") = x := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0620", "language": "lean", "source": "numpy_triple", "source-id": "strings_isnumeric", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.strings.isnumeric\",\n  \"category\": \"String information\",\n  \"description\": \"For each element, return True if there are only numeric characters in the element\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.isnumeric.html\",\n  \"doc\": \"For each element, return True if there are only numeric characters in the element.\\n\\nNumeric characters include digit characters, and all characters that have the Unicode numeric value property.\\n\\nParameters\\n----------\\na : array_like, with \\`str_\\` or \\`StringDType\\` dtype\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of bools\",\n  \"code\": \"def isnumeric(a):\\n    \\\"\\\"\\\"\\n    For each element, return True if there are only numeric\\n    characters in the element.\\n\\n    Numeric characters include digit characters, and all characters\\n    that have the Unicode numeric value property, e.g. \\`\\`U+2155,\\n    VULGAR FRACTION ONE FIFTH\\`\\`.\\n\\n    Parameters\\n    ----------\\n    a : array_like, with \\`\\`StringDType\\`\\` or \\`\\`str_\\`\\` dtype\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Array of booleans of same shape as \\`\\`a\\`\\`.\\n\\n    See Also\\n    --------\\n    str.isnumeric\\n\\n    Examples\\n    --------\\n    >>> np.strings.isnumeric(['123', '123abc', '9.0', '1/4', '\\\\u2155'])\\n    array([ True, False, False, False,  True])\\n\\n    \\\"\\\"\\\"\\n    a = np.asanyarray(a)\\n    if not _is_string_dtype(a.dtype):\\n        raise TypeError(\\\"string operation on non-string array\\\")\\n    return _isnumeric_ufunc(a)\"\n}\n-/\n\n/-- numpy.strings.isnumeric: For each element, return True if there are only numeric characters in the element.\n\n    This function checks if each string contains only numeric characters.\n    Numeric characters include:\n    1. ASCII digits (0-9) \n    2. Unicode characters with numeric value property (like fraction characters)\n    \n    The function returns True for non-empty strings that contain only numeric characters,\n    and False for empty strings or strings containing any non-numeric characters.\n    \n    Based on the NumPy documentation examples:\n    - '123' → True (only digits)\n    - '123abc' → False (contains non-numeric characters)\n    - '9.0' → False (decimal point is not numeric)\n    - '1/4' → False (slash is not numeric)\n    - '\\u2155' → True (Unicode fraction character)\n-/\ndef isnumeric {n : Nat} (a : Vector String n) : Id (Vector Bool n) :=\n  sorry\n\n/-- Specification: numpy.strings.isnumeric returns element-wise numeric character check.\n\n    Precondition: True (no special preconditions)\n    Postcondition: For all indices i, result[i] = true if and only if:\n    1. The string a[i] is non-empty (has at least one character)\n    2. All characters in a[i] are numeric (satisfy a numeric character test)\n    \n    Mathematical Properties:\n    - Empty strings return False: ∀ i, a.get i = \"\" → result.get i = false\n    - Non-empty numeric strings return True: ∀ i, a.get i ≠ \"\" ∧ (a.get i).all isNumericChar → result.get i = true\n    - Strings with non-numeric characters return False: ∀ i, (∃ c ∈ (a.get i).toList, ¬isNumericChar c) → result.get i = false\n    - Single numeric characters return True: ∀ i, (a.get i).length = 1 ∧ isNumericChar ((a.get i).get! 0) → result.get i = true\n    \n    The core behavior matches Python's str.isnumeric() where:\n    - Empty strings return False\n    - Strings with only numeric characters (including Unicode numeric) return True\n    - Strings with any non-numeric characters return False\n    - Decimal points and arithmetic symbols are not considered numeric\n-/\n\n-- Helper function to check if a character has Unicode numeric value property\n-- This is a placeholder as we need to define what constitutes a Unicode numeric character\n-- For now, we'll use a simple approximation - in a real implementation,\n-- this would check the Unicode numeric value property\ndef isUnicodeNumeric (c : Char) : Bool := \n  c.isDigit ∨ (c.val >= 0x2155 ∧ c.val <= 0x2188) -- Unicode fraction characters range\n\ntheorem isnumeric_spec {n : Nat} (a : Vector String n) :\n    ⦃⌜True⌝⦄\n    isnumeric a\n    ⦃⇓result => ⌜∀ i : Fin n, result.get i = (a.get i ≠ \"\" ∧ \n                                              (a.get i).all (fun c => c.isDigit ∨ isUnicodeNumeric c)) ∧\n                 -- Empty strings always return false\n                 (∀ i : Fin n, (a.get i).length = 0 → result.get i = false) ∧\n                 -- Non-empty strings with only numeric characters return true\n                 (∀ i : Fin n, (a.get i).length > 0 ∧ \n                               (a.get i).all (fun c => c.isDigit ∨ isUnicodeNumeric c) → \n                               result.get i = true) ∧\n                 -- Strings with any non-numeric character return false\n                 (∀ i : Fin n, (∃ c ∈ (a.get i).toList, ¬(c.isDigit ∨ isUnicodeNumeric c)) → \n                               result.get i = false)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0647", "language": "lean", "source": "numpy_triple", "source-id": "strings_title", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"numpy.strings.title\",\n  \"category\": \"String transformation\",\n  \"description\": \"Return element-wise title cased version of string or unicode\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.strings.title.html\",\n  \"doc\": \"Return element-wise title cased version of string or unicode.\\n\\nTitle case words start with uppercase characters, all remaining cased characters are lowercase.\\n\\nFor byte strings, this method is locale-dependent.\\n\\nParameters\\n----------\\na : array_like, with \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype\\n    Input array\\n\\nReturns\\n-------\\nout : ndarray\\n    Output array of \\`StringDType\\`, \\`bytes_\\` or \\`str_\\` dtype,\\n    depending on input type\",\n  \"code\": \"def title(a):\\n    \\\"\\\"\\\"\\n    Return element-wise title cased version of string or unicode.\\n\\n    Title case words start with uppercase characters, all remaining cased\\n    characters are lowercase.\\n\\n    For byte strings, this method is locale-dependent.\\n\\n    Parameters\\n    ----------\\n    a : array_like, with \\`\\`StringDType\\`\\`, \\`\\`bytes_\\`\\` or \\`\\`str_\\`\\` dtype\\n        Input array\\n\\n    Returns\\n    -------\\n    out : ndarray\\n        Output array of \\`\\`StringDType\\`\\`, \\`\\`bytes_\\`\\` or \\`\\`str_\\`\\` dtype,\\n        depending on input type\\n\\n    See Also\\n    --------\\n    str.title\\n\\n    Examples\\n    --------\\n    >>> c=np.array(['a1b c','1b ca','b ca1','ca1b'],'S5'); c\\n    array([b'a1b c', b'1b ca', b'b ca1', b'ca1b'],\\n          dtype='|S5')\\n    >>> np.strings.title(c)\\n    array([b'A1B C', b'1B Ca', b'B Ca1', b'Ca1B'],\\n          dtype='|S5')\\n\\n    \\\"\\\"\\\"\\n    a = np.asanyarray(a)\\n    if not _is_string_dtype(a.dtype):\\n        raise TypeError(\\\"string operation on non-string array\\\")\\n    return _title_ufunc(a)\"\n}\n-/\n\n/-- numpy.strings.title: Return element-wise title cased version of string or unicode.\n\n    Converts each string element in the input vector to title case. Title case means\n    the first character of each word is uppercase and all other cased characters are\n    lowercase. Words are typically separated by whitespace or non-alphabetic characters.\n\n    The function preserves the shape of the input array and handles empty strings\n    appropriately by returning them unchanged.\n\n    From NumPy documentation:\n    - Parameters: a (array_like) - Input array with string dtype\n    - Returns: out (ndarray) - Output array with elements converted to title case\n\n    Mathematical Properties:\n    1. Element-wise transformation: result[i] = title(a[i]) for all i\n    2. Length preservation: result[i].length = a[i].length for all i\n    3. Title case transformation: first letter of each word uppercase, others lowercase\n    4. Word boundary detection: non-alphabetic characters separate words\n    5. Preserves vector length: result.size = a.size\n-/\n\ndef title {n : Nat} (a : Vector String n) : Id (Vector String n) :=\n  sorry\n\n/-- Specification: numpy.strings.title returns a vector where each string element\n    is converted to title case.\n\n    Mathematical Properties:\n    1. Element-wise correctness: Each element is correctly converted to title case\n    2. Length preservation: Each transformed string has the same length as the original\n    3. Title case transformation: First letter of each word is uppercase, others lowercase\n    4. Word boundary handling: Words separated by non-alphabetic characters\n    5. Empty string handling: Empty strings remain empty\n\n    Precondition: True (no special preconditions for title case conversion)\n    Postcondition: For all indices i, result[i] is the title case version of a[i]\n-/\ntheorem title_spec {n : Nat} (a : Vector String n) :\n    ⦃⌜True⌝⦄\n    title a\n    ⦃⇓r => ⌜∀ i : Fin n, \n      let original := a.get i\n      let result := r.get i\n      -- Length preservation: result has same length as original\n      (result.length = original.length) ∧\n      -- Empty string case: empty input produces empty output\n      (original.length = 0 → result = \"\") ∧\n      -- Title case transformation: correct case for each character\n      (∀ j : Nat, j < original.length → \n        ∃ origChar resultChar : Char, \n          original.get? ⟨j⟩ = some origChar ∧ \n          result.get? ⟨j⟩ = some resultChar ∧\n          -- If character should be uppercase (word start), it is uppercase\n          (shouldBeUpperInTitle original j → resultChar = origChar.toUpper) ∧\n          -- If character should be lowercase (not word start but alphabetic), it is lowercase\n          (¬shouldBeUpperInTitle original j ∧ origChar.isAlpha → resultChar = origChar.toLower) ∧\n          -- Non-alphabetic characters remain unchanged\n          (¬origChar.isAlpha → resultChar = origChar)) ∧\n      -- Word boundary property: alphabetic chars after non-alphabetic are uppercase\n      (∀ j : Nat, j < original.length → j > 0 →\n        ∃ prevChar currChar resultChar : Char,\n          original.get? ⟨j - 1⟩ = some prevChar ∧\n          original.get? ⟨j⟩ = some currChar ∧\n          result.get? ⟨j⟩ = some resultChar ∧\n          (¬prevChar.isAlpha ∧ currChar.isAlpha → resultChar = currChar.toUpper)) ∧\n      -- Sanity check: non-empty strings are properly title-cased\n      (original.length > 0 →\n        ∃ firstChar : Char,\n          original.get? ⟨0⟩ = some firstChar ∧\n          (firstChar.isAlpha → \n            ∃ resultFirstChar : Char,\n              result.get? ⟨0⟩ = some resultFirstChar ∧\n              resultFirstChar = firstChar.toUpper))⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0653", "language": "lean", "source": "numpy_triple", "source-id": "ufunc_at", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"ufunc.at\",\n  \"category\": \"In-place Method\",\n  \"description\": \"Performs operation in-place at specified array indices\",\n  \"url\": \"https://numpy.org/doc/stable/reference/generated/numpy.ufunc.at.html\",\n  \"signature\": \"ufunc.at(a, indices, b=None, /)\",\n  \"parameters\": {\n    \"a\": \"Array to perform in-place operation on\",\n    \"indices\": \"Indices where operation is applied\",\n    \"b\": \"Second operand for binary ufuncs\"\n  },\n  \"example\": \"a = np.array([1, 2, 3, 4])\\nnp.add.at(a, [0, 1, 2, 2], 1)\\n# a becomes [2, 3, 5, 4]\",\n  \"notes\": [\n    \"Performs unbuffered in-place operation\",\n    \"Useful for updating specific array elements\"\n  ]\n}\n-/\n\n/-- ufunc.at: Performs operation in-place at specified array indices.\n\n    Performs an in-place operation on an array at specified indices, with special\n    handling for repeated indices. Unlike standard array indexing, this function\n    allows accumulation of results when the same index appears multiple times.\n\n    This function is particularly useful for scatter operations where you need to\n    accumulate values at specific indices without the buffering limitations of\n    regular array indexing.\n\n    From NumPy documentation:\n    - Parameters: a (array_like) - target array, indices (array_like) - indexing specification,\n      b (array_like, optional) - second operand for binary operations\n    - Returns: None (modifies array in-place)\n\n    Mathematical Properties:\n    1. In-place modification: modifies the original array a\n    2. Accumulation with repeated indices: when an index appears multiple times,\n       the operation is applied multiple times\n    3. Unbuffered operation: does not suffer from buffering issues of regular indexing\n    4. Preserves array shape: only modifies values, not structure\n    5. Index bounds checking: indices must be valid for the array\n-/\ndef «at» {n m : Nat} (a : Vector Int n) (indices : Vector (Fin n) m) (b : Vector Int m) : Id (Vector Int n) :=\n  sorry\n\n/-- Specification: ufunc.at performs in-place operation at specified indices\n    with proper handling of repeated indices.\n\n    Mathematical Properties:\n    1. In-place semantics: modifies the original array values\n    2. Accumulation property: for repeated indices, operations accumulate\n    3. Index correspondence: indices[i] determines where b[i] is applied\n    4. Bounds safety: all indices must be valid for the array\n    5. Preserves array length: result has same length as input array\n\n    Precondition: All indices must be valid (within bounds of array a)\n    Postcondition: For each index i in indices, the value at a[indices[i]] is\n    modified by the operation with b[i], with accumulation for repeated indices\n-/\ntheorem at_spec {n m : Nat} (a : Vector Int n) (indices : Vector (Fin n) m) (b : Vector Int m) :\n    ⦃⌜True⌝⦄\n    «at» a indices b\n    ⦃⇓result => ⌜∀ i : Fin n, ∃ acc : Int, result.get i = a.get i + acc ∧ acc ≥ 0⌝⦄ := by\n  sorry\n\n-- Additional properties for comprehensive specification\ntheorem at_length_preservation {n m : Nat} (_a : Vector Int n) (_indices : Vector (Fin n) m) (_b : Vector Int m) :\n    True := by\n  trivial\n\ntheorem at_accumulation {n : Nat} (a : Vector Int n) (idx : Fin n) (val : Int) :\n    «at» a (Vector.replicate 2 idx) (Vector.replicate 2 val) = \n    a.set idx (a.get idx + 2 * val) := by\n  sorry\n\ntheorem at_single_index {n : Nat} (a : Vector Int n) (idx : Fin n) (val : Int) :\n    «at» a (Vector.singleton idx) (Vector.singleton val) = \n    a.set idx (a.get idx + val) := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "LT0660", "language": "lean", "source": "numpy_triple", "source-id": "ufuncs_nin", "source-notes": "", "vc-description": "", "vc-preamble": "import Std.Do.Triple\nimport Std.Tactic.Do\n\nopen Std.Do\n\n/-!\n{\n  \"name\": \"nin\",\n  \"description\": \"The number of input arguments\",\n  \"examples\": {\n    \"add.nin\": \"2\",\n    \"sin.nin\": \"1\",\n    \"modf.nin\": \"1\"\n  }\n}\n-/\n\n/-- Enumeration of common NumPy universal functions (ufuncs).\n    This represents the different types of ufuncs that have nin properties. -/\ninductive UfuncType where\n  /-- Binary arithmetic operation: element-wise addition (a + b) -/\n  | add\n  /-- Binary arithmetic operation: element-wise subtraction (a - b) -/\n  | subtract\n  /-- Binary arithmetic operation: element-wise multiplication (a * b) -/\n  | multiply\n  /-- Binary arithmetic operation: element-wise division (a / b) -/\n  | divide\n  /-- Binary arithmetic operation: element-wise exponentiation (a ** b) -/\n  | power\n  /-- Unary trigonometric function: sine of elements -/\n  | sin\n  /-- Unary trigonometric function: cosine of elements -/\n  | cos\n  /-- Unary exponential function: e raised to the power of elements -/\n  | exp\n  /-- Unary logarithmic function: natural logarithm of elements -/\n  | log\n  /-- Unary square root function: square root of elements -/\n  | sqrt\n  /-- Unary absolute value function: absolute value of elements -/\n  | abs\n  /-- Unary function returning fractional and integer parts of elements -/\n  | modf\n  deriving DecidableEq\n\n/-- Returns the number of input arguments for a given ufunc type.\n    Binary operations return 2, unary operations return 1. -/\ndef nin (ufunc : UfuncType) : Id Nat :=\n  match ufunc with\n  | .add => pure 2\n  | .subtract => pure 2\n  | .multiply => pure 2\n  | .divide => pure 2\n  | .power => pure 2\n  | .sin => pure 1\n  | .cos => pure 1\n  | .exp => pure 1\n  | .log => pure 1\n  | .sqrt => pure 1\n  | .abs => pure 1\n  | .modf => pure 1\n\n/-- Helper definition: the set of binary ufuncs (those requiring 2 inputs) -/\ndef binaryUfuncs : List UfuncType := [.add, .subtract, .multiply, .divide, .power]\n\n/-- Helper definition: the set of unary ufuncs (those requiring 1 input) -/\ndef unaryUfuncs : List UfuncType := [.sin, .cos, .exp, .log, .sqrt, .abs, .modf]\n\n/-- Specification: nin returns the correct number of input arguments for each ufunc type.\n    \n    For binary ufuncs (add, subtract, multiply, divide, power), nin returns 2.\n    For unary ufuncs (sin, cos, exp, log, sqrt, abs, modf), nin returns 1.\n    \n    This property is essential for ufunc introspection and validates that the\n    number of inputs matches the mathematical definition of each operation.\n    \n    Key properties:\n    1. Binary operations consistently return 2 inputs\n    2. Unary operations consistently return 1 input  \n    3. All ufuncs are classified as either binary or unary\n    4. The result is always a positive integer (1 or 2) -/\ntheorem nin_spec (ufunc : UfuncType) :\n    ⦃⌜True⌝⦄\n    nin ufunc\n    ⦃⇓result => ⌜(ufunc ∈ binaryUfuncs → result = 2) ∧\n                  (ufunc ∈ unaryUfuncs → result = 1) ∧\n                  (ufunc ∈ binaryUfuncs ∨ ufunc ∈ unaryUfuncs) ∧\n                  (result > 0) ∧\n                  (result ≤ 2)⌝⦄ := by\n  sorry", "vc-helpers": "", "vc-definitions": "", "vc-theorems": "", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "unformatted", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
