{"id": "VA0001", "language": "verus", "source": "apps", "source-id": "apps_test_5", "source-notes": "", "vc-description": "Given n browser tabs indexed 1 to n with cursor at position pos, find minimum time to close\nall tabs except those in range [l, r]. Operations: move cursor (1 sec), close all tabs to\nleft of cursor (1 sec), close all tabs to right of cursor (1 sec).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, pos: int, l: int, r: int) -> bool {\n    1 <= n <= 100 && 1 <= pos <= n && 1 <= l <= r <= n\n}\n\nspec fn no_tabs_to_close(l: int, r: int, n: int) -> bool {\n    l == 1 && r == n\n}\n\nspec fn only_close_right(l: int, r: int, n: int) -> bool {\n    l == 1 && r < n\n}\n\nspec fn only_close_left(l: int, r: int, n: int) -> bool {\n    l > 1 && r == n\n}\n\nspec fn close_both_sides(l: int, r: int, n: int) -> bool {\n    l > 1 && r < n\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, pos: i8, l: i8, r: i8) -> (result: i8)\n    requires \n        valid_input(n as int, pos as int, l as int, r as int)\n    ensures \n        result as int >= 0,\n        no_tabs_to_close(l as int, r as int, n as int) ==> result as int == 0,\n        only_close_right(l as int, r as int, n as int) ==> result as int == if pos as int >= r as int { pos as int - r as int } else { r as int - pos as int } + 1,\n        only_close_left(l as int, r as int, n as int) ==> result as int == if pos as int >= l as int { pos as int - l as int } else { l as int - pos as int } + 1,\n        close_both_sides(l as int, r as int, n as int) && l as int <= pos as int && pos as int <= r as int && (pos as int - l as int) < (r as int - pos as int) ==> result as int == (pos as int - l as int) + 1 + (r as int - l as int) + 1,\n        close_both_sides(l as int, r as int, n as int) && l as int <= pos as int && pos as int <= r as int && (pos as int - l as int) >= (r as int - pos as int) ==> result as int == (r as int - pos as int) + 1 + (r as int - l as int) + 1,\n        close_both_sides(l as int, r as int, n as int) && pos as int > r as int ==> result as int == (pos as int - r as int) + 1 + (r as int - l as int) + 1,\n        close_both_sides(l as int, r as int, n as int) && pos as int < l as int ==> result as int == (l as int - pos as int) + 1 + (r as int - l as int) + 1,\n        result as int <= 2 * n as int", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0006", "language": "verus", "source": "apps", "source-id": "apps_test_29", "source-notes": "", "vc-description": "Given a 6-digit ticket (string of digits 0-9), find the minimum number of digit replacements needed to make it \"lucky\".\nA ticket is lucky when the sum of its first three digits equals the sum of its last three digits.\nAny digit can be replaced with any digit 0-9.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn char_to_int(c: char) -> int {\n    c as int - '0' as int\n}\n\nspec fn is_lucky(digits: Seq<int>) -> bool {\n    digits.len() == 6 ==> {\n        let sum1 = digits[0] + digits[1] + digits[2];\n        let sum2 = digits[3] + digits[4] + digits[5];\n        sum1 == sum2\n    }\n}\n\nspec fn valid_ticket(ticket: Seq<char>) -> bool {\n    ticket.len() == 6 && forall|i: int| 0 <= i < ticket.len() ==> '0' <= ticket[i] <= '9'\n}\n\nspec fn can_make_lucky_with_0_changes(digits: Seq<int>) -> bool {\n    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> is_lucky(digits)\n}\n\nspec fn can_make_lucky_with_1_change(digits: Seq<int>) -> bool {\n    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> {\n        exists|pos: int| 0 <= pos < 6 &&\n            exists|new_digit: int| 0 <= new_digit <= 9 && {\n                let new_digits = digits.subrange(0, pos).add(seq![new_digit]).add(digits.subrange(pos + 1, digits.len() as int));\n                is_lucky(new_digits)\n            }\n    }\n}\n\nspec fn can_make_lucky_with_2_changes(digits: Seq<int>) -> bool {\n    digits.len() == 6 && (forall|i: int| 0 <= i < digits.len() ==> 0 <= digits[i] <= 9) ==> {\n        exists|i: int, j: int| 0 <= j < i < 6 &&\n            exists|k: int, l: int| 0 <= k <= 9 && 0 <= l <= 9 && {\n                let new_digits = digits.subrange(0, i).add(seq![k]).add(digits.subrange(i + 1, digits.len() as int));\n                let final_digits = new_digits.subrange(0, j).add(seq![l]).add(new_digits.subrange(j + 1, new_digits.len() as int));\n                is_lucky(final_digits)\n            }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(ticket: &Vec<char>) -> (result: u32)\n    requires valid_ticket(ticket@)\n    ensures 0 <= result <= 3", "vc-code": "{\n    // impl-start\n    assume(false);\n    0\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0015", "language": "verus", "source": "apps", "source-id": "apps_test_72", "source-notes": "", "vc-description": "Three players each have a ribbon (string). The beauty of a ribbon is the maximum frequency of any character.\nIn n turns, each player must change exactly one character. After n turns, the player with highest beauty wins.\nFind the winner assuming optimal play, or \"Draw\" if tied.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result =~= seq!['K','u','r','o'] || result =~= seq!['S','h','i','r','o'] || result =~= seq!['K','a','t','i','e'] || result =~= seq!['D','r','a','w'] || result.len() == 0\n}\n\nspec fn optimal_score(ribbon: Seq<char>, turns: int) -> int \n    recommends ribbon.len() >= 0 && turns >= 0\n{\n    let max_freq = max_char_freq(ribbon);\n    let length = ribbon.len() as int;\n    if turns == 1 && max_freq == length {\n        if max_freq > 0 { max_freq - 1 } else { 0 }\n    } else if length < max_freq + turns {\n        length\n    } else {\n        max_freq + turns\n    }\n}\nspec fn max_char_freq(s: Seq<char>) -> int {\n    0\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn max3(a: int, b: int, c: int) -> int {\n    if a >= b && a >= c { a } else if b >= c { b } else { c }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(result)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0019", "language": "verus", "source": "apps", "source-id": "apps_test_93", "source-notes": "", "vc-description": "Given two 2x2 sliding puzzles with tiles A, B, C and empty cell X,\ndetermine if there exists a sequence of moves that can make both puzzles\nreach the same configuration. A move slides a tile adjacent to the empty\ncell into the empty cell.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn count_newlines(s: Seq<char>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0int\n    } else {\n        (if s[0] == '\\n' { 1int } else { 0int }) + count_newlines(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.contains('\\n') && count_newlines(input) >= 3\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    /* Implementation details for splitting lines */\n    seq![seq![]]\n}\n\nspec fn reverse_seq(s: Seq<char>) -> Seq<char> {\n    s.reverse()\n}\n\nspec fn remove_first_x(s: Seq<char>) -> Seq<char> {\n    /* Implementation details for removing first X */\n    s\n}\n\nspec fn extract_and_normalize_puzzle1(input: Seq<char>) -> Seq<char> {\n    if valid_input(input) {\n        let lines = split_lines(input);\n        if lines.len() >= 2 {\n            let line1 = lines[0];\n            let line2 = reverse_seq(lines[1]);\n            let combined = line1.add(line2);\n            remove_first_x(combined)\n        } else {\n            seq![]\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn extract_and_normalize_puzzle2(input: Seq<char>) -> Seq<char> {\n    if valid_input(input) {\n        let lines = split_lines(input);\n        if lines.len() >= 4 {\n            let line3 = lines[2];\n            let line4 = reverse_seq(lines[3]);\n            let combined = line3.add(line4);\n            remove_first_x(combined)\n        } else {\n            seq![]\n        }\n    } else {\n        seq![]\n    }\n}\n\nspec fn rotate_puzzle_left(puzzle: Seq<char>, rotation: int) -> Seq<char> {\n    /* Implementation details for rotating puzzle */\n    puzzle\n}\n\nspec fn can_reach_same_config(input: Seq<char>) -> bool {\n    if valid_input(input) {\n        exists|rotation: int| 0 <= rotation < 4 && \n            extract_and_normalize_puzzle1(input) == rotate_puzzle_left(extract_and_normalize_puzzle2(input), rotation)\n    } else {\n        false\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    ensures can_reach_same_config(input@) ==> result@ == seq!['Y', 'E', 'S']\n    ensures !can_reach_same_config(input@) ==> result@ == seq!['N', 'O']", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0020", "language": "verus", "source": "apps", "source-id": "apps_test_95", "source-notes": "", "vc-description": "Given an array of integers, determine if it is unimodal.\nAn array is unimodal if it follows this exact pattern:\n1. An optional strictly increasing sequence at the beginning\n2. An optional constant sequence in the middle  \n3. An optional strictly decreasing sequence at the end\nAll three parts are optional, but if present, they must appear in this exact order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: nat, arr: Seq<int>) -> bool {\n    n > 0 && arr.len() == n && forall|i: int| 0 <= i < arr.len() ==> arr[i] >= 1\n}\n\nspec fn is_unimodal(arr: Seq<int>) -> bool {\n    if arr.len() <= 1 { \n        true \n    } else {\n        let phases = compute_phases(arr);\n        phases.0 <= phases.1 && phases.1 <= phases.2 && phases.2 == arr.len() &&\n        (forall|i: int, j: int| 0 <= i < j < phases.0 ==> #[trigger] arr[i] < #[trigger] arr[j]) &&\n        (forall|i: int| phases.0 <= i < phases.1 ==> #[trigger] arr[i] == (if phases.0 > 0 { arr[phases.0] } else { arr[0] })) &&\n        (forall|i: int, j: int| phases.1 <= i < j < phases.2 ==> #[trigger] arr[i] > #[trigger] arr[j]) &&\n        (phases.0 > 0 && phases.1 < arr.len() ==> arr[phases.0-1] >= (if phases.1 > phases.0 { arr[phases.0] } else { arr[phases.1] }))\n    }\n}\n\nspec fn compute_phases(arr: Seq<int>) -> (int, int, int) {\n    let inc_end = compute_increasing_end(arr, 0, 0);\n    let const_end = compute_constant_end(arr, inc_end, if inc_end > 0 { arr[inc_end-1] } else { 0 });\n    let dec_end = compute_decreasing_end(arr, const_end, if const_end > inc_end { arr[inc_end] } else if inc_end > 0 { arr[inc_end-1] } else { 0 });\n    (inc_end, const_end, dec_end)\n}\n\nspec fn compute_increasing_end(arr: Seq<int>, start: int, prev: int) -> int {\n    0\n}\n\nspec fn compute_constant_end(arr: Seq<int>, start: int, value: int) -> int {\n    start\n}\n\nspec fn compute_decreasing_end(arr: Seq<int>, start: int, prev: int) -> int {\n    arr.len() as int\n}", "vc-helpers": "", "vc-spec": "fn solve(n: nat, arr: Seq<int>) -> (result: String)\n    requires \n        valid_input(n, arr),\n    ensures \n        result@ == \"YES\"@ || result@ == \"NO\"@,\n        result@ == \"YES\"@ <==> is_unimodal(arr),", "vc-code": "{\n    assume(false);\n    \"NO\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0021", "language": "verus", "source": "apps", "source-id": "apps_test_98", "source-notes": "", "vc-description": "Given a rectangular board and two rectangular paintings, determine if both paintings \ncan be placed on the board without overlapping or extending beyond edges. Each rectangle \ncan be rotated 90 degrees.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 3 &&\n    {\n        let board_parts = split_spaces_func(lines[0]);\n        let paint1_parts = split_spaces_func(lines[1]);\n        let paint2_parts = split_spaces_func(lines[2]);\n        board_parts.len() >= 2 && paint1_parts.len() >= 2 && paint2_parts.len() >= 2 &&\n        is_valid_int(board_parts[0]) && is_valid_int(board_parts[1]) &&\n        is_valid_int(paint1_parts[0]) && is_valid_int(paint1_parts[1]) &&\n        is_valid_int(paint2_parts[0]) && is_valid_int(paint2_parts[1])\n    }\n}\n\nspec fn can_place_both_paintings(a: int, b: int, c: int, d: int, e: int, f: int) -> bool {\n    (c+e <= a && max(d,f) <= b) ||\n    (c+e <= b && max(d,f) <= a) ||\n    (c+f <= a && max(d,e) <= b) ||\n    (c+f <= b && max(d,e) <= a) ||\n    (d+e <= a && max(c,f) <= b) ||\n    (d+e <= b && max(c,f) <= a) ||\n    (d+f <= a && max(c,e) <= b) ||\n    (d+f <= b && max(c,e) <= a)\n}\n\nspec fn max(x: int, y: int) -> int {\n    if x >= y { x } else { y }\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> ('0' <= s[i] && s[i] <= '9')\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['a']; 3]\n}\n\nspec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['1']; 2]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    1\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (result: Vec<char>)\n    requires input.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0025", "language": "verus", "source": "apps", "source-id": "apps_test_114", "source-notes": "", "vc-description": "Given an n×m matrix A containing only 0s and 1s, and matrix B initially all zeros.\nYou can perform operations on B: choose integers x, y where 1 ≤ x < n and 1 ≤ y < m,\nthen set B[x,y], B[x,y+1], B[x+1,y], and B[x+1,y+1] to 1.\nDetermine if B can be made equal to A, and if so, provide a sequence of operations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n' &&\n    exists|lines: Seq<Seq<char>>| {\n        &&& lines == split_lines(input)\n        &&& lines.len() >= 3\n        &&& valid_dimension_line(lines[0])\n        &&& {\n            let parsed = parse_dimensions(lines[0]);\n            let (n, m) = (parsed.0, parsed.1);\n            &&& lines.len() == n + 1 && 2 <= n <= 50 && 2 <= m <= 50\n            &&& forall|i: int| 1 <= i <= n ==> valid_matrix_row(lines[i], m)\n            &&& forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==> \n                parse_matrix_element(lines[i], j) == 0 || parse_matrix_element(lines[i], j) == 1\n        }\n    }\n}\n\nspec fn valid_operation_sequence(output: Seq<char>, original_input: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == '\\n' &&\n    exists|lines: Seq<Seq<char>>| {\n        &&& lines == split_lines(output)\n        &&& lines.len() >= 1\n        &&& valid_number(lines[0])\n        &&& {\n            let k = parse_number(lines[0]);\n            &&& 0 <= k <= 2500\n            &&& lines.len() == k + 1\n            &&& {\n                let parsed = parse_input(original_input);\n                let (n, m) = (parsed.0, parsed.1);\n                forall|i: int| 1 <= i <= k ==> valid_coordinate_pair(lines[i], n-1, m-1)\n            }\n        }\n    }\n}\n\nspec fn valid_dimension_line(line: Seq<char>) -> bool { line.len() > 0 }\nspec fn valid_matrix_row(line: Seq<char>, m: int) -> bool { line.len() > 0 && m > 0 }\nspec fn valid_number(s: Seq<char>) -> bool { s.len() > 0 }\nspec fn valid_coordinate_pair(s: Seq<char>, max_x: int, max_y: int) -> bool { \n    s.len() > 0 && max_x > 0 && max_y > 0 \n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> { seq![s] }\nspec fn parse_dimensions(line: Seq<char>) -> (int, int) { (2, 2) }\nspec fn parse_number(s: Seq<char>) -> int { 0 }\nspec fn parse_input(input: Seq<char>) -> (int, int, Seq<Seq<int>>) { \n    (2, 2, seq![seq![0, 0], seq![0, 0]]) \n}\nspec fn parse_operations(output: Seq<char>) -> Seq<(int, int)> { seq![] }\nspec fn parse_matrix_element(line: Seq<char>, pos: int) -> int { 0 }\nspec fn to_string(n: int) -> Seq<char> { seq!['0'] }\n\nspec fn apply_greedy_algorithm(n: int, m: int, a: Seq<Seq<int>>) -> (Seq<Seq<int>>, Seq<(int, int)>) {\n    let b = Seq::new(n as nat, |i: int| Seq::new(m as nat, |j: int| 0));\n    let ops = seq![];\n    greedy_step(a, b, ops, 0, 0, n, m)\n}\n\nspec fn greedy_step(a: Seq<Seq<int>>, b: Seq<Seq<int>>, ops: Seq<(int, int)>, \n                   start_i: int, start_j: int, n: int, m: int) -> (Seq<Seq<int>>, Seq<(int, int)>) {\n    (b, ops)\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires \n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures \n        result@.len() > 0,\n        result@ == \"-1\\n\"@ || valid_operation_sequence(result@, stdin_input@),\n        result@ != \"-1\\n\"@ ==> {\n            let parsed = parse_input(stdin_input@);\n            let (n, m, a) = (parsed.0, parsed.1, parsed.2);\n            let ops = parse_operations(result@);\n            let algorithm_result = apply_greedy_algorithm(n, m, a);\n            let (b, expected_ops) = (algorithm_result.0, algorithm_result.1);\n            b == a && ops == expected_ops\n        },\n        result@ == \"-1\\n\"@ ==> {\n            let parsed = parse_input(stdin_input@);\n            let (n, m, a) = (parsed.0, parsed.1, parsed.2);\n            let algorithm_result = apply_greedy_algorithm(n, m, a);\n            let b = algorithm_result.0;\n            b != a\n        },\n        result@ == \"-1\\n\"@ || exists|k: nat, lines: Seq<Seq<char>>| {\n            &&& lines == split_lines(result@)\n            &&& lines.len() == k + 1\n            &&& lines[0] == to_string(k as int)\n            &&& k <= 2500\n            &&& {\n                let parsed = parse_input(stdin_input@);\n                let (n, m) = (parsed.0, parsed.1);\n                forall|i: int| #[trigger] lines[i].len() > 0 && 1 <= i <= k ==> {\n                    &&& 1 <= n-1 && 1 <= m-1\n                    &&& lines[i] == seq!['d', 'u', 'm', 'm', 'y']\n                }\n            }\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"-1\\n\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0030", "language": "verus", "source": "apps", "source-id": "apps_test_131", "source-notes": "", "vc-description": "Given two configurations of n stone piles, determine if the first configuration\ncan be transformed into the second using operations: remove one stone from any pile,\nor move one stone from one pile to another pile.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 && \n    parse_int(lines[0]) > 0 &&\n    parse_int_array(lines[1]).len() == parse_int(lines[0]) &&\n    parse_int_array(lines[2]).len() == parse_int(lines[0])\n}\n\nspec fn get_initial_sum(input: &str) -> int\n    recommends is_valid_input(input)\n{\n    let lines = split_lines(input);\n    sum_seq(parse_int_array(lines[1]))\n}\n\nspec fn get_target_sum(input: &str) -> int\n    recommends is_valid_input(input)\n{\n    let lines = split_lines(input);\n    sum_seq(parse_int_array(lines[2]))\n}\n\nspec fn sum_seq(nums: Seq<int>) -> int\n    decreases nums.len()\n{\n    if nums.len() == 0 {\n        0\n    } else {\n        nums[0] + sum_seq(nums.subrange(1, nums.len() as int))\n    }\n}\n\nuninterp spec fn split_lines(input: &str) -> Seq<&str>;\nuninterp spec fn parse_int(s: &str) -> int;\nuninterp spec fn parse_int_array(s: &str) -> Seq<int>;", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires is_valid_input(input)\n    ensures (result == \"Yes\") <==> get_initial_sum(input) >= get_target_sum(input)", "vc-code": "{\n    assume(false);\n    \"No\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0032", "language": "verus", "source": "apps", "source-id": "apps_test_144", "source-notes": "", "vc-description": "Given a sequence of n digits, determine if it can be divided into two or more \nnon-overlapping contiguous segments such that all segments have equal digit sums.\nEach digit must belong to exactly one segment.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn can_partition_into_equal_sum_segments(input: Seq<char>) -> bool {\n    if input.len() == 0 {\n        false\n    } else {\n        let lines = split_lines(input);\n        if lines.len() < 2 {\n            false\n        } else {\n            let n_str = trim(lines[0]);\n            let digits_str = trim(lines[1]);\n            let n = parse_int(n_str);\n            if n < 2 || n > 100 || digits_str.len() != n {\n                false\n            } else {\n                let digits = parse_digits(digits_str);\n                if digits.len() != n {\n                    false\n                } else {\n                    exists|i: int| 0 <= i < n - 1 && {\n                        let first_sum = sum(digits.subrange(0, i + 1));\n                        first_sum >= 0 &&\n                        can_partition_remainder(digits, i + 1, first_sum)\n                    }\n                }\n            }\n        }\n    }\n}\n\nspec fn can_partition_remainder(digits: Seq<int>, start: int, target_sum: int) -> bool \n    decreases digits.len() - start\n{\n    if start < 0 || start > digits.len() || target_sum < 0 {\n        false\n    } else if start >= digits.len() {\n        true\n    } else {\n        exists|segment_end: int| start < segment_end <= digits.len() && \n            sum(digits.subrange(start, segment_end)) == target_sum &&\n            can_partition_remainder(digits, segment_end, target_sum)\n    }\n}\n\nspec fn sum(s: Seq<int>) -> int {\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.skip(1))\n    }\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        char_to_digit(s[0])\n    } else {\n        char_to_digit(s[0]) * power10(s.len() - 1) + parse_int(s.skip(1))\n    }\n}\n\nspec fn char_to_digit(c: char) -> int {\n    if '0' <= c && c <= '9' {\n        (c as int) - ('0' as int)\n    } else {\n        0\n    }\n}\n\nspec fn power10(n: int) -> int {\n    if n <= 0 {\n        1\n    } else {\n        10 * power10(n - 1)\n    }\n}\n\nspec fn parse_digits(s: Seq<char>) -> Seq<int> {\n    if s.len() == 0 {\n        seq![]\n    } else {\n        seq![char_to_digit(s[0])] + parse_digits(s.skip(1))\n    }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    split_by_char(s, '\\n')\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        seq![seq![]]\n    } else if s[0] == delimiter {\n        seq![seq![]] + split_by_char(s.skip(1), delimiter)\n    } else {\n        let rest = split_by_char(s.skip(1), delimiter);\n        if rest.len() == 0 {\n            seq![s.subrange(0, 1)]\n        } else {\n            seq![s.subrange(0, 1) + rest[0]] + rest.skip(1)\n        }\n    }\n}\n\nspec fn trim(s: Seq<char>) -> Seq<char> {\n    trim_left(trim_right(s))\n}\n\nspec fn trim_left(s: Seq<char>) -> Seq<char> {\n    if s.len() == 0 {\n        s\n    } else if s[0] == ' ' || s[0] == '\\t' || s[0] == '\\n' || s[0] == '\\r' {\n        trim_left(s.skip(1))\n    } else {\n        s\n    }\n}\n\nspec fn trim_right(s: Seq<char>) -> Seq<char> {\n    if s.len() == 0 {\n        s\n    } else if s[s.len() - 1] == ' ' || s[s.len() - 1] == '\\t' || s[s.len() - 1] == '\\n' || s[s.len() - 1] == '\\r' {\n        trim_right(s.subrange(0, s.len() - 1))\n    } else {\n        s\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: Seq<char>) -> (result: Seq<char>)\n    requires s.len() > 0", "vc-code": "{\n    /* impl-start */\n    assume(false);\n    Seq::new(3 as nat, |i: nat| match i {\n        0 => 'N',\n        1 => 'O',\n        2 => '\\n',\n        _ => 'N'\n    })\n    /* impl-end */\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0035", "language": "verus", "source": "apps", "source-id": "apps_test_155", "source-notes": "", "vc-description": "Given an n×m matrix where n is even, determine Lara's position after exactly k moves\nfollowing a specific path: start at (1,1), move down column 1 to (n,1), then move in\na snake pattern through remaining columns alternating between moving right-up-left-up\nuntil reaching (1,2). Find coordinates after exactly k moves.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int) -> bool {\n    n >= 2 && m >= 2 && n % 2 == 0 && k >= 0 && k < n * m\n}\n\nspec fn valid_output(result: &Vec<int>, n: int, m: int) -> bool {\n    result.len() == 2 && result[0] >= 1 && result[0] <= n && result[1] >= 1 && result[1] <= m\n}\n\nspec fn correct_position(result: &Vec<int>, n: int, m: int, k: int) -> bool\n    recommends valid_input(n, m, k) && result.len() == 2\n{\n    if k < n {\n        result[0] == k + 1 && result[1] == 1\n    } else {\n        let k_remaining = k - n;\n        let r = n - k_remaining / (m - 1);\n        result[0] == r &&\n        (r % 2 == 1 ==> result[1] == m - k_remaining % (m - 1)) &&\n        (r % 2 == 0 ==> result[1] == 2 + k_remaining % (m - 1))\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, k: i8) -> (result: Vec<i8>)\n    requires\n        valid_input(n as int, m as int, k as int)\n    ensures\n        result.len() == 2,\n        {\n            let spec_result: Vec<int> = result@.map(|i, x: i8| x as int);\n            valid_output(&spec_result, n as int, m as int) && correct_position(&spec_result, n as int, m as int, k as int)\n        }", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0037", "language": "verus", "source": "apps", "source-id": "apps_test_162", "source-notes": "", "vc-description": "Find the minimum number of hours to water a garden of length k using exactly one type of bucket.\nEach bucket type i can water a continuous segment of length a_i per hour.\nMust choose a bucket size that evenly divides the garden length to avoid gaps or overlaps.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, a: Seq<int>) -> bool {\n    n >= 1 && k >= 1 && a.len() == n &&\n    (forall|i: int| 0 <= i < a.len() ==> a[i] >= 1) &&\n    (exists|i: int| 0 <= i < a.len() && k % a[i] == 0)\n}\n\nspec fn valid_bucket(k: int, bucket_size: int) -> bool {\n    bucket_size >= 1 && k % bucket_size == 0\n}\n\nspec fn hours_needed(k: int, bucket_size: int) -> int\n    recommends valid_bucket(k, bucket_size)\n{\n    k / bucket_size\n}\n\nspec fn is_optimal_choice(k: int, a: Seq<int>, chosen_bucket: int) -> bool {\n    0 <= chosen_bucket < a.len() &&\n    valid_bucket(k, a[chosen_bucket]) &&\n    (forall|i: int| 0 <= i < a.len() && valid_bucket(k, a[i]) ==> a[i] <= a[chosen_bucket])\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, a: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, k as int, a@.map(|i, x| x as int)),\n    ensures \n        result >= 1,\n        #[trigger] exists|i: int| is_optimal_choice(k as int, a@.map(|i, x| x as int), i) && result as int == hours_needed(k as int, a@.map(|i, x| x as int)[i]),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0038", "language": "verus", "source": "apps", "source-id": "apps_test_163", "source-notes": "", "vc-description": "Given a line of n cells and a grasshopper that can jump exactly k cells at a time,\ndetermine if the grasshopper can reach a target cell. The line contains exactly one\ngrasshopper ('G'), one target ('T'), empty cells ('.'), and obstacles ('#').\nThe grasshopper can only land on empty cells or the target.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn valid_input(n: int, k: int, s: Seq<char>) -> bool {\n    n >= 2 &&\n    1 <= k < n &&\n    s.len() == n &&\n    (exists|i: int| 0 <= i < s.len() && s[i] == 'G') &&\n    (exists|i: int| 0 <= i < s.len() && s[i] == 'T') &&\n    (forall|i: int| 0 <= i < s.len() ==> (s[i] == 'G' || s[i] == 'T' || s[i] == '.' || s[i] == '#')) &&\n    (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == 'G' ==> s[j] != 'G') &&\n    (forall|i: int, j: int| 0 <= i < j < s.len() && s[i] == 'T' ==> s[j] != 'T')\n}\n\nspec fn find_first_g_or_t(s: Seq<char>) -> int\n    recommends exists|i: int| 0 <= i < s.len() && (s[i] == 'G' || s[i] == 'T')\n    decreases s.len()\n{\n    if s.len() > 0 && (s[0] == 'G' || s[0] == 'T') {\n        0\n    } else if s.len() > 1 {\n        find_first_g_or_t(s.subrange(1, s.len() as int)) + 1\n    } else {\n        0\n    }\n}\n\nspec fn can_reach_target(s: Seq<char>, k: int) -> bool\n    recommends k > 0\n{\n    exists|start: int| \n        0 <= start < s.len() && \n        (s[start] == 'G' || s[start] == 'T') &&\n        (forall|j: int| 0 <= j < start ==> !(s[j] == 'G' || s[j] == 'T')) &&\n        (exists|final_pos: int| \n            start < final_pos < s.len() &&\n            (s[final_pos] == 'G' || s[final_pos] == 'T') &&\n            (final_pos - start) % k == 0 &&\n            (forall|pos: int| start < pos < final_pos && (pos - start) % k == 0 ==> !(s[pos] == 'G' || s[pos] == 'T' || s[pos] == '#'))\n        )\n}", "vc-spec": "fn solve(n: int, k: int, s: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(n, k, s)\n    ensures \n        result == seq!['Y', 'E', 'S'] || result == seq!['N', 'O'],\n        (result == seq!['Y', 'E', 'S']) <==> can_reach_target(s, k)", "vc-code": "{\n    assume(false);\n    seq!['N', 'O']\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0044", "language": "verus", "source": "apps", "source-id": "apps_test_178", "source-notes": "", "vc-description": "Given a string of n digits where n is odd and n >= 13, two players (Vasya first, then Petya) \ntake turns removing one character at a time until exactly 11 characters remain. \nVasya wins if the final 11-character string starts with digit 8, otherwise Petya wins.\nDetermine if Vasya has a winning strategy.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn valid_input(n: int, s: Seq<char>) -> bool {\n    n >= 13 && n % 2 == 1 && s.len() == n\n}\n\nspec fn count_eights_in_prefix(s: Seq<char>, len: int) -> int\n    decreases len\n{\n    if len == 0 {\n        0\n    } else {\n        (if s[len-1] == '8' { 1 } else { 0 }) + count_eights_in_prefix(s, len-1)\n    }\n}\n\nspec fn vasya_wins(n: int, s: Seq<char>) -> bool {\n    let petya_moves = (n - 11) / 2;\n    let prefix_len = n - 10;\n    let eights_in_prefix = count_eights_in_prefix(s, prefix_len);\n    petya_moves < eights_in_prefix\n}", "vc-spec": "fn solve(n: int, s: Seq<char>) -> (result: String)\n    requires valid_input(n, s)\n    ensures result == \"NO\" || result == \"YES\"\n    ensures result == if vasya_wins(n, s) { \"YES\".to_string() } else { \"NO\".to_string() }", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0061", "language": "verus", "source": "apps", "source-id": "apps_test_232", "source-notes": "", "vc-description": "Given an array of n integers representing lightsaber colors (each integer is between 1 and m),\ndetermine if there exists a contiguous subarray where each color i appears exactly k_i times.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn count_occurrences(s: Seq<nat>, value: nat) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s[0] == value {\n        1 + count_occurrences(s.subrange(1, s.len() as int), value)\n    } else {\n        count_occurrences(s.subrange(1, s.len() as int), value)\n    }\n}\n\nspec fn sum_seq(s: Seq<nat>) -> nat\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn subarray_matches_desired(subarray: Seq<nat>, desired: Seq<nat>, m: nat) -> bool\n{\n    desired.len() == m &&\n    forall|color: nat| #[trigger] count_occurrences(subarray, color) == desired[color as int - 1] && 1 <= color <= m\n}\n\nspec fn valid_input(n: nat, m: nat, colors: Seq<nat>, desired: Seq<nat>) -> bool\n{\n    colors.len() == n &&\n    desired.len() == m &&\n    (forall|i: int| #[trigger] colors[i] >= 1 && colors[i] <= m && 0 <= i < colors.len()) &&\n    (forall|i: int| #[trigger] desired[i] >= 0 && 0 <= i < desired.len()) &&\n    sum_seq(desired) <= n\n}", "vc-helpers": "", "vc-spec": "fn solve(n: u8, m: u8, colors: Vec<u8>, desired: Vec<u8>) -> (result: String)\n    requires\n        valid_input(n as nat, m as nat, colors@.map(|i, x| x as nat), desired@.map(|i, x| x as nat)),\n    ensures\n        result@ == seq!['Y' as char, 'E' as char, 'S' as char] <==> exists|i: int, j: int| 0 <= i <= j < n as int && #[trigger] subarray_matches_desired(colors@.map(|k, x| x as nat).subrange(i, j + 1), desired@.map(|k, x| x as nat), m as nat),\n        result@ == seq!['Y' as char, 'E' as char, 'S' as char] || result@ == seq!['N' as char, 'O' as char],", "vc-code": "{\n    assume(false);\n    \"NO\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0066", "language": "verus", "source": "apps", "source-id": "apps_test_256", "source-notes": "", "vc-description": "Game theory problem: Two teams of 2 players each compete. Each player has defense and attack skills.\nTeam 1 chooses their defense/attack assignment first, then Team 2 responds optimally.\nA team wins if their defense > opponent's attack AND their attack > opponent's defense.\nDetermine which team can guarantee a win with optimal play, or if neither can.\n\n/* player 1 defense */\n\n/* player 1 attack */\n\n/* player 2 defense */\n\n/* player 2 attack */\n\n/* player 3 defense */\n\n/* player 3 attack */\n\n/* player 4 defense */\n\n/* player 4 attack */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn split_lines(input: &str) -> Seq<&str> {\n    Seq::empty()\n}\n\n#[verifier::external_body]\nspec fn split_by_char(line: &str, c: char) -> Seq<&str> {\n    Seq::empty()\n}\n\n#[verifier::external_body]\nspec fn char_at(s: &str, i: int) -> char {\n    ' '\n}\n\n#[verifier::external_body]\nspec fn str_len(s: &str) -> int {\n    0\n}\n\n#[verifier::external_body]\nspec fn empty_string() -> String {\n    String::new()\n}\n\n#[verifier::external_body]\nspec fn team1_string() -> String {\n    \"Team 1\\n\".to_string()\n}\n\n#[verifier::external_body]\nspec fn team2_string() -> String {\n    \"Team 2\\n\".to_string()\n}\n\n#[verifier::external_body]\nspec fn draw_string() -> String {\n    \"Draw\\n\".to_string()\n}\n\nspec fn is_valid_integer(s: &str) -> bool {\n    str_len(s) > 0 && forall|i: int| 0 <= i < str_len(s) ==> ('0' <= char_at(s, i) && char_at(s, i) <= '9')\n}\n\nspec fn valid_player_line(line: &str) -> bool {\n    let parts = split_by_char(line, ' ');\n    parts.len() == 2 &&\n    is_valid_integer(parts[0]) &&\n    is_valid_integer(parts[1])\n}\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 4 &&\n    forall|i: int| 0 <= i < 4 ==> valid_player_line(lines[i])\n}\n\n#[verifier::external_body]\nspec fn parse_line(line: &str) -> Seq<int> {\n    Seq::empty()\n}\n\nspec fn compute_result(input: &str) -> String {\n    let lines = split_lines(input);\n    if lines.len() < 4 {\n        empty_string()\n    } else {\n        let player1 = parse_line(lines[0]);\n        let player2 = parse_line(lines[1]);\n        let player3 = parse_line(lines[2]);\n        let player4 = parse_line(lines[3]);\n\n        if player1.len() != 2 || player2.len() != 2 || player3.len() != 2 || player4.len() != 2 {\n            empty_string()\n        } else {\n            let a = player1[0];\n            let b = player1[1];\n            let c = player2[0];\n            let d = player2[1];\n            let x = player3[0];\n            let y = player3[1];\n            let z = player4[0];\n            let w = player4[1];\n\n            let team1 = (a > w && a > y && d > x && d > z) || (c > w && c > y && b > x && b > z);\n            let team2 = ((x > b && w > c) || (z > b && y > c)) && ((x > d && w > a) || (z > d && y > a));\n\n            if team1 {\n                team1_string()\n            } else if team2 {\n                team2_string()\n            } else {\n                draw_string()\n            }\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires \n        valid_input(input)\n    ensures \n        result == compute_result(input),\n        (result@ == \"Team 1\\n\"@) || (result@ == \"Team 2\\n\"@) || (result@ == \"Draw\\n\"@)", "vc-code": "{\n    assume(false);\n    \"Draw\\n\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0067", "language": "verus", "source": "apps", "source-id": "apps_test_259", "source-notes": "", "vc-description": "Given n bus routes with start times and intervals, find which route has the earliest bus\narriving at or after target time t. Each route i has first bus at time s_i and subsequent\nbuses every d_i minutes. Return the 1-indexed route number.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, t: int, routes: Seq<(int, int)>) -> bool {\n  n > 0 && routes.len() == n && \n  forall|i: int| 0 <= i < n ==> routes[i].1 > 0\n}\n\nspec fn get_next_arrival_time(first_time: int, interval: int, target_time: int) -> int\n  requires interval > 0\n{\n  if first_time >= target_time { \n    first_time\n  } else { \n    first_time + ((target_time - first_time + interval - 1) / interval) * interval\n  }\n}\n\nspec fn is_optimal_route(routes: Seq<(int, int)>, t: int, route_index: int) -> bool {\n  &&& 0 <= route_index < routes.len()\n  &&& (forall|i: int| 0 <= i < routes.len() ==> routes[i].1 > 0)\n  &&& (forall|i: int| 0 <= i < routes.len() ==> \n    get_next_arrival_time(routes[route_index].0, routes[route_index].1, t) <= \n    get_next_arrival_time(routes[i].0, routes[i].1, t))\n}", "vc-helpers": "", "vc-spec": "fn solve(n: int, t: int, routes: Seq<(int, int)>) -> (result: int)\n  requires valid_input(n, t, routes),\n  ensures 1 <= result <= n,\n  ensures is_optimal_route(routes, t, result - 1)", "vc-code": "{\n  assume(false);\n  0\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0068", "language": "verus", "source": "apps", "source-id": "apps_test_263", "source-notes": "", "vc-description": "Given n benches with initial occupancies and m additional people to seat,\nfind the minimum and maximum possible values of k, where k is the maximum\noccupancy of any single bench after all m people are seated.\nFor minimum k: distribute people as evenly as possible.\nFor maximum k: add all m people to the bench with current maximum occupancy.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn valid_input(n: nat, m: nat, benches: Seq<nat>) -> bool {\n    n > 0 && m > 0 && benches.len() == n && forall|i: int| 0 <= i < n ==> benches[i] > 0\n}\n\nspec fn max_seq(s: Seq<nat>) -> nat\n    recommends s.len() > 0\n{\n    if s.len() == 1 {\n        s[0]\n    } else if s[0] >= max_seq(s.subrange(1, s.len() as int)) {\n        s[0]\n    } else {\n        max_seq(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn sum_seq(s: Seq<nat>) -> nat {\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum_seq(s.subrange(1, s.len() as int))\n    }\n}", "vc-spec": "fn solve(n: nat, m: nat, benches: Seq<nat>) -> (result: (nat, nat))\n    requires valid_input(n, m, benches)\n    ensures result.1 == max_seq(benches) + m\n    ensures {\n        let total = sum_seq(benches) + m;\n        let current_max = max_seq(benches);\n        if total <= current_max * n { result.0 == current_max } \n        else { result.0 == (total + n - 1) / n }\n    }", "vc-code": "{\n    assume(false);\n    (0, 0)\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0096", "language": "verus", "source": "apps", "source-id": "apps_test_502", "source-notes": "", "vc-description": "Given three distinct points a, b, and c, determine if there exists a rotation center and angle \nsuch that rotating point a gives point b, and rotating point b gives point c.\nThe rotation must map a → b and b → c using the same center and angle.\nFor a valid rotation to exist, the distances |ab| and |bc| must be equal and \nthe three points cannot be collinear.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn length_sqr(p1: (int, int), p2: (int, int)) -> int {\n    (p1.0 - p2.0) * (p1.0 - p2.0) + (p1.1 - p2.1) * (p1.1 - p2.1)\n}\n\nspec fn valid_rotation_exists(a: (int, int), b: (int, int), c: (int, int)) -> bool {\n    let dist_ab_sqr = length_sqr(a, b);\n    let dist_bc_sqr = length_sqr(b, c);\n    let dx1 = c.0 - b.0;\n    let dy1 = c.1 - b.1;\n    let dx2 = b.0 - a.0;\n    let dy2 = b.1 - a.1;\n    dist_ab_sqr == dist_bc_sqr && dx1 * dy2 != dy1 * dx2\n}\n\nspec fn parse_input_func(input: Seq<char>) -> Seq<int>\n    recommends input.len() > 0\n{\n    parse_input_helper(input, 0, seq![], seq![])\n}\n\nspec fn parse_input_helper(input: Seq<char>, i: int, result: Seq<int>, current: Seq<char>) -> Seq<int>\n    recommends 0 <= i <= input.len()\n    decreases input.len() - i\n{\n    if i == input.len() {\n        if current.len() > 0 { result.push(string_to_int(current)) }\n        else { result }\n    } else {\n        let ch = input[i];\n        if ch == ' ' || ch == '\\n' || ch == '\\t' {\n            if current.len() > 0 {\n                parse_input_helper(input, i + 1, result.push(string_to_int(current)), seq![])\n            } else {\n                parse_input_helper(input, i + 1, result, seq![])\n            }\n        } else if ('0' <= ch <= '9') || ch == '-' {\n            parse_input_helper(input, i + 1, result, current.push(ch))\n        } else {\n            parse_input_helper(input, i + 1, result, current)\n        }\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s.len() == 1 && s[0] == '-' { 0 }\n    else if s[0] == '-' && s.len() > 1 && is_digit_string(s.subrange(1, s.len() as int)) { -string_to_int_helper(s.subrange(1, s.len() as int)) }\n    else if is_digit_string(s) { string_to_int_helper(s) }\n    else { 0 }\n}\n\nspec fn is_digit_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'\n}\n\nspec fn string_to_int_helper(s: Seq<char>) -> int\n    recommends forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'\n{\n    if s.len() == 0 { 0 }\n    else if s.len() == 1 { char_to_digit(s[0]) }\n    else { string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 + char_to_digit(s[s.len() - 1]) }\n}\n\nspec fn char_to_digit(c: char) -> int\n    recommends '0' <= c <= '9'\n{\n    (c as int) - ('0' as int)\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires input@.len() > 0\n    ensures result@ == \"Yes\"@ || result@ == \"No\"@ || result@ == \"\"@", "vc-code": "{\n    assume(false);\n    \"\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0097", "language": "verus", "source": "apps", "source-id": "apps_test_505", "source-notes": "", "vc-description": "Given an n×m rectangular maze with a robot starting at position 'X', find the lexicographically smallest path of exactly k moves that returns the robot to its starting position.\nThe maze contains '.' for empty cells, '*' for obstacles, and 'X' for the robot's starting position.\nRobot can move in 4 directions: L (left), R (right), U (up), D (down) and can only move to empty cells.\nReturn the lexicographically smallest string of length k consisting of characters 'D', 'L', 'R', 'U' that returns the robot to start, or \"IMPOSSIBLE\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int, k: int, grid: Seq<Seq<char>>) -> bool {\n    n > 0 && m > 0 && k >= 0 &&\n    grid.len() == n &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] grid[i].len() == m) &&\n    (exists|i: int, j: int| 0 <= i < n && 0 <= j < m && grid[i][j] == 'X')\n}\n\nspec fn get_next_position(x: int, y: int, move_char: char) -> (int, int) {\n    match move_char {\n        'D' => (x + 1, y),\n        'L' => (x, y - 1),\n        'R' => (x, y + 1),\n        'U' => (x - 1, y),\n        _ => (x, y)\n    }\n}\n\nspec fn simulate_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> (int, int)\n    decreases path.len()\n{\n    if path.len() == 0 {\n        (start_x, start_y)\n    } else {\n        let next_pos = get_next_position(start_x, start_y, path[0]);\n        simulate_path(next_pos.0, next_pos.1, path.subrange(1, path.len() as int), grid, n, m)\n    }\n}\n\nspec fn valid_path(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n    forall|i: int| #![trigger simulate_path(start_x, start_y, path.subrange(0, i), grid, n, m)] \n        0 <= i <= path.len() ==> {\n            let pos = simulate_path(start_x, start_y, path.subrange(0, i), grid, n, m);\n            0 <= pos.0 < n && 0 <= pos.1 < m && \n            pos.0 < grid.len() && pos.1 < grid[pos.0].len() &&\n            grid[pos.0][pos.1] != '*'\n        }\n}\n\nspec fn path_returns_to_start(start_x: int, start_y: int, path: Seq<char>, grid: Seq<Seq<char>>, n: int, m: int) -> bool {\n    let final_pos = simulate_path(start_x, start_y, path, grid, n, m);\n    final_pos.0 == start_x && final_pos.1 == start_y\n}\n\nspec fn valid_directions(path: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < path.len() ==> \n        #[trigger] path[i] == 'D' || path[i] == 'L' || path[i] == 'R' || path[i] == 'U'\n}", "vc-helpers": "", "vc-spec": "fn solve(n: usize, m: usize, k: usize, grid: Vec<Vec<char>>) -> (result: String)\n    requires\n        valid_input(n as int, m as int, k as int, grid@.map_values(|row: Vec<char>| row@))\n    ensures\n        result == \"IMPOSSIBLE\" || (\n            result.len() == k &&\n            valid_directions(result@) &&\n            {\n                let mut start_x = 0;\n                let mut start_y = 0;\n                let mut found = false;\n                let mut i = 0;\n                while i < n {\n                    let mut j = 0;\n                    while j < m {\n                        if grid[i][j] == 'X' {\n                            start_x = i as int;\n                            start_y = j as int;\n                            found = true;\n                        }\n                        j += 1;\n                    }\n                    i += 1;\n                }\n                found\n            } ==> {\n                let start_x = {\n                    let mut sx = 0;\n                    let mut i = 0;\n                    while i < n {\n                        let mut j = 0;\n                        while j < m {\n                            if grid[i][j] == 'X' {\n                                sx = i as int;\n                            }\n                            j += 1;\n                        }\n                        i += 1;\n                    }\n                    sx\n                };\n                let start_y = {\n                    let mut sy = 0;\n                    let mut i = 0;\n                    while i < n {\n                        let mut j = 0;\n                        while j < m {\n                            if grid[i][j] == 'X' {\n                                sy = j as int;\n                            }\n                            j += 1;\n                        }\n                        i += 1;\n                    }\n                    sy\n                };\n                valid_path(start_x, start_y, result@, grid@.map_values(|row: Vec<char>| row@), n as int, m as int) &&\n                path_returns_to_start(start_x, start_y, result@, grid@.map_values(|row: Vec<char>| row@), n as int, m as int)\n            }\n        )", "vc-code": "{\n    assume(false);\n    \"IMPOSSIBLE\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0099", "language": "verus", "source": "apps", "source-id": "apps_test_510", "source-notes": "", "vc-description": "Three ropewalkers are positioned at coordinates a, b, and c on an infinite line.\nEach second, exactly one ropewalker can move by 1 unit left or right.\nFind the minimum time needed so that the distance between every pair of ropewalkers is at least d.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn pos1(a: int, b: int, c: int) -> int {\n        if a <= b && a <= c {\n            a\n        } else if b <= a && b <= c {\n            b\n        } else {\n            c\n        }\n    }\n    \n    spec fn pos2(a: int, b: int, c: int) -> int {\n        if a <= b && a <= c {\n            if b <= c { b } else { c }\n        } else if b <= a && b <= c {\n            if a <= c { a } else { c }\n        } else {\n            if a <= b { a } else { b }\n        }\n    }\n    \n    spec fn pos3(a: int, b: int, c: int) -> int {\n        if a <= b && a <= c {\n            if b <= c { c } else { b }\n        } else if b <= a && b <= c {\n            if a <= c { c } else { a }\n        } else {\n            if a <= b { b } else { a }\n        }\n    }", "vc-helpers": "", "vc-spec": "fn solve(a: int, b: int, c: int, d: int) -> (result: int)\n    requires 1 <= a && a <= 1_000_000_000\n    requires 1 <= b && b <= 1_000_000_000\n    requires 1 <= c && c <= 1_000_000_000\n    requires 1 <= d && d <= 1_000_000_000\n    ensures result >= 0\n    ensures result == (if d > (pos2(a, b, c) - pos1(a, b, c)) { d - (pos2(a, b, c) - pos1(a, b, c)) } else { 0 }) +\n                     (if d > (pos3(a, b, c) - pos2(a, b, c)) { d - (pos3(a, b, c) - pos2(a, b, c)) } else { 0 })", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0106", "language": "verus", "source": "apps", "source-id": "apps_test_540", "source-notes": "", "vc-description": "Given an n×m grid representing an ice cave level, determine if you can move from starting position (r1, c1) to target position (r2, c2) and fall through the target cell.\nGrid representation: '.' = intact ice, 'X' = cracked ice\nMovement rules: Move to side-adjacent cells only, cannot move to same cell, moving to intact ice cracks it, moving to cracked ice causes fall through\nGoal: Reach (r2, c2) when it's cracked ice and fall through it\nStarting cell (r1, c1) is guaranteed to contain 'X' in the input", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    stdin_input.len() >= 7 &&\n    contains_required_newlines(stdin_input) &&\n    ends_with_newline_or_can_append(stdin_input) &&\n    has_valid_structure(stdin_input) &&\n    all_grid_characters_valid(stdin_input) &&\n    has_exactly_required_lines(stdin_input)\n}\n\nspec fn valid_grid_bounds(stdin_input: Seq<char>) -> bool {\n    let parsed = parse_dimensions(stdin_input);\n    parsed.0 >= 1 && parsed.0 <= 500 && parsed.1 >= 1 && parsed.1 <= 500\n}\n\nspec fn valid_coordinates(stdin_input: Seq<char>) -> bool {\n    let dims = parse_dimensions(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    coords.0 >= 1 && coords.0 <= dims.0 && coords.1 >= 1 && coords.1 <= dims.1 &&\n    coords.2 >= 1 && coords.2 <= dims.0 && coords.3 >= 1 && coords.3 <= dims.1\n}\n\nspec fn starting_cell_is_cracked(stdin_input: Seq<char>) -> bool {\n    let grid = parse_grid(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    valid_grid_index(grid, coords.0-1, coords.1-1) &&\n    grid.index(coords.0-1).index(coords.1-1) == 'X'\n}\n\nspec fn well_formed_input(stdin_input: Seq<char>) -> bool {\n    valid_input_format(stdin_input) &&\n    valid_grid_bounds(stdin_input) &&\n    valid_coordinates(stdin_input) &&\n    starting_cell_is_cracked(stdin_input) &&\n    grid_contains_only_valid_chars(stdin_input) &&\n    coordinates_within_bounds(stdin_input)\n}\n\nspec fn can_solve_ice_maze(stdin_input: Seq<char>) -> bool {\n    let grid = parse_grid(stdin_input);\n    let coords = parse_coordinates(stdin_input);\n    let r1 = coords.0-1;\n    let c1 = coords.1-1;\n    let r2 = coords.2-1;\n    let c2 = coords.3-1;\n    let target_is_cracked = grid.index(r2).index(c2) == 'X';\n    let surrounding_dots = count_surrounding_intact_ice(grid, r2, c2);\n\n    if target_is_cracked {\n        if r1 == r2 && c1 == c2 {\n            surrounding_dots >= 1\n        } else {\n            can_reach_target_with_bfs(grid, r1, c1, r2, c2)\n        }\n    } else {\n        if surrounding_dots >= 2 {\n            can_reach_target_with_bfs(grid, r1, c1, r2, c2)\n        } else if surrounding_dots == 0 {\n            false\n        } else {\n            is_adjacent(r1+1, c1+1, r2+1, c2+1)\n        }\n    }\n}\n\nspec fn parse_dimensions(stdin_input: Seq<char>) -> (int, int) {\n    (1, 1)\n}\n\nspec fn parse_grid(stdin_input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['X']]\n}\n\nspec fn parse_coordinates(stdin_input: Seq<char>) -> (int, int, int, int) {\n    (1, 1, 1, 1)\n}\n\nspec fn valid_grid_index(grid: Seq<Seq<char>>, r: int, c: int) -> bool {\n    0 <= r < grid.len() && 0 <= c < grid.index(r).len()\n}\n\n/* Helper functions that are referenced but not defined */\nspec fn contains_required_newlines(input: Seq<char>) -> bool { true }\nspec fn ends_with_newline_or_can_append(input: Seq<char>) -> bool { true }\nspec fn has_valid_structure(input: Seq<char>) -> bool { true }\nspec fn all_grid_characters_valid(input: Seq<char>) -> bool { true }\nspec fn has_exactly_required_lines(input: Seq<char>) -> bool { true }\nspec fn grid_contains_only_valid_chars(input: Seq<char>) -> bool { true }\nspec fn coordinates_within_bounds(input: Seq<char>) -> bool { true }\nspec fn count_surrounding_intact_ice(grid: Seq<Seq<char>>, r: int, c: int) -> int { 0 }\nspec fn can_reach_target_with_bfs(grid: Seq<Seq<char>>, r1: int, c1: int, r2: int, c2: int) -> bool { true }\nspec fn is_adjacent(r1: int, c1: int, r2: int, c2: int) -> bool { \n    (r1 == r2 && (c1 == c2 + 1 || c1 == c2 - 1)) ||\n    (c1 == c2 && (r1 == r2 + 1 || r1 == r2 - 1))\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        valid_input_format(stdin_input),\n        valid_grid_bounds(stdin_input),\n        valid_coordinates(stdin_input),\n        starting_cell_is_cracked(stdin_input),\n        well_formed_input(stdin_input),\n    ensures \n        result == seq!['Y', 'E', 'S', '\\n'] || result == seq!['N', 'O', '\\n'],\n        result.len() > 0,\n        (result == seq!['Y', 'E', 'S', '\\n']) <==> can_solve_ice_maze(stdin_input),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0107", "language": "verus", "source": "apps", "source-id": "apps_test_543", "source-notes": "", "vc-description": "Determine if pizza requirements for n consecutive days can be fulfilled using only:\n- Discount: Buy exactly 2 pizzas on the same day\n- Coupon: Buy exactly 1 pizza on each of two consecutive days\nCannot buy more pizzas than needed on any day, and cannot have unused coupons after the last day.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(pizzas: Seq<int>) -> bool {\n    forall|i: int| 0 <= i < pizzas.len() ==> pizzas[i] >= 0\n}\n\nspec fn validate_pizza_solution(pizzas: Seq<int>, index: int, d: bool, p: int) -> bool\n    decreases pizzas.len() - index\n    when 0 <= index <= pizzas.len() && (p == 0 || p == 1)\n{\n    if index == pizzas.len() {\n        d && p == 0\n    } else {\n        let requirement = pizzas[index];\n        let new_p = if requirement % 2 == 1 { 1 - p } else { p };\n        let new_d = if requirement % 2 == 0 && p == 1 && requirement == 0 { false } else { d };\n        validate_pizza_solution(pizzas, index + 1, new_d, new_p)\n    }\n}\n\nspec fn can_fulfill_requirements(pizzas: Seq<int>) -> bool {\n    validate_pizza_solution(pizzas, 0, true, 0)\n}", "vc-helpers": "", "vc-spec": "fn solve(pizzas: Vec<i8>) -> (result: String)\n    requires\n        forall|i: int| 0 <= i < pizzas.len() ==> pizzas[i] as int >= 0,\n        valid_input(pizzas@.map(|i, x| x as int)),\n    ensures\n        result == \"YES\" ==> can_fulfill_requirements(pizzas@.map(|i, x| x as int)),\n        result == \"NO\" ==> !can_fulfill_requirements(pizzas@.map(|i, x| x as int)),", "vc-code": "{\n    assume(false);\n    \"NO\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0114", "language": "verus", "source": "apps", "source-id": "apps_test_601", "source-notes": "", "vc-description": "Given two people with carrying capacities p and f, and a shop containing cnt_s swords\n(each weighing s units) and cnt_w war axes (each weighing w units), find the maximum\ntotal number of items both people can carry. The input contains multiple test cases.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_func(input: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn process_test_cases_helper(input: Seq<char>, lines: Seq<Seq<char>>, line_idx: int, case_idx: int, total_cases: int, acc: Seq<int>) -> Seq<int> {\n    seq![]\n}\n\nspec fn format_output_helper(results: Seq<int>, idx: int, acc: Seq<char>) -> Seq<char> {\n    seq![]\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    {\n        let lines = split_func(input, '\\n');\n        lines.len() >= 1 &&\n        parse_int_func(lines[0]) >= 0 &&\n        lines.len() >= 1 + 3 * parse_int_func(lines[0])\n    }\n}\n\nspec fn process_test_cases(input: Seq<char>) -> Seq<int> {\n    if valid_input(input) {\n        let lines = split_func(input, '\\n');\n        let t = parse_int_func(lines[0]);\n        process_test_cases_helper(input, lines, 1, 0, t, seq![])\n    } else {\n        seq![]\n    }\n}\n\nspec fn format_output(results: Seq<int>) -> Seq<char> {\n    format_output_helper(results, 0, seq![])\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        input.len() > 0,\n        valid_input(input),\n    ensures\n        result.len() >= 0,\n        result == format_output(process_test_cases(input)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0118", "language": "verus", "source": "apps", "source-id": "apps_test_607", "source-notes": "", "vc-description": "Given integers n and m, compute the sum of happiness values for all permutations of length n, \nmodulo prime number m. A permutation's happiness is the count of its framed segments, where\na framed segment [l,r] satisfies max{elements} - min{elements} = r - l.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, m: int) -> bool {\n    n > 0 && m > 0\n}\n\nspec fn compute_happiness_sum(n: int, m: int) -> int\n    recommends n > 0 && m > 0\n{\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(n: int, m: int) -> (output: int)\n    requires n > 0 && m > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0121", "language": "verus", "source": "apps", "source-id": "apps_test_619", "source-notes": "", "vc-description": "Sasha has x chizhiks and Masha has y chizhiks. Coconuts cost z chizhiks each.\nFind the maximum number of coconuts they can buy together by potentially exchanging\nchizhiks, and determine the minimum number of chizhiks that must be exchanged.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(x: int, y: int, z: int) -> bool {\n    x >= 0 && y >= 0 && z > 0\n}\n\nspec fn max_coconuts(x: int, y: int, z: int) -> int {\n    (x + y) / z\n}\n\nspec fn min_exchange(x: int, y: int, z: int) -> int {\n    let rx = x % z;\n    let ry = y % z;\n    if rx + ry < z { 0 } else { z - if rx > ry { rx } else { ry } }\n}", "vc-helpers": "", "vc-spec": "fn solve(x: i8, y: i8, z: i8) -> (result: (i8, i8))\n    requires valid_input(x as int, y as int, z as int)\n    ensures result.0 as int == max_coconuts(x as int, y as int, z as int) && result.1 as int == min_exchange(x as int, y as int, z as int) && result.0 as int >= (x as int) / (z as int) + (y as int) / (z as int) && result.0 as int <= (x as int) / (z as int) + (y as int) / (z as int) + 1 && result.1 as int >= 0 && result.1 as int < (z as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0124", "language": "verus", "source": "apps", "source-id": "apps_test_631", "source-notes": "", "vc-description": "Given an array of n integers, determine if it's possible to reorder the elements \nto make the double sum equal a target value m. The double sum is defined as\nsum over i from 1 to n of (sum over j from i to n of a_j/j).\nNo elements may be added or removed from the array.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(s: Seq<char>) -> bool {\n    s.len() >= 7 && \n    exists|pos: int| 0 < pos < s.len() && s[pos] == '\\n'\n}\n\nspec fn get_test_count(stdin_input: Seq<char>) -> int {\n    1\n}\n\nspec fn get_array_sum(stdin_input: Seq<char>, test_idx: int) -> int {\n    0\n}\n\nspec fn get_target_m(stdin_input: Seq<char>, test_idx: int) -> int {\n    0\n}\n\nspec fn compute_expected_output(stdin_input: Seq<char>, start_idx: int, count: int) -> Seq<char> {\n    seq![]\n}\n\nspec fn count_responses(result: Seq<char>) -> int {\n    0\n}\n\nspec fn get_response_at_index(result: Seq<char>, i: int) -> Seq<char> {\n    seq![]\n}\n\nspec fn expected_output_for_input(stdin_input: Seq<char>) -> Seq<char> {\n    compute_expected_output(stdin_input, 0, get_test_count(stdin_input))\n}\n\nspec fn behavioral_correctness(stdin_input: Seq<char>, result: Seq<char>) -> bool {\n    let T = get_test_count(stdin_input);\n    count_responses(result) == T &&\n    (forall|i: int| #![trigger get_array_sum(stdin_input, i)] 0 <= i < T ==> {\n        let array_sum = get_array_sum(stdin_input, i);\n        let target_m = get_target_m(stdin_input, i);\n        let response = get_response_at_index(result, i);\n        let yes_response = seq![\n            'Y' as char, 'E' as char, 'S' as char, '\\n' as char\n        ];\n        let no_response = seq![\n            'N' as char, 'O' as char, '\\n' as char\n        ];\n        (array_sum == target_m <==> response == yes_response) &&\n        (array_sum != target_m <==> response == no_response)\n    })\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires valid_input_format(stdin_input@)\n    ensures behavioral_correctness(stdin_input@, result@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0130", "language": "verus", "source": "apps", "source-id": "apps_test_651", "source-notes": "", "vc-description": "Given a 2D maze and a sequence of movement instructions (digits 0-3), determine how many ways\nthe instructions can be interpreted to successfully navigate from start to exit. Each digit\nmust map to a unique direction (up, down, left, right). The robot stops upon reaching the exit\nor crashes when hitting obstacles/boundaries.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_two_ints(s: Seq<char>) -> (int, int) {\n    (0, 0)\n}\n\nspec fn count_occurrences(lines: Seq<Seq<char>>, n: int, m: int, c: char) -> int {\n    0\n}\n\nspec fn find_start(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {\n    (0, 0)\n}\n\nspec fn find_end(lines: Seq<Seq<char>>, n: int, m: int) -> (int, int) {\n    (0, 0)\n}\n\nspec fn count_permutations_reaching_goal(lines: Seq<Seq<char>>, n: int, m: int, path: Seq<char>, start: (int, int), end: (int, int)) -> int {\n    0\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 &&\n    has_valid_dimensions(lines) &&\n    has_valid_grid(lines) &&\n    has_start_and_end(lines) &&\n    has_valid_path(lines)\n}\n\nspec fn has_valid_dimensions(lines: Seq<Seq<char>>) -> bool {\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    n > 0 && m > 0 && lines.len() >= n + 2\n}\n\nspec fn has_valid_grid(lines: Seq<Seq<char>>) -> bool {\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    n > 0 && m > 0 && lines.len() >= n + 2 &&\n    forall|i: int| 1 <= i <= n && i < lines.len() ==>\n        forall|j: int| 0 <= j < lines[i].len() && j < m ==>\n            lines[i][j] == '.' || lines[i][j] == '#' || \n            lines[i][j] == 'S' || lines[i][j] == 'E'\n}\n\nspec fn has_start_and_end(lines: Seq<Seq<char>>) -> bool {\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    n > 0 && m > 0 && lines.len() >= n + 2 &&\n    (exists|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() && j < m && lines[i][j] == 'S') &&\n    (exists|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() && j < m && lines[i][j] == 'E') &&\n    count_occurrences(lines, n, m, 'S') == 1 &&\n    count_occurrences(lines, n, m, 'E') == 1\n}\n\nspec fn has_valid_path(lines: Seq<Seq<char>>) -> bool {\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    n > 0 && m > 0 && lines.len() >= n + 2 &&\n    valid_path_string(lines[n + 1])\n}\n\nspec fn valid_path_string(path: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < path.len() ==> \n        '0' <= path[i] && path[i] <= '3'\n}\n\nspec fn valid_result(result: Seq<char>) -> bool {\n    result.len() > 0 &&\n    forall|c: char| result.contains(c) ==> \n        ('0' <= c && c <= '9') || c == '\\n'\n}\n\nspec fn count_valid_ways(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let dimensions = parse_two_ints(lines[0]);\n    let n = dimensions.0;\n    let m = dimensions.1;\n    let start = find_start(lines, n, m);\n    let end = find_end(lines, n, m);\n    let path = lines[n + 1];\n    count_permutations_reaching_goal(lines, n, m, path, start, end)\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input.len() > 0", "vc-code": "{\n    // impl-start\n    assume(false);\n    String::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0131", "language": "verus", "source": "apps", "source-id": "apps_test_656", "source-notes": "", "vc-description": "Given n winter days with temperature forecasts, minimize tire changes to drive safely.\nStart with summer tires (safe when temp >= 0). Winter tires safe at any temp but \nlimited to k days total. Must drive safely every day. Can change tires at start of any day.\nReturn minimum tire changes needed, or -1 if impossible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn count_negative_temp_days(temps: Seq<int>) -> int\n    decreases temps.len()\n{\n    if temps.len() == 0 {\n        0int\n    } else {\n        (if temps[0] < 0 { 1int } else { 0int }) + count_negative_temp_days(temps.subrange(1, temps.len() as int))\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, temps: Vec<i8>) -> (result: i8)\n    requires \n        n >= 1,\n        k >= 0 && k <= n,\n        temps@.len() == n as nat,\n        forall|i: int| 0 <= i < n as int ==> #[trigger] temps@[i] as int >= -20 && #[trigger] temps@[i] as int <= 20,\n    ensures \n        result as int == -1 <==> count_negative_temp_days(temps@.map(|i, x: i8| x as int)) > k as int,\n        result != -1 ==> result >= 0,\n        result as int == 0 ==> forall|i: int| 0 <= i < n as int ==> #[trigger] temps@[i] as int >= 0,\n        result > 0 ==> exists|i: int| 0 <= i < n as int && #[trigger] temps@[i] as int < 0,", "vc-code": "{\n    assume(false);\n    0i8\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0138", "language": "verus", "source": "apps", "source-id": "apps_test_701", "source-notes": "", "vc-description": "Given two distinct strings s and t, determine if s can be transformed into t using character removal and/or character swapping operations.\nReturn \"array\" if only swapping needed, \"automaton\" if only removal needed, \"both\" if both operations needed, or \"need tree\" if impossible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn parse_lines(stdin_input: Seq<char>) -> Seq<Seq<char>>\n    decreases stdin_input.len()\n{\n    if stdin_input.len() == 0 {\n        seq![]\n    } else {\n        let newline_pos = find_newline(stdin_input, 0);\n        if newline_pos == -1 {\n            seq![stdin_input]\n        } else if newline_pos == 0 {\n            parse_lines(stdin_input.subrange(1, stdin_input.len() as int))\n        } else if newline_pos < stdin_input.len() && newline_pos >= 0 {\n            seq![stdin_input.subrange(0, newline_pos)] + parse_lines(stdin_input.subrange(newline_pos + 1, stdin_input.len() as int))\n        } else {\n            seq![]\n        }\n    }\n}\n\nspec fn find_newline(s: Seq<char>, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() {\n        -1\n    } else if s[start] == '\\n' {\n        start\n    } else {\n        find_newline(s, start + 1)\n    }\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    let lines = parse_lines(stdin_input);\n    lines.len() >= 2 && lines[0].len() > 0 && lines[1].len() > 0 &&\n    (forall|i: int| 0 <= i < lines[0].len() ==> 'a' <= lines[0][i] <= 'z') &&\n    (forall|i: int| 0 <= i < lines[1].len() ==> 'a' <= lines[1][i] <= 'z')\n}\n\nspec fn is_subsequence(s: Seq<char>, t: Seq<char>) -> bool {\n    if s.len() == 0 {\n        true\n    } else if t.len() == 0 {\n        false\n    } else if s[0] == t[0] {\n        is_subsequence(s.subrange(1, s.len() as int), t.subrange(1, t.len() as int))\n    } else {\n        is_subsequence(s, t.subrange(1, t.len() as int))\n    }\n}\n\nspec fn sort_string(s: Seq<char>) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() <= 1 {\n        s\n    } else {\n        let pivot = s[0];\n        let smaller = filter_chars(s.subrange(1, s.len() as int), pivot, true, false);\n        let equal = filter_chars(s, pivot, false, true);\n        let larger = filter_chars(s.subrange(1, s.len() as int), pivot, false, false);\n        sort_string(smaller) + equal + sort_string(larger)\n    }\n}\n\nspec fn filter_chars(s: Seq<char>, pivot: char, take_less: bool, take_equal: bool) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let first = s[0];\n        let rest = filter_chars(s.subrange(1, s.len() as int), pivot, take_less, take_equal);\n        if (take_less && first < pivot) || (take_equal && first == pivot) || (!take_less && !take_equal && first > pivot) {\n            seq![first] + rest\n        } else {\n            rest\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: &'static str)", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"array\"\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0141", "language": "verus", "source": "apps", "source-id": "apps_test_715", "source-notes": "", "vc-description": "Given a multiple-choice question with four options (A, B, C, D), predict a child's choice.\nCalculate the length of each option's description (excluding prefix \"A.\", \"B.\", etc.).\nA choice is \"great\" if its description is either at least twice shorter than all others\nOR at least twice longer than all others. If exactly one choice is great, select it.\nOtherwise, select choice C.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_result(result: &str) -> bool {\n    result == \"A\" || result == \"B\" || result == \"C\" || result == \"D\"\n}\n\nspec fn choice_from_index(index: int) -> &'static str\n    recommends 0 <= index <= 3\n{\n    if index == 0 { \"A\" }\n    else if index == 1 { \"B\" }\n    else if index == 2 { \"C\" }\n    else { \"D\" }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn sort_lengths_with_indices(lengths: Seq<int>) -> Seq<(int, int)>\n    recommends lengths.len() == 4\n{\n    Seq::empty()\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (result: &'static str)\n    requires input.len() > 0\n    ensures valid_result(result)", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"C\"\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0143", "language": "verus", "source": "apps", "source-id": "apps_test_726", "source-notes": "", "vc-description": "Given n hotels at distinct integer coordinates on a number line, find the number of positions \nwhere a new hotel can be built such that the minimum distance from the new hotel to any \nexisting hotel is exactly d.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_sorted(hotels: Seq<int>, n: int) -> bool\n    decreases n\n{\n    if n <= 1 {\n        true\n    } else {\n        hotels[n-2] < hotels[n-1] && is_sorted(hotels, n-1)\n    }\n}\n\nspec fn valid_input(n: int, d: int, hotels: Seq<int>) -> bool {\n    n > 0 && d > 0 && hotels.len() == n && is_sorted(hotels, n)\n}\n\nspec fn sum_contributions(hotels: Seq<int>, d: int, i: int) -> int\n    recommends 0 <= i && i <= hotels.len() - 1,\n                d > 0,\n                is_sorted(hotels, hotels.len() as int)\n    decreases i\n    when i >= 0\n{\n    if i == 0 { \n        0 \n    } else {\n        let gap = hotels[i as int] - hotels[(i-1) as int];\n        let contribution: int = if gap == 2*d { 1 } else if gap > 2*d { 2 } else { 0 };\n        contribution + sum_contributions(hotels, d, i-1)\n    }\n}\n\nspec fn correct_result(n: int, d: int, hotels: Seq<int>, result: int) -> bool\n    recommends valid_input(n, d, hotels)\n{\n    result == 2 + sum_contributions(hotels, d, n-1) && result >= 2\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, d: i8, hotels: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, d as int, hotels@.map(|_, x: i8| x as int))\n    ensures correct_result(n as int, d as int, hotels@.map(|_, x: i8| x as int), result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0145", "language": "verus", "source": "apps", "source-id": "apps_test_743", "source-notes": "", "vc-description": "Given n positive integers, repeatedly perform operations where you select two indices i,j\nwith x_i > x_j and set x_i = x_i - x_j. Find the minimum possible sum after any number of operations.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn valid_input(n: int, ar: Seq<int>) -> bool {\n    n >= 2 && ar.len() == n && (forall|i: int| 0 <= i < n ==> ar[i] > 0)\n}\n\nspec fn gcd(x: int, y: int) -> int\n    requires x > 0 && y > 0,\n    ensures gcd(x, y) > 0,\n    decreases if x < y { y } else { x },\n{\n    if x == y { x }\n    else if x < y { gcd(x, y - x) }\n    else { gcd(x - y, y) }\n}\n\nspec fn gcd_of_sequence(ar: Seq<int>) -> int\n    requires ar.len() >= 1,\n    requires (forall|i: int| 0 <= i < ar.len() ==> ar[i] > 0),\n    ensures gcd_of_sequence(ar) > 0,\n    decreases ar.len(),\n{\n    if ar.len() == 1 { ar[0] }\n    else { gcd(ar[0], gcd_of_sequence(ar.subrange(1, ar.len() as int))) }\n}\n\nspec fn minimal_sum(n: int, ar: Seq<int>) -> int\n    requires valid_input(n, ar),\n{\n    gcd_of_sequence(ar) * n\n}", "vc-spec": "fn solve(n: int, ar: Seq<int>) -> (result: int)\n    requires valid_input(n, ar),\n    ensures result == minimal_sum(n, ar),\n    ensures result > 0,", "vc-code": "{\n    assume(false);\n    0\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0149", "language": "verus", "source": "apps", "source-id": "apps_test_752", "source-notes": "", "vc-description": "Given two lists of T-shirt sizes (previous year and current year), find the minimum number \nof character replacements needed to transform the previous year's list into the current year's \nlist. Each replacement changes one character in one T-shirt size to any uppercase Latin letter. \nThe lists are unordered (only the frequency of each size matters).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: &str) -> Seq<&str>\n    uninterp;\n\nspec fn parse_integer(s: &str) -> int\n    uninterp;\n\nspec fn count_sizes(sizes: Seq<&str>) -> Map<&str, nat>\n    uninterp;\n\nspec fn count_unmatched_sizes(prev_sizes: Map<&str, nat>, current_sizes: Seq<&str>) -> nat\n    uninterp;\n\nspec fn int_to_string(n: nat) -> String\n    uninterp;\n\nspec fn valid_input(stdin_input: &str) -> bool {\n    let lines = split_lines(stdin_input);\n    lines.len() >= 1 && {\n        let n = parse_integer(lines[0]);\n        n >= 0 && lines.len() >= (2 * n + 1) && \n        (forall|i: int| 1 <= i <= 2 * n ==> \n            i < lines.len() && lines[i].len() > 0)\n    }\n}\n\nspec fn compute_mismatches(stdin_input: &str) -> nat\n    decreases stdin_input.len()\n{\n    let lines = split_lines(stdin_input);\n    let n = parse_integer(lines[0]);\n    if n == 0 { \n        0 \n    } else {\n        let prev_sizes = count_sizes(lines.subrange(1, n + 1));\n        let current_sizes = lines.subrange(n + 1, 2 * n + 1);\n        count_unmatched_sizes(prev_sizes, current_sizes)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires \n        stdin_input.len() > 0,\n        valid_input(stdin_input),\n    ensures \n        result.len() > 0,\n        result.as_bytes()[result.len()-1] == b'\\n' || \n            (result.len() > 1 && result.as_bytes().subrange(result.len()-2, result.len()) == seq![b'\\r', b'\\n']),\n        exists|mismatches: nat| \n            result == int_to_string(mismatches) + \"\\n\" && \n            mismatches == compute_mismatches(stdin_input),\n        ({\n            let lines = split_lines(stdin_input);\n            let n = parse_integer(lines[0]);\n            n >= 0 ==> {\n                let mismatches = compute_mismatches(stdin_input);\n                mismatches <= n &&\n                result == int_to_string(mismatches) + \"\\n\"\n            }\n        }),", "vc-code": "{\n    // impl-start\n    assume(false);\n    String::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0150", "language": "verus", "source": "apps", "source-id": "apps_test_753", "source-notes": "", "vc-description": "Given a monitor with aspect ratio a:b and a movie with aspect ratio c:d,\nfit the movie on screen while preserving its aspect ratio and maximizing area.\nCalculate the ratio of empty screen area to total screen area as an irreducible fraction.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn gcd(a: int, b: int) -> int\n    decreases (if b == 0 { 0 } else { (if b >= 0 { b } else { -b }) })\n{\n    if b == 0 {\n        if a >= 0 { a } else { -a }\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nspec fn valid_input(a: int, b: int, c: int, d: int) -> bool {\n    a > 0 && b > 0 && c > 0 && d > 0\n}\n\nspec fn is_valid_fraction_string(s: Seq<char>, num: int, den: int) -> bool {\n    num >= 0 && den > 0 && \n    gcd(num, den) == 1\n    /* && s == int_to_string(num) + \"/\" + int_to_string(den) */\n}", "vc-helpers": "", "vc-spec": "fn solve(a: int, b: int, c: int, d: int) -> (result: Seq<char>)\n    requires valid_input(a, b, c, d)\n    ensures ({\n        let equal_case = a * d == b * c;\n        let greater_case = a * d > b * c;\n        let less_case = a * d < b * c;\n        \n        (equal_case ==> result == seq!['0', '/', '1']) &&\n        (greater_case ==> exists|numerator: int, denominator: int| \n            numerator > 0 && denominator > 0 && \n            gcd(numerator, denominator) == 1 &&\n            numerator * a * d == (a * d - b * c) * denominator) &&\n        (less_case ==> exists|numerator: int, denominator: int| \n            numerator > 0 && denominator > 0 && \n            gcd(numerator, denominator) == 1 &&\n            numerator * b * c == (b * c - a * d) * denominator)\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0153", "language": "verus", "source": "apps", "source-id": "apps_test_756", "source-notes": "", "vc-description": "Given a 90-minute game with certain interesting minutes, determine how many\nminutes are watched before turning off the TV. The TV turns off immediately\nafter 15 consecutive boring minutes occur.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 1 && n <= 90 &&\n    a.len() == n &&\n    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= 90) &&\n    (forall|i: int, j: int| i + 1 == j && 0 <= i < n - 1 ==> #[trigger] a[i] < #[trigger] a[j])\n}\n\nspec fn find_cutoff(a: Seq<int>, index: int, cutoff: int) -> int\n    decreases a.len() - index\n    when 0 <= index <= a.len()\n{\n    if index >= a.len() {\n        cutoff\n    } else if a[index] > cutoff {\n        cutoff\n    } else {\n        find_cutoff(a, index + 1, a[index] + 15)\n    }\n}\n\nspec fn min(x: int, y: int) -> int {\n    if x <= y { x } else { y }\n}\n\nspec fn valid_output(result: int, n: int, a: Seq<int>) -> bool {\n    valid_input(n, a) ==>\n    (1 <= result <= 90 &&\n     result == min(90, find_cutoff(a, 0, 15)))\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a@.map(|x| x as int))\n    ensures valid_output(result as int, n as int, a@.map(|x| x as int))", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0158", "language": "verus", "source": "apps", "source-id": "apps_test_787", "source-notes": "", "vc-description": "Given a string q and an integer k, split the string into exactly k non-empty substrings\nsuch that the substrings concatenate to form the original string and each substring \nstarts with a different character (all first characters are distinct).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn concat_seqs(seqs: Seq<Seq<char>>) -> Seq<char>\n    decreases seqs.len()\n{\n    if seqs.len() == 0 { \n        Seq::<char>::empty() \n    } else { \n        seqs[0] + concat_seqs(seqs.subrange(1, seqs.len() as int))\n    }\n}\n\nspec fn valid_split(result: Seq<Seq<char>>, k: int, q: Seq<char>) -> bool {\n    result.len() == k &&\n    (forall|i: int| 0 <= i < result.len() ==> result[i].len() > 0) &&\n    (forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i][0] != result[j][0]) &&\n    concat_seqs(result) == q\n}", "vc-helpers": "", "vc-spec": "fn solve(k: i8, q: Vec<char>) -> (result: Vec<Vec<char>>)\n    requires \n        k >= 0,\n        q.len() >= 0,\n    ensures \n        k <= 0 || q.len() == 0 ==> result.len() == 0,\n        k > 0 && q.len() > 0 ==> (\n            (result.len() == 0) || valid_split(Seq::new(result.len(), |i: int| result[i]@), k as int, q@)\n        ),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0164", "language": "verus", "source": "apps", "source-id": "apps_test_807", "source-notes": "", "vc-description": "Find maximum profit from borrowing a honey barrel on day d, selling it for price x_d,\nbuying a new barrel on day d+1 for price x_{d+1}, and paying rental cost c.\nProfit = x_d - x_{d+1} - c. Only execute if profitable, otherwise return 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, c: int, prices: Seq<int>) -> bool {\n    n >= 2 && prices.len() == n && c >= 0 &&\n    (forall|i: int| 0 <= i < prices.len() ==> prices[i] >= 0)\n}\n\nspec fn profit_for_day(prices: Seq<int>, day: int, c: int) -> int {\n    if 0 <= day < prices.len() - 1 {\n        prices[day] - prices[day + 1] - c\n    } else {\n        0\n    }\n}\n\nspec fn max_possible_profit(prices: Seq<int>, c: int) -> int {\n    if prices.len() >= 2 {\n        let profits = Seq::new((prices.len() - 1) as nat, |i: int| profit_for_day(prices, i, c));\n        if profits.len() == 0 { \n            0 \n        } else {\n            let max_profit = profits[0];\n            if profits.len() == 1 { \n                max_profit \n            } else { \n                seq_max(profits) \n            }\n        }\n    } else {\n        0\n    }\n}\n\nspec fn seq_max(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() > 0 {\n        if s.len() == 1 { \n            s[0] \n        } else if s[0] >= seq_max(s.subrange(1, s.len() as int)) { \n            s[0] \n        } else { \n            seq_max(s.subrange(1, s.len() as int)) \n        }\n    } else {\n        0\n    }\n}\n\nspec fn correct_result(n: int, c: int, prices: Seq<int>, result: int) -> bool {\n    valid_input(n, c, prices) ==>\n    (result >= 0 &&\n     (result == 0 <==> (forall|i: int| 0 <= i < n - 1 ==> profit_for_day(prices, i, c) <= 0)) &&\n     (result > 0 ==> (exists|i: int| 0 <= i < n - 1 && profit_for_day(prices, i, c) == result)) &&\n     (forall|i: int| 0 <= i < n - 1 ==> profit_for_day(prices, i, c) <= result))\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, c: i8, prices: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, c as int, prices@.map(|v| v as int))\n    ensures correct_result(n as int, c as int, prices@.map(|v| v as int), result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0166", "language": "verus", "source": "apps", "source-id": "apps_test_813", "source-notes": "", "vc-description": "Given n apples numbered 1 to n, distribute all apples between two hamsters (Arthur and Alexander) \nsuch that each hamster receives only apples they like. Arthur gets '1', Alexander gets '2'.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 && split_spaces(lines[0]).len() >= 3 &&\n    {\n        let n = parse_int(split_spaces(lines[0])[0]);\n        n > 0\n    }\n}\n\nspec fn valid_output(input: Seq<char>, result: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    let n = parse_int(split_spaces(lines[0])[0]);\n    result.len() == 2 * n - 1 &&\n    (forall|i: int| 0 <= i < n ==> #[trigger] result[2*i] == '1' || result[2*i] == '2') &&\n    (forall|i: int| 0 <= i < n-1 ==> #[trigger] result[2*i+1] == ' ')\n}\n\nspec fn correct_assignment(input: Seq<char>, result: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    let n = parse_int(split_spaces(lines[0])[0]);\n    let arthur_apples = parse_int_seq(split_spaces(lines[1]));\n    let arthur_set = Set::new(|x: int| arthur_apples.contains(x));\n    forall|i: int| 1 <= i <= n ==> \n        (arthur_set.contains(i) ==> #[trigger] result[2*(i-1)] == '1') &&\n        (!arthur_set.contains(i) ==> result[2*(i-1)] == '2')\n}\n\n/* Helper functions for parsing (spec functions) */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_seq(strs: Seq<Seq<char>>) -> Seq<int> {\n    Seq::empty()\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Vec<char>) -> (result: Vec<char>)\n    requires input.len() > 0\n    ensures \n        !valid_input(input@) ==> result.len() == 0,\n        valid_input(input@) ==> valid_output(input@, result@) && correct_assignment(input@, result@),\n        forall|i: int| 0 <= i < result.len() ==> #[trigger] result[i] == '1' || result[i] == '2' || result[i] == ' ',", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0175", "language": "verus", "source": "apps", "source-id": "apps_test_864", "source-notes": "", "vc-description": "Given n participants and m food packages where each package has a food type,\ndetermine the maximum number of days an expedition can last under these constraints:\n- Each participant eats exactly one package per day\n- Each participant must eat the same food type throughout the entire expedition\n- Different participants can eat different food types", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn possible(n: int, food_types: Seq<int>, days: int) -> bool\n    recommends n >= 0, days >= 0, forall|i: int| 0 <= i < food_types.len() ==> food_types[i] >= 1\n{\n    if days == 0 { true }\n    else {\n        let total_participants = count_total_participants(food_types, days, 1);\n        total_participants >= n\n    }\n}\n\nspec fn count_total_participants(food_types: Seq<int>, days: int, current_type: int) -> int\n    recommends days >= 0, current_type >= 1\n    decreases 101 - current_type\n{\n    if current_type > 100 { 0 }\n    else {\n        let packages_of_this_type = count_packages(food_types, current_type);\n        let participants_for_this_type = if days > 0 { packages_of_this_type / days } else { 0 };\n        participants_for_this_type + count_total_participants(food_types, days, current_type + 1)\n    }\n}\n\nspec fn count_packages(food_types: Seq<int>, target_type: int) -> int\n    recommends target_type >= 1\n    decreases food_types.len()\n{\n    if food_types.len() == 0 { 0 }\n    else if food_types[0] == target_type { 1 + count_packages(food_types.subrange(1, food_types.len() as int), target_type) }\n    else { count_packages(food_types.subrange(1, food_types.len() as int), target_type) }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, food_types: Vec<i8>) -> (result: i8)\n    requires 1 <= n <= 100,\n             1 <= m <= 100,\n             food_types@.len() == m as int,\n             forall|i: int| 0 <= i < food_types@.len() ==> #[trigger] food_types@[i] >= 1 && #[trigger] food_types@[i] <= 100\n    ensures result >= 0,\n            result <= m,\n            result > 0 ==> possible(n as int, food_types@.map(|i, x: i8| x as int), result as int),\n            !possible(n as int, food_types@.map(|i, x: i8| x as int), result as int + 1),\n            forall|d: int| #[trigger] possible(n as int, food_types@.map(|i, x: i8| x as int), d) ==> d <= result as int", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0177", "language": "verus", "source": "apps", "source-id": "apps_test_877", "source-notes": "", "vc-description": "Given n problems numbered 1 to n in ascending order of difficulty and m pairs \nof similar problems, split the problems into two non-empty divisions such that:\n1. Each problem belongs to exactly one division\n2. All problems in division 1 are harder than all problems in division 2  \n3. Similar problems must be in different divisions\nCount the number of valid ways to make this split.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, pairs: Seq<(int, int)>) -> bool {\n    n >= 2 && \n    m >= 0 && \n    pairs.len() == m &&\n    (forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i].0 >= 1 && #[trigger] pairs[i].0 <= n && #[trigger] pairs[i].1 >= 1 && #[trigger] pairs[i].1 <= n) &&\n    (forall|i: int| 0 <= i < pairs.len() ==> #[trigger] pairs[i].0 != #[trigger] pairs[i].1)\n}\n\nspec fn compute_final_l(pairs: Seq<(int, int)>) -> int\n    decreases pairs.len()\n{\n    if pairs.len() == 0 { 1 }\n    else {\n        let x = pairs[pairs.len() - 1].0;\n        let y = pairs[pairs.len() - 1].1;\n        let min_val = if x < y { x } else { y };\n        let rest_l = compute_final_l(pairs.subrange(0, pairs.len() - 1));\n        if rest_l > min_val { rest_l } else { min_val }\n    }\n}\n\nspec fn compute_final_r(n: int, pairs: Seq<(int, int)>) -> int\n    decreases pairs.len()\n{\n    if pairs.len() == 0 { n }\n    else {\n        let x = pairs[pairs.len() - 1].0;\n        let y = pairs[pairs.len() - 1].1;\n        let max_val = if x > y { x } else { y };\n        let rest_r = compute_final_r(n, pairs.subrange(0, pairs.len() - 1));\n        if rest_r < max_val { rest_r } else { max_val }\n    }\n}\n\nspec fn max(a: int, b: int) -> int {\n    if a > b { a } else { b }\n}\n\nspec fn valid_result(n: int, pairs: Seq<(int, int)>, result: int) -> bool {\n    result >= 0 &&\n    result <= n - 1 &&\n    result == max(compute_final_r(n, pairs) - compute_final_l(pairs), 0)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, pairs: Vec<(i8, i8)>) -> (result: i8)\n    requires valid_input(n as int, m as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)))\n    ensures valid_result(n as int, seq![p | p in pairs@].map(|p: (i8, i8)| (p.0 as int, p.1 as int)), result as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0179", "language": "verus", "source": "apps", "source-id": "apps_test_889", "source-notes": "", "vc-description": "Given a 4×4 grid where each cell is either black ('#') or white ('.'), \ndetermine if it's possible to create a 2×2 square of uniform color by \nrepainting at most one cell. Return \"YES\" if possible, \"NO\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn parse_input_lines(input: Seq<char>) -> Seq<Seq<char>>\n{\n    split_by_newline_simple(input, 0, seq![])\n}\n\nspec fn split_by_newline_simple(input: Seq<char>, pos: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>>\n    decreases input.len() - pos\n{\n    if pos >= input.len() {\n        acc\n    } else {\n        let next_newline = find_next_newline(input, pos);\n        if next_newline == -1 {\n            if pos < input.len() {\n                acc.push(input.subrange(pos, input.len() as int))\n            } else {\n                acc\n            }\n        } else {\n            split_by_newline_simple(input, next_newline + 1, acc.push(input.subrange(pos, next_newline)))\n        }\n    }\n}\n\nspec fn find_next_newline(input: Seq<char>, start: int) -> int\n    decreases input.len() - start\n{\n    if start >= input.len() {\n        -1\n    } else if input[start] == '\\n' {\n        start\n    } else {\n        find_next_newline(input, start + 1)\n    }\n}\n\nspec fn count_black_in_square(lines: Seq<Seq<char>>, row: int, col: int) -> int\n{\n    (if lines[row][col] == '#' { 1int } else { 0int }) +\n    (if lines[row][col + 1] == '#' { 1int } else { 0int }) +\n    (if lines[row + 1][col] == '#' { 1int } else { 0int }) +\n    (if lines[row + 1][col + 1] == '#' { 1int } else { 0int })\n}\n\nspec fn valid_grid(lines: Seq<Seq<char>>) -> bool\n{\n    lines.len() == 4 && (forall|k: int| 0 <= k < 4 ==> lines[k].len() >= 4)\n}\n\nspec fn can_make_uniform_square(lines: Seq<Seq<char>>) -> bool\n{\n    exists|i: int, j: int| 0 <= i <= 2 && 0 <= j <= 2 && \n        i + 1 < lines.len() && j + 1 < lines[i].len() && j + 1 < lines[i + 1].len() &&\n        {\n            let black_count = count_black_in_square(lines, i, j);\n            black_count >= 3 || black_count <= 1\n        }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    ensures result@ =~= seq!['Y', 'E', 'S'] || result@ =~= seq!['N', 'O']", "vc-code": "{\n    assume(false);\n    String::new()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0182", "language": "verus", "source": "apps", "source-id": "apps_test_901", "source-notes": "", "vc-description": "Given n parallel universes and m groups, determine if there exists a scenario \nwhere at least one group contains only traitors. In each universe, exactly one \nperson (Rick or Morty) is a traitor. A group is dangerous if all its members \ncould potentially be traitors in some assignment, which happens when the group \ndoesn't contain both Rick and Morty from any single universe.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn split_lines(s: &str) -> Seq<&str>\n{\n    if s.len() == 0 { seq![] } else { seq![s] }\n}\n\nspec fn split_ints(s: &str) -> Seq<int>\n{\n    seq![]\n}\n\nspec fn seq_to_set(s: Seq<int>) -> Set<int>\n{\n    s.to_set()\n}\n\nspec fn is_dangerous_group(group_data: Seq<int>) -> bool\n{\n    if group_data.len() <= 1 { \n        false \n    } else {\n        let group_members = group_data.subrange(1, group_data.len() as int);\n        let member_set = seq_to_set(group_members);\n        forall|member: int| member_set.contains(member) ==> !member_set.contains(-member)\n    }\n}\n\nspec fn exists_dangerous_group(stdin_input: &str) -> bool\n{\n    let lines = split_lines(stdin_input);\n    if lines.len() == 0 { \n        false \n    } else {\n        let first_line = split_ints(lines[0]);\n        if first_line.len() < 2 { \n            false \n        } else {\n            let n = first_line[0];\n            let m = first_line[1];\n            if m <= 0 || n <= 0 { \n                false \n            } else {\n                exists|i: int| 1 <= i <= m && i < lines.len() && \n                    is_dangerous_group(split_ints(lines[i]))\n            }\n        }\n    }\n}", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input.len() > 0\n    ensures (result == \"YES\\n\") || (result == \"NO\\n\")", "vc-code": "{\n    assume(false);\n    \"NO\\n\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0184", "language": "verus", "source": "apps", "source-id": "apps_test_911", "source-notes": "", "vc-description": "Given n problems with initial scores and solving times, where problems are sorted by increasing\ndifficulty. Two contestants (Limak and Radewoosh) solve all problems in opposite orders.\nWhen problem i is submitted at time x, it awards max(0, p_i - c*x) points where c is penalty rate.\nDetermine who scores more total points.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, c: int, p: Seq<int>, t: Seq<int>) -> bool {\n    n > 0 && c > 0 && p.len() == n && t.len() == n &&\n    (forall|i: int| 0 <= i < n ==> p[i] > 0) &&\n    (forall|i: int| 0 <= i < n ==> t[i] > 0) &&\n    (forall|i: int| 0 <= i < n-1 ==> p[i] < p[i+1]) &&\n    (forall|i: int| 0 <= i < n-1 ==> t[i] < t[i+1])\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 }\n    else { s[0] + sum_seq(s.drop_first()) }\n}\n\nspec fn calculate_limak_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int\n    requires n > 0 && p.len() == n && t.len() == n\n    decreases n\n{\n    if n == 0 { 0 }\n    else { \n        let cumulative_time = sum_seq(t.take(1));\n        let score = if p[0] - c * cumulative_time > 0 { p[0] - c * cumulative_time } else { 0 };\n        score + calculate_limak_score_helper(n-1, c, p.skip(1), t.skip(1), cumulative_time)\n    }\n}\n\nspec fn calculate_limak_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int\n    requires remaining >= 0 && p.len() == remaining && t.len() == remaining\n    decreases remaining\n{\n    if remaining == 0 { 0 }\n    else { \n        let cumulative_time = prev_time + t[0];\n        let score = if p[0] - c * cumulative_time > 0 { p[0] - c * cumulative_time } else { 0 };\n        score + calculate_limak_score_helper(remaining-1, c, p.skip(1), t.skip(1), cumulative_time)\n    }\n}\n\nspec fn calculate_radewoosh_score(n: int, c: int, p: Seq<int>, t: Seq<int>) -> int\n    requires n > 0 && p.len() == n && t.len() == n\n{\n    calculate_radewoosh_score_helper(n, c, p, t, 0)\n}\n\nspec fn calculate_radewoosh_score_helper(remaining: int, c: int, p: Seq<int>, t: Seq<int>, prev_time: int) -> int\n    requires remaining >= 0 && p.len() >= remaining && t.len() >= remaining\n    decreases remaining\n{\n    if remaining == 0 { 0 }\n    else { \n        let idx = remaining - 1;\n        let cumulative_time = prev_time + t[idx];\n        let score = if p[idx] - c * cumulative_time > 0 { p[idx] - c * cumulative_time } else { 0 };\n        score + calculate_radewoosh_score_helper(remaining-1, c, p, t, cumulative_time)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: int, c: int, p: Seq<int>, t: Seq<int>) -> (result: String)\n    requires valid_input(n, c, p, t)\n    ensures result == \"Limak\" || result == \"Radewoosh\" || result == \"Tie\"\n    ensures {\n            let limak_score = calculate_limak_score(n, c, p, t);\n            let radewoosh_score = calculate_radewoosh_score(n, c, p, t);\n            (result == \"Limak\") == (limak_score > radewoosh_score) &&\n            (result == \"Radewoosh\") == (limak_score < radewoosh_score) &&\n            (result == \"Tie\") == (limak_score == radewoosh_score)\n    }", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0195", "language": "verus", "source": "apps", "source-id": "apps_test_966", "source-notes": "", "vc-description": "Given a year number, find the minimum year that is strictly greater than the given year \nand contains only distinct digits (no repeated digits).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(y: int) -> bool {\n    1000 <= y <= 9000\n}\n\nspec fn has_distinct_digits(n: int) -> bool {\n    let digits = number_to_digits(n);\n    all_distinct(digits)\n}\n\nspec fn number_to_digits(n: int) -> Seq<int> {\n    if n == 0 { seq![0] }\n    else if n > 0 { number_to_digits_helper(n, seq![]) }\n    else { number_to_digits_helper(-n, seq![]) }\n}\n\nspec fn number_to_digits_helper(n: int, acc: Seq<int>) -> Seq<int>\n    decreases n when n >= 0\n{\n    if n == 0 { acc }\n    else { number_to_digits_helper(n / 10, seq![n % 10].add(acc)) }\n}\n\nspec fn all_distinct(digits: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < digits.len() ==> digits[i] != digits[j]\n}", "vc-helpers": "", "vc-spec": "fn solve(y: i8) -> (result: i8)\n    requires valid_input(y as int)\n    ensures \n        result as int > y as int,\n        has_distinct_digits(result as int),\n        forall|n: int| y as int < n && n < result as int ==> !has_distinct_digits(n)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0202", "language": "verus", "source": "apps", "source-id": "apps_test_992", "source-notes": "", "vc-description": "Given N positive integers A₁, A₂, ..., Aₙ and a positive integer S,\nfor each non-empty subset T of {1, 2, ..., N}, define f(T) as the number \nof non-empty subsets of T whose corresponding A values sum to S.\nFind the sum of f(T) over all 2ᴺ - 1 non-empty subsets T, modulo 998244353.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, s: int, a: Seq<int>) -> bool {\n    n >= 1 && n <= 3000 &&\n    s >= 1 && s <= 3000 &&\n    a.len() == n &&\n    forall|i: int| 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000\n}\n\nspec fn compute_subset_sum_ways(n: int, s: int, a: Seq<int>) -> int {\n    let dp = compute_dp_table(n, s, a);\n    if dp.len() > n && dp[n].len() > s { dp[n][s] } else { 0 }\n}\n\nspec fn compute_dp_table(n: int, s: int, a: Seq<int>) -> Seq<Seq<int>>\n    decreases n\n{\n    if n == 1 {\n        let base = Seq::new(s+1, |j: int| if j == 0 { 1 } else { 0 });\n        let new_row = Seq::new(s+1, |j: int| {\n            let doubled = (base[j] * 2) % 998244353;\n            if j >= a[0] && j - a[0] >= 0 && j - a[0] < s+1 { \n                (doubled + base[j - a[0]]) % 998244353\n            } else { \n                doubled\n            }\n        });\n        seq![base, new_row]\n    } else {\n        let prev_dp = compute_dp_table(n-1, s, a.subrange(0, n-1));\n        let new_row = Seq::new(s+1, |j: int| {\n            let doubled = (prev_dp[n-1][j] * 2) % 998244353;\n            if j >= a[n-1] && j - a[n-1] >= 0 && j - a[n-1] < s+1 {\n                (doubled + prev_dp[n-1][j - a[n-1]]) % 998244353\n            } else {\n                doubled\n            }\n        });\n        prev_dp.push(new_row)\n    }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![], seq![]]\n}\n\nspec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn valid_parsed_input(input: Seq<char>, n: int, s: int, a: Seq<int>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 && {\n        let first_line = split_whitespace(lines[0]);\n        let second_line = split_whitespace(lines[1]);\n        first_line.len() >= 2 && second_line.len() == n &&\n        n == string_to_int(first_line[0]) &&\n        s == string_to_int(first_line[1]) &&\n        a.len() == n &&\n        (forall|i: int| 0 <= i < n ==> (a[i] == string_to_int(second_line[i]))) &&\n        valid_input(n, s, a)\n    }\n}\n\nspec fn valid_parsed_input_exists(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() < 2 {\n        false\n    } else {\n        let first_line = split_whitespace(lines[0]);\n        let second_line = split_whitespace(lines[1]);\n        if first_line.len() < 2 || second_line.len() == 0 {\n            false\n        } else {\n            let n = string_to_int(first_line[0]);\n            let s = string_to_int(first_line[1]);\n            n >= 1 && n <= 3000 && s >= 1 && s <= 3000 && second_line.len() == n &&\n            forall|i: int| 0 <= i < n ==> {\n                let ai = string_to_int(second_line[i]);\n                ai >= 1 && ai <= 3000\n            }\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires\n        stdin_input.len() > 0,\n    ensures\n        result.len() > 0,\n    ensures\n        result.as_bytes()[result.len()-1] == 10u8", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"0\\n\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0207", "language": "verus", "source": "apps", "source-id": "apps_test_1008", "source-notes": "", "vc-description": "Given a string s and an integer k, determine if s can be split into exactly k\npalindromes of equal length. Return \"YES\" if possible, \"NO\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn is_palindrome(s: Seq<char>) -> bool {\n        forall|i: int| 0 <= i < s.len() / 2 ==> s[i] == s[s.len() - 1 - i]\n    }", "vc-helpers": "", "vc-spec": "fn solve(s: Seq<char>, k: int) -> (result: Seq<char>)\n    requires k > 0\n    ensures result == seq!['Y', 'E', 'S'] || result == seq!['N', 'O']\n    ensures s.len() % k != 0 ==> result == seq!['N', 'O']\n    ensures s.len() % k == 0 && (forall|i: int| 0 <= i < k ==> is_palindrome(s.subrange(i * (s.len() / k), (i + 1) * (s.len() / k)))) ==> result == seq!['Y', 'E', 'S']\n    ensures s.len() % k == 0 && (exists|i: int| 0 <= i < k && !is_palindrome(s.subrange(i * (s.len() / k), (i + 1) * (s.len() / k)))) ==> result == seq!['N', 'O']", "vc-code": "{\n    // impl-start\n    assume(false);\n    seq!['N', 'O']\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0209", "language": "verus", "source": "apps", "source-id": "apps_test_1013", "source-notes": "", "vc-description": "Given an n×m grid where some cells are \"good\" (value 1) and others are not (value 0).\nCorner cells are never good. In one operation, choose a good cell and a corner cell,\nthen color all cells in the rectangle formed by these two cells.\nFind the minimum number of operations to color all cells in the grid.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['d', 'u', 'm', 'm', 'y']]\n}\n\nspec fn split_whitespace_func(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['d', 'u', 'm', 'm', 'y']]\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn get_grid_cell_helper(lines: Seq<Seq<char>>, i: int, j: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn get_n(input: Seq<char>) -> int {\n    3\n}\n\nspec fn get_m(input: Seq<char>) -> int {\n    3\n}\n\nspec fn get_grid_cell(input: Seq<char>, i: int, j: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn result_two_newline() -> Seq<char> {\n    seq!['2', '\\n']\n}\n\nspec fn result_four_newline() -> Seq<char> {\n    seq!['4', '\\n']\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n        valid_input(input@)\n    ensures\n        result@ =~= result_two_newline() || result@ =~= result_four_newline(),\n        result@ =~= result_two_newline() <==> (exists|i: int, j: int| \n            0 <= i < get_n(input@) && 0 <= j < get_m(input@) && \n            get_grid_cell(input@, i, j) =~= seq!['1'] && \n            (i == 0 || j == 0 || i == get_n(input@) - 1 || j == get_m(input@) - 1))", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"2\\n\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0213", "language": "verus", "source": "apps", "source-id": "apps_test_1027", "source-notes": "", "vc-description": "Given a Mancala board with 14 holes containing stones, determine the maximum score achievable in one move.\nMove rules: Choose a hole with positive stones, take all stones, redistribute counter-clockwise,\ncollect stones from holes with even counts as the score.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn can_parse_to_board(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn board_matches_input(board: Seq<int>, input: Seq<char>) -> bool {\n    board.len() == 14\n}\n\nspec fn string_represents_int(s: Seq<char>, n: int) -> bool {\n    s.len() > 0 && n >= 0\n}\n\nspec fn max_achievable_score_from_input(input: Seq<char>) -> int {\n    0\n}\n\nspec fn max_score_from_range(board: Seq<int>, up_to: int) -> int\n    decreases up_to\n{\n    if up_to == 0 { \n        0 \n    } else if board.len() == 14 && 0 <= up_to <= 14 && (forall|i: int| 0 <= i < 14 ==> board[i] >= 0) { \n        let prev_max = max_score_from_range(board, up_to - 1);\n        let current_score = if board[up_to - 1] == 0 { -1 } else { 0 };\n        if current_score > prev_max { current_score } else { prev_max }\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: String) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        can_parse_to_board(stdin_input@),\n    ensures result@.len() > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0215", "language": "verus", "source": "apps", "source-id": "apps_test_1035", "source-notes": "", "vc-description": "Given two positive integers A and B, find the maximum number of positive common divisors \nthat can be chosen such that any two chosen divisors are coprime (share no common factors other than 1).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: int, b: int) -> bool {\n  a > 0 && b > 0\n}\n\nspec fn gcd(a: int, b: int) -> int\n  recommends a > 0 && b >= 0\n  decreases b when b >= 0\n{\n  if b == 0 { a } else { gcd(b, a % b) }\n}\n\nspec fn count_distinct_prime_factors(n: int) -> int\n  recommends n > 0\n{\n  if n == 1 { 0 } else { 0 }\n}\n\nspec fn count_distinct_prime_factors_helper(n: int, i: int) -> int\n  recommends n > 0 && i >= 2\n{\n  0\n}\n\nspec fn divide_out_factor(n: int, factor: int) -> int\n  recommends n > 0 && factor > 1 && n % factor == 0\n{\n  n / factor\n}\n\nspec fn correct_result(a: int, b: int, result: int) -> bool\n  recommends a > 0 && b > 0\n{\n  result == count_distinct_prime_factors(gcd(a, b)) + 1\n}", "vc-helpers": "", "vc-spec": "fn solve(a: int, b: int) -> (result: int)\n    requires \n        valid_input(a, b),\n    ensures\n        result > 0,\n        correct_result(a, b, result),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0218", "language": "verus", "source": "apps", "source-id": "apps_test_1044", "source-notes": "", "vc-description": "Two players play a cycle-splitting game alternately. Player 1 goes first.\nPlayers split cycles with ≥2 vertices into two smaller cycles.\nProcess n operations sequentially, each adding a cycle.\nAfter each operation, determine who wins if the game starts with current cycle set.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_by_newline_spec(s);\n    lines.len() >= 2 &&\n    is_valid_integer(lines[0]) &&\n    {\n        let n = parse_int_spec(lines[0]);\n        let numbers = split_by_space_spec(lines[1]);\n        numbers.len() == n &&\n        forall|i: int| 0 <= i < numbers.len() ==> is_valid_integer(numbers[i])\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn split_by_newline_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![], seq![]]\n}\n\nspec fn split_by_space_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    0\n}\n\nspec fn simulates_game_logic(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {\n    let output_lines = split_by_newline_spec(result);\n    computes_correct_players(numbers, output_lines)\n}\n\nspec fn computes_correct_players(numbers: Seq<Seq<char>>, outputs: Seq<Seq<char>>) -> bool {\n    numbers.len() == outputs.len() &&\n    {\n        let players = compute_players_sequence(numbers);\n        players.len() == outputs.len() &&\n        forall|i: int| 0 <= i < outputs.len() ==> \n            (players[i] == 1 ==> outputs[i] == seq!['1']) &&\n            (players[i] == 2 ==> outputs[i] == seq!['2'])\n    }\n}\n\nspec fn compute_players_sequence(numbers: Seq<Seq<char>>) -> Seq<int>\n    decreases numbers.len()\n{\n    if numbers.len() == 0 {\n        seq![]\n    } else {\n        compute_players_helper(numbers, 0, 2)\n    }\n}\n\nspec fn compute_players_helper(numbers: Seq<Seq<char>>, index: int, current_player: int) -> Seq<int>\n    decreases numbers.len() - index\n{\n    if index >= numbers.len() {\n        seq![]\n    } else {\n        let num = parse_int_spec(numbers[index]);\n        let next_player = if num % 2 == 0 { 3 - current_player } else { current_player };\n        seq![next_player].add(compute_players_helper(numbers, index + 1, next_player))\n    }\n}\n\nspec fn count_lines(s: Seq<char>) -> int {\n    count_newlines(s, 0, 0)\n}\n\nspec fn count_newlines(s: Seq<char>, index: int, count: int) -> int\n    decreases s.len() - index\n{\n    if index >= s.len() {\n        count\n    } else if s[index] == '\\n' {\n        count_newlines(s, index + 1, count + 1)\n    } else {\n        count_newlines(s, index + 1, count)\n    }\n}\n\nspec fn starts_with_player2_and_toggles_on_even(numbers: Seq<Seq<char>>, result: Seq<char>) -> bool {\n    let output_lines = split_by_newline_spec(result);\n    let computed_players = compute_players_sequence(numbers);\n    output_lines.len() == computed_players.len() &&\n    forall|i: int| 0 <= i < output_lines.len() ==>\n        (computed_players[i] == 1 ==> output_lines[i] == seq!['1']) &&\n        (computed_players[i] == 2 ==> output_lines[i] == seq!['2'])\n}\n\nspec fn alternates_correctly(input: Seq<char>, output: Seq<char>) -> bool {\n    let lines = split_by_newline_spec(input);\n    lines.len() >= 2 ==> {\n        let numbers = split_by_space_spec(lines[1]);\n        let output_lines = split_by_newline_spec(output);\n        output_lines.len() == numbers.len() &&\n        computes_correct_players(numbers, output_lines)\n    }\n}\n\nspec fn partial_simulation(numbers: Seq<Seq<char>>, output: Seq<char>, processed: int, current_player: int) -> bool {\n    let output_lines = split_by_newline_spec(output);\n    output_lines.len() == processed &&\n    {\n        let partial_computed = compute_players_sequence(numbers.subrange(0, processed));\n        output_lines.len() == partial_computed.len() &&\n        forall|i: int| 0 <= i < output_lines.len() ==>\n            (partial_computed[i] == 1 ==> output_lines[i] == seq!['1']) &&\n            (partial_computed[i] == 2 ==> output_lines[i] == seq!['2'])\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(s: &str) -> (result: String)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0220", "language": "verus", "source": "apps", "source-id": "apps_test_1046", "source-notes": "", "vc-description": "Given n secretaries, each assigned either a positive session ID if on a call or 0 if not talking.\nWhen two people call each other, they share the same unique session ID. Each call connects exactly \ntwo people (no conferences). Determine how many pairs of secretaries are talking to each other, \nor return -1 if the situation is impossible (any session ID appears more than twice).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_occurrences(s: Seq<int>, x: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else {\n        (if s[0] == x { 1int } else { 0int }) + count_occurrences(s.subrange(1, s.len() as int), x)\n    }\n}\n\nspec fn count_pairs(s: Seq<int>) -> int\n{\n    let positive_sessions = filter_positive(s);\n    count_pairs_helper(positive_sessions)\n}\n\nspec fn filter_positive(s: Seq<int>) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::empty()\n    } else if s[0] > 0 {\n        seq![s[0]].add(filter_positive(s.subrange(1, s.len() as int)))\n    } else {\n        filter_positive(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn remove_all_occurrences(s: Seq<int>, x: int) -> Seq<int>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        Seq::empty()\n    } else if s[0] == x {\n        remove_all_occurrences(s.subrange(1, s.len() as int), x)\n    } else {\n        seq![s[0]].add(remove_all_occurrences(s.subrange(1, s.len() as int), x))\n    }\n}\n\nspec fn count_pairs_helper(s: Seq<int>) -> int\n    decreases s.len()\n    when s.len() > 1 ==> remove_all_occurrences(s, s[0]).len() < s.len()\n{\n    if s.len() <= 1 {\n        0\n    } else {\n        let count = count_occurrences(s, s[0]);\n        let remaining = remove_all_occurrences(s, s[0]);\n        (if count == 2 { 1int } else { 0int }) + count_pairs_helper(remaining)\n    }\n}\n\nspec fn exists_index(s: Seq<int>, x: int) -> bool\n{\n    exists|i: int| 0 <= i < s.len() && s[i] == x\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, sessions: Vec<i8>) -> (result: i8)\n    requires \n        n >= 1,\n        sessions.len() == n as nat,\n        forall|i: int| 0 <= i < sessions.len() ==> sessions[i] as int >= 0,\n    ensures \n        result == -1 || result >= 0,\n        result == -1 ==> (exists|id: int| id > 0 && #[trigger] count_occurrences(sessions@.map_values(|x: i8| x as int), id) > 2),\n        result >= 0 ==> forall|id: int| id > 0 ==> count_occurrences(sessions@.map_values(|x: i8| x as int), id) <= 2,\n        result >= 0 ==> result as int == count_pairs(sessions@.map_values(|x: i8| x as int)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0222", "language": "verus", "source": "apps", "source-id": "apps_test_1049", "source-notes": "", "vc-description": "Given n opponents and d days, determine the maximum number of consecutive days where Arya wins fights.\nArya wins on a day if at least one opponent is absent. Arya loses on a day if all opponents are present.\nEach day's attendance is given as a binary string of length n, where '1' means present and '0' means absent.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn input_well_formed(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 &&\n    {\n        let first_line_parts = split_string(lines[0], ' ');\n        first_line_parts.len() == 2 &&\n        is_valid_int(first_line_parts[0]) &&\n        is_valid_int(first_line_parts[1]) &&\n        {\n            let n = string_to_int(first_line_parts[0]);\n            let d = string_to_int(first_line_parts[1]);\n            n >= 0 && d >= 0 &&\n            lines.len() >= d + 1 &&\n            forall|i: int| 1 <= i <= d ==> i < lines.len() && is_valid_binary_string(lines[i], n)\n        }\n    }\n}\n\nspec fn compute_max_consecutive_wins(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line_parts = split_string(lines[0], ' ');\n    let n = string_to_int(first_line_parts[0]);\n    let d = string_to_int(first_line_parts[1]);\n    max_consecutive_wins_up_to(lines, n, d)\n}\n\nspec fn is_valid_int(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn is_valid_binary_string(s: Seq<char>, expected_length: int) -> bool {\n    s.len() == expected_length && forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\n/* Helper function stubs - these would need proper implementations */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { Seq::empty() }\nspec fn string_to_int(s: Seq<char>) -> int { 0 }\nspec fn max_consecutive_wins_up_to(lines: Seq<Seq<char>>, n: int, d: int) -> int { 0 }\nspec fn int_to_string(n: int) -> Seq<char> { Seq::empty() }", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires \n        input.len() > 0,\n        input_well_formed(input),\n    ensures \n        result == int_to_string(compute_max_consecutive_wins(input)).add(seq!['\\n']),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0225", "language": "verus", "source": "apps", "source-id": "apps_test_1063", "source-notes": "", "vc-description": "Given a sequence of n strings where each string contains digits and question marks (?),\nrestore the original strictly increasing sequence of positive integers by replacing each\nquestion mark with a single digit (0-9). The resulting sequence must be strictly increasing,\nall numbers must be positive integers (no leading zeros allowed), and each ? represents\nexactly one missing digit.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(stdin_input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn is_well_formed_input(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    if lines.len() < 1 { \n        false \n    } else {\n        let n = parse_int(lines[0]);\n        n >= 0 && lines.len() >= n + 1 &&\n        forall|i: int| #![trigger lines[i]] 1 <= i <= n && i < lines.len() ==> {\n            let line = lines[i];\n            line.len() >= 1 && line.len() <= 8 &&\n            forall|j: int| 0 <= j < line.len() ==> \n                ((#[trigger] line[j]) >= '0' && line[j] <= '9') || line[j] == '?'\n        }\n    }\n}\n\nspec fn has_valid_solution(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines(stdin_input);\n    let n = parse_int(lines[0]);\n    if n <= 0 { \n        true \n    } else {\n        let input_strings = lines.subrange(1, n + 1);\n        exists|solution: Seq<Seq<char>>| is_valid_sequence_solution(input_strings, solution)\n    }\n}\n\nspec fn is_valid_sequence_solution(input: Seq<Seq<char>>, solution: Seq<Seq<char>>) -> bool {\n    input.len() == solution.len() &&\n    forall|i: int| #![trigger input[i], solution[i]] 0 <= i < input.len() ==> {\n        input[i].len() == solution[i].len() &&\n        forall|j: int| 0 <= j < input[i].len() ==> {\n            ((#[trigger] input[i][j]) != '?' ==> input[i][j] == solution[i][j]) &&\n            (input[i][j] == '?' ==> solution[i][j] >= '0' && solution[i][j] <= '9')\n        }\n    } &&\n    forall|i: int| #![trigger solution[i]] 0 <= i < solution.len() ==> is_valid_positive_integer(solution[i]) &&\n    is_strictly_increasing_sequence(solution)\n}\n\nspec fn is_valid_positive_integer(s: Seq<char>) -> bool {\n    s.len() >= 1 && \n    forall|i: int| 0 <= i < s.len() ==> ((#[trigger] s[i]) >= '0' && s[i] <= '9') &&\n    (s.len() == 1 || s[0] != '0')\n}\n\nspec fn is_strictly_increasing_sequence(nums: Seq<Seq<char>>) -> bool {\n    forall|i: int| #![trigger nums[i]] 0 <= i < nums.len() - 1 ==> \n        is_lexicographically_smaller(nums[i], nums[(i + 1) as int])\n}\n\nspec fn is_lexicographically_smaller(a: Seq<char>, b: Seq<char>) -> bool {\n    a.len() < b.len() || (a.len() == b.len() && lexicographic_compare(a, b))\n}\n\nspec fn lexicographic_compare(a: Seq<char>, b: Seq<char>) -> bool \n    decreases a.len()\n{\n    if a.len() == 0 || b.len() == 0 {\n        a.len() < b.len()\n    } else if a[0] != b[0] {\n        a[0] < b[0]\n    } else {\n        lexicographic_compare(a.drop_first(), b.drop_first())\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        is_well_formed_input(stdin_input),\n    ensures \n        result.len() > 0,\n        result == \"NO\\n\"@ || (result.len() > 4 && result.subrange(0, 4) == \"YES\\n\"@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0231", "language": "verus", "source": "apps", "source-id": "apps_test_1084", "source-notes": "", "vc-description": "Given an n×m grid that is initially all white, determine if it can be transformed into a target \nconfiguration using a sequence of operations. Each operation selects a non-empty subset of rows \nand a non-empty subset of columns, then colors all intersections black. Each row and each column \ncan be used in at most one operation across all operations. The key constraint is that if two \nblack cells share the same column, their rows must have identical patterns of black cells.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn can_be_constructed_by_operations(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() < 2 {\n        false\n    } else {\n        let first_line = lines[0];\n        let grid_lines = lines.subrange(1, lines.len() as int);\n        let dimensions = parse_dimensions(first_line);\n        let n = dimensions.0;\n        let m = dimensions.1;\n        if n <= 0 || m <= 0 || grid_lines.len() != n {\n            false\n        } else if !valid_grid(grid_lines, m) {\n            false\n        } else {\n            true /* simplified - column pattern constraint implementation omitted for spec purposes */\n        }\n    }\n}\n\nspec fn valid_grid(grid_lines: Seq<Seq<char>>, m: int) -> bool {\n    (forall|i: int| 0 <= i < grid_lines.len() ==> #[trigger] grid_lines[i].len() == m) &&\n    (forall|i: int, j: int| 0 <= i < grid_lines.len() && 0 <= j < grid_lines[i].len() ==> \n            #[trigger] grid_lines[i][j] == '.' || grid_lines[i][j] == '#')\n}\n\nspec fn get_row_pattern(row: Seq<char>, m: int) -> Set<int> {\n    Set::new(|j: int| 0 <= j < m && row[j] == '#')\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_helper(input, 0, Seq::empty())\n}\n\nspec fn split_lines_helper(input: Seq<char>, start: int, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {\n    if start >= input.len() {\n        acc\n    } else {\n        acc.push(Seq::empty())\n    }\n}\n\nspec fn parse_dimensions(line: Seq<char>) -> (int, int) {\n    let parts = split_on_space(line);\n    if parts.len() >= 2 {\n        (string_to_int(parts[0]), string_to_int(parts[1]))\n    } else {\n        (0, 0)\n    }\n}\n\nspec fn split_on_space(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires \n        valid_input(stdin_input@),\n    ensures \n        result@ == \"Yes\\n\"@ || result@ == \"No\\n\"@,\n        result@.len() > 0,\n        (result@ == \"Yes\\n\"@) <==> can_be_constructed_by_operations(stdin_input@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"No\\n\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0243", "language": "verus", "source": "apps", "source-id": "apps_test_1125", "source-notes": "", "vc-description": "Given N piles of stones, two players alternate removing stones from any single pile.\nThe player unable to make a move loses. Before the game begins, the second player\ncan move between 0 and (A_1 - 1) stones from pile 1 to pile 2. Find the minimum\nnumber of stones to move to guarantee the second player wins, or output -1 if impossible.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_lines_func(s);\n    lines.len() >= 2 && \n    parse_int_func(lines[0]) >= 2 &&\n    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&\n    forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] >= 1\n}\n\nspec fn is_valid_output(s: Seq<char>) -> bool {\n    s == seq!['-', '1'] || (parse_int_func(s) >= 0)\n}\n\nspec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 2 ==>\n    {\n        let n = parse_int_func(lines[0]);\n        let a = parse_int_array_func(lines[1]);\n    \n        if n == 2 {\n            (output == seq!['-', '1'] <==> (a[0] < a[1] || (a[0] - a[1]) % 2 != 0)) &&\n            (output != seq!['-', '1'] ==> parse_int_func(output) == (a[0] - a[1]) / 2)\n        } else {\n            let xor_rest = xor_range(a, 2, n);\n            let and_val = a[0] + a[1] - xor_rest;\n            let target_and = and_val / 2;\n    \n            if and_val % 2 != 0 || a[0] < target_and || and_op(target_and, xor_rest) != 0 {\n                output == seq!['-', '1']\n            } else {\n                let a0 = construct_a0(target_and, xor_rest, a[0]);\n                if a0 == 0 {\n                    output == seq!['-', '1']\n                } else {\n                    output != seq!['-', '1'] && parse_int_func(output) == a[0] - a0\n                }\n            }\n        }\n    }\n}\n\nspec fn second_player_wins(original_piles: Seq<int>, stones_moved: int) -> bool\n    recommends\n        original_piles.len() >= 2,\n        0 <= stones_moved < original_piles[0],\n        forall|i: int| 0 <= i < original_piles.len() ==> original_piles[i] >= 0\n{\n    let new_piles = original_piles.update(0, original_piles[0] - stones_moved).update(1, original_piles[1] + stones_moved);\n    nim_sum(new_piles) == 0\n}\n\nspec fn nim_sum(piles: Seq<int>) -> int\n    recommends forall|i: int| 0 <= i < piles.len() ==> piles[i] >= 0\n    decreases piles.len()\n{\n    if piles.len() == 0 {\n        0\n    } else {\n        xor_op(piles[0], nim_sum(piles.subrange(1, piles.len() as int)))\n    }\n}\n\nspec fn xor_op(x: int, y: int) -> int\n    recommends x >= 0 && y >= 0\n{\n    if x >= 0 && y >= 0 {\n        0  /* placeholder for bitwise XOR operation */\n    } else {\n        0\n    }\n}\n\nspec fn and_op(x: int, y: int) -> int\n    recommends x >= 0 && y >= 0\n{\n    if x >= 0 && y >= 0 {\n        0  /* placeholder for bitwise AND operation */\n    } else {\n        0\n    }\n}\n\nspec fn xor_range(a: Seq<int>, start: int, end: int) -> int\n    recommends\n        0 <= start <= end <= a.len(),\n        forall|i: int| 0 <= i < a.len() ==> a[i] >= 0\n    decreases end - start\n{\n    if start >= end {\n        0\n    } else {\n        xor_op(a[start], xor_range(a, start + 1, end))\n    }\n}\n\nspec fn construct_a0(initial_and: int, num: int, max_pile: int) -> int\n    recommends initial_and >= 0 && num >= 0\n{\n    let max_power = find_max_power(num);\n    construct_a0_helper(initial_and, num, max_pile, max_power)\n}\n\nspec fn find_max_power(num: int) -> int\n    recommends num >= 0\n{\n    if num == 0 {\n        1\n    } else {\n        find_max_power_helper(1, num)\n    }\n}\n\nspec fn find_max_power_helper(current_power: int, num: int) -> int\n    recommends current_power >= 1 && num >= 0\n{\n    if current_power > num {\n        if current_power / 2 >= 1 { current_power / 2 } else { 1 }\n    } else {\n        1  /* simplified to avoid recursion issues */\n    }\n}\n\nspec fn construct_a0_helper(a0: int, num: int, max_pile: int, power: int) -> int\n    recommends a0 >= 0 && num >= 0 && power >= 1\n    decreases power\n{\n    if power == 1 {\n        if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 }\n    } else {\n        let new_a0 = if and_op(num, power) != 0 && a0 + power <= max_pile { a0 + power } else { a0 };\n        if power / 2 >= 1 { construct_a0_helper(new_a0, num, max_pile, power / 2) } else { new_a0 }\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![s]\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    seq!['0']\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input(stdin_input@),\n    ensures\n        result@.len() > 0,\n        is_valid_output(result@),\n        result@ == seq!['-', '1'] || (parse_int_func(result@) >= 0),\n        correct_solution(stdin_input@, result@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0256", "language": "verus", "source": "apps", "source-id": "apps_test_1209", "source-notes": "", "vc-description": "Given n real numbers with sum equal to 0, construct a sequence where each element \nis either the floor or ceiling of the corresponding input number, such that the \nsum of the constructed sequence is also 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool \n{\n    input.len() > 0 && contains_newline(input) && \n    has_valid_structure(input) && \n    first_line_is_valid_integer(input) &&\n    remaining_lines_are_valid_reals(input)\n}\n\nspec fn input_sum_is_zero(input: Seq<char>) -> bool\n{\n    has_valid_structure(input) ==> sum_of_input_reals(input) == 0.0\n}\n\nspec fn valid_output_format(output: Seq<char>) -> bool\n{\n    output.len() >= 0 && \n    (output.len() == 0 || (ends_with_newline(output) && all_lines_are_integers(output)))\n}\n\nspec fn output_has_correct_length(input: Seq<char>, output: Seq<char>) -> bool\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    count_lines(output) == get_n_from_input(input)\n}\n\nspec fn each_output_is_floor_or_ceiling(input: Seq<char>, output: Seq<char>) -> bool\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    forall|i: int| 0 <= i < get_n_from_input(input) ==> \n        #[trigger] get_ith_real(input, i) == get_ith_real(input, i) ==>\n        {\n            let input_val = get_ith_real(input, i);\n            let output_val = get_ith_integer(output, i);\n            output_val == floor_of(input_val) || output_val == ceiling_of(input_val)\n        }\n}\n\nspec fn output_sum_is_zero(input: Seq<char>, output: Seq<char>) -> bool\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    sum_of_output_integers(output) == 0\n}\n\nspec fn output_preserves_integers(input: Seq<char>, output: Seq<char>) -> bool\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    forall|i: int| 0 <= i < get_n_from_input(input) ==> \n        #[trigger] get_ith_real(input, i) == get_ith_real(input, i) ==>\n        {\n            let input_val = get_ith_real(input, i);\n            is_integer(input_val) ==> get_ith_integer(output, i) == int_value_of(input_val)\n        }\n}\n\nspec fn contains_newline(s: Seq<char>) -> bool\n{\n    exists|i: int| 0 <= i < s.len() && #[trigger] s[i] == '\\n'\n}\n\nspec fn ends_with_newline(s: Seq<char>) -> bool\n{\n    s.len() > 0 && s[s.len()-1] == '\\n'\n}\n\nspec fn has_valid_structure(s: Seq<char>) -> bool { true }\nspec fn first_line_is_valid_integer(s: Seq<char>) -> bool { true }\nspec fn remaining_lines_are_valid_reals(s: Seq<char>) -> bool { true }\nspec fn all_lines_are_integers(s: Seq<char>) -> bool { true }\nspec fn is_integer(r: f64) -> bool { true }\n\nspec fn sum_of_input_reals(input: Seq<char>) -> f64 { 0.0 }\nspec fn sum_of_output_integers(output: Seq<char>) -> int { 0 }\nspec fn get_n_from_input(input: Seq<char>) -> nat { 1 }\nspec fn count_lines(s: Seq<char>) -> nat { if s == seq![48 as char, '\\n'] { 1 } else { 0 } }\nspec fn get_ith_real(input: Seq<char>, i: int) -> f64 { 0.0 }\nspec fn get_ith_integer(output: Seq<char>, i: int) -> int { 0 }\nspec fn floor_of(r: f64) -> int { 0 }\nspec fn ceiling_of(r: f64) -> int { 0 }\nspec fn int_value_of(r: f64) -> int { 0 }", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Seq<char>) -> (output: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        valid_input_format(stdin_input),\n        input_sum_is_zero(stdin_input),\n    ensures\n        valid_output_format(output),\n        output_has_correct_length(stdin_input, output),\n        each_output_is_floor_or_ceiling(stdin_input, output),\n        output_sum_is_zero(stdin_input, output),\n        output_preserves_integers(stdin_input, output),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0268", "language": "verus", "source": "apps", "source-id": "apps_test_1268", "source-notes": "", "vc-description": "Given n cola cans where each can i has remaining volume a_i and capacity b_i,\ndetermine if all remaining cola can be poured into exactly 2 cans.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: Seq<int>, b: Seq<int>) -> bool {\n    a.len() == b.len() && a.len() >= 2 && forall|i: int| 0 <= i < a.len() ==> 0 <= #[trigger] a[i] <= #[trigger] b[i]\n}\n\nspec fn sum_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { 0 } else { s[0] + sum_seq(s.subrange(1, s.len() as int)) }\n}\n\nspec fn find_two_largest_sum(s: Seq<int>) -> int\n    recommends s.len() >= 2\n{\n    0\n}\n\nspec fn find_max(s: Seq<int>) -> int\n    recommends s.len() >= 1\n{\n    0\n}\n\nspec fn find_max_excluding(s: Seq<int>, exclude: int) -> int\n    recommends s.len() >= 2 && 0 <= exclude < s.len()\n{\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(a: Seq<int>, b: Seq<int>) -> (result: String)\n    requires \n        valid_input(a, b),\n    ensures \n        result@ == seq!['Y','E','S'] || result@ == seq!['N','O'],\n        (result@ == seq!['Y','E','S']) <==> find_two_largest_sum(b) >= sum_seq(a),", "vc-code": "{\n    assume(false);\n    \"NO\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0278", "language": "verus", "source": "apps", "source-id": "apps_test_1329", "source-notes": "", "vc-description": "Given an integer N (1 ≤ N ≤ 100), count how many divisors of N! have exactly 75 divisors.\nA number has exactly 75 divisors if and only if its prime factorization has one of these forms:\n- p^74 (where p is prime)\n- p^24 × q^2 (where p, q are distinct primes)  \n- p^14 × q^4 (where p, q are distinct primes)\n- p^4 × q^4 × r^2 (where p, q, r are distinct primes)\n\n/* Abstract specification - represents the count of divisors of N! that have exactly 75 divisors */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n  1 <= n <= 100\n}\n\nspec fn count_divisors_with_75_factors(n: int) -> int \n  recommends valid_input(n)\n{\n  0\n}\n\nspec fn valid_output(result: int) -> bool {\n  result >= 0\n}", "vc-helpers": "", "vc-spec": "fn solve(n: int) -> (result: int)\n  requires valid_input(n)\n  ensures valid_output(result)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0280", "language": "verus", "source": "apps", "source-id": "apps_test_1339", "source-notes": "", "vc-description": "Given n segments on a coordinate line, where each segment i is defined by [l_i, r_i], \nfind a segment that covers all other segments. A segment [a, b] covers segment [c, d] \nif a ≤ c ≤ d ≤ b. Return the 1-indexed number of such a segment, or -1 if none exists.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn valid_input(n: int, segments: Seq<(int, int)>) -> bool {\n    n >= 1 && segments.len() == n && \n    forall|i: int| 0 <= i < n ==> segments[i].0 <= segments[i].1\n}\n\nspec fn covers_all(segments: Seq<(int, int)>, idx: int) -> bool {\n    0 <= idx < segments.len() &&\n    forall|j: int| 0 <= j < segments.len() ==> \n        segments[idx].0 <= segments[j].0 && segments[j].1 <= segments[idx].1\n}\n\nspec fn has_min_left_and_max_right(segments: Seq<(int, int)>, idx: int) -> bool {\n    0 <= idx < segments.len() &&\n    (forall|j: int| 0 <= j < segments.len() ==> segments[idx].0 <= segments[j].0) &&\n    (forall|j: int| 0 <= j < segments.len() ==> segments[idx].1 >= segments[j].1)\n}\n\nspec fn min_left(segments: Seq<(int, int)>) -> int\n    requires segments.len() > 0\n    decreases segments.len()\n{\n    if segments.len() == 1 { \n        segments[0].0\n    } else if segments[0].0 <= min_left(segments.subrange(1, segments.len() as int)) { \n        segments[0].0\n    } else { \n        min_left(segments.subrange(1, segments.len() as int))\n    }\n}\n\nspec fn max_right(segments: Seq<(int, int)>) -> int\n    requires segments.len() > 0\n    decreases segments.len()\n{\n    if segments.len() == 1 { \n        segments[0].1\n    } else if segments[0].1 >= max_right(segments.subrange(1, segments.len() as int)) { \n        segments[0].1\n    } else { \n        max_right(segments.subrange(1, segments.len() as int))\n    }\n}", "vc-spec": "fn solve(n: i32, segments: &[i32]) -> (result: i32)\n    requires \n        n >= 1 && segments.len() == n && \n        forall|i: int| 0 <= i < n ==> i % 2 == 0 ==> segments[i] <= segments[i + 1]\n    ensures \n        result == -1 || (1 <= result <= n)", "vc-code": "{\n    assume(false);\n    -1\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0281", "language": "verus", "source": "apps", "source-id": "apps_test_1346", "source-notes": "", "vc-description": "Given two polynomials f(x) and g(x) with positive integer coefficients,\nfind any coefficient in their product h(x) = f(x) · g(x) that is not\ndivisible by a given prime p. The gcd constraint ensures at least one\ncoefficient in each polynomial is not divisible by p.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, p: int, f: Seq<int>, g: Seq<int>) -> bool {\n    n >= 1 && m >= 1 &&\n    p >= 2 &&\n    f.len() == n && g.len() == m &&\n    (forall|k: int| 0 <= k < f.len() ==> f[k] > 0) &&\n    (forall|k: int| 0 <= k < g.len() ==> g[k] > 0) &&\n    (exists|k: int| 0 <= k < f.len() && f[k] % p != 0) &&\n    (exists|k: int| 0 <= k < g.len() && g[k] % p != 0)\n}\n\nspec fn valid_result(result: int, n: int, m: int, p: int, f: Seq<int>, g: Seq<int>) -> bool \n    recommends p != 0\n{\n    exists|i: int, j: int| 0 <= i < f.len() && 0 <= j < g.len() &&\n            (forall|k: int| 0 <= k < i ==> f[k] % p == 0) &&\n            f[i] % p != 0 &&\n            (forall|k: int| 0 <= k < j ==> g[k] % p == 0) &&\n            g[j] % p != 0 &&\n            result == i + j &&\n            0 <= result < f.len() + g.len()\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, p: i8, f: Vec<i8>, g: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, p as int, f@.map(|v: i8| v as int), g@.map(|v: i8| v as int)),\n        p != 0,\n    ensures valid_result(result as int, n as int, m as int, p as int, f@.map(|v: i8| v as int), g@.map(|v: i8| v as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0283", "language": "verus", "source": "apps", "source-id": "apps_test_1354", "source-notes": "", "vc-description": "Given a 1×n grid where Alice claims to have placed k ships of size a (consecutive cells)\nsuch that no two ships intersect or touch, and Bob makes m shots that all \"miss\",\ndetermine the first shot after which we can be certain Alice is cheating\n(i.e., it becomes impossible to place k non-intersecting, non-touching ships without hitting a shot).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, k: int, a: int, m: int, shots: Seq<int>) -> bool {\n    n > 0 && k > 0 && a > 0 && m > 0 && shots.len() == m &&\n    (forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n)\n}\n\nspec fn can_place_ships_func(n: int, k: int, a: int, shots: Seq<int>, num_shots: int) -> bool\n    recommends\n        n > 0 && k > 0 && a > 0 && num_shots >= 0,\n        num_shots <= shots.len(),\n        forall|i: int| #![trigger shots[i]] 0 <= i < shots.len() ==> 1 <= shots[i] <= n\n{\n    let hit_cells = Set::new(|cell: int| exists|i: int| 0 <= i < num_shots && i < shots.len() && shots[i] == cell);\n    greedy_ship_placement(n, k, a, hit_cells) >= k\n}\n\nspec fn greedy_ship_placement(n: int, k: int, a: int, hit_cells: Set<int>) -> int\n    recommends\n        n > 0 && k > 0 && a > 0,\n        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n\n{\n    greedy_place_ships_from_position(1, n, k, a, hit_cells)\n}\n\nspec fn greedy_place_ships_from_position(pos: int, n: int, k: int, a: int, hit_cells: Set<int>) -> int\n    recommends\n        pos >= 1 && n > 0 && k >= 0 && a > 0,\n        forall|cell: int| #![trigger hit_cells.contains(cell)] hit_cells.contains(cell) ==> 1 <= cell <= n\n{\n    if k == 0 || pos > n {\n        0\n    } else {\n        // Simplified implementation without termination issues\n        if pos + a - 1 <= n { 1 } else { 0 }\n    }\n}\n\nspec fn is_natural_number_string(s: Seq<char>) -> bool {\n    s.len() > 0 && s[0] != '0' && (forall|i: int| #![trigger s[i]] 0 <= i < s.len() ==> '0' <= s[i] <= '9')\n}\n\nspec fn parse_input_spec(input: Seq<char>) -> Seq<Seq<char>>\n    recommends input.len() > 0\n{\n    seq![]\n}\n\nspec fn parse_three_ints_spec(line: Seq<char>) -> (int, int, int) {\n    (1, 1, 1)\n}\n\nspec fn parse_int_spec(line: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_int_array_spec(line: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn int_to_string_spec(value: int) -> Seq<char>\n    recommends value >= 1\n{\n    seq!['1']\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len()-1] == '\\n'\n    ensures\n        result.len() > 0,\n        result[result.len()-1] == '\\n',\n        result == seq!['-', '1', '\\n'] || (exists|shot_num_str: Seq<char>| #![auto] shot_num_str.len() > 0 && \n                             result == shot_num_str + seq!['\\n'] && \n                             is_natural_number_string(shot_num_str)),\n        ({\n            let lines = parse_input_spec(stdin_input);\n            if lines.len() >= 3 {\n                let first_line = parse_three_ints_spec(lines[0]);\n                let (n, k, a) = (first_line.0, first_line.1, first_line.2);\n                let m = parse_int_spec(lines[1]);\n                let shots = parse_int_array_spec(lines[2]);\n                if valid_input(n, k, a, m, shots) {\n                    if can_place_ships_func(n, k, a, shots, m) {\n                        result == seq!['-', '1', '\\n']\n                    } else {\n                        exists|shot_idx: int| #![auto] 1 <= shot_idx <= m && \n                                            result == int_to_string_spec(shot_idx) + seq!['\\n'] &&\n                                            !can_place_ships_func(n, k, a, shots, shot_idx) &&\n                                            (shot_idx == 1 || can_place_ships_func(n, k, a, shots, shot_idx-1))\n                    }\n                } else {\n                    true\n                }\n            } else {\n                true\n            }\n        })", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0288", "language": "verus", "source": "apps", "source-id": "apps_test_1386", "source-notes": "", "vc-description": "Given a w×h grid, place square tiles that are diagonally split into white and black halves.\nEach tile can be rotated in 4 orientations. Adjacent tiles must have different colors on their\nshared edge. Count the number of valid tilings modulo 998244353.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|i: int| 0 < i < input.len() - 1 && input[i] == ' ' &&\n    (forall|j: int| 0 <= j < i ==> '0' <= input[j] <= '9') &&\n    (forall|j: int| i < j < input.len() ==> '0' <= input[j] <= '9')\n}\n\nspec fn valid_dimensions(w: int, h: int) -> bool {\n    w >= 1 && h >= 1 && w <= 1000 && h <= 1000\n}\n\nspec fn parse_two_ints(input: Seq<char>) -> (int, int) {\n    let space_index = find_space_spec(input, 0);\n    let w = string_to_int_spec(input.subrange(0, space_index));\n    let h = string_to_int_spec(input.subrange(space_index + 1, input.len() as int));\n    (w, h)\n}\n\nspec fn find_space_spec(s: Seq<char>, start: int) -> int\n    decreases s.len() - start\n{\n    if s[start] == ' ' {\n        start\n    } else {\n        find_space_spec(s, start + 1)\n    }\n}\n\nspec fn string_to_int_spec(s: Seq<char>) -> int {\n    if s.len() == 1 {\n        s[0] as int - '0' as int\n    } else {\n        string_to_int_spec(s.subrange(0, s.len() - 1)) * 10 + (s[s.len() - 1] as int - '0' as int)\n    }\n}\n\nspec fn int_to_string_spec(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 10 {\n        seq![('0' as int + n) as char]\n    } else {\n        int_to_string_spec(n / 10).add(int_to_string_spec(n % 10))\n    }\n}\n\nspec fn mod_pow_spec(base: int, exp: int, mod_val: int) -> int {\n    if exp == 0 {\n        1int % mod_val\n    } else if exp % 2 == 0 {\n        let half = mod_pow_spec(base, exp / 2, mod_val);\n        (half * half) % mod_val\n    } else {\n        (base * mod_pow_spec(base, exp - 1, mod_val)) % mod_val\n    }\n}", "vc-helpers": "", "vc-spec": "fn main_function() -> (result: int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0294", "language": "verus", "source": "apps", "source-id": "apps_test_1448", "source-notes": "", "vc-description": "Given integers n and d, determine for each grasshopper whether their position \nis inside or on the boundary of a cornfield quadrilateral with vertices at \n(0,d), (d,0), (n,n-d), (n-d,n). Output \"YES\" if inside/on boundary, \"NO\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 3 && \n    valid_first_line(lines[0]) &&\n    valid_second_line(lines[1]) &&\n    valid_grasshopper_lines_simple(lines) &&\n    ({\n        let first_line = split_spaces(lines[0]);\n        let n = string_to_int(first_line[0]);\n        let d = string_to_int(first_line[1]);\n        let m = string_to_int(lines[1]);\n        d >= 1 && d < n && n <= 100 &&\n        m >= 1 && m <= 100 &&\n        lines.len() >= 2 + m &&\n        forall|i: int| #[trigger] valid_grasshopper_line(lines[2 + i], n) && 0 <= i < m ==> valid_grasshopper_line(lines[2 + i], n)\n    })\n}\n\nspec fn valid_first_line(line: Seq<char>) -> bool {\n    let parts = split_spaces(line);\n    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1])\n}\n\nspec fn valid_second_line(line: Seq<char>) -> bool {\n    is_valid_integer(line)\n}\n\nspec fn valid_grasshopper_lines_simple(lines: Seq<Seq<char>>) -> bool {\n    lines.len() >= 3 &&\n    ({\n        let m = string_to_int(lines[1]);\n        lines.len() >= 2 + m\n    })\n}\n\nspec fn valid_grasshopper_line(line: Seq<char>, n: int) -> bool {\n    let parts = split_spaces(line);\n    parts.len() == 2 && is_valid_integer(parts[0]) && is_valid_integer(parts[1]) &&\n    string_to_int(parts[0]) >= 0 && string_to_int(parts[0]) <= n &&\n    string_to_int(parts[1]) >= 0 && string_to_int(parts[1]) <= n\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn get_n(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line = split_spaces(lines[0]);\n    string_to_int(first_line[0])\n}\n\nspec fn get_d(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    let first_line = split_spaces(lines[0]);\n    string_to_int(first_line[1])\n}\n\nspec fn get_number_of_grasshoppers(input: Seq<char>) -> int {\n    let lines = split_lines(input);\n    string_to_int(lines[1])\n}\n\nspec fn get_grasshopper(input: Seq<char>, i: int) -> (int, int) {\n    let lines = split_lines(input);\n    let coords = split_spaces(lines[2 + i]);\n    (string_to_int(coords[0]), string_to_int(coords[1]))\n}\n\nspec fn is_inside_cornfield(grasshopper: (int, int), n: int, d: int) -> bool {\n    let (x, y) = grasshopper;\n    x + y >= d && x + y <= 2 * n - d && x - y >= -d && x - y <= d\n}\n\n/* Helper functions for string processing */\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: Vec<String>)", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0298", "language": "verus", "source": "apps", "source-id": "apps_test_1512", "source-notes": "", "vc-description": "Given a permutation of integers from 1 to n, determine which single element to remove\nto maximize the number of records in the remaining sequence. A record is an element\nthat is greater than all elements that appear before it in the sequence. If multiple\nelements can be removed to achieve the same maximum number of records, return the\nsmallest such element.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_permutation(p: Seq<int>, n: int) -> bool {\n  p.len() == n && n >= 1 &&\n  (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] p[i] <= n) &&\n  (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn count_records(s: Seq<int>) -> int {\n  if s.len() == 0 { 0 }\n  else { 1 + count_records_from_index(s, 1, s[0]) }\n}\n\nspec fn count_records_after_removal(p: Seq<int>, to_remove: int) -> int {\n  let filtered = Seq::new((p.len() - 1) as nat, |i: int| \n    if index_of(p, to_remove) <= i { p[i + 1] } else { p[i] });\n  count_records(filtered)\n}\nspec fn count_records_from_index(s: Seq<int>, idx: int, max_so_far: int) -> int\n  decreases s.len() - idx\n{\n  if idx >= s.len() { 0 }\n  else if s[idx] > max_so_far { \n    1 + count_records_from_index(s, idx + 1, s[idx])\n  } else { \n    count_records_from_index(s, idx + 1, max_so_far)\n  }\n}\n\nspec fn index_of(s: Seq<int>, elem: int) -> int {\n  choose|i: int| 0 <= i < s.len() && s[i] == elem\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, p: Vec<i8>) -> (result: i8)\n  requires \n    valid_permutation(p@.map(|i, x: i8| x as int), n as int)\n  ensures \n    1 <= result as int <= n as int,\n    p@.map(|i, x: i8| x as int).contains(result as int),\n    {\n      let p_int = p@.map(|i, x: i8| x as int);\n      forall|x: int| p_int.contains(x) ==> count_records_after_removal(p_int, result as int) >= count_records_after_removal(p_int, x)\n    },\n    {\n      let p_int = p@.map(|i, x: i8| x as int);\n      forall|x: int| p_int.contains(x) && count_records_after_removal(p_int, x) == count_records_after_removal(p_int, result as int) ==> result as int <= x\n    }", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0303", "language": "verus", "source": "apps", "source-id": "apps_test_1547", "source-notes": "", "vc-description": "Given an n×m grid initially filled with color 0, perform k painting operations and output the final grid.\nOperations can paint entire rows or columns with specified colors.\nWhen a cell is painted multiple times, it takes the color of the most recent operation affecting it.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() > 0 && split_string(&lines[0], ' ').len() == 3 &&\n    {\n        let n = string_to_int(&split_string(&lines[0], ' ')[0]);\n        let m = string_to_int(&split_string(&lines[0], ' ')[1]);\n        let k = string_to_int(&split_string(&lines[0], ' ')[2]);\n        n > 0 && m > 0 && k >= 0 && lines.len() >= k + 1\n    }\n}\n\nspec fn get_dimensions(input: &str) -> (int, int, int)\n{\n    let lines = split_lines(input);\n    let first_line = split_string(&lines[0], ' ');\n    (string_to_int(&first_line[0]), string_to_int(&first_line[1]), string_to_int(&first_line[2]))\n}\n\nspec fn compute_grid(lines: Seq<String>, n: int, m: int, k: int) -> Seq<Seq<int>>\n{\n    let row = Seq::new(n as nat, |i: int| (0, -1));\n    let col = Seq::new(m as nat, |i: int| (0, -1));\n    let processed_arrays = process_operations(lines, n, m, k, 0, row, col);\n    build_grid(n, m, processed_arrays.0, processed_arrays.1)\n}", "vc-helpers": "/* Helper functions would be defined here */\nspec fn split_lines(input: &str) -> Seq<String> {\n    Seq::empty()\n}\n\nspec fn split_string(s: &str, delimiter: char) -> Seq<String> {\n    Seq::empty()\n}\n\nspec fn string_to_int(s: &str) -> int {\n    0\n}\n\nspec fn process_operations(lines: Seq<String>, n: int, m: int, k: int, index: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> (Seq<(int, int)>, Seq<(int, int)>) {\n    (Seq::empty(), Seq::empty())\n}\n\nspec fn build_grid(n: int, m: int, row: Seq<(int, int)>, col: Seq<(int, int)>) -> Seq<Seq<int>> {\n    Seq::empty()\n}\n\nspec fn format_grid(grid: Seq<Seq<int>>) -> String {\n    \"\".to_string()\n}", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    ensures !valid_input(input) ==> result@ == \"\"@\n    ensures valid_input(input) ==> (\n        let (n, m, k) = get_dimensions(input);\n        let lines = split_lines(input);\n        result == format_grid(compute_grid(lines, n, m, k))\n    )", "vc-code": "{\n    assume(false);\n    \"\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0309", "language": "verus", "source": "apps", "source-id": "apps_test_1586", "source-notes": "", "vc-description": "Given a non-negative integer N, compute the double factorial f(N) where f(n) = 1 if n < 2,\nand f(n) = n × f(n-2) if n ≥ 2. Find the number of trailing zeros in the decimal representation of f(N).\nTrailing zeros are produced by factors of 10, which come from pairs of prime factors 2 and 5.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int) -> bool {\n    n >= 0\n}\n\nspec fn factors_in_factorial(n: int, p: int) -> int {\n    0\n}\n\nspec fn factors_in_double_factorial(n: int, p: int) -> int {\n    0\n}\n\nspec fn valid_result(n: int, result: int) -> bool {\n    n >= 0 ==> (\n        result >= 0 &&\n        result == if factors_in_double_factorial(n, 2) < factors_in_double_factorial(n, 5) {\n            factors_in_double_factorial(n, 2)\n        } else {\n            factors_in_double_factorial(n, 5)\n        }\n    )\n}", "vc-helpers": "", "vc-spec": "fn solve(n: int) -> (result: int)\n    requires valid_input(n)\n    ensures valid_result(n, result)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0313", "language": "verus", "source": "apps", "source-id": "apps_test_1615", "source-notes": "", "vc-description": "Given n non-intersecting integer segments, find the minimum number of moves\nto make the total count of integers covered by all segments divisible by k.\nEach move extends any segment by 1 unit either left or right.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input_format(s: Seq<u8>) -> bool {\n    let lines = split_lines(s);\n    lines.len() >= 1 &&\n    exists|n: nat, k: nat| \n        parses_as_integers_pair(lines[0], n as int, k as int) && n > 0 && k > 0 && lines.len() >= n + 1 &&\n        forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i] == lines[i] && \n            exists|a: int, b: int| parses_as_integers_pair(lines[i], a, b)\n}\n\nspec fn parsed_correctly(input: Seq<u8>, n: nat, k: nat, segments: Seq<(int, int)>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= n + 1 && segments.len() == n &&\n    parses_as_integers_pair(lines[0], n as int, k as int) &&\n    forall|i: int| 0 <= i < n && i + 1 < lines.len() ==> #[trigger] segments[i] == segments[i] && \n        parses_as_integers_pair(lines[i + 1], segments[i].0, segments[i].1)\n}\n\nspec fn is_valid_output(s: Seq<u8>) -> bool {\n    s.len() > 0 && s[s.len() - 1] == 10u8 && \n    forall|i: int| 0 <= i < s.len() - 1 ==> #[trigger] s[i] == s[i] && s[i] != 10u8 &&\n    is_numeric_output(s.subrange(0, s.len() - 1))\n}\n\nspec fn min_moves_to_divisible(segments: Seq<(int, int)>, k: nat) -> nat\n    recommends k > 0\n{\n    let total_coverage = total_coverage(segments);\n    let remainder = total_coverage % k;\n    if remainder == 0 { 0 } else { (k - remainder) as nat }\n}\n\nspec fn total_coverage(segments: Seq<(int, int)>) -> nat\n    decreases segments.len()\n{\n    if segments.len() == 0 { \n        0 \n    } else { \n        segment_length(segments[0]) + total_coverage(segments.subrange(1, segments.len() as int))\n    }\n}\n\nspec fn segment_length(segment: (int, int)) -> nat {\n    let max_val = if segment.0 >= segment.1 { segment.0 } else { segment.1 };\n    let min_val = if segment.0 <= segment.1 { segment.0 } else { segment.1 };\n    if max_val >= min_val { (max_val - min_val + 1) as nat } else { 1 }\n}\n\n/* Helper functions that would need to be implemented */\nspec fn split_lines(s: Seq<u8>) -> Seq<Seq<u8>> {\n    seq![seq![]]\n}\n\nspec fn parses_as_integers_pair(line: Seq<u8>, a: int, b: int) -> bool {\n    true\n}\n\nspec fn is_numeric_output(s: Seq<u8>) -> bool {\n    true\n}\n\nspec fn contains_newline(s: Seq<u8>) -> bool {\n    exists|i: int| 0 <= i < s.len() && s[i] == 10u8\n}\n\nspec fn int_to_string(n: nat) -> Seq<u8> {\n    seq![48u8]\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() - 1] == 10u8 || !contains_newline(stdin_input@),\n    ensures\n        result.len() == 0 || result[result.len() - 1] == 10u8,\n        valid_input_format(stdin_input@) ==> \n            exists|n: nat, k: nat, segments: Seq<(int, int)>|\n                n > 0 && k > 0 && segments.len() == n &&\n                parsed_correctly(stdin_input@, n, k, segments) &&\n                result@ == int_to_string(min_moves_to_divisible(segments, k)).add(seq![10u8]),\n        valid_input_format(stdin_input@) ==> is_valid_output(result@),\n        !valid_input_format(stdin_input@) ==> \n            (result.len() == 0 || (result.len() > 0 && result[result.len() - 1] == 10u8)),", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0314", "language": "verus", "source": "apps", "source-id": "apps_test_1617", "source-notes": "", "vc-description": "Given n people sitting in a circle numbered 1 to n, person 1 starts with a ball and chooses a positive integer k ≤ n.\nThe ball is passed to the k-th neighbor in clockwise direction repeatedly until it returns to person 1.\nThe fun value is the sum of all unique person IDs who touched the ball during this process.\nFind all possible fun values for all valid choices of k.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn f(n: int, x: int) -> int {\n  let y = n / x;\n  y + x * y * (y - 1) / 2\n}\n\nspec fn is_divisor(d: int, n: int) -> bool {\n  d > 0 && n % d == 0\n}\n\nspec fn is_sorted(s: Seq<int>) -> bool {\n  forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\nspec fn no_duplicates(s: Seq<int>) -> bool {\n  forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8) -> (result: Vec<i8>)\n  requires n as int >= 2\n  ensures \n      no_duplicates(result@.map(|i: int, x: i8| x as int)) &&\n      is_sorted(result@.map(|i: int, x: i8| x as int)) &&\n      (forall|v: int| #[trigger] result@.map(|i: int, x: i8| x as int).contains(v) <==> exists|d: int| #[trigger] is_divisor(d, n as int) && v == f(n as int, d)) &&\n      result@.len() > 0", "vc-code": "{\n  assume(false);\n  Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0321", "language": "verus", "source": "apps", "source-id": "apps_test_1631", "source-notes": "", "vc-description": "Given n strings of lowercase Latin letters, determine if there exists a permutation \nof the 26 lowercase Latin letters such that the strings are in lexicographical order\naccording to this custom alphabet. Output the valid alphabet permutation or \"Impossible\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(stdin_input: Seq<char>, n: int) -> bool {\n    exists|lines: Seq<Seq<char>>| (parse_input(stdin_input) == lines &&\n    lines.len() >= 1 &&\n    lines.len() == n + 1 &&\n    parse_int(lines[0]) == n &&\n    n >= 1 && n <= 100 &&\n    (forall|i: int| 1 <= i < lines.len() ==> \n        1 <= lines[i].len() <= 100 && \n        forall|j: int| 0 <= j < lines[i].len() ==> 'a' <= lines[i][j] <= 'z'))\n}\n\nspec fn valid_alphabet_ordering(stdin_input: Seq<char>, alphabet: Seq<char>) -> bool\n    recommends alphabet.len() == 26,\n              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',\n              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]\n{\n    exists|lines: Seq<Seq<char>>, n: int| (parse_input(stdin_input) == lines &&\n    lines.len() >= 1 &&\n    lines.len() == n + 1 &&\n    parse_int(lines[0]) == n &&\n    (forall|i: int| 1 <= i < n ==> lexicographically_less_or_equal(lines[i], lines[i+1], alphabet)))\n}\n\nspec fn lexicographically_less_or_equal(s1: Seq<char>, s2: Seq<char>, alphabet: Seq<char>) -> bool\n    recommends alphabet.len() == 26,\n              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',\n              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j]\n{\n    if s1 == s2 {\n        true\n    } else if s1.len() <= s2.len() && s1 == s2.subrange(0, s1.len() as int) {\n        true\n    } else if s2.len() < s1.len() && s2 == s1.subrange(0, s2.len() as int) {\n        false\n    } else {\n        exists|i: int| (0 <= i < s1.len() && i < s2.len() && s1[i] != s2[i] &&\n        (forall|j: int| 0 <= j < i ==> s1[j] == s2[j]) &&\n        'a' <= s1[i] <= 'z' && 'a' <= s2[i] <= 'z' &&\n        alphabet_order(s1[i], s2[i], alphabet))\n    }\n}\n\nspec fn alphabet_order(c1: char, c2: char, alphabet: Seq<char>) -> bool\n    recommends alphabet.len() == 26,\n              forall|i: int| 0 <= i < alphabet.len() ==> 'a' <= alphabet[i] <= 'z',\n              forall|i: int, j: int| 0 <= i < j < alphabet.len() ==> alphabet[i] != alphabet[j],\n              'a' <= c1 <= 'z' && 'a' <= c2 <= 'z'\n{\n    exists|i: int, j: int| 0 <= i < j < alphabet.len() && alphabet[i] == c1 && alphabet[j] == c2\n}\n\nspec fn parse_input(input: Seq<char>) -> Seq<Seq<char>>\n{\n    Seq::<Seq<char>>::empty()\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n{\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        exists|n: int| n >= 1 && valid_input(stdin_input@, n),\n    ensures\n        result@ == \"Impossible\"@ || (result@.len() == 26 && forall|i: int| 0 <= i < result@.len() ==> 'a' <= result@[i] <= 'z'),\n        result@ != \"Impossible\"@ ==> (forall|i: int, j: int| 0 <= i < j < result@.len() ==> result@[i] != result@[j]),\n        result@ != \"Impossible\"@ ==> valid_alphabet_ordering(stdin_input@, result@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"Impossible\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0322", "language": "verus", "source": "apps", "source-id": "apps_test_1634", "source-notes": "", "vc-description": "Given ticket costs and transportation usage, find the minimum cost to buy tickets.\nThere are 4 ticket types: individual ride cost, unlimited rides on one vehicle,\nunlimited rides on all buses OR all trolleys, and unlimited rides on everything.\nInput includes 4 costs and arrays of ride counts for buses and trolleys.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_costs(c: &[int]) -> bool {\n  c.len() == 4 &&\n  c[0] >= 1 && c[1] >= 1 && c[2] >= 1 && c[3] >= 1 &&\n  c[0] <= 1000 && c[1] <= 1000 && c[2] <= 1000 && c[3] <= 1000\n}\n\nspec fn valid_rides(rides: &[int]) -> bool {\n  rides.len() >= 1 && rides.len() <= 1000 &&\n  forall|i: int| #![trigger rides[i]] 0 <= i < rides.len() ==> 0 <= rides[i] <= 1000\n}\n\nspec fn sum_array(arr: Seq<int>) -> int\n  decreases arr.len(),\n{\n  if arr.len() == 0 { \n    0 \n  } else { \n    arr[0] + sum_array(arr.drop_first()) \n  }\n}\n\nspec fn optimized_cost(rides: Seq<int>, individual_cost: int, unlimited_cost: int) -> int {\n  let initial_cost = sum_array(rides) * individual_cost;\n  min_with_unlimited(rides, initial_cost, individual_cost, unlimited_cost, 0)\n}\n\nspec fn min_with_unlimited(rides: Seq<int>, current_cost: int, individual_cost: int, unlimited_cost: int, index: int) -> int\n  decreases rides.len() - index,\n{\n  if index >= rides.len() { \n    current_cost \n  } else {\n    let new_cost = current_cost - rides[index] * individual_cost + unlimited_cost;\n    let updated_cost = if new_cost < current_cost && new_cost >= 0 { new_cost } else { current_cost };\n    min_with_unlimited(rides, updated_cost, individual_cost, unlimited_cost, index + 1)\n  }\n}\n\nspec fn min5(a: int, b: int, c: int, d: int, e: int) -> int {\n  let min_ab = if a <= b { a } else { b };\n  let min_cd = if c <= d { c } else { d };\n  let min_abcd = if min_ab <= min_cd { min_ab } else { min_cd };\n  if min_abcd <= e { min_abcd } else { e }\n}\n\nspec fn correct_result(c: &[int], a: &[int], b: &[int], result: int) -> bool {\n  result == min5(optimized_cost(a@, c[0], c[1]) + optimized_cost(b@, c[0], c[1]),\n                 optimized_cost(a@, c[0], c[1]) + c[2],\n                 optimized_cost(b@, c[0], c[1]) + c[2],\n                 c[2] + c[2],\n                 c[3])\n}", "vc-helpers": "", "vc-spec": "fn solve(c: &Vec<i8>, a: &Vec<i8>, b: &Vec<i8>) -> (result: i8)\n  requires \n    c.len() == 4,\n    c@[0] as int >= 1 && c@[1] as int >= 1 && c@[2] as int >= 1 && c@[3] as int >= 1,\n    c@[0] as int <= 1000 && c@[1] as int <= 1000 && c@[2] as int <= 1000 && c@[3] as int <= 1000,\n    a.len() >= 1 && a.len() <= 1000,\n    b.len() >= 1 && b.len() <= 1000,\n    forall|i: int| #![trigger a@[i]] 0 <= i < a.len() ==> 0 <= a@[i] as int <= 1000,\n    forall|i: int| #![trigger b@[i]] 0 <= i < b.len() ==> 0 <= b@[i] as int <= 1000,\n  ensures \n    result >= 0,\n    result as int <= min5(sum_array(a@.map(|_, x: i8| x as int)) * (c@[0] as int) + sum_array(b@.map(|_, x: i8| x as int)) * (c@[0] as int), \n                  sum_array(a@.map(|_, x: i8| x as int)) * (c@[0] as int) + (c@[2] as int),\n                  sum_array(b@.map(|_, x: i8| x as int)) * (c@[0] as int) + (c@[2] as int),\n                  (c@[2] as int) + (c@[2] as int),\n                  c@[3] as int),", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0328", "language": "verus", "source": "apps", "source-id": "apps_test_1661", "source-notes": "", "vc-description": "Given n games with costs and m bills with values, determine how many games can be bought\nby processing games in order. For each game, use the first available bill if it has\nsufficient value to buy the game, otherwise skip the game. Return total games bought.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_buyable_games(games: Seq<int>, bills: Seq<int>) -> int\n    decreases games.len()\n{\n    if games.len() == 0 {\n        0\n    } else if bills.len() == 0 {\n        0\n    } else if bills[0] >= games[0] {\n        1 + count_buyable_games(games.subrange(1, games.len() as int), bills.subrange(1, bills.len() as int))\n    } else {\n        count_buyable_games(games.subrange(1, games.len() as int), bills)\n    }\n}\n\nspec fn valid_input(n: int, m: int, games: Seq<int>, bills: Seq<int>) -> bool {\n    n >= 1 && m >= 1 &&\n    games.len() == n && bills.len() == m &&\n    (forall|i: int| 0 <= i < games.len() ==> #[trigger] games[i] >= 1 && #[trigger] games[i] <= 1000) &&\n    (forall|i: int| 0 <= i < bills.len() ==> #[trigger] bills[i] >= 1 && #[trigger] bills[i] <= 1000)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, m: i8, games: Vec<i8>, bills: Vec<i8>) -> (result: i8)\n    requires \n        valid_input(n as int, m as int, games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),\n    ensures \n        0 <= result as int <= n as int,\n        result as int <= m as int,\n        result as int == count_buyable_games(games@.map(|v: i8| v as int), bills@.map(|v: i8| v as int)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0331", "language": "verus", "source": "apps", "source-id": "apps_test_1684", "source-notes": "", "vc-description": "Given n points numbered 1 to n arranged clockwise on a circle's circumference \nand m line segments connecting pairs of these points, determine if the resulting \nimage has rotational symmetry. The image has rotational symmetry if there exists \nan integer k (1 ≤ k < n) such that rotating all segments clockwise by k units \naround the center produces the same image.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\npub struct InputData {\n    pub n: int,\n    pub m: int,\n    pub segments: Set<(int, int)>,\n}\n\nspec fn valid_input_format(stdin_input: &str) -> bool {\n    stdin_input.len() > 0\n}\n\nspec fn parse_input(stdin_input: &str) -> InputData\n    requires valid_input_format(stdin_input)\n{\n    InputData {\n        n: 2,\n        m: 0,\n        segments: Set::empty(),\n    }\n}\n\nspec fn rotate_segment(seg: (int, int), k: int, n: int) -> (int, int)\n    requires 1 <= seg.0 <= n && 1 <= seg.1 <= n && k >= 0 && n > 0\n{\n    let temp_a = (seg.0 + k) % n;\n    let a = if temp_a == 0 { n } else { temp_a };\n    let temp_b = (seg.1 + k) % n;\n    let b = if temp_b == 0 { n } else { temp_b };\n    (a, b)\n}\n\nspec fn exists_rotational_symmetry(data: InputData) -> bool {\n    exists|k: int| 1 <= k < data.n && \n        data.n % k == 0 &&\n        (forall|seg: (int, int)| data.segments.contains(seg) ==> \n            seg.0 >= 1 && seg.0 <= data.n && seg.1 >= 1 && seg.1 <= data.n &&\n            data.segments.contains(rotate_segment(seg, k, data.n)))\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires stdin_input.len() > 0\n    requires valid_input_format(stdin_input)\n    ensures result == \"Yes\" || result == \"No\"\n    ensures (result == \"Yes\") == exists_rotational_symmetry(parse_input(stdin_input))", "vc-code": "{\n    assume(false);\n    \"No\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0332", "language": "verus", "source": "apps", "source-id": "apps_test_1687", "source-notes": "", "vc-description": "Given an array of positive integers, find an element from the array such that all elements\nin the array are divisible by it. If no such element exists, return -1. If multiple valid\nelements exist, return any one of them.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn min(a: Seq<int>) -> int\n    recommends a.len() > 0\n{\n    choose|x: int| a.contains(x) && forall|i: int| 0 <= i < a.len() ==> x <= a[i]\n}", "vc-helpers": "", "vc-spec": "fn solve(a: Vec<i8>) -> (result: i8)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i] as int > 0,\n    ensures \n        result as int == -1 || exists|i: int| 0 <= i < a.len() && a[i] == result,\n        result as int != -1 ==> forall|i: int| 0 <= i < a.len() ==> a[i] as int % result as int == 0,\n        result as int == -1 ==> forall|x: int| (exists|i: int| 0 <= i < a.len() && a[i] as int == x) ==> exists|i: int| 0 <= i < a.len() && a[i] as int % x != 0,\n        (forall|i: int| 0 <= i < a.len() ==> a[i] as int % min(a@.map(|i: int, x: i8| x as int)) == 0) ==> result as int == min(a@.map(|i: int, x: i8| x as int)),\n        (exists|i: int| 0 <= i < a.len() && a[i] as int % min(a@.map(|i: int, x: i8| x as int)) != 0) ==> result as int == -1,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0337", "language": "verus", "source": "apps", "source-id": "apps_test_1724", "source-notes": "", "vc-description": "Given an array a of n non-negative integers and a binary string representing number m,\nfind the maximum value of function f(x) = sum(a[i] * bit_i(x)) for all integers x in range [0, m],\nwhere bit_i(x) is 1 if the i-th bit of x is set, 0 otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn valid_input(n: int, a: Seq<int>, k: Seq<char>) -> bool {\n  n >= 1 && a.len() == n && k.len() == n && \n  (forall|i: int| 0 <= i < n ==> a[i] >= 0) &&\n  is_binary_string(k)\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n  forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn pow(base: int, exp: int) -> int\n  decreases exp\n{\n  if exp == 0 { 1 }\n  else if exp > 0 { base * pow(base, exp - 1) }\n  else { 1 }\n}\n\nspec fn binary_string_to_int(s: Seq<char>) -> int\n  requires is_binary_string(s)\n  ensures binary_string_to_int(s) >= 0\n  decreases s.len()\n{\n  if s.len() == 0 { 0 }\n  else { (if s[0] == '1' { 1 } else { 0 }) * pow(2, s.len() as int - 1) + binary_string_to_int(s.subrange(1, s.len() as int)) }\n}\n\nspec fn f(a: Seq<int>, x: int, n: int) -> int\n  requires n >= 0 && a.len() == n\n  ensures (forall|i: int| 0 <= i < n ==> a[i] >= 0) ==> f(a, x, n) >= 0\n  decreases n\n{\n  if n == 0 { 0 }\n  else { (if (x / pow(2, n-1)) % 2 == 1 { a[n-1] } else { 0 }) + f(a.subrange(0, n-1), x % pow(2, n-1), n-1) }\n}", "vc-spec": "fn solve(n: int, a: Seq<int>, k: Seq<char>) -> (result: int)\n  requires valid_input(n, a, k)\n  ensures result >= 0,\n  ensures exists|x: int| 0 <= x <= binary_string_to_int(k) && result == f(a, x, n),\n  ensures forall|x: int| 0 <= x <= binary_string_to_int(k) ==> f(a, x, n) <= result", "vc-code": "{\n  assume(false);\n  0\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0340", "language": "verus", "source": "apps", "source-id": "apps_test_1745", "source-notes": "", "vc-description": "Given an n × m grid where '.' represents empty cells and '#' represents occupied cells,\ncount the number of distinct ways to create a pipe with constraints:\n1. The pipe is a width-1 polyline through empty cells only\n2. The pipe starts and ends on the grid boundary (but not corner cells)\n3. The pipe has at most 2 turns (90-degree turns)\n4. The pipe touches exactly 2 boundary cells (start and end)\n5. If the pipe is a straight line, start and end must be on different edges\n6. Each non-boundary pipe cell has exactly 2 adjacent pipe cells\n7. Each boundary pipe cell has exactly 1 adjacent pipe cell\n\n/* Simplified implementation */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input.index(input.len() - 1) == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 && output.index(output.len() - 1) == '\\n'\n}\n\nspec fn parse_grid(input: Seq<char>) -> (Seq<Seq<char>>, int, int) {\n    (seq![], 0, 0)\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn find_newline(s: Seq<char>, start: int) -> int {\n    -1\n}\n\nspec fn is_valid_grid(grid: Seq<Seq<char>>, rows: int, cols: int) -> bool {\n    grid.len() == rows &&\n    rows >= 0 && cols >= 0 &&\n    (forall|i: int| #![auto] 0 <= i < rows ==> grid.index(i).len() == cols) &&\n    (forall|i: int, j: int| 0 <= i < rows && 0 <= j < cols ==> \n        grid.index(i).index(j) == '.' || grid.index(i).index(j) == '#')\n}\n\nspec fn is_boundary_cell(i: int, j: int, rows: int, cols: int) -> bool {\n    i == 0 || i == rows - 1 || j == 0 || j == cols - 1\n}\n\nspec fn is_corner_cell(i: int, j: int, rows: int, cols: int) -> bool {\n    (i == 0 && j == 0) || (i == 0 && j == cols - 1) ||\n    (i == rows - 1 && j == 0) || (i == rows - 1 && j == cols - 1)\n}\n\nspec fn count_valid_pipes(grid: Seq<Seq<char>>, rows: int, cols: int) -> int {\n    0\n}", "vc-helpers": "", "vc-spec": "fn execute_python_logic(input: Seq<char>) -> (output: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(output)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0346", "language": "verus", "source": "apps", "source-id": "apps_test_1780", "source-notes": "", "vc-description": "Given an array of n integers (each either -1 or 1), determine for each query \nwhether the array can be rearranged so that the sum of elements in a given \nrange equals 0. A range can sum to 0 only if it has even length and we have \nenough positive and negative values to fill half the positions each.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq!['0']]\n}\n\nspec fn extract_m_from_line(line: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_n(line: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_m(input: Seq<char>) -> int {\n    0\n}\n\nspec fn extract_query(line: Seq<char>) -> (int, int) {\n    (0, 0)\n}\n\nspec fn count_ones(line: Seq<char>) -> int {\n    0\n}\n\nspec fn count_dashes(line: Seq<char>) -> int {\n    0\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn join_with_newlines(outputs: Seq<Seq<char>>) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 &&\n    contains_valid_first_line(lines[0]) &&\n    contains_valid_second_line(lines[1]) &&\n    lines.len() == 2 + extract_m_from_line(lines[0]) &&\n    (forall|i: int| 2 <= i < lines.len() ==> contains_valid_query(lines[i])) &&\n    extract_n(lines[0]) == lines[1].len()\n}\n\nspec fn contains_valid_first_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn contains_valid_second_line(line: Seq<char>) -> bool {\n    line.len() >= 0 &&\n    forall|i: int| 0 <= i < line.len() ==> line[i] == '1' || line[i] == '-'\n}\n\nspec fn contains_valid_query(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn compute_correct_result(input: Seq<char>) -> Seq<char> {\n    let lines = split_lines(input);\n    let first_line = lines[0];\n    let n = extract_n(first_line);\n    let m = extract_m(input);\n    let array_line = lines[1];\n    let positives = count_ones(array_line);\n    let negatives = count_dashes(array_line);\n    let max_balanceable = 2 * min(positives, negatives);\n\n    let outputs: Seq<Seq<char>> = Seq::new(m as nat, |i: int| {\n        let query = extract_query(lines[i + 2]);\n        let l = query.0;\n        let r = query.1;\n        let range_length = r - l + 1;\n        if range_length % 2 == 0 && range_length <= max_balanceable {\n            seq!['1']\n        } else {\n            seq!['0']\n        }\n    });\n\n    join_with_newlines(outputs)\n}\n\nspec fn ends_with_newline_if_non_empty(s: Seq<char>) -> bool {\n    s.len() == 0 || (s.len() > 0 && s[s.len() - 1] == '\\n')\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        valid_input(stdin_input),\n    ensures\n        result.len() >= 0,\n        result == compute_correct_result(stdin_input),\n        forall|line: Seq<char>| split_lines(result).contains(line) ==> line == seq!['0'] || line == seq!['1'],\n        split_lines(result).len() == extract_m(stdin_input),\n        ends_with_newline_if_non_empty(result),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0352", "language": "verus", "source": "apps", "source-id": "apps_test_1824", "source-notes": "", "vc-description": "Given three lists of compilation errors (initial with n errors, second with n-1 errors, third with n-2 errors),\nfind the two error values that were corrected. The compiler shows errors in different order each time,\nbut the actual error values remain the same.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_by_newline(input);\n    lines.len() >= 4 && \n    is_valid_integer(lines[0]) &&\n    string_to_int(lines[0]) >= 3 &&\n    split_by_space(lines[1]).len() == string_to_int(lines[0]) &&\n    split_by_space(lines[2]).len() == string_to_int(lines[0]) - 1 &&\n    split_by_space(lines[3]).len() == string_to_int(lines[0]) - 2 &&\n    (forall|i: int| 0 <= i < split_by_space(lines[1]).len() ==> is_valid_integer(split_by_space(lines[1])[i])) &&\n    (forall|i: int| 0 <= i < split_by_space(lines[2]).len() ==> is_valid_integer(split_by_space(lines[2])[i])) &&\n    (forall|i: int| 0 <= i < split_by_space(lines[3]).len() ==> is_valid_integer(split_by_space(lines[3])[i]))\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (s[0] == '-' ==> s.len() > 1) && \n    (forall|i: int| (if s[0] == '-' { 1int } else { 0int }) <= i < s.len() ==> '0' <= s[i] <= '9')\n}\n\nspec fn get_first_sum(input: Seq<char>) -> int {\n    let lines = split_by_newline(input);\n    let first_line = split_by_space(lines[1]);\n    sum_sequence(first_line)\n}\n\nspec fn get_second_sum(input: Seq<char>) -> int {\n    let lines = split_by_newline(input);\n    let second_line = split_by_space(lines[2]);\n    sum_sequence(second_line)\n}\n\nspec fn get_third_sum(input: Seq<char>) -> int {\n    let lines = split_by_newline(input);\n    let third_line = split_by_space(lines[3]);\n    sum_sequence(third_line)\n}\n\nspec fn sum_sequence(numbers: Seq<Seq<char>>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() == 0 { 0 }\n    else { string_to_int(numbers[0]) + sum_sequence(numbers.drop_first()) }\n}\n\nspec fn split_by_newline(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { seq![] }\n    else if s[0] == '\\n' { split_by_newline(s.drop_first()) }\n    else {\n        let rest = split_by_newline(s.drop_first());\n        if rest.len() == 0 { seq![s] }\n        else { seq![seq![s[0]].add(rest[0])].add(rest.drop_first()) }\n    }\n}\n\nspec fn split_by_space(s: Seq<char>) -> Seq<Seq<char>> {\n    split_by_char(s, ' ')\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { seq![] }\n    else {\n        let pos = find_char(s, delimiter, 0);\n        if pos == -1 { seq![s] }\n        else if pos == 0 { split_by_char(s.drop_first(), delimiter) }\n        else { seq![s.take(pos)].add(split_by_char(s.skip(pos + 1), delimiter)) }\n    }\n}\n\nspec fn find_char(s: Seq<char>, c: char, start: int) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { -1 }\n    else if s[start] == c { start }\n    else { find_char(s, c, start + 1) }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 { 0 }\n    else if s[0] == '-' { -string_to_int_helper(s.drop_first(), 0) }\n    else { string_to_int_helper(s, 0) }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, acc: int) -> int\n    decreases s.len()\n{\n    if s.len() == 0 { acc }\n    else if '0' <= s[0] <= '9' {\n        string_to_int_helper(s.drop_first(), acc * 10 + (s[0] as int - '0' as int))\n    } else { acc }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else if n < 0 { seq!['-'].add(int_to_string_helper(-n)) }\n    else { int_to_string_helper(n) }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    decreases n\n{\n    if n == 0 { seq![] }\n    else { int_to_string_helper(n / 10).add(seq![((n % 10) + '0' as int) as char]) }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    requires valid_input(input@)\n    ensures result@ == int_to_string(get_first_sum(input@) - get_second_sum(input@)).add(seq!['\\n']).add(int_to_string(get_second_sum(input@) - get_third_sum(input@))).add(seq!['\\n'])", "vc-code": "{\n    assume(false);\n    String::new()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0354", "language": "verus", "source": "apps", "source-id": "apps_test_1835", "source-notes": "", "vc-description": "Given n binary strings, you can swap any two characters from any positions \n(within same string or across different strings) any number of times. \nFind the maximum number of strings that can be made palindromic simultaneously.\nA palindrome reads the same forwards and backwards.\n\n/* Simplified implementation */\n\n/* Simplified implementation */\n\n/* Simplified implementation */\n\n/* Simplified implementation */\n\n/* Simplified implementation */\n\n/* Simplified implementation */\n\n/* Simplified implementation */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> s[i] == '0' || s[i] == '1'\n}\n\nspec fn count_test_cases(input: Seq<char>) -> nat\n    recommends valid_input_format(input)\n{\n    1\n}\n\nspec fn count_lines(s: Seq<char>) -> nat {\n    1\n}\n\nspec fn get_line(s: Seq<char>, i: nat) -> Seq<char>\n    recommends i < count_lines(s)\n{\n    seq!['1']\n}\n\nspec fn get_string_count(input: Seq<char>, test_case: nat) -> nat\n    recommends test_case < count_test_cases(input) && valid_input_format(input)\n{\n    1\n}\n\nspec fn get_test_case_strings(input: Seq<char>, test_case: nat) -> Seq<Seq<char>>\n    recommends test_case < count_test_cases(input) && valid_input_format(input)\n{\n    seq![seq!['0']]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    1\n}\n\nspec fn greedy_palindrome_count(strings: Seq<Seq<char>>) -> nat\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)\n{\n    0\n}\n\nspec fn compute_max_palindromes(strings: Seq<Seq<char>>) -> nat\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s)\n{\n    greedy_palindrome_count(strings)\n}\n\nspec fn palindromic_strings_achievable(strings: Seq<Seq<char>>, k: nat) -> bool\n    recommends forall|s: Seq<char>| strings.contains(s) ==> is_binary_string(s) && k <= strings.len()\n{\n    k <= greedy_palindrome_count(strings)\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (result: Seq<char>)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0355", "language": "verus", "source": "apps", "source-id": "apps_test_1836", "source-notes": "", "vc-description": "Given n points and m segments, find a \"hedgehog\" with maximum beauty.\nA hedgehog has a tail (path with strictly increasing point numbers) and \nspines (all segments connected to tail's endpoint). \nBeauty = (tail length) × (number of spines).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, edges: Seq<(int, int)>) -> bool {\n    n >= 2 &&\n    forall|i: int| 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n && edges[i].0 != edges[i].1\n}\n\nspec fn valid_output(result: int, n: int, edges: Seq<(int, int)>) -> bool {\n    result >= 0 && result <= 2 * edges.len() * (edges.len() + 1)\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, edges: Vec<(i8, i8)>) -> (result: i8)\n    requires \n        valid_input(n as int, edges@.map(|e: (i8, i8)| -> (int, int) { (e.0 as int, e.1 as int) }))\n    ensures \n        valid_output(result as int, n as int, edges@.map(|e: (i8, i8)| -> (int, int) { (e.0 as int, e.1 as int) }))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0367", "language": "verus", "source": "apps", "source-id": "apps_test_1912", "source-notes": "", "vc-description": "Given T test cases with four integers r, g, b, w representing ball counts,\ndetermine if balls can be arranged into a palindrome after performing operations.\nOperation: select one red, green, and blue ball and change all three to white.\nFor palindromes, at most one color can have an odd count.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    input[input.len() as int - 1] == '\\n' &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output_format(output: Seq<char>) -> bool {\n    output.len() == 0 || output[output.len() as int - 1] == '\\n'\n}\n\nspec fn input_output_correspondence(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input) && valid_output_format(output)\n{\n    true\n}\n\nspec fn process_input(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    input.subrange(0, 0)\n}\n\nspec fn can_form_palindrome(r: int, g: int, b: int, w: int) -> bool\n    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + \n                    (if g % 2 == 1 { 1int } else { 0int }) + \n                    (if b % 2 == 1 { 1int } else { 0int }) + \n                    (if w % 2 == 1 { 1int } else { 0int });\n    odd_count <= 1 || \n    (r > 0 && g > 0 && b > 0 && can_form_palindrome_after_operation(r-1, g-1, b-1, w+3))\n}\n\nspec fn can_form_palindrome_after_operation(r: int, g: int, b: int, w: int) -> bool\n    recommends r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n    let odd_count = (if r % 2 == 1 { 1int } else { 0int }) + \n                    (if g % 2 == 1 { 1int } else { 0int }) + \n                    (if b % 2 == 1 { 1int } else { 0int }) + \n                    (if w % 2 == 1 { 1int } else { 0int });\n    odd_count <= 1\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires\n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() as int - 1] == '\\n' || \n        !stdin_input.subrange(0, stdin_input.len() as int - 1).contains('\\n'),\n        valid_input(stdin_input),\n    ensures\n        result.len() >= 0,\n        forall|i: int| 0 <= i < result.len() ==> \n            result[i] == 'Y' || result[i] == 'e' || result[i] == 's' || \n            result[i] == 'N' || result[i] == 'o' || result[i] == '\\n' || result[i] == ' ',\n        result.len() == 0 || result[result.len() as int - 1] == '\\n',\n        valid_output_format(result),\n        input_output_correspondence(stdin_input, result),\n        result == process_input(stdin_input),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0371", "language": "verus", "source": "apps", "source-id": "apps_test_1932", "source-notes": "", "vc-description": "Given a collection of regular polyhedrons, calculate the total number of faces.\nEach polyhedron type has a fixed number of faces:\n- Tetrahedron: 4 faces, Cube: 6 faces, Octahedron: 8 faces\n- Dodecahedron: 12 faces, Icosahedron: 20 faces\nInput: First line contains n (number of polyhedrons), next n lines contain polyhedron names\nOutput: Total number of faces across all polyhedrons", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(input: String) -> bool {\n        input.len() > 0 && \n        {\n            let lines = split_lines_func(input);\n            lines.len() >= 2 && \n            string_to_int_func(lines[0]) >= 1 &&\n            string_to_int_func(lines[0]) <= (lines.len() as int) - 1\n        }\n    }\n    \n    spec fn get_faces(polyhedron: String) -> int {\n        if polyhedron == \"Tetrahedron\" { 4 }\n        else if polyhedron == \"Cube\" { 6 }\n        else if polyhedron == \"Octahedron\" { 8 }\n        else if polyhedron == \"Dodecahedron\" { 12 }\n        else if polyhedron == \"Icosahedron\" { 20 }\n        else { 0 }\n    }\n    \n    spec fn split_lines_func(s: String) -> Seq<String> {\n        split_lines_helper(s, 0, 0, seq![])\n    }\n    \n    spec fn split_lines_helper(s: String, start: int, i: int, acc: Seq<String>) -> Seq<String>\n        decreases s.len() - i\n    {\n        if i >= s.len() {\n            if start < s.len() { acc.push(s.substring_char(start as usize, s.len()).to_string()) }\n            else { acc }\n        } else if s.get_char(i as usize) == '\\n' {\n            let new_acc = if start <= i { acc.push(s.substring_char(start as usize, i as usize).to_string()) } else { acc };\n            split_lines_helper(s, i + 1, i + 1, new_acc)\n        } else {\n            split_lines_helper(s, start, i + 1, acc)\n        }\n    }\n    \n    spec fn string_to_int_func(s: String) -> int {\n        let trimmed = trim_func(s);\n        if trimmed.len() == 0 { 0 }\n        else { string_to_int_helper(trimmed, 0, 0) }\n    }\n    \n    spec fn string_to_int_helper(s: String, i: int, acc: int) -> int\n        decreases s.len() - i\n    {\n        if i >= s.len() { acc }\n        else if '0' <= s.get_char(i as usize) <= '9' {\n            string_to_int_helper(s, i + 1, acc * 10 + (s.get_char(i as usize) as int - '0' as int))\n        } else {\n            string_to_int_helper(s, i + 1, acc)\n        }\n    }\n    \n    spec fn int_to_string_func(n: int) -> String {\n        if n == 0 { \"0\".to_string() }\n        else { int_to_string_helper(n) }\n    }\n    \n    spec fn int_to_string_helper(n: int) -> String\n        decreases n\n    {\n        if n < 10 { \n            char::from_u32((n + ('0' as int)) as u32).unwrap().to_string()\n        } else { \n            int_to_string_helper(n / 10) + char::from_u32((n % 10 + ('0' as int)) as u32).unwrap().to_string()\n        }\n    }\n    \n    spec fn trim_func(s: String) -> String {\n        let start = trim_start(s, 0);\n        let end = trim_end(s, s.len() as int, start);\n        if start < end { s.substring_char(start as usize, end as usize).to_string() } else { \"\".to_string() }\n    }\n    \n    spec fn trim_start(s: String, i: int) -> int\n        decreases s.len() - i\n    {\n        if i >= s.len() { i }\n        else if s.get_char(i as usize) == ' ' || s.get_char(i as usize) == '\\t' || s.get_char(i as usize) == '\\r' || s.get_char(i as usize) == '\\n' {\n            trim_start(s, i + 1)\n        } else { i }\n    }\n    \n    spec fn trim_end(s: String, j: int, start: int) -> int\n        decreases j - start\n    {\n        if j <= start { start }\n        else if s.get_char((j-1) as usize) == ' ' || s.get_char((j-1) as usize) == '\\t' || s.get_char((j-1) as usize) == '\\r' || s.get_char((j-1) as usize) == '\\n' {\n            trim_end(s, j - 1, start)\n        } else { j }\n    }\n    \n    spec fn compute_total_up_to(lines: Seq<String>, count: int) -> int {\n        if count == 0 { 0 }\n        else if count >= lines.len() { 0 }\n        else { get_faces(trim_func(lines[count])) + compute_total_up_to(lines, count - 1) }\n    }", "vc-helpers": "", "vc-spec": "fn solve(input: String) -> (result: String)\n    requires\n        valid_input(input),\n    ensures\n        result.len() > 0,\n        result.get_char((result.len() - 1) as usize) == '\\n',\n        exists|total_faces: int| total_faces >= 0 && result == int_to_string_func(total_faces) + \"\\n\",\n        valid_input(input) ==> {\n            let lines = split_lines_func(input);\n            let n = string_to_int_func(lines[0]);\n            let expected_total = compute_total_up_to(lines, n);\n            result == int_to_string_func(expected_total) + \"\\n\"\n        },", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"0\\n\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0373", "language": "verus", "source": "apps", "source-id": "apps_test_1948", "source-notes": "", "vc-description": "Given an undirected tree with n vertices rooted at vertex 1, Alice starts at vertex 1 and Bob starts at vertex x.\nPlayers alternate turns with Bob going first. Each turn a player can stay at current vertex or move to adjacent vertex.\nGame ends when Alice reaches Bob's vertex. Alice minimizes total moves, Bob maximizes total moves.\nFind the total number of moves in optimal play.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, x: int, edges: Seq<(int, int)>) -> bool {\n  n > 0 && 1 <= x <= n && edges.len() == n - 1 &&\n  forall|e: (int, int)| #[trigger] edges.contains(e) ==> 0 <= e.0 < n && 0 <= e.1 < n\n}\n\nspec fn valid_distances(way_a: Seq<int>, way_b: Seq<int>, n: int, x: int) -> bool {\n  way_a.len() == n && way_b.len() == n && n > 0 && 1 <= x <= n &&\n  way_a[0] == 0 && way_b[x-1] == 0 &&\n  forall|i: int| 0 <= i < n ==> #[trigger] way_a[i] >= 0 && #[trigger] way_b[i] >= 0\n}\n\nspec fn valid_leaves(leaves: Seq<int>, edges: Seq<(int, int)>, n: int) -> bool {\n  valid_input(n, 1, edges) ==>\n  (forall|i: int| 0 <= i < leaves.len() ==> 0 <= #[trigger] leaves[i] < n) &&\n  (forall|i: int| 0 <= i < leaves.len() ==> is_leaf_node(#[trigger] leaves[i], edges, n)) &&\n  (forall|i: int| 0 <= i < n ==> is_leaf_node(i, edges, n) ==> #[trigger] leaves.contains(i)) &&\n  no_duplicates(leaves)\n}\n\nspec fn optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {\n  2 * compute_optimal_moves(way_a, way_b, leaves, x-1)\n}\nspec fn is_leaf_node(node: int, edges: Seq<(int, int)>, n: int) -> bool {\n  if 0 <= node < n {\n    let degree = edges.filter(|e: (int, int)| e.0 == node || e.1 == node).len();\n    degree <= 1\n  } else {\n    false\n  }\n}\n\nspec fn no_duplicates(s: Seq<int>) -> bool {\n  forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() && i != j ==> #[trigger] s[i] != #[trigger] s[j]\n}\n\nspec fn compute_optimal_moves(way_a: Seq<int>, way_b: Seq<int>, leaves: Seq<int>, x: int) -> int {\n  if leaves.len() == 0 {\n    0\n  } else {\n    let max_leaf = leaves.fold_left(0, |acc: int, leaf: int| \n      if way_a[leaf] + way_b[leaf] > acc { way_a[leaf] + way_b[leaf] } else { acc }\n    );\n    max_leaf\n  }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, x: i8, edges: Vec<(i8, i8)>, leaves: Vec<i8>, way_a: Vec<i8>, way_b: Vec<i8>) -> (result: i8)\n  requires \n    valid_input(n as int, x as int, edges@.map(|e: (i8, i8)| (e.0 as int, e.1 as int))) &&\n    valid_distances(way_a@.map(|w: i8| w as int), way_b@.map(|w: i8| w as int), n as int, x as int) &&\n    valid_leaves(leaves@.map(|l: i8| l as int), edges@.map(|e: (i8, i8)| (e.0 as int, e.1 as int)), n as int) &&\n    (forall|i: int| 0 <= i < leaves@.len() ==> \n      (0 <= leaves@[i] as int < way_a@.len()) && \n      (0 <= leaves@[i] as int < way_b@.len()))\n  ensures \n    result >= 0 &&\n    result as int == optimal_moves(way_a@.map(|w: i8| w as int), way_b@.map(|w: i8| w as int), leaves@.map(|l: i8| l as int), x as int) &&\n    (result as int) % 2 == 0 &&\n    result as int >= 2 * way_a@[(x-1) as int] as int", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0376", "language": "verus", "source": "apps", "source-id": "apps_test_1966", "source-notes": "", "vc-description": "Given 4 square pieces of size n×n (where n is odd), each containing squares colored 0 (white) or 1 (black),\narrange them into a 2n×2n board and recolor the minimum number of squares to form a valid chessboard.\nA valid chessboard has alternating colors where each square has a different color from all its adjacent squares.\nPieces can be rearranged but cannot be rotated or flipped.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn contains_valid_input_format(input: Seq<char>) -> bool {\n    exists|n: int| 1 <= n <= 100 && n % 2 == 1 && \n        input_has_correct_structure_for_n(input, n) &&\n        input_contains_exactly_four_pieces_of_size_n(input, n) &&\n        all_pieces_contain_only_binary_chars(input, n)\n}\n\nspec fn input_has_correct_structure_for_n(input: Seq<char>, n: int) -> bool\n    recommends 1 <= n <= 100 && n % 2 == 1\n{\n    let lines = split_by_newline(input);\n    lines.len() >= 4*n + 4 &&\n    is_valid_integer_string(lines[0]) &&\n    string_to_int(lines[0]) == n &&\n    (lines.len() > n+1 ==> equal(lines[n+1], seq![])) && \n    (lines.len() > 2*n+2 ==> equal(lines[2*n+2], seq![])) && \n    (lines.len() > 3*n+3 ==> equal(lines[3*n+3], seq![]))\n}\n\nspec fn input_contains_exactly_four_pieces_of_size_n(input: Seq<char>, n: int) -> bool\n    recommends 1 <= n <= 100 && n % 2 == 1\n{\n    let lines = split_by_newline(input);\n    lines.len() >= 4*n + 4 &&\n    (forall|i: int| 1 <= i <= n && i < lines.len() ==> #[trigger] lines[i].len() == n) &&\n    (forall|i: int| n+2 <= i <= 2*n+1 && i < lines.len() ==> #[trigger] lines[i].len() == n) &&\n    (forall|i: int| 2*n+3 <= i <= 3*n+2 && i < lines.len() ==> #[trigger] lines[i].len() == n) &&\n    (forall|i: int| 3*n+4 <= i <= 4*n+3 && i < lines.len() ==> #[trigger] lines[i].len() == n)\n}\n\nspec fn all_pieces_contain_only_binary_chars(input: Seq<char>, n: int) -> bool\n    recommends 1 <= n <= 100 && n % 2 == 1\n{\n    let lines = split_by_newline(input);\n    lines.len() >= 4*n + 4 &&\n    (forall|i: int, j: int| 1 <= i <= n && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&\n    (forall|i: int, j: int| n+2 <= i <= 2*n+1 && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&\n    (forall|i: int, j: int| 2*n+3 <= i <= 3*n+2 && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1')) &&\n    (forall|i: int, j: int| 3*n+4 <= i <= 4*n+3 && i < lines.len() && 0 <= j < lines[i].len() ==> \n        (#[trigger] lines[i][j] == '0' || #[trigger] lines[i][j] == '1'))\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    (s[0] != '0' || s.len() == 1) &&\n    forall|i: int| 0 <= i < s.len() ==> ('0' <= #[trigger] s[i] && #[trigger] s[i] <= '9')\n}\n\nspec fn represents_minimum_recoloring_count(input: Seq<char>, output: Seq<char>) -> bool {\n    is_valid_integer_string(output) &&\n    contains_valid_input_format(input) &&\n    {\n        let n = extract_n_from_input(input);\n        let pieces = extract_pieces_from_input(input);\n        pieces.len() == 4 &&\n        (forall|piece: Seq<Seq<char>>| pieces.contains(piece) ==> \n            piece.len() == n && \n            (forall|row: Seq<char>| piece.contains(row) ==> \n                row.len() == n &&\n                (forall|i: int| 0 <= i < row.len() ==> (row[i] == '0' || row[i] == '1')))) &&\n        string_to_int(output) == minimum_recoloring_for_pieces(pieces, n)\n    }\n}\n\nspec fn extract_n_from_input(input: Seq<char>) -> int\n    recommends contains_valid_input_format(input)\n{\n    let lines = split_by_newline(input);\n    if lines.len() > 0 && is_valid_integer_string(lines[0]) {\n        string_to_int(lines[0])\n    } else {\n        1\n    }\n}\n\nspec fn extract_pieces_from_input(input: Seq<char>) -> Seq<Seq<Seq<char>>>\n    recommends contains_valid_input_format(input)\n{\n    let lines = split_by_newline(input);\n    let n = extract_n_from_input(input);\n    seq![\n        lines.subrange(1, n+1),\n        lines.subrange(n+2, 2*n+2), \n        lines.subrange(2*n+3, 3*n+3),\n        lines.subrange(3*n+4, 4*n+4)\n    ]\n}\n\nspec fn minimum_recoloring_for_pieces(pieces: Seq<Seq<Seq<char>>>, n: int) -> int {\n    0\n}\n\nspec fn split_by_newline(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0377", "language": "verus", "source": "apps", "source-id": "apps_test_1968", "source-notes": "", "vc-description": "Given n sellers and Valera's budget v, determine which sellers Valera can make a deal with.\nEach seller i has ki items with prices. Valera can buy from seller i if his budget v is\nstrictly greater than the minimum price among seller i's items.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, v: int, sellers: Seq<Seq<int>>) -> bool {\n    n >= 0 && v >= 0 && sellers.len() == n && \n    forall|i: int| 0 <= i < sellers.len() ==> sellers[i].len() > 0\n}\n\nspec fn valid_output(count: int, indices: Seq<int>, n: int) -> bool {\n    count == indices.len() && count >= 0 && count <= n &&\n    (forall|i: int| 0 <= i < indices.len() ==> 1 <= indices[i] <= n) &&\n    (forall|i: int| 0 <= i < indices.len() - 1 ==> indices[i] < indices[i+1])\n}\n\nspec fn correct_solution(v: int, sellers: Seq<Seq<int>>, indices: Seq<int>) -> bool \n    recommends forall|i: int| 0 <= i < sellers.len() ==> sellers[i].len() > 0,\n              forall|i: int| 0 <= i < indices.len() ==> 1 <= indices[i] <= sellers.len()\n{\n    (forall|i: int| 0 <= i < indices.len() ==> v > seq_min(sellers[indices[i] - 1])) &&\n    (forall|i: int| 0 <= i < sellers.len() ==> (v > seq_min(sellers[i]) <==> indices.contains(i + 1)))\n}\n\nspec fn seq_min(s: Seq<int>) -> int\n    recommends s.len() > 0\n{\n    if s.len() == 1 {\n        s[0]\n    } else {\n        let first = s[0];\n        let rest_min = seq_min(s.subrange(1, s.len() as int));\n        if first < rest_min { first } else { rest_min }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i32, v: i32, sellers: Vec<Vec<i32>>) -> (result: (i32, Vec<i32>))\n    requires valid_input(n as int, v as int, sellers@.map(|i: int, s: Vec<i32>| s@.map(|j: int, x: i32| x as int)))\n    ensures ({\n        let (count, indices) = result;\n        valid_output(count as int, indices@.map(|i: int, x: i32| x as int), n as int) && \n        correct_solution(v as int, sellers@.map(|i: int, s: Vec<i32>| s@.map(|j: int, x: i32| x as int)), indices@.map(|i: int, x: i32| x as int))\n    })", "vc-code": "{\n    // impl-start\n    assume(false);\n    (0, Vec::new())\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0378", "language": "verus", "source": "apps", "source-id": "apps_test_1972", "source-notes": "", "vc-description": "Process queries on an array of 500,000 integers initially set to zero.\nType 1 queries add a value to a specific position.\nType 2 queries calculate sum of elements at positions with specific modular property.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    output.len() > 0 && output[output.len() - 1] == '\\n'\n}\n\nspec fn correct_incremental_query_processing(input: Seq<char>, output: Seq<char>) -> bool {\n    true\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    if input.len() == 0 { \n        seq![]\n    } else { \n        seq![seq!['1'], seq!['q', 'u', 'e', 'r', 'y', '1']] \n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn count_type2_queries(queries: Seq<Seq<char>>) -> nat {\n    0\n}\n\nspec fn int_to_string(x: int) -> Seq<char> {\n    seq!['1']\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (output: Seq<char>)\n    requires \n        input.len() > 0,\n        valid_input(input),\n    ensures \n        valid_output(output, input),\n        output.len() > 0 && output[output.len() - 1] == '\\n',\n        correct_incremental_query_processing(input, output),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0379", "language": "verus", "source": "apps", "source-id": "apps_test_1980", "source-notes": "", "vc-description": "Given n problems with difficulties d_i (in increasing order) and costs c_i, find the maximum profit \nfrom selecting a consecutive subsegment of problems. For a subsegment [l, r]:\n- Revenue: (r - l + 1) × a burles (where a is profit per problem)\n- Costs: sum of c_i for i in [l, r] + gap(l, r)\n- gap(l, r) = max{(d_{i+1} - d_i)² | l ≤ i < r}, or 0 if l = r\n- Profit = Revenue - Costs\nFind the maximum possible profit (can be 0 if all segments are unprofitable).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_spec(input);\n    lines.len() >= 1 && \n    split_whitespace_spec(lines[0]).len() >= 2 &&\n    {\n        let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);\n        let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);\n        n > 0 && k > 0 && lines.len() >= n + 1 &&\n        (forall|i: int| 1 <= i <= n ==> \n            i < lines.len() && split_whitespace_spec(lines[i]).len() >= 2)\n    }\n}\n\nspec fn optimal_segment_profit(input: Seq<char>, n: nat, k: int) -> int {\n    let lines = split_lines_spec(input);\n    let difficulties = Seq::new(n, |i: int| \n        parse_int_spec(split_whitespace_spec(lines[i + 1])[0]));\n    let costs = Seq::new(n, |i: int| \n        parse_int_spec(split_whitespace_spec(lines[i + 1])[1]));\n\n    max_subsegment_profit(difficulties, costs, k)\n}\n\nspec fn max_subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int) -> int {\n    if difficulties.len() == 0 {\n        0\n    } else {\n        let all_segment_profits = Seq::new(difficulties.len(), |l: int| \n            Seq::new((difficulties.len() - l) as nat, |len: int|\n                subsegment_profit(difficulties, costs, k, l as nat, (l + len) as nat)));\n        max_value(0, max_in_nested_seq(all_segment_profits))\n    }\n}\n\nspec fn subsegment_profit(difficulties: Seq<int>, costs: Seq<int>, k: int, l: nat, r: nat) -> int {\n    let length = r - l + 1;\n    let revenue = length * k;\n    let cost_sum = sum_range(costs, l, r);\n    let gap = if l == r { 0 } else { max_gap_squared(difficulties, l, r) };\n    revenue - cost_sum - gap\n}\n\nspec fn split_lines_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_whitespace_spec(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int_spec(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string_result(n: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn sum_range(costs: Seq<int>, l: nat, r: nat) -> int {\n    0\n}\n\nspec fn max_gap_squared(difficulties: Seq<int>, l: nat, r: nat) -> int {\n    0\n}\n\nspec fn max_value(a: int, b: int) -> int {\n    if a >= b { a } else { b }\n}\n\nspec fn max_in_nested_seq(nested: Seq<Seq<int>>) -> int {\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires\n        input@.len() > 0,\n    ensures\n        result@.len() > 0,\n        result@.last() == '\\n',\n        ({\n            let lines = split_lines_spec(input@);\n            (lines.len() == 0 || lines.len() == 1 || \n             split_whitespace_spec(lines[0]).len() < 2 ||\n             parse_int_spec(split_whitespace_spec(lines[0])[0]) <= 0) ==> \n            result@ == \"0\\n\"@\n        }),\n        (valid_input(input@) ==> {\n            let lines = split_lines_spec(input@);\n            let n = parse_int_spec(split_whitespace_spec(lines[0])[0]);\n            let k = parse_int_spec(split_whitespace_spec(lines[0])[1]);\n            exists|profit: int| \n                profit >= 0 && \n                result@ == int_to_string_result(profit) + \"\\n\"@ &&\n                profit == optimal_segment_profit(input@, n as nat, k)\n        }),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0380", "language": "verus", "source": "apps", "source-id": "apps_test_1984", "source-notes": "", "vc-description": "Given k game levels represented as n×m grids containing candies (letters) or empty cells ('.'),\nfind the minimum cost to transmit all levels. Each level can be transmitted in full (cost: n×m)\nor as differences from a previously transmitted level (cost: d×w where d is number of differing cells).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_first_line(s: Seq<char>) -> (nat, nat, nat, nat) {\n    (1, 1, 1, 1)\n}\n\nspec fn parse_levels(lines: Seq<Seq<char>>, n: nat, m: nat, k: nat) -> Seq<Seq<Seq<char>>> {\n    seq![]\n}\n\nspec fn int_to_string(n: nat) -> Seq<char> {\n    seq![]\n}\n\nspec fn parse_dependency_line(s: Seq<char>) -> (nat, nat) {\n    (1, 0)\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n    stdin_input.len() > 0 &&\n    stdin_input[stdin_input.len() as int - 1] == '\\n' &&\n    {\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        lines.len() > 0 &&\n        1 <= parse_first_line(lines[0]).0 <= 10 &&\n        1 <= parse_first_line(lines[0]).1 <= 10 &&\n        1 <= parse_first_line(lines[0]).2 <= 1000 &&\n        1 <= parse_first_line(lines[0]).3 <= 1000\n    }\n}\n\nspec fn valid_output(result: Seq<char>, stdin_input: Seq<char>) -> bool {\n    result.len() > 0 &&\n    result[result.len() as int - 1] == '\\n' &&\n    {\n        let result_lines = split_lines(result);\n        let lines = split_lines(stdin_input);\n        lines.len() >= 1 &&\n        result_lines.len() >= 1 &&\n        is_valid_spanning_tree(result_lines, parse_first_line(lines[0]).2)\n    }\n}\n\nspec fn calculate_mst_cost(n: nat, m: nat, k: nat, w: nat, levels: Seq<Seq<Seq<char>>>) -> nat {\n    0\n}\n\nspec fn is_valid_spanning_tree(result_lines: Seq<Seq<char>>, k: nat) -> bool {\n    true\n}\n\nspec fn count_differences(level1: Seq<Seq<char>>, level2: Seq<Seq<char>>, n: nat, m: nat) -> nat {\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires valid_input(stdin_input@)\n    ensures valid_output(result@, stdin_input@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0390", "language": "verus", "source": "apps", "source-id": "apps_test_2086", "source-notes": "", "vc-description": "Given n timezones where day has n hours, find the optimal start time for a 1-hour contest\nto maximize participants. When it's hour 1 in timezone 1, it's hour i in timezone i.\nPeople participate only if contest starts between hours s and f-1 in their local time.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>, s: int, f: int) -> bool {\n  n >= 2 && a.len() == n && s >= 1 && f > s && f <= n &&\n  forall|i: int| 0 <= i < n ==> a[i] >= 1\n}\n\nspec fn participant_count(a: Seq<int>, s: int, f: int, n: int, start: int) -> int {\n  participant_count_helper(a, s, f, n, start, 0)\n}\n\nspec fn participant_count_helper(a: Seq<int>, s: int, f: int, n: int, start: int, i: int) -> int\n  decreases n - i\n{\n  if i >= n {\n    0\n  } else {\n    let local_hour = (start + i - 1) % n + 1;\n    let contribution = if s <= local_hour < f { a[i] } else { 0 };\n    contribution + participant_count_helper(a, s, f, n, start, i + 1)\n  }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>, s: i8, f: i8) -> (result: i8)\n  requires \n    valid_input(n as int, a@.map(|i, x| x as int), s as int, f as int),\n  ensures \n    1 <= result <= n &&\n    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start) \n      && 1 <= start <= n as int ==> \n      participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, result as int) >= participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start)) &&\n    (forall|start: int| #[trigger] participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start)\n      && 1 <= start <= n as int && \n      participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, start) == participant_count(a@.map(|i, x| x as int), s as int, f as int, n as int, result as int) \n      ==> result as int <= start)", "vc-code": "{\n  assume(false);\n  unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0391", "language": "verus", "source": "apps", "source-id": "apps_test_2100", "source-notes": "", "vc-description": "Given n cupboards with left and right doors that can be open (1) or closed (0),\nfind the minimum number of operations to make all left doors have the same state\nand all right doors have the same state. Each operation changes one door's state.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 &&\n    is_valid_number(lines[0]) &&\n    {\n        let n = string_to_int(lines[0]);\n        n >= 0 && n + 1 <= lines.len() &&\n        forall|i: int| 1 <= i <= n && i < lines.len() ==>\n            {\n                let parts = split_spaces(#[trigger] lines[i as int]);\n                parts.len() >= 2 && is_valid_door_state(parts[0]) && is_valid_door_state(parts[1])\n            }\n    }\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    is_valid_number(output)\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> (#[trigger] s[i] >= '0' && #[trigger] s[i] <= '9')\n}\n\nspec fn is_valid_door_state(s: Seq<char>) -> bool {\n    s == seq!['0'] || s == seq!['1']\n}\n\nspec fn calculate_min_operations(input: Seq<char>) -> Seq<char> {\n    let lines = split_lines(input);\n    let n = string_to_int(lines[0]);\n    if n == 0 {\n        seq!['0']\n    } else {\n        let left_zeros = count_left_zeros(lines, 1, n);\n        let right_zeros = count_right_zeros(lines, 1, n);\n        let left_ops = if left_zeros < n - left_zeros { left_zeros } else { n - left_zeros };\n        let right_ops = if right_zeros < n - right_zeros { right_zeros } else { n - right_zeros };\n        int_to_string(left_ops + right_ops)\n    }\n}\n\n/* Helper functions for string operations */\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn split_spaces(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq!['0']\n}\n\nspec fn count_left_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {\n    0\n}\n\nspec fn count_right_zeros(lines: Seq<Seq<char>>, start: int, n: int) -> int {\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires \n        input@.len() > 0,\n        valid_input(input@),\n    ensures \n        result@.len() > 0,\n        valid_output(result@),\n        result@ == calculate_min_operations(input@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0393", "language": "verus", "source": "apps", "source-id": "apps_test_2113", "source-notes": "", "vc-description": "Given a tree with n nodes, determine the maximum number of edges that can be added \nwhile maintaining the bipartite property and keeping the graph simple (no loops or multiple edges).\nSince any tree is bipartite, we can 2-color it into partitions of sizes a and b.\nA complete bipartite graph has a×b edges, and the tree has n-1 edges, so answer is a×b-(n-1).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn is_connected_tree(n: int, edges: Seq<(int, int)>) -> bool {\n        n >= 1 && edges.len() == n - 1 &&\n        (n == 1 ==> edges.len() == 0) &&\n        (n > 1 ==> is_connected_graph(n, edges))\n    }\n    \n    spec fn is_connected_graph(n: int, edges: Seq<(int, int)>) -> bool {\n        n > 1 ==>\n        (forall|node: int| 2 <= node <= n ==> \n            can_reach_node_one(node, edges, n))\n    }\n    \n    spec fn can_reach_node_one(target: int, edges: Seq<(int, int)>, max_depth: int) -> bool\n        decreases max_depth\n    {\n        if max_depth <= 0 { \n            false\n        } else if target == 1 { \n            true\n        } else {\n            exists|i: int| 0 <= i < edges.len() && \n                ((edges[i].0 == target && can_reach_node_one(edges[i].1, edges, max_depth - 1)) ||\n                 (edges[i].1 == target && can_reach_node_one(edges[i].0, edges, max_depth - 1)))\n        }\n    }\n    \n    spec fn valid_tree_input(n: int, edges: Seq<(int, int)>) -> bool {\n        n >= 1 &&\n        edges.len() == n - 1 &&\n        (forall|i: int| #[trigger] edges.index(i).0 == edges[i].0 && 0 <= i < edges.len() ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n) &&\n        (forall|i: int| #[trigger] edges.index(i).0 == edges[i].0 && 0 <= i < edges.len() ==> edges[i].0 != edges[i].1) &&\n        (forall|i: int, j: int| #[trigger] edges.index(i).0 == edges[i].0 && #[trigger] edges.index(j).0 == edges[j].0 && 0 <= i < j < edges.len() ==> \n            !(edges[i].0 == edges[j].0 && edges[i].1 == edges[j].1) && \n            !(edges[i].0 == edges[j].1 && edges[i].1 == edges[j].0)) &&\n        (n == 1 ==> edges.len() == 0) &&\n        (n > 1 ==> (forall|node: int| #[trigger] (node + 1 - 1) == node && 1 <= node <= n ==> \n            (exists|i: int| 0 <= i < edges.len() && (edges[i].0 == node || edges[i].1 == node)))) &&\n        is_connected_tree(n, edges)\n    }", "vc-helpers": "", "vc-spec": "fn solve(n: i8, edges: Vec<(i8, i8)>) -> (result: i8)\n    requires\n        valid_tree_input(n as int, Seq::from_vec(edges).map(|i, e| (e.0 as int, e.1 as int))),\n    ensures\n        result >= 0,\n        exists|blue: int, red: int| #[trigger] (blue + red) == (blue + red) &&\n            blue >= 0 && red >= 0 && blue + red == n as int && result as int == blue * red - (n as int - 1),\n        n == 1 ==> result == 0,\n        n == 2 ==> result == 0,\n        n > 2 ==> exists|blue: int, red: int| #[trigger] (blue + red) == (blue + red) &&\n            blue > 0 && red > 0 && blue + red == n as int && result as int == blue * red - (n as int - 1),\n        result as int <= (n as int * n as int) / 4 - (n as int - 1) + (if n % 2 == 0 { 0int } else { 1int }),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0395", "language": "verus", "source": "apps", "source-id": "apps_test_2133", "source-notes": "", "vc-description": "Given a tree with vertices colored black (1) or white (0), find the minimum number of paint operations\nto make all vertices the same color. A paint(v) operation changes the color of all vertices u such that\nall vertices on the shortest path from v to u have the same color.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_tree_input(input: Seq<char>) -> bool {\n  let lines = split_lines(input);\n  lines.len() >= 2 &&\n  {\n    let n = parse_int(lines[0]);\n    n >= 1 && n <= 200000 &&\n    lines.len() == n + 1 &&\n    valid_color_line(lines[1], n) &&\n    valid_edge_lines(lines.subrange(2, lines.len() as int), n) &&\n    {\n      let edges = Seq::new((lines.len() - 2) as nat, |i: int| {\n        let edge = parse_int_seq(lines[i + 2]);\n        (edge[0], edge[1])\n      });\n      is_valid_tree(n, edges)\n    }\n  }\n}\n\nspec fn valid_color_line(line: Seq<char>, n: int) -> bool {\n  let colors = parse_int_seq(line);\n  colors.len() == n &&\n  forall|i: int| #![trigger colors[i]] 0 <= i < colors.len() ==> colors[i] == 0 || colors[i] == 1\n}\n\nspec fn valid_edge_lines(lines: Seq<Seq<char>>, n: int) -> bool {\n  lines.len() == n - 1 &&\n  forall|i: int| #![trigger lines[i]] 0 <= i < lines.len() ==> {\n    let edge = parse_int_seq(lines[i]);\n    edge.len() == 2 && \n    1 <= edge[0] <= n && \n    1 <= edge[1] <= n && \n    edge[0] != edge[1]\n  }\n}\n\nspec fn is_valid_tree(n: int, edges: Seq<(int, int)>) -> bool {\n  n >= 1 &&\n  edges.len() == n - 1 &&\n  is_connected(n, edges) &&\n  (forall|e: (int, int)| edges.contains(e) ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1) &&\n  no_duplicate_edges(edges)\n}\n\nspec fn is_connected(n: int, edges: Seq<(int, int)>) -> bool {\n  true\n}\n\nspec fn no_duplicate_edges(edges: Seq<(int, int)>) -> bool {\n  forall|i: int, j: int| #![trigger edges[i], edges[j]] 0 <= i < j < edges.len() ==> \n    edges[i] != edges[j] && \n    (edges[i].0, edges[i].1) != (edges[j].1, edges[j].0)\n}\n\nspec fn valid_integer_output(output: Seq<char>) -> bool {\n  let trimmed = trim_whitespace(output);\n  trimmed.len() > 0 &&\n  forall|c: char| trimmed.contains(c) ==> '0' <= c <= '9'\n}\n\nspec fn all_same_color(colors: Seq<int>) -> bool {\n  colors.len() > 0 ==> forall|i: int| #![trigger colors[i]] 0 <= i < colors.len() ==> colors[i] == colors[0]\n}\n\nspec fn parse_input(input: Seq<char>) -> (int, Seq<int>, Seq<(int, int)>) {\n  let lines = split_lines(input);\n  let n = parse_int(lines[0]);\n  let colors = parse_int_seq(lines[1]);\n  let edges = Seq::new((lines.len() - 2) as nat, |i: int| {\n    let edge = parse_int_seq(lines[i + 2]);\n    (edge[0], edge[1])\n  });\n  (n, colors, edges)\n}\n\nspec fn parse_output(output: Seq<char>) -> int {\n  parse_int(trim_whitespace(output))\n}\n\nspec fn compute_min_paint_ops(n: int, colors: Seq<int>, edges: Seq<(int, int)>) -> int {\n  if all_same_color(colors) {\n    0\n  } else {\n    let components = build_same_color_components(colors, edges);\n    let component_graph = build_component_graph(components, colors, edges);\n    (tree_diameter(component_graph) + 1) / 2\n  }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> { Seq::empty() }\nspec fn parse_int(line: Seq<char>) -> int { 0 }\nspec fn parse_int_seq(line: Seq<char>) -> Seq<int> { Seq::empty() }\nspec fn trim_whitespace(output: Seq<char>) -> Seq<char> { output }\nspec fn build_same_color_components(colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<Seq<int>> { Seq::empty() }\nspec fn build_component_graph(components: Seq<Seq<int>>, colors: Seq<int>, edges: Seq<(int, int)>) -> Seq<(int, int)> { Seq::empty() }\nspec fn tree_diameter(graph: Seq<(int, int)>) -> int { 0 }", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (output: String)\n  requires \n    stdin_input@ .len() > 0,\n    valid_tree_input(stdin_input@),\n  ensures \n    output@ .len() > 0,\n    valid_integer_output(output@),\n    ({\n      let result = parse_output(output@);\n      result >= 0\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      n >= 1 ==> {\n        let result = parse_output(output@);\n        result <= n\n      }\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      all_same_color(colors) ==> parse_output(output@) == 0\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      n == 1 ==> parse_output(output@) == 0\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      is_valid_tree(n, edges) && n >= 1\n    }),\n    ({\n      let (n, colors, edges) = parse_input(stdin_input@);\n      let result = parse_output(output@);\n      result == compute_min_paint_ops(n, colors, edges)\n    }),", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0397", "language": "verus", "source": "apps", "source-id": "apps_test_2168", "source-notes": "", "vc-description": "Given n companies, each with employees having specific salaries, merge all companies into one. \nCompanies can only merge if their maximum salaries are equal. You can increase salaries in any \ncompany, but all employees in the same company must receive the same increase. Find the minimum \ntotal salary increase needed to enable merging all companies.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_company_input(input: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 1 && \n    is_valid_positive_int(lines[0]) &&\n    {\n        let n = parse_int_func(lines[0]);\n        n >= 1 && lines.len() >= n + 1 &&\n        (forall|i: int| #![auto] 1 <= i <= n ==> valid_company_line(lines[i]))\n    }\n}\n\nspec fn valid_company_line(line: Seq<char>) -> bool {\n    let parts = split_spaces_func(line);\n    parts.len() >= 1 && is_valid_positive_int(parts[0]) &&\n    {\n        let m = parse_int_func(parts[0]);\n        m >= 1 && parts.len() == m + 1 &&\n        (forall|j: int| #![auto] 1 <= j <= m ==> is_valid_positive_int(parts[j]))\n    }\n}\n\nspec fn is_valid_positive_int(s: Seq<char>) -> bool {\n    s.len() >= 1 && (forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] && s[i] <= '9')\n}\n\nspec fn parse_companies(input: Seq<char>) -> Seq<Seq<int>> {\n    let lines = split_lines_func(input);\n    let n = parse_int_func(lines[0]);\n    Seq::new(n as nat, |i: int| {\n        let parts = split_spaces_func(lines[i + 1]);\n        let m = parse_int_func(parts[0]);\n        Seq::new(m as nat, |j: int| parse_int_func(parts[j + 1]))\n    })\n}\n\nspec fn calculate_minimum_increase(companies: Seq<Seq<int>>) -> int {\n    let global_max = global_max_salary(companies);\n    sum_over_companies(companies, global_max)\n}\n\nspec fn global_max_salary(companies: Seq<Seq<int>>) -> int {\n    max_in_seq_of_seq(Seq::new(companies.len(), |i: int| max_in_seq_func(companies[i])))\n}\n\nspec fn sum_over_companies(companies: Seq<Seq<int>>, global_max: int) -> int\n    decreases companies.len()\n{\n    if companies.len() == 0 {\n        0\n    } else if companies.len() == 1 {\n        let company_max = max_in_seq_func(companies[0]);\n        let increase_per_employee = global_max - company_max;\n        increase_per_employee * companies[0].len()\n    } else {\n        let company_max = max_in_seq_func(companies[0]);\n        let increase_per_employee = global_max - company_max;\n        increase_per_employee * companies[0].len() + sum_over_companies(companies.subrange(1, companies.len() as int), global_max)\n    }\n}\n\nspec fn max_in_seq_func(s: Seq<int>) -> int {\n    if s.len() > 0 {\n        max_in_seq(s)\n    } else {\n        0\n    }\n}\n\nspec fn max_in_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_max = max_in_seq(s.subrange(1, s.len() as int));\n        if s[0] >= tail_max {\n            s[0]\n        } else {\n            tail_max\n        }\n    }\n}\n\nspec fn max_in_seq_of_seq(s: Seq<int>) -> int\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        s[0]\n    } else {\n        let tail_max = max_in_seq_of_seq(s.subrange(1, s.len() as int));\n        if s[0] >= tail_max {\n            s[0]\n        } else {\n            tail_max\n        }\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn split_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: int)\n    requires\n        input@.len() > 0,\n        valid_company_input(input@),\n    ensures\n        result >= 0,\n        result == calculate_minimum_increase(parse_companies(input@)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0401", "language": "verus", "source": "apps", "source-id": "apps_test_2195", "source-notes": "", "vc-description": "Given two non-negative integers x and y, find the minimum cost to make both equal to zero using these operations:\n1. Pay $a to change exactly one integer by ±1\n2. Pay $b to change both integers by ±1 in the same direction", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 1 &&\n    is_valid_integer(lines[0]) &&\n    {\n        let t = string_to_int(lines[0]);\n        t >= 0 &&\n        lines.len() >= 1 + 2 * t &&\n        forall|i: int| 0 <= i < t ==> {\n            let line1_idx = 1 + 2 * i;\n            let line2_idx = 1 + 2 * i + 1;\n            line1_idx < lines.len() && line2_idx < lines.len() &&\n            {\n                let xy_parts = split_whitespace(lines[line1_idx]);\n                let ab_parts = split_whitespace(lines[line2_idx]);\n                xy_parts.len() >= 2 && ab_parts.len() >= 2 &&\n                is_valid_integer(xy_parts[0]) &&\n                is_valid_integer(xy_parts[1]) &&\n                is_valid_integer(ab_parts[0]) &&\n                is_valid_integer(ab_parts[1]) &&\n                string_to_int(xy_parts[0]) >= 0 &&\n                string_to_int(xy_parts[1]) >= 0 &&\n                string_to_int(ab_parts[0]) >= 1 &&\n                string_to_int(ab_parts[1]) >= 1\n            }\n        }\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() == 0 {\n        output.len() == 0\n    } else {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == (if t == 0 { 0 } else { t }) &&\n        forall|i: int| 0 <= i < output_lines.len() ==> is_valid_integer(output_lines[i])\n    }\n}\n\nspec fn correct_computation(input: Seq<char>, output: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    if lines.len() == 0 {\n        output.len() == 0\n    } else {\n        let t = string_to_int(lines[0]);\n        let output_lines = if output.len() == 0 { Seq::empty() } else { split_lines(output) };\n        output_lines.len() == (if t == 0 { 0 } else { t }) &&\n        forall|i: int| 0 <= i < t && 1 + 2 * i + 1 < lines.len() ==> {\n            let xy_line = split_whitespace(lines[1 + 2 * i]);\n            let ab_line = split_whitespace(lines[1 + 2 * i + 1]);\n            (xy_line.len() >= 2 && ab_line.len() >= 2) ==> {\n                let x = string_to_int(xy_line[0]);\n                let y = string_to_int(xy_line[1]);\n                let a = string_to_int(ab_line[0]);\n                let b = string_to_int(ab_line[1]);\n                let expected_result = if b <= 2 * a {\n                    b * (if x <= y { x } else { y }) + (if x >= y { x } else { y } - if x <= y { x } else { y }) * a\n                } else {\n                    a * (x + y)\n                };\n                i < output_lines.len() && string_to_int(output_lines[i]) == expected_result\n            }\n        }\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 &&\n    (s[0] == '-' ==> s.len() > 1) &&\n    forall|i: int| (if s[0] == '-' { 1int } else { 0int }) <= i < s.len() ==> '0' <= s[i] <= '9'\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        Seq::empty()\n    } else {\n        split_by_char(s, '\\n')\n    }\n}\n\nspec fn split_whitespace(s: Seq<char>) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        Seq::empty()\n    } else {\n        split_by_char(s, ' ')\n    }\n}\n\nspec fn split_by_char(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    if s.len() == 0 {\n        seq![Seq::empty()]\n    } else if s[0] == delimiter {\n        seq![Seq::empty()].add(split_by_char(s.subrange(1, s.len() as int), delimiter))\n    } else {\n        let rest = split_by_char(s.subrange(1, s.len() as int), delimiter);\n        if rest.len() == 0 {\n            seq![s]\n        } else {\n            seq![s.subrange(0, 1).add(rest[0])].add(rest.subrange(1, rest.len() as int))\n        }\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s[0] == '-' && s.len() > 1 {\n        -string_to_int_helper(s.subrange(1, s.len() as int))\n    } else {\n        string_to_int_helper(s)\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>) -> int {\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        if '0' <= s[0] <= '9' { s[0] as int - '0' as int } else { 0 }\n    } else {\n        string_to_int_helper(s.subrange(0, s.len() - 1)) * 10 +\n        (if '0' <= s[s.len() - 1] <= '9' { s[s.len() - 1] as int - '0' as int } else { 0 })\n    }\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    if n == 0 {\n        seq!['0']\n    } else if n < 0 {\n        seq!['-'].add(int_to_string_helper(-n))\n    } else {\n        int_to_string_helper(n)\n    }\n}\n\nspec fn int_to_string_helper(n: int) -> Seq<char>\n    recommends n >= 0\n{\n    if n == 0 {\n        Seq::empty()\n    } else {\n        let digit_char = ((n % 10) + ('0' as int)) as char;\n        int_to_string_helper(n / 10).push(digit_char)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (output: String)\n    requires\n        input@.len() > 0,\n        valid_input(input@),\n    ensures\n        valid_output(output@, input@),\n        correct_computation(input@, output@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0404", "language": "verus", "source": "apps", "source-id": "apps_test_2219", "source-notes": "", "vc-description": "Given integers n and k, find the minimum number of steps to reduce n to 0 using operations:\n1. Decrease n by 1, or 2. Divide n by k (only if n is divisible by k)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn min_steps_to_zero(n: nat, k: nat) -> nat {\n    0\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && \n    {\n        let lines = split_lines_func(input);\n        lines.len() >= 1 &&\n        is_valid_number(lines[0]) && {\n            let t = string_to_int_func(lines[0]);\n            t >= 1 && t <= 100 &&\n            lines.len() >= t + 1 &&\n            forall|i: int| 1 <= i <= t ==> valid_test_case(#[trigger] lines[i])\n        }\n    }\n}\n\nspec fn valid_test_case(line: Seq<char>) -> bool {\n    let parts = split_spaces_func(line);\n    parts.len() == 2 &&\n    is_valid_number(parts[0]) &&\n    is_valid_number(parts[1]) && {\n        let n = string_to_int_func(parts[0]);\n        let k = string_to_int_func(parts[1]);\n        n >= 1 && k >= 2\n    }\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() >= 1 &&\n    (s =~= seq!['0'] || (s[0] != '0' && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9')) &&\n    forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn expected_output(input: Seq<char>) -> Seq<char>\n    recommends valid_input(input)\n{\n    let lines = split_lines_func(input);\n    let t = string_to_int_func(lines[0]);\n    let results = Seq::new(t as nat, |i: int| {\n        let parts = split_spaces_func(lines[i+1]);\n        let n = string_to_int_func(parts[0]);\n        let k = string_to_int_func(parts[1]);\n        nat_to_string_func(min_steps_to_zero(n as nat, k as nat))\n    });\n    join_lines_seq(results)\n}\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn nat_to_string_func(n: nat) -> Seq<char> {\n    seq![]\n}\n\nspec fn join_lines_seq(lines: Seq<Seq<char>>) -> Seq<char> {\n    seq![]\n}", "vc-helpers": "", "vc-spec": "fn solve(input: String) -> (result: String)", "vc-code": "{\n    /* impl-start */\n    assume(false);\n    unreached()\n    /* impl-end */\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0407", "language": "verus", "source": "apps", "source-id": "apps_test_2241", "source-notes": "", "vc-description": "Given n notes where each note i has maximum playable volume a_i and required total volume b_i,\nfind piano volume x_i and guitar volume y_i such that 1 ≤ x_i ≤ a_i, 1 ≤ y_i ≤ a_i, and x_i + y_i = b_i.\nFor playable notes, add x_i × y_i to total joy. For unplayable notes, subtract 1.\nReturn the maximum possible total joy.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn sum_contributions(a: Seq<int>, b: Seq<int>) -> int\n    recommends a.len() == b.len()\n    decreases a.len()\n{\n    if a.len() == 0 { \n        0\n    } else {\n        (if b[0] > 1 && 2 * a[0] >= b[0] {\n            let x = b[0] / 2;\n            let y = b[0] - x;\n            x * y\n         } else { \n             -1 \n         }) + sum_contributions(a.subrange(1, a.len() as int), b.subrange(1, b.len() as int))\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(a: Vec<i8>, b: Vec<i8>) -> (result: i8)\n    requires a.len() == b.len()\n    ensures result as int == sum_contributions(a@.map(|x| x as int), b@.map(|x| x as int))", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0408", "language": "verus", "source": "apps", "source-id": "apps_test_2252", "source-notes": "", "vc-description": "Given a permutation P of n pages and m queries, determine for each query whether a specific element \nremains in the same position after sorting a subsegment in ascending order. For each query with \nparameters (l, r, x): sort the subsegment P[l...r] in ascending order, check if the element at \nposition x remains unchanged. Each query is independent (permutation resets after each query).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 && \n    {\n        let first_line = parse_integers(lines[0]);\n        first_line.len() == 2 &&\n        {\n            let n = first_line[0];\n            let m = first_line[1];\n            n >= 1 && m >= 0 &&\n            parse_integers(lines[1]).len() == n &&\n            is_valid_permutation(parse_integers(lines[1]), n) &&\n            lines.len() == 2 + m &&\n            (forall|i: int| 2 <= i < lines.len() ==> {\n                let query = parse_integers(#[trigger] lines[i]);\n                query.len() == 3 &&\n                {\n                    let l = query[0];\n                    let r = query[1];\n                    let x = query[2];\n                    1 <= l <= x <= r <= n\n                }\n            })\n        }\n    }\n}\n\nspec fn is_valid_permutation(p: Seq<int>, n: int) -> bool {\n    p.len() == n && \n    (forall|i: int| 0 <= i < p.len() ==> 1 <= #[trigger] p[i] <= n) &&\n    (forall|i: int, j: int| 0 <= i < j < p.len() ==> #[trigger] p[i] != #[trigger] p[j])\n}\n\nspec fn valid_output_format(output: Seq<char>) -> bool {\n    let lines = split_lines(output);\n    forall|line: Seq<char>| #[trigger] lines.contains(line) ==> (seq_equals(line, seq!['Y','e','s']) || seq_equals(line, seq!['N','o']))\n}\n\nspec fn seq_equals(s1: Seq<char>, s2: Seq<char>) -> bool {\n    s1.len() == s2.len() && forall|i: int| 0 <= i < s1.len() ==> #[trigger] s1[i] == s2[i]\n}\n\nspec fn output_matches_queries(input: Seq<char>, output: Seq<char>) -> bool {\n    let input_lines = split_lines(input);\n    let output_lines = split_lines(output);\n    if input_lines.len() < 2 { false }\n    else {\n        let first_line = parse_integers(input_lines[0]);\n        if first_line.len() != 2 { false }\n        else {\n            let n = first_line[0];\n            let m = first_line[1];\n            input_lines.len() == 2 + m &&\n            output_lines.len() == m &&\n            {\n                let p = parse_integers(input_lines[1]);\n                forall|i: int| 0 <= i < m ==> {\n                    let query = parse_integers(input_lines[2 + i]);\n                    let l = query[0];\n                    let r = query[1]; \n                    let x = query[2];\n                    let px = p[x - 1];\n                    let cnt = l + count_smaller_in_range(p, l - 1, r - 1, px);\n                    seq_equals(#[trigger] output_lines[i], if cnt == x { seq!['Y','e','s'] } else { seq!['N','o'] })\n                }\n            }\n        }\n    }\n}\n\nspec fn count_smaller_in_range(p: Seq<int>, start: int, end: int, value: int) -> int\n    decreases if start <= end { end - start + 1 } else { 0 }\n{\n    if start > end { 0int }\n    else if start < 0 || start >= p.len() { 0int }\n    else { (if p[start] < value { 1int } else { 0int }) + count_smaller_in_range(p, start + 1, end, value) }\n}\n\nspec fn parse_integers(line: Seq<char>) -> Seq<int> {\n    seq![]\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>>\n    decreases s.len()\n{\n    if s.len() == 0 { seq![] }\n    else {\n        let idx = find_newline(s, 0);\n        if idx == -1 { seq![s] }\n        else if idx >= 0 && idx < s.len() && idx + 1 <= s.len() {\n            seq![s.subrange(0, idx)].add(split_lines(s.subrange(idx+1, s.len() as int)))\n        } else { seq![s] }\n    }\n}\n\nspec fn find_newline(s: Seq<char>, start: nat) -> int\n    decreases s.len() - start\n{\n    if start >= s.len() { -1 }\n    else if s[start as int] == '\\n' { start as int }\n    else { find_newline(s, start + 1) }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0415", "language": "verus", "source": "apps", "source-id": "apps_test_2321", "source-notes": "", "vc-description": "Given a string of '>' and '<' characters, determine the minimum number of characters \nto remove so that the remaining string can be reduced to exactly one character using \nthese operations: Choose '>': delete the character immediately to its right (if exists),\nChoose '<': delete the character immediately to its left (if exists).\nProcess multiple test cases where each test case consists of a string length and the string.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_string(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn is_valid_problem_string(s: Seq<char>) -> bool {\n    forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i] == '>' || #[trigger] s[i] == '<'\n}\n\nspec fn is_valid_integer_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    if is_valid_integer_string(s) {\n        string_to_int_helper(s, s.len() as int)\n    } else {\n        0\n    }\n}\n\nspec fn string_to_int_helper(s: Seq<char>, pos: int) -> int\n    decreases pos\n{\n    if pos <= 0 || pos > s.len() { \n        0 \n    } else if !forall|i: int| 0 <= i < pos ==> '0' <= #[trigger] s[i] <= '9' {\n        0\n    } else if pos == 0 { \n        0 \n    } else { \n        string_to_int_helper(s, pos - 1) * 10 + (s[pos - 1] as int - '0' as int) \n    }\n}\n\nspec fn min_deletions_needed(s: Seq<char>) -> int {\n    if is_valid_problem_string(s) {\n        let first_greater = first_greater_from_left(s);\n        let first_less_from_right = first_less_from_right(s);\n        if first_greater < first_less_from_right { first_greater } else { first_less_from_right }\n    } else {\n        0\n    }\n}\n\nspec fn first_greater_from_left(s: Seq<char>) -> int {\n    if is_valid_problem_string(s) {\n        first_greater_from_left_helper(s, 0)\n    } else {\n        s.len() as int\n    }\n}\n\nspec fn first_greater_from_left_helper(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos\n{\n    if !is_valid_problem_string(s) || pos < 0 || pos > s.len() {\n        s.len() as int\n    } else if pos >= s.len() { \n        s.len() as int \n    } else if s[pos] == '>' { \n        pos \n    } else { \n        first_greater_from_left_helper(s, pos + 1) \n    }\n}\n\nspec fn first_less_from_right(s: Seq<char>) -> int {\n    if is_valid_problem_string(s) {\n        first_less_from_right_helper(s, s.len() as int - 1)\n    } else {\n        s.len() as int\n    }\n}\n\nspec fn first_less_from_right_helper(s: Seq<char>, pos: int) -> int\n    decreases pos + 1\n{\n    if !is_valid_problem_string(s) || pos >= s.len() || pos < -1 {\n        s.len() as int\n    } else if pos < 0 { \n        s.len() as int \n    } else if s[pos] == '<' { \n        s.len() as int - 1 - pos \n    } else { \n        first_less_from_right_helper(s, pos - 1) \n    }\n}\n\nspec fn min(a: int, b: int) -> int {\n    if a < b { a } else { b }\n}", "vc-helpers": "", "vc-spec": "fn solve(lines: Vec<Vec<char>>) -> (results: Vec<i8>)\n    requires \n        lines@.len() > 0,\n        forall|i: int| 0 <= i < lines@.len() ==> is_valid_string(lines@[i]),\n        is_valid_integer_string(lines@[0]),\n        ({let t = string_to_int(lines@[0]); lines@.len() >= 1 + 2 * t}),\n        forall|i: int| 0 <= i < string_to_int(lines@[0]) ==> \n            is_valid_integer_string(lines@[1 + 2*i]) && is_valid_problem_string(lines@[2 + 2*i])\n    ensures \n        results@.len() == string_to_int(lines@[0]),\n        forall|r: i8| #[trigger] results@.contains(r) ==> r as int >= 0,\n        forall|i: int| 0 <= i < results@.len() ==> \n            #[trigger] results@[i] as int == min_deletions_needed(lines@[2 + 2*i])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0421", "language": "verus", "source": "apps", "source-id": "apps_test_2362", "source-notes": "", "vc-description": "Given a tree with n vertices where each vertex i has value a_i, find the maximum length path \nwhere all values on the path share a common divisor greater than 1. The path length is the \nnumber of vertices on the simple path (inclusive). If no such path exists, return 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n  stdin_input.len() > 0 && \n  has_valid_tree_structure(stdin_input) &&\n  all_vertex_values_in_range(stdin_input) &&\n  vertex_count_in_range(stdin_input)\n}\n\nspec fn stdin_input_sum_equals_n(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && sum_of_vertex_values(stdin_input) == get_vertex_count(stdin_input)\n}\n\nspec fn has_common_prime_paths(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && exists_path_with_common_prime_factor(stdin_input)\n}\n\nspec fn no_common_prime_paths(stdin_input: Seq<char>) -> bool {\n  valid_input_format(stdin_input) && !has_common_prime_paths(stdin_input)\n}\n\nspec fn max_common_prime_path_length(stdin_input: Seq<char>) -> int {\n  if valid_input_format(stdin_input) && has_common_prime_paths(stdin_input) {\n    1\n  } else {\n    0\n  }\n}\n\nspec fn has_valid_tree_structure(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn all_vertex_values_in_range(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn vertex_count_in_range(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn exists_path_with_common_prime_factor(stdin_input: Seq<char>) -> bool {\n  true\n}\n\nspec fn sum_of_vertex_values(stdin_input: Seq<char>) -> int {\n  0\n}\n\nspec fn get_vertex_count(stdin_input: Seq<char>) -> int {\n  if valid_input_format(stdin_input) {\n    1\n  } else {\n    0\n  }\n}\n\nspec fn int_to_string_spec(x: int) -> Seq<char>\n  decreases x\n{\n  if x >= 0 {\n    if x == 0 { seq!['0'] }\n    else if x < 10 { seq![char_of_digit(x)] }\n    else { int_to_string_spec(x / 10).add(seq![char_of_digit(x % 10)]) }\n  } else {\n    seq!['0']\n  }\n}\n\nspec fn char_of_digit(d: int) -> char {\n  if 0 <= d && d <= 9 {\n    if d == 0 { '0' }\n    else if d == 1 { '1' }\n    else if d == 2 { '2' }\n    else if d == 3 { '3' }\n    else if d == 4 { '4' }\n    else if d == 5 { '5' }\n    else if d == 6 { '6' }\n    else if d == 7 { '7' }\n    else if d == 8 { '8' }\n    else { '9' }\n  } else {\n    '0'\n  }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)", "vc-code": "{\n  // impl-start\n  assume(false);\n  unreached()\n  // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0424", "language": "verus", "source": "apps", "source-id": "apps_test_2379", "source-notes": "", "vc-description": "Given N days, choose exactly K days to work with constraints:\n- After working, cannot work for next C consecutive days  \n- Can only work on days where S[i] == 'o' (not 'x')\nFind all days that must be worked in every valid selection of K workdays", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn is_valid_work_selection(n: int, k: int, c: int, s: Seq<char>, selection: Set<int>) -> bool\n    recommends s.len() == n\n{\n    selection.len() == k &&\n    (forall|day: int| #[trigger] selection.contains(day) ==> 0 <= day < n && day < s.len() && s[day] == 'o') &&\n    (forall|day1: int, day2: int| selection.contains(day1) && selection.contains(day2) && day1 != day2 ==> \n        day1 < day2 - c || day2 < day1 - c)\n}\n\nspec fn count_available_days(s: Seq<char>) -> int {\n    (Set::new(|i: int| 0 <= i < s.len() && s[i] == 'o')).len() as int\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, c: i8, s: Vec<char>) -> (result: Vec<i8>)\n    requires \n        n > 0,\n        k > 0,\n        c >= 0,\n        k <= n,\n        s.len() == n as usize,\n        forall|i: int| 0 <= i < s@.len() ==> s@[i] == 'o' || s@[i] == 'x',\n        count_available_days(s@) >= k as int,\n        exists|valid_selection: Set<int>| is_valid_work_selection(n as int, k as int, c as int, s@, valid_selection),\n    ensures\n        forall|i: int| 0 <= i < result@.len() ==> 1 <= #[trigger] result@[i] as int <= n as int,\n        forall|i: int| 0 <= i < result@.len() ==> s@[#[trigger] result@[i] as int - 1] == 'o',\n        forall|i: int, j: int| 0 <= i < j < result@.len() ==> #[trigger] result@[i] as int < #[trigger] result@[j] as int,\n        result@.len() <= k as usize,", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0428", "language": "verus", "source": "apps", "source-id": "apps_test_2411", "source-notes": "", "vc-description": "Given n distinct points representing electric poles, count the number of pairs of wires that intersect.\nEvery pair of poles is connected by a wire (infinite straight line). If multiple poles lie on the same line,\nthey share a single wire. Return the number of intersecting wire pairs.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_first_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_first_line_as_nat(line: Seq<char>) -> nat {\n    0\n}\n\nspec fn is_valid_coordinate_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn get_distinct_lines(points: Seq<(int, int)>) -> Seq<Seq<(int, int)>> {\n    seq![]\n}\n\nspec fn group_lines_by_slope(lines: Seq<Seq<(int, int)>>) -> Seq<Seq<Seq<(int, int)>>> {\n    seq![]\n}\n\nspec fn sum_over_slope_groups(groups: Seq<Seq<Seq<(int, int)>>>, total: nat) -> nat {\n    0\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() as int - 1] == '\\n' &&\n    {\n        let lines = split_lines(input);\n        lines.len() >= 3 && lines.len() <= 1001 &&\n        is_valid_first_line(lines[0]) &&\n        {\n            let n = parse_first_line_as_nat(lines[0]);\n            n >= 2 && n <= 1000 && lines.len() == n + 1 &&\n            forall|i: int| 1 <= i < lines.len() ==> is_valid_coordinate_line(#[trigger] lines[i])\n        }\n    }\n}\n\nspec fn is_non_negative_numeric_string(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= #[trigger] s[i] <= '9'\n}\n\nspec fn valid_coordinate(point: (int, int)) -> bool {\n    let (x, y) = point;\n    -10000 <= x <= 10000 && -10000 <= y <= 10000\n}\n\nspec fn extract_n(input: Seq<char>) -> nat {\n    if valid_input_format(input) {\n        let lines = split_lines(input);\n        parse_first_line_as_nat(lines[0])\n    } else {\n        0\n    }\n}\n\nspec fn extract_points(input: Seq<char>) -> Seq<(int, int)> {\n    if valid_input_format(input) {\n        seq![(0, 0), (1, 1)]\n    } else {\n        seq![]\n    }\n}\n\nspec fn count_intersecting_line_pairs(points: Seq<(int, int)>) -> nat {\n    if points.len() >= 2 &&\n       forall|i: int, j: int| 0 <= i < j < points.len() ==> #[trigger] points[i] != #[trigger] points[j] &&\n       forall|i: int| 0 <= i < points.len() ==> valid_coordinate(#[trigger] points[i]) {\n        let distinct_lines = get_distinct_lines(points);\n        let slope_groups = group_lines_by_slope(distinct_lines);\n        let total_lines = distinct_lines.len();\n        (sum_over_slope_groups(slope_groups, total_lines)) / 2\n    } else {\n        0\n    }\n}\n\nspec fn string_to_int(s: Seq<char>) -> nat {\n    if is_non_negative_numeric_string(s) {\n        0\n    } else {\n        0\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0 &&\n        valid_input_format(stdin_input)\n    ensures \n        result.len() > 0 &&\n        is_non_negative_numeric_string(result) &&\n        ({\n            let n = extract_n(stdin_input);\n            let points = extract_points(stdin_input);\n            points.len() == n && n >= 2 && n <= 1000 &&\n            (forall|i: int| 0 <= i < points.len() ==> valid_coordinate(#[trigger] points[i])) &&\n            (forall|i: int, j: int| 0 <= i < j < points.len() ==> #[trigger] points[i] != #[trigger] points[j]) &&\n            string_to_int(result) == count_intersecting_line_pairs(points)\n        })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0431", "language": "verus", "source": "apps", "source-id": "apps_test_2431", "source-notes": "", "vc-description": "Given n castles with soldiers, two players alternate turns starting with White.\nEach turn a player attacks a castle using mixed (x damage), infantry (y damage, \nforbidden if previous attack on same castle was infantry), or cavalry (z damage,\nforbidden if previous attack on same castle was cavalry). Player making the last\nattack wins. Find number of White's winning first moves using Grundy number theory.\n\n/* Implementation uses Grundy number theory */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nstruct TestCase {\n    n: nat,\n    x: nat,\n    y: nat,\n    z: nat,\n    castles: Seq<nat>,\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    valid_input_structure(input)\n}\n\nspec fn valid_input_structure(input: Seq<char>) -> bool {\n    true /* TODO: implement input validation */\n}\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    output.len() > 0 &&\n    valid_output_structure(input, output)\n}\n\nspec fn valid_output_structure(input: Seq<char>, output: Seq<char>) -> bool {\n    true /* TODO: implement output validation */\n}\n\nspec fn get_test_count(s: Seq<char>) -> nat\n    recommends valid_input(s)\n{\n    1 /* TODO: implement test count parsing */\n}\n\nspec fn get_test_case(s: Seq<char>, i: nat) -> TestCase\n    recommends valid_input(s) && i < get_test_count(s)\n{\n    TestCase {\n        n: 1,\n        x: 1,\n        y: 1,\n        z: 1,\n        castles: seq![1],\n    }\n}\n\nspec fn count_winning_first_moves(tc: TestCase) -> nat {\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<char>) -> (result: Vec<char>)\n    requires valid_input(stdin_input@)\n    ensures valid_output(stdin_input@, result@)", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0435", "language": "verus", "source": "apps", "source-id": "apps_test_2446", "source-notes": "", "vc-description": "Given a sequence of n integers and q queries, for each query value x, count the number of contiguous subarrays whose greatest common divisor (GCD) equals x.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines_func(input);\n    lines.len() >= 3 &&\n    parse_int_func(lines[0]) > 0 &&\n    parse_int_func(lines[2]) >= 0 &&\n    lines.len() >= 3 + parse_int_func(lines[2]) &&\n    parse_int_array_func(lines[1]).len() == parse_int_func(lines[0]) &&\n    (forall|i: int| 0 <= i < parse_int_array_func(lines[1]).len() ==> parse_int_array_func(lines[1])[i] > 0) &&\n    forall|i: int| 0 <= i < parse_int_func(lines[2]) ==> parse_int_func(lines[3 + i]) > 0\n}\n\nspec fn get_expected_results(input: Seq<char>) -> Seq<int> {\n    let lines = split_lines_func(input);\n    let arr = parse_int_array_func(lines[1]);\n    let q = parse_int_func(lines[2]);\n    Seq::new(q as nat, |i: int| count_subarrays_with_gcd(arr, parse_int_func(lines[3 + i])))\n}\n\nspec fn format_output(results: Seq<int>) -> Seq<char> {\n    if results.len() == 0 { seq![] }\n    else if results.len() == 1 { \n        int_to_string_func(results[0])\n    }\n    else {\n        int_to_string_func(results[0]) + seq!['\\n'] + format_output(results.subrange(1, results.len() as int))\n    }\n}\n\nspec fn count_subarrays_with_gcd(arr: Seq<int>, target: int) -> int {\n    let pairs = subarray_pairs(arr);\n    pairs.filter(|pair: (int, int)| subarray_gcd(arr, pair.0, pair.1) == target).len() as int\n}\n\nspec fn subarray_pairs(arr: Seq<int>) -> Set<(int, int)> {\n    Set::new(|pair: (int, int)| 0 <= pair.0 <= pair.1 < arr.len())\n}\n\nspec fn subarray_gcd(arr: Seq<int>, start: int, end: int) -> int\n    decreases end - start\n{\n    if start == end { arr[start] }\n    else {\n        let rest = subarray_gcd(arr, start + 1, end);\n        gcd(arr[start], rest)\n    }\n}\n\nspec fn split_lines_func(s: Seq<char>) -> Seq<Seq<char>> {\n    split_lines_helper(s, 0, seq![], seq![])\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    parse_int_helper(s, 0, 0)\n}\n\nspec fn parse_int_array_func(s: Seq<char>) -> Seq<int> {\n    parse_int_array_helper(s, 0, seq![], seq![])\n}\n\nspec fn int_to_string_func(n: int) -> Seq<char> {\n    if n == 0 { seq!['0'] }\n    else { int_to_string_helper(n, seq![]) }\n}\n\nspec fn split_lines_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<Seq<char>>) -> Seq<Seq<char>> {\n    if pos >= s.len() {\n        if current.len() > 0 { acc.push(current) } else { acc }\n    } else {\n        if s[pos] == '\\n' {\n            split_lines_helper(s, pos + 1, seq![], acc.push(current))\n        } else {\n            split_lines_helper(s, pos + 1, current.push(s[pos]), acc)\n        }\n    }\n}\n\nspec fn parse_int_helper(s: Seq<char>, pos: int, acc: int) -> int {\n    if pos >= s.len() { acc }\n    else {\n        let c = s[pos];\n        if c >= '0' && c <= '9' {\n            parse_int_helper(s, pos + 1, acc * 10 + (c as int - '0' as int))\n        } else {\n            acc\n        }\n    }\n}\n\nspec fn parse_int_array_helper(s: Seq<char>, pos: int, current: Seq<char>, acc: Seq<int>) -> Seq<int> {\n    if pos >= s.len() {\n        if current.len() > 0 { acc.push(parse_int_func(current)) } else { acc }\n    } else {\n        let c = s[pos];\n        if c == ' ' || c == '\\t' {\n            if current.len() > 0 {\n                parse_int_array_helper(s, pos + 1, seq![], acc.push(parse_int_func(current)))\n            } else {\n                parse_int_array_helper(s, pos + 1, current, acc)\n            }\n        } else {\n            parse_int_array_helper(s, pos + 1, current.push(c), acc)\n        }\n    }\n}\n\nspec fn int_to_string_helper(n: int, acc: Seq<char>) -> Seq<char> {\n    if n == 0 { acc }\n    else { int_to_string_helper(n / 10, seq![(n % 10) as char] + acc) }\n}\n\nspec fn gcd(a: int, b: int) -> int {\n    if b == 0 { a } else { gcd(b, a % b) }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires \n        input.len() > 0,\n        valid_input(input),\n    ensures \n        result == format_output(get_expected_results(input)),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0436", "language": "verus", "source": "apps", "source-id": "apps_test_2447", "source-notes": "", "vc-description": "Given multiple binary strings, determine the minimum number of character flips needed \nto make each string \"good\". A string is \"good\" if it contains neither \"010\" nor \"101\" \nas a subsequence. Input format: first line contains number of test cases t, followed \nby t binary strings. Output the minimum operations needed for each string.\n\n/* placeholder implementation */\n\n/* placeholder implementation */\n\n/* placeholder implementation */\n\n/* placeholder implementation */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    seq![seq![]]\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_int(s: Seq<char>) -> int\n    recommends is_valid_number(s)\n{\n    0\n}\n\nspec fn is_binary_string(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn ends_with_newline(s: Seq<char>) -> bool {\n    s.len() > 0 && s[s.len() - 1] == '\\n'\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    input[input.len() - 1] == '\\n' &&\n    {\n        let lines = split_lines(input);\n        lines.len() >= 2 &&\n        is_valid_number(lines[0]) &&\n        {\n            let t = parse_int(lines[0]);\n            t >= 1 && t <= 100 &&\n            lines.len() == t + 1 &&\n            forall|i: int| 1 <= i < lines.len() ==> \n                is_binary_string(lines[i]) && lines[i].len() >= 1 && lines[i].len() <= 1000\n        }\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() > 0 &&\n    (ends_with_newline(result) || result.len() == 0) &&\n    {\n        let output_lines = split_lines(result);\n        output_lines.len() >= 1 &&\n        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> is_valid_number(output_lines[i])) &&\n        (forall|i: int| 0 <= i < output_lines.len() - 1 ==> parse_int(output_lines[i]) >= 0)\n    }\n}\n\nspec fn correct_result(input: Seq<char>, result: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    {\n        let input_lines = split_lines(input);\n        let t = parse_int(input_lines[0]);\n        let output_lines = split_lines(result);\n        output_lines.len() == t + 1 &&\n        forall|test_case: int| 0 <= test_case < t ==> #[trigger] parse_int(output_lines[test_case]) == min_operations_to_make_good(input_lines[test_case + 1])\n    }\n}\n\nspec fn min_operations_to_make_good(s: Seq<char>) -> int\n    recommends is_binary_string(s)\n{\n    if s.len() == 0 { 0 } else { min_ops_helper(s, 0, s.len() as int) }\n}\n\nspec fn min_ops_helper(s: Seq<char>, start: int, end: int) -> int {\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        valid_input(input),\n    ensures\n        valid_output(result),\n        correct_result(input, result),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0439", "language": "verus", "source": "apps", "source-id": "apps_test_2457", "source-notes": "", "vc-description": "Given n grains where each grain weighs between (a-b) and (a+b) grams inclusive,\ndetermine if the total weight of all n grains can fall within the range [c-d, c+d] grams inclusive.\nInput format: first line contains number of test cases t, followed by t lines each containing\n5 integers n, a, b, c, d representing the parameters for each test case.\nOutput \"Yes\" if possible, \"No\" otherwise for each test case.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn valid_test_case(n: int, a: int, b: int, c: int, d: int) -> bool {\n    n >= 1 && n <= 1000 &&\n    a >= 0 && a <= 1000 &&\n    b >= 0 && b < a &&\n    c >= 0 && c <= 1000 &&\n    d >= 0 && d < c\n}\n\nspec fn can_achieve_weight(n: int, a: int, b: int, c: int, d: int) -> bool {\n    let min_weight = (a - b) * n;\n    let max_weight = (a + b) * n;\n    let target_min = c - d;\n    let target_max = c + d;\n    !(min_weight > target_max || max_weight < target_min)\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    true\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires\n        valid_input(input),\n    ensures\n        valid_output(result),\n        (input.len() == 0 || (input.len() == 1 && input[0] == '\\n')) ==> result.len() == 0,\n        !(input.len() == 0 || (input.len() == 1 && input[0] == '\\n')) ==> \n            (result.len() > 0 ==> \n                result[result.len() - 1] == '\\n' || \n                (result.len() > 3 && (result.subrange(result.len() - 4, result.len() as int) == seq!['Y', 'e', 's', '\\n'] || \n                                     result.subrange(result.len() - 3, result.len() as int) == seq!['N', 'o', '\\n']))),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0441", "language": "verus", "source": "apps", "source-id": "apps_test_2466", "source-notes": "", "vc-description": "Given a list of distinct integers, generate all possible permutations of the elements.\nEach permutation should be a list containing all elements from the input in a different order.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn factorial(n: nat) -> nat\n    decreases n\n{\n    if n == 0 { 1 } else { n * factorial((n - 1) as nat) }\n}\n\nspec fn is_permutation(perm: Seq<int>, original: Seq<int>) -> bool {\n    perm.len() == original.len() && perm.to_multiset() == original.to_multiset()\n}\n\nspec fn all_distinct<T>(s: Seq<T>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]\n}", "vc-helpers": "", "vc-spec": "fn permute(nums: Vec<i8>) -> (result: Vec<Vec<i8>>)\n    requires \n        all_distinct(nums@.map(|i: int, x: i8| x as int)),\n    ensures \n        result.len() == factorial(nums.len() as nat),\n        forall|p: Vec<i8>| #[trigger] result@.contains(p) ==> is_permutation(p@.map(|i: int, x: i8| x as int), nums@.map(|i: int, x: i8| x as int)),\n        all_distinct(result@),\n        forall|perm: Seq<int>| #[trigger] is_permutation(perm, nums@.map(|i: int, x: i8| x as int)) ==> exists|v: Vec<i8>| result@.contains(v) && v@.map(|i: int, x: i8| x as int) == perm,", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0444", "language": "verus", "source": "apps", "source-id": "apps_test_2501", "source-notes": "", "vc-description": "Given N attendees numbered 1 to N with heights A_i, count the number of pairs (i,j) \nwhere i ≠ j such that the absolute difference of their numbers equals the sum of their heights: \n|i - j| = A_i + A_j.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(a: &[int]) -> bool {\n    a.len() >= 2 && forall|i: int| 0 <= i < a.len() ==> a[i] >= 1\n}\n\nspec fn abs(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn valid_pair(a: &[int], i: int, j: int) -> bool\n    recommends 0 <= i < a.len() && 0 <= j < a.len()\n{\n    i != j && abs((i+1) - (j+1)) == a[i] + a[j]\n}\n\nspec fn count_valid_pairs(a: &[int]) -> int\n    recommends valid_input(a)\n{\n    /* Count of pairs (i,j) where valid_pair(a, i, j) holds */\n    0 /* Placeholder for set cardinality */\n}", "vc-helpers": "", "vc-spec": "fn solve(a: &Vec<i8>) -> (result: i8)\n    requires\n        a@.len() >= 2,\n        forall|i: int| 0 <= i < a@.len() ==> a@[i] >= 1\n    ensures\n        result >= 0,\n        result as int == count_valid_pairs(a@.as_slice())", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0446", "language": "verus", "source": "apps", "source-id": "apps_test_2522", "source-notes": "", "vc-description": "Given two sorted sequences A and B of length N, determine if B can be reordered \nso that A[i] ≠ B[i] for all positions i. If possible, output any valid reordering of B.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(n: int, a: Seq<int>, b: Seq<int>) -> bool {\n        a.len() == n && b.len() == n && n >= 1 &&\n        (forall|i: int| 0 <= i < n-1 ==> a[i] <= a[i+1]) &&\n        (forall|i: int| 0 <= i < n-1 ==> b[i] <= b[i+1])\n    }\n    \n    spec fn valid_reordering(a: Seq<int>, reordered_b: Seq<int>) -> bool\n        recommends a.len() == reordered_b.len()\n    {\n        forall|i: int| 0 <= i < a.len() ==> a[i] != reordered_b[i]\n    }\n    \n    spec fn is_reordering_of(original: Seq<int>, reordered: Seq<int>) -> bool {\n        original.len() == reordered.len() && original.to_multiset() == reordered.to_multiset()\n    }\n    \n    spec fn is_rotation(original: Seq<int>, rotated: Seq<int>) -> bool {\n        original.len() == rotated.len() && \n        (exists|k: int| 0 <= k < original.len() && rotated == original.subrange(k, original.len() as int) + original.subrange(0, k))\n    }", "vc-helpers": "", "vc-spec": "fn solve(n: int, a: Seq<int>, b: Seq<int>) -> (result: (bool, Seq<int>))\n    requires \n        valid_input(n, a, b)\n    ensures \n        result.0 ==> result.1.len() == n,\n        result.0 ==> is_reordering_of(b, result.1),\n        result.0 ==> valid_reordering(a, result.1),\n        !result.0 ==> result.1 == seq![],\n        result.0 ==> is_rotation(b, result.1),", "vc-code": "{\n    assume(false);\n    (false, seq![])\n}", "vc-postamble": "}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0449", "language": "verus", "source": "apps", "source-id": "apps_test_2553", "source-notes": "", "vc-description": "Given an array of n integers, determine if it's possible to select exactly x elements \nsuch that their sum is odd. A sum is odd if and only if it contains an odd number of odd elements.\n\n/* Placeholder implementation */\n\n/* Placeholder implementation */\n\n/* Placeholder implementation */\n\n/* Placeholder implementation */\n\n/* Placeholder implementation */\n\n/* Placeholder implementation */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() as int - 1] == '\\n' &&\n    count_lines(input) >= 1 &&\n    exists|q: nat| (1 <= q <= 100 && \n        parse_first_line(input) == q &&\n        count_lines(input) == 1 + 2 * q &&\n        valid_test_cases_format(input, q))\n}\n\nspec fn valid_test_cases_format(input: Seq<char>, q: nat) -> bool\n    recommends 1 <= q <= 100,\n              count_lines(input) >= 1 + 2 * q\n{\n    forall|i: int| 0 <= i < q ==> \n        exists|n: nat, x: nat| (1 <= x <= n <= 1000 &&\n        get_test_case_n(input, i) == n &&\n        get_test_case_x(input, i) == x &&\n        get_test_case_array(input, i).len() == n &&\n        forall|j: int| 0 <= j < n ==> 1 <= get_test_case_array(input, i)[j] <= 1000)\n}\n\nspec fn valid_output(output: Seq<char>) -> bool {\n    output.len() >= 0 && \n    (output.len() == 0 || output[output.len() as int - 1] == '\\n') &&\n    forall|i: int| 0 <= i < count_lines(output) ==> \n        (get_line(output, i) == seq!['Y', 'e', 's'] || get_line(output, i) == seq!['N', 'o'])\n}\n\nspec fn output_matches_algorithm(input: Seq<char>, output: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    let q = parse_first_line(input);\n    count_lines(output) == q &&\n    forall|i: int| 0 <= i < q ==> {\n        let arr = get_test_case_array(input, i);\n        let x = get_test_case_x(input, i);\n        let expected = if can_select_odd_sum(arr, x) { seq!['Y', 'e', 's'] } else { seq!['N', 'o'] };\n        get_line(output, i) == expected\n    }\n}\n\nspec fn can_select_odd_sum(arr: Seq<int>, x: nat) -> bool\n    recommends x <= arr.len()\n{\n    let odd_count = count_odd_elements(arr);\n    let even_count = arr.len() - odd_count;\n\n    if x == arr.len() {\n        odd_count % 2 == 1\n    } else if odd_count > 0 && even_count > 0 {\n        true\n    } else if even_count == 0 {\n        x % 2 == 1\n    } else {\n        false\n    }\n}\n\nspec fn count_odd_elements(arr: Seq<int>) -> nat\n    decreases arr.len()\n{\n    if arr.len() == 0 {\n        0\n    } else if arr[0] % 2 == 1 {\n        1 + count_odd_elements(arr.subrange(1, arr.len() as int))\n    } else {\n        count_odd_elements(arr.subrange(1, arr.len() as int))\n    }\n}\n\nspec fn parse_first_line(input: Seq<char>) -> nat\n    recommends input.len() > 0,\n               count_lines(input) >= 1\n{\n    1\n}\n\nspec fn get_test_case_n(input: Seq<char>, case_index: int) -> nat\n    recommends input.len() > 0,\n               count_lines(input) >= 1 + 2 * (case_index + 1)\n{\n    1\n}\n\nspec fn get_test_case_x(input: Seq<char>, case_index: int) -> nat\n    recommends input.len() > 0,\n               count_lines(input) >= 1 + 2 * (case_index + 1)\n{\n    1\n}\n\nspec fn get_test_case_array(input: Seq<char>, case_index: int) -> Seq<int>\n    recommends input.len() > 0,\n               count_lines(input) >= 1 + 2 * (case_index + 1)\n{\n    seq![1]\n}\n\nspec fn count_lines(s: Seq<char>) -> nat {\n    if s.len() == 0 { 0 } else { 1 }\n}\n\nspec fn get_line(s: Seq<char>, line_index: int) -> Seq<char>\n    recommends line_index < count_lines(s)\n{\n    if line_index == 0 { seq!['N', 'o'] } else { seq![] }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Seq<char>) -> (output: Seq<char>)\n    requires \n        valid_input(stdin_input),\n    ensures \n        valid_output(output),\n        output_matches_algorithm(stdin_input, output),\n        count_lines(output) == parse_first_line(stdin_input),\n        forall|i: int| 0 <= i < count_lines(output) ==> \n            (get_line(output, i) == seq!['Y', 'e', 's'] || get_line(output, i) == seq!['N', 'o'])", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0450", "language": "verus", "source": "apps", "source-id": "apps_test_2556", "source-notes": "", "vc-description": "Given n rooms, for each room i install at most c_i radiators to achieve at least sum_i total sections.\nEach radiator with k sections costs k² burles. Find the minimum cost for each room.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0\n}\n\nspec fn valid_output(input: Seq<char>, output: Seq<char>) -> bool {\n    &&& valid_input(input)\n    &&& {\n        let input_pairs = get_input_pairs(input);\n        let expected_results = Seq::new(input_pairs.len(), |i: int| \n            if input_pairs[i].0 > 0 && input_pairs[i].1 >= 0 {\n                compute_minimum_cost(input_pairs[i].0, input_pairs[i].1)\n            } else {\n                0\n            });\n        output == format_results(expected_results)\n    }\n}\n\nspec fn compute_minimum_cost(c: int, s: int) -> int {\n    if c > 0 && s >= 0 {\n        let a = s / c;\n        let r = s % c;\n        (c - r) * a * a + r * (a + 1) * (a + 1)\n    } else {\n        0\n    }\n}\n\nspec fn get_input_pairs(input: Seq<char>) -> Seq<(int, int)> {\n    if input.len() > 0 {\n        let lines = split_lines(input);\n        if lines.len() == 0 {\n            Seq::new(0, |i: int| (0, 0))\n        } else {\n            let n = parse_int(lines[0]);\n            get_pairs_from_lines(lines, 1, n)\n        }\n    } else {\n        Seq::new(0, |i: int| (0, 0))\n    }\n}\n\nspec fn format_results(results: Seq<int>) -> Seq<char> {\n    if forall|j: int| 0 <= j < results.len() ==> results[j] >= 0 {\n        format_results_helper(results, 0, Seq::new(0, |i: int| 'a'))\n    } else {\n        Seq::new(0, |i: int| 'a')\n    }\n}\n\n#[verifier::external_body]\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    Seq::new(0, |i: int| Seq::new(0, |j: int| 'a'))\n}\n\n#[verifier::external_body]\nspec fn parse_int(line: Seq<char>) -> int {\n    0\n}\n\n#[verifier::external_body]\nspec fn get_pairs_from_lines(lines: Seq<Seq<char>>, start: int, n: int) -> Seq<(int, int)> {\n    Seq::new(0, |i: int| (0, 0))\n}\n\n#[verifier::external_body]\nspec fn format_results_helper(results: Seq<int>, index: int, acc: Seq<char>) -> Seq<char> {\n    Seq::new(0, |i: int| 'a')\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(input)\n    ensures valid_output(input, result)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0454", "language": "verus", "source": "apps", "source-id": "apps_test_2594", "source-notes": "", "vc-description": "Given a rectangular park represented as an n×m grid of squares, find the minimum number \nof lanterns needed to light up all squares. Lanterns are placed on edges between squares,\nand each lantern illuminates adjacent squares (up to 2 squares, or 1 if on boundary).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: &str) -> bool {\n    true\n}\n\nspec fn min_lanterns(n: int, m: int) -> int {\n    if n >= 1 && m >= 1 {\n        (n * m + 1) / 2\n    } else {\n        0\n    }\n}\n\nspec fn valid_output(input: &str, output: Seq<int>) -> bool {\n    true\n}", "vc-helpers": "", "vc-spec": "fn solve_lanterns() -> (result: bool)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0457", "language": "verus", "source": "apps", "source-id": "apps_test_2616", "source-notes": "", "vc-description": "Given n piles of stones, two players alternate turns removing stones from the leftmost non-empty pile.\nThe player who cannot make a move loses. Determine the winner when both players play optimally.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(test_cases: Seq<Seq<int>>) -> bool {\n    forall|i: int| 0 <= i < test_cases.len() ==> \n        test_cases[i].len() >= 1 && \n        forall|j: int| 0 <= j < test_cases[i].len() ==> test_cases[i][j] >= 1\n}\n\nspec fn valid_results(results: Seq<Seq<char>>) -> bool {\n    forall|i: int| 0 <= i < results.len() ==> \n        results[i] == seq!['F', 'i', 'r', 's', 't'] || results[i] == seq!['S', 'e', 'c', 'o', 'n', 'd']\n}\n\nspec fn count_leading_ones(piles: Seq<int>) -> nat\n    decreases piles.len()\n{\n    if piles.len() == 0 {\n        0\n    } else if piles[0] != 1 {\n        0\n    } else {\n        1 + count_leading_ones(piles.subrange(1, piles.len() as int))\n    }\n}\n\nspec fn count_ones_in_seq(piles: Seq<int>) -> nat {\n    piles.filter(|x: int| x == 1).len()\n}\n\nspec fn correct_game_result(piles: Seq<int>, result: Seq<char>) -> bool {\n    &&& piles.len() >= 1\n    &&& (forall|j: int| 0 <= j < piles.len() ==> piles[j] >= 1)\n    &&& (result == seq!['F', 'i', 'r', 's', 't'] || result == seq!['S', 'e', 'c', 'o', 'n', 'd'])\n    &&& {\n        let ones_count = count_ones_in_seq(piles);\n        let all_ones = (ones_count == piles.len());\n        let leading_ones = count_leading_ones(piles);\n        if all_ones {\n            if ones_count % 2 == 1 {\n                result == seq!['F', 'i', 'r', 's', 't']\n            } else {\n                result == seq!['S', 'e', 'c', 'o', 'n', 'd']\n            }\n        } else {\n            if leading_ones % 2 == 1 {\n                result == seq!['S', 'e', 'c', 'o', 'n', 'd']\n            } else {\n                result == seq!['F', 'i', 'r', 's', 't']\n            }\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(test_cases: Vec<Vec<i8>>) -> (results: Vec<Vec<char>>)\n    requires \n        valid_input(test_cases@.map(|i: int, v: Vec<i8>| v@.map(|j: int, x: i8| x as int)))\n    ensures \n        results.len() == test_cases.len(),\n        valid_results(results@.map(|i: int, v: Vec<char>| v@)),\n        forall|i: int| 0 <= i < test_cases.len() ==> correct_game_result(test_cases@[i].map(|j: int, x: i8| x as int), results@[i])", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0458", "language": "verus", "source": "apps", "source-id": "apps_test_2621", "source-notes": "", "vc-description": "Given n columns with initial heights, determine if a character can move from column 1 to column n.\nCharacter starts at column 1 with m blocks in bag. At each column, character can remove/add blocks\nand move to next column if height difference is at most k.\n\n/* Simplified for compilation */\n\n/* Simplified for compilation */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, m: int, k: int, h: Seq<int>) -> bool {\n    n >= 1 && n == h.len() && m >= 0 && k >= 0 && \n    (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)\n}\n\nspec fn can_reach_end(n: int, m: int, k: int, h: Seq<int>) -> bool\n{\n    &&& valid_input(n, m, k, h)\n    &&& simulate_game(0, m, n, k, h)\n}\n\nspec fn simulate_game(pos: int, blocks: int, n: int, k: int, h: Seq<int>) -> bool\n    decreases n - pos\n{\n    &&& 0 <= pos < n\n    &&& n == h.len()\n    &&& k >= 0\n    &&& blocks >= 0\n    &&& (forall|i: int| 0 <= i < h.len() ==> h[i] >= 0)\n    &&& if pos == n - 1 {\n        true\n    } else {\n        let h1 = h[pos];\n        let h2 = h[pos + 1];\n        if h1 >= h2 {\n            let new_blocks = if h2 >= k { blocks + (h1 - h2) + k } else { blocks + h1 };\n            simulate_game(pos + 1, new_blocks, n, k, h)\n        } else {\n            if h2 > h1 + blocks + k {\n                false\n            } else {\n                let new_blocks = \n                    if h2 <= k { blocks + h1 }\n                    else if (h2 - h1) <= k { blocks + k - (h2 - h1) }\n                    else { blocks - (h2 - h1 - k) };\n                new_blocks >= 0 && simulate_game(pos + 1, new_blocks, n, k, h)\n            }\n        }\n    }\n}\n\nspec fn valid_complete_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 && input[input.len() - 1] == '\\n'\n}\n\nspec fn valid_output_format(output: Seq<char>, input: Seq<char>) -> bool {\n    output.len() >= 0 && \n    (output.len() == 0 || output[output.len() - 1] == '\\n') &&\n    (forall|i: int| 0 <= i < output.len() ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\\n')\n}\n\nspec fn correct_game_results(output: Seq<char>, input: Seq<char>) -> bool {\n    true\n}\n\nspec fn output_matches_test_case_count(output: Seq<char>, input: Seq<char>) -> bool {\n    true\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires \n        stdin_input.len() > 0,\n        stdin_input[stdin_input.len() - 1] == '\\n',\n        valid_complete_input_format(stdin_input),\n    ensures \n        result.len() >= 0,\n        forall|i: int| 0 <= i < result.len() ==> result[i] == 'Y' || result[i] == 'E' || result[i] == 'S' || result[i] == 'N' || result[i] == 'O' || result[i] == '\\n',\n        result.len() == 0 || result[result.len() - 1] == '\\n',\n        valid_output_format(result, stdin_input),\n        correct_game_results(result, stdin_input),\n        output_matches_test_case_count(result, stdin_input),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0465", "language": "verus", "source": "apps", "source-id": "apps_test_2647", "source-notes": "", "vc-description": "Given an H×W grid where each cell is either black (#) or white (.), find the maximum number \nof white cells that can be changed to black such that a path still exists from cell (1,1) to \ncell (H,W). Movement is allowed only through white cells in 4 directions. Cells (1,1) and \n(H,W) cannot be changed and must be white. Return -1 if no path exists initially.\n\n/* Simplified for placeholder */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    true\n}\n\nspec fn is_valid_output(output: Seq<char>) -> bool {\n    output.len() > 0 &&\n    (output == seq!['-', '1', '\\n'] || \n     (output != seq!['-', '1', '\\n'] && output.len() > 1 && output.last() == '\\n'))\n}\n\nstruct GridData {\n    h: int,\n    w: int,\n    cells: Seq<Seq<char>>,\n}\n\nspec fn valid_grid(grid: GridData) -> bool {\n    grid.h > 0 && grid.w > 0 && \n    grid.cells.len() == grid.h &&\n    (forall|i: int| 0 <= i < grid.h ==> grid.cells[i].len() == grid.w) &&\n    (forall|i: int, j: int| 0 <= i < grid.h && 0 <= j < grid.w ==> \n        grid.cells[i][j] == '.' || grid.cells[i][j] == '#') &&\n    grid.cells[0][0] == '.' && grid.cells[grid.h-1][grid.w-1] == '.'\n}\n\nspec fn parse_input(input: Seq<char>) -> GridData {\n    GridData {\n        h: 1,\n        w: 1,\n        cells: seq![seq!['.']]\n    }\n}\n\nspec fn path_exists(grid: GridData) -> bool {\n    true\n}\n\nspec fn max_changeable_white_cells(grid: GridData) -> int {\n    0\n}\n\nspec fn count_white_cells(grid: GridData) -> int {\n    2\n}\n\nspec fn min_cut_size(grid: GridData) -> int {\n    2\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (output: String)", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0473", "language": "verus", "source": "apps", "source-id": "apps_test_4147", "source-notes": "", "vc-description": "Given N bamboos with lengths, find minimum magic points (MP) to create exactly three bamboos \nwith target lengths A, B, and C. Operations: Extension Magic (1 MP per unit), Shortening Magic \n(1 MP per unit), Composition Magic (10 MP to combine two bamboos). Input format: first line \ncontains N A B C, followed by N lines with bamboo lengths. Output minimum MP needed.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    true\n}\n\nspec fn valid_assignment(input: Seq<char>, assignment: Seq<nat>) -> bool {\n    true\n}\n\nspec fn has_all_three_groups(assignment: Seq<nat>) -> bool {\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 1) &&\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 2) &&\n    (exists|i: int| 0 <= i < assignment.len() && assignment[i] == 3)\n}\n\nspec fn calculate_assignment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {\n    composition_cost(assignment) + adjustment_cost(input, assignment)\n}\n\nspec fn composition_cost(assignment: Seq<nat>) -> nat {\n    let group_a_size = count_group_members(assignment, 1);\n    let group_b_size = count_group_members(assignment, 2);\n    let group_c_size = count_group_members(assignment, 3);\n    (if group_a_size > 0 { ((group_a_size - 1) * 10) as nat } else { 0nat }) +\n    (if group_b_size > 0 { ((group_b_size - 1) * 10) as nat } else { 0nat }) +\n    (if group_c_size > 0 { ((group_c_size - 1) * 10) as nat } else { 0nat })\n}\n\nspec fn adjustment_cost(input: Seq<char>, assignment: Seq<nat>) -> nat {\n    let lines = split_lines(input);\n    let (n, a, b, c) = parse_first_line_bamboo(lines[0]);\n    let sum_a = calculate_group_sum(input, assignment, 1);\n    let sum_b = calculate_group_sum(input, assignment, 2);\n    let sum_c = calculate_group_sum(input, assignment, 3);\n    abs_diff(sum_a, a) + abs_diff(sum_b, b) + abs_diff(sum_c, c)\n}\n\nspec fn count_group_members(assignment: Seq<nat>, group: nat) -> nat\n    decreases assignment.len()\n{\n    if assignment.len() == 0 {\n        0nat\n    } else {\n        (if assignment[0] == group { 1nat } else { 0nat }) + count_group_members(assignment.drop_first(), group)\n    }\n}\n\nspec fn calculate_group_sum(input: Seq<char>, assignment: Seq<nat>, group: nat) -> nat {\n    0nat\n}\n\nspec fn abs_diff(a: nat, b: nat) -> nat {\n    if a >= b { (a - b) as nat } else { (b - a) as nat }\n}\n\nspec fn split_lines(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::<Seq<char>>::empty()\n}\n\nspec fn parse_first_line_bamboo(line: Seq<char>) -> (nat, nat, nat, nat) {\n    (0nat, 0nat, 0nat, 0nat)\n}\n\nspec fn parse_bamboo_length(line: Seq<char>) -> nat {\n    0nat\n}\n\nfn int_to_string(n: nat) -> String {\n    \"\".to_string()\n}\n\nspec fn string_to_int(s: Seq<char>) -> nat {\n    0nat\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0474", "language": "verus", "source": "apps", "source-id": "apps_test_4148", "source-notes": "", "vc-description": "Given a string S of uppercase English letters and an integer N, shift each character in S by N positions forward in the alphabet. The alphabet wraps around (A follows Z).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>>\n    requires input.len() > 0\n{\n    let newline_pos = find_newline(input, 0);\n    if newline_pos == -1 {\n        seq![input]\n    } else if newline_pos >= 0 && newline_pos < input.len() {\n        if newline_pos + 1 >= input.len() {\n            seq![input.subrange(0, newline_pos), seq![]]\n        } else {\n            seq![input.subrange(0, newline_pos), input.subrange(newline_pos + 1, input.len() as int)]\n        }\n    } else {\n        seq![input]\n    }\n}\n\nspec fn find_newline(input: Seq<char>, start: int) -> int\n    requires 0 <= start <= input.len()\n    ensures find_newline(input, start) == -1 || (0 <= find_newline(input, start) < input.len())\n    decreases input.len() - start\n{\n    if start >= input.len() {\n        -1\n    } else if input[start] == '\\n' {\n        start\n    } else {\n        find_newline(input, start + 1)\n    }\n}\n\nspec fn is_valid_number(s: Seq<char>) -> bool {\n    s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'\n}\n\nspec fn string_to_nat(s: Seq<char>) -> nat\n    requires is_valid_number(s)\n    decreases s.len()\n{\n    if s.len() == 0 {\n        0\n    } else if s.len() == 1 {\n        (s[0] as int - '0' as int) as nat\n    } else {\n        (s[0] as int - '0' as int) as nat * 10 + string_to_nat(s.subrange(1, s.len() as int))\n    }\n}\n\nspec fn caesar_shift(s: Seq<char>, n: nat) -> Seq<char>\n    decreases s.len()\n{\n    if s.len() == 0 {\n        seq![]\n    } else {\n        let shifted_val = (s[0] as int - 'A' as int + n) % 26;\n        let shifted_char = ('A' as int + shifted_val) as char;\n        seq![shifted_char].add(caesar_shift(s.subrange(1, s.len() as int), n))\n    }\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    (exists|i: int| 0 <= i < input.len() && input[i] == '\\n') &&\n    {\n        let lines = split_lines(input);\n        lines.len() >= 2 &&\n        is_valid_number(lines[0]) &&\n        string_to_nat(lines[0]) <= 26 &&\n        lines[1].len() >= 1 && lines[1].len() <= 10000 &&\n        (forall|j: int| 0 <= j < lines[1].len() ==> 'A' <= lines[1][j] <= 'Z')\n    }\n}", "vc-spec": "fn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(input)\n    ensures ({\n        let lines = split_lines(input);\n        let n = string_to_nat(lines[0]);\n        let s = lines[1];\n        result == caesar_shift(s, n).add(seq!['\\n'])\n    })", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0477", "language": "verus", "source": "apps", "source-id": "apps_test_4165", "source-notes": "", "vc-description": "Given N side lengths of a polygon, determine if the polygon can be drawn in a 2D plane.\nA polygon can be drawn if and only if the longest side length is strictly less than \nthe sum of all other side lengths.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(sides: Seq<int>) -> bool {\n    sides.len() >= 3 && forall|i: int| 0 <= i < sides.len() ==> sides[i] > 0\n}\n\nspec fn can_form_polygon(sides: Seq<int>) -> bool\n    recommends valid_input(sides)\n{\n    let sorted_sides = quicksort(sides);\n    let longest = sorted_sides[sorted_sides.len() - 1];\n    let sum_of_others = sum_except_last(sorted_sides);\n    sum_of_others > longest\n}\n\nspec fn quicksort(s: Seq<int>) -> Seq<int> {\n    seq![]\n}\n\nspec fn filter(s: Seq<int>, pred: spec_fn(int) -> bool) -> Seq<int> {\n    seq![]\n}\n\nspec fn sum_except_last(s: Seq<int>) -> int\n    recommends s.len() >= 1\n{\n    0\n}\n\nproof fn filter_preserves_inclusion(s: Seq<int>, pred: spec_fn(int) -> bool)\n    ensures forall|x: int| #![auto] filter(s, pred).contains(x) ==> s.contains(x)\n{\n    assume(false); /* TODO: Remove this line and implement the proof */\n}", "vc-helpers": "", "vc-spec": "fn solve(sides: Seq<int>) -> (result: String)\n    requires\n        valid_input(sides),\n    ensures\n        result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o'],\n        (result@ == seq!['Y', 'e', 's']) == can_form_polygon(sides),", "vc-code": "{\n    assume(false);\n    \"No\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0480", "language": "verus", "source": "apps", "source-id": "apps_test_4175", "source-notes": "", "vc-description": "Given N words announced in a shiritori game, determine if all shiritori rules were followed.\nShiritori rules No word can be repeated, For each consecutive pair of words, \nthe last character of the first word must equal the first character of the second word.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn no_repeats(words: Seq<Seq<char>>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < words.len() ==> words[i] != words[j]\n}\n\nspec fn consecutive_chars_match(words: Seq<Seq<char>>) -> bool \n    recommends forall|i: int| 0 <= i < words.len() ==> words[i].len() > 0\n{\n    forall|i: int| 0 <= i < words.len() - 1 ==> words[i][words[i].len() - 1] == words[i+1][0]\n}\n\nspec fn valid_shiritori(words: Seq<Seq<char>>) -> bool \n    recommends forall|i: int| 0 <= i < words.len() ==> words[i].len() > 0\n{\n    no_repeats(words) && consecutive_chars_match(words)\n}", "vc-helpers": "", "vc-spec": "fn solve(words: Vec<Vec<char>>) -> (result: Vec<char>)\n    requires forall|i: int| 0 <= i < words@.len() ==> words@[i].len() > 0\n    ensures result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']\n    ensures (result@ == seq!['Y', 'e', 's']) <==> valid_shiritori(words@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0490", "language": "verus", "source": "apps", "source-id": "apps_test_4199", "source-notes": "", "vc-description": "Count how many people can ride a roller coaster given their heights and a minimum height requirement.\nInput: N (number of people), K (minimum height requirement), and N heights.\nOutput: Number of people who can ride (height >= K).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, k: int, heights: Seq<int>) -> bool {\n    n >= 1 && k >= 1 && heights.len() == n && \n    forall|i: int| 0 <= i < heights.len() ==> heights[i] >= 1\n}\n\nspec fn count_eligible(heights: Seq<int>, k: int) -> int {\n    heights.filter(|height: int| height >= k).len() as int\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, k: i8, heights: Vec<i8>) -> (count: i8)\n    requires \n        valid_input(n as int, k as int, heights@.ext_equal(heights@.map_values(|x| x as int)))\n    ensures \n        0 <= count as int <= heights@.len(),\n        count as int == count_eligible(heights@.map_values(|x| x as int), k as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0499", "language": "verus", "source": "apps", "source-id": "apps_test_4229", "source-notes": "", "vc-description": "Given a positive integer N, calculate the sum of all numbers in the first N terms of the FizzBuzz sequence.\nThe FizzBuzz sequence transforms each position i (1 to N) as follows:\n- If i is divisible by both 3 and 5: term = \"FizzBuzz\" (skip from sum)\n- If i is divisible by 3 only: term = \"Fizz\" (skip from sum)  \n- If i is divisible by 5 only: term = \"Buzz\" (skip from sum)\n- Otherwise: term = i (include in sum)\nReturn the sum of all numeric terms only.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn int_to_string(i: int) -> Seq<char>\n    recommends i >= 0\n{\n    seq!['1']\n}\n\nspec fn parse_int_from_string(s: Seq<char>) -> int\n    recommends s.len() > 0\n{\n    1\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool\n{\n    stdin_input.len() > 0\n}\n\nspec fn sum_of_non_fizzbuzz_numbers(n: int) -> int\n    recommends n >= 0\n    decreases n when n >= 0\n{\n    if n <= 0 {\n        0\n    } else {\n        let num = n;\n        if num % 3 != 0 && num % 5 != 0 {\n            sum_of_non_fizzbuzz_numbers(n - 1) + num\n        } else {\n            sum_of_non_fizzbuzz_numbers(n - 1)\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Seq<char>) -> (result: Seq<char>)\n    requires valid_input(stdin_input)\n    ensures result.len() > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0501", "language": "verus", "source": "apps", "source-id": "apps_test_4233", "source-notes": "", "vc-description": "Given an n×m grid containing '*' and '.' characters, find a set of stars that exactly reproduces this pattern.\nA star has a center (x,y) and size s, placing '*' at the center and s positions in each cardinal direction.\nOutput the number of stars and their parameters, or \"-1\" if impossible.\n\n/* Each star is valid and within bounds */\n\n/* The stars exactly cover all '*' positions */\n\n/* center */\n\n/* horizontal ray */\n\n/* vertical ray */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn min_int(a: int, b: int) -> int {\n    if a <= b { a } else { b }\n}\n\nspec fn valid_input(input: Seq<u8>) -> bool {\n    input.len() >= 1 && \n    parse_grid_dimensions(input).is_some() &&\n    (match parse_grid_dimensions(input) {\n        Some((n, m)) => n >= 3 && m >= 3 && grid_has_valid_format(input, n, m),\n        None => false\n    })\n}\n\nspec fn parse_grid_dimensions(input: Seq<u8>) -> Option<(int, int)> {\n    Some((3, 3)) /* Placeholder - actual parsing would be complex */\n}\n\nspec fn grid_has_valid_format(input: Seq<u8>, n: int, m: int) -> bool {\n    true /* Placeholder - check that grid has n rows of m characters each, containing only '*' and '.' */\n}\n\nspec fn exists_valid_star_decomposition(input: Seq<u8>) -> bool {\n    valid_input(input) &&\n    (match parse_grid_dimensions(input) {\n        Some((n, m)) => exists|k: int, stars: Seq<(int, int, int)>| \n            0 <= k <= n * m && stars.len() == k &&\n            (forall|s: (int, int, int)| stars.contains(s) ==> \n                1 <= s.0 <= n && 1 <= s.1 <= m && 1 <= s.2 <= min_int(n, m)) &&\n            valid_star_decomposition(input, stars),\n        None => false\n    })\n}\n\nspec fn valid_star_decomposition(input: Seq<u8>, stars: Seq<(int, int, int)>) -> bool {\n    valid_input(input) &&\n    (match parse_grid_dimensions(input) {\n        Some((n, m)) => \n            (forall|s: (int, int, int)| stars.contains(s) ==> \n                s.0 >= 1 && s.0 <= n && s.1 >= 1 && s.1 <= m && s.2 > 0 &&\n                valid_star(n, m, s.0, s.1, s.2)) &&\n            (forall|i: int, j: int| 1 <= i <= n && 1 <= j <= m ==>\n                (grid_char_at(input, i, j) == b'*') <==> covered_by_stars(stars, i, j)),\n        None => false\n    })\n}\n\nspec fn valid_star(n: int, m: int, x: int, y: int, s: int) -> bool {\n    x >= 1 && x <= n && y >= 1 && y <= m && s > 0 &&\n    x - s >= 1 && x + s <= n && y - s >= 1 && y + s <= m\n}\n\nspec fn covered_by_stars(stars: Seq<(int, int, int)>, i: int, j: int) -> bool {\n    exists|s: (int, int, int)| stars.contains(s) && covered_by_star(s.0, s.1, s.2, i, j)\n}\n\nspec fn covered_by_star(x: int, y: int, size: int, i: int, j: int) -> bool {\n    (i == x && j == y) ||\n    (i == x && 1 <= abs_int(j - y) <= size) ||\n    (j == y && 1 <= abs_int(i - x) <= size)\n}\n\nspec fn abs_int(x: int) -> int {\n    if x >= 0 { x } else { -x }\n}\n\nspec fn grid_char_at(input: Seq<u8>, i: int, j: int) -> u8 {\n    b'*' /* Placeholder - actual grid parsing would be complex */\n}\n\nspec fn starts_with_int_and_valid_format(s: Seq<u8>, k: int) -> bool {\n    s.len() > 0 && \n    int_to_string_len(k) <= s.len() && \n    s.subrange(0, int_to_string_len(k) as int) == int_to_string_seq(k)\n}\n\nspec fn int_to_string_len(k: int) -> nat {\n    1 /* Placeholder */\n}\n\nspec fn int_to_string_seq(k: int) -> Seq<u8> {\n    seq![b'0'] /* Placeholder */\n}\n\nspec fn format_star_output(k: int, stars: Seq<(int, int, int)>) -> Seq<u8> {\n    if k >= 0 && stars.len() == k {\n        let result = int_to_string_seq(k).add(seq![b'\\n']);\n        format_star_output_helper(result, stars, 0)\n    } else {\n        seq![]\n    }\n}\n\nspec fn format_star_output_helper(result: Seq<u8>, stars: Seq<(int, int, int)>, idx: int) -> Seq<u8> \n    decreases stars.len() - idx\n{\n    if 0 <= idx <= stars.len() {\n        if idx >= stars.len() { \n            result \n        } else { \n            let new_result = result.add(int_to_string_seq(stars[idx].0))\n                .add(seq![b' ']).add(int_to_string_seq(stars[idx].1))\n                .add(seq![b' ']).add(int_to_string_seq(stars[idx].2))\n                .add(seq![b'\\n']);\n            format_star_output_helper(new_result, stars, idx + 1)\n        }\n    } else {\n        result\n    }\n}", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    ensures\n        valid_input(input.as_bytes()@) ==> \n            (result.as_bytes()@ == seq![b'-', b'1', b'\\n']) <==> !exists_valid_star_decomposition(input.as_bytes()@),\n        valid_input(input.as_bytes()@) && result.as_bytes()@ != seq![b'-', b'1', b'\\n'] ==>\n            (exists|k: int, stars: Seq<(int, int, int)>|\n                k >= 0 && stars.len() == k &&\n                valid_star_decomposition(input.as_bytes()@, stars) &&\n                result.as_bytes()@ == format_star_output(k, stars)),\n        valid_input(input.as_bytes()@) ==> result.as_bytes()@ != seq![],\n        !valid_input(input.as_bytes()@) ==> result.as_bytes()@ == seq![b'-', b'1', b'\\n'],\n        result.as_bytes()@ == seq![b'-', b'1', b'\\n'] || (exists|k: int| k >= 0 && starts_with_int_and_valid_format(result.as_bytes()@, k)),\n        result.as_bytes()@ == seq![] || result.as_bytes()@[result.as_bytes()@.len()-1] == b'\\n',", "vc-code": "{\n    // impl-start\n    assume(false);\n    \"-1\\n\".to_string()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0517", "language": "verus", "source": "apps", "source-id": "apps_test_4271", "source-notes": "", "vc-description": "Calculate total satisfaction points from eating N dishes in a specific order.\nEach dish provides base satisfaction, plus bonus points for eating consecutive dishes in sequence.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, a: Seq<int>, b: Seq<int>, c: Seq<int>) -> bool {\n    n >= 1 &&\n    a.len() == n &&\n    b.len() == n &&\n    c.len() == n - 1 &&\n    (forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n) &&\n    (forall|i: int, j: int| 0 <= i < j < n ==> #[trigger] a[i] != #[trigger] a[j])\n}\n\nspec fn sum_satisfaction(a: Seq<int>, b: Seq<int>, c: Seq<int>, n: int) -> int\n    recommends\n        n >= 1,\n        a.len() == n,\n        b.len() == n,\n        c.len() == n - 1,\n        forall|i: int| 0 <= i < n ==> 1 <= #[trigger] a[i] <= n\n{\n    sum_satisfaction_up_to(a, b, c, n)\n}\n\nspec fn sum_satisfaction_up_to(a: Seq<int>, b: Seq<int>, c: Seq<int>, k: int) -> int\n    recommends\n        0 <= k <= a.len(),\n        b.len() == a.len(),\n        c.len() == a.len() - 1,\n        forall|i: int| 0 <= i < a.len() ==> 1 <= #[trigger] a[i] <= a.len()\n    decreases k\n{\n    if k <= 0 {\n        0\n    } else {\n        let prev_sum = sum_satisfaction_up_to(a, b, c, k - 1);\n        let base_contrib = b[a[k - 1] - 1];\n        let bonus_contrib = if k > 1 && a[k - 1] == a[k - 2] + 1 {\n            c[a[k - 1] - 2]\n        } else {\n            0\n        };\n        prev_sum + base_contrib + bonus_contrib\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>, b: Vec<i8>, c: Vec<i8>) -> (result: i8)\n    requires valid_input(n as int, a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int))\n    ensures result as int == sum_satisfaction(a@.map(|x| x as int), b@.map(|x| x as int), c@.map(|x| x as int), n as int)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0518", "language": "verus", "source": "apps", "source-id": "apps_test_4274", "source-notes": "", "vc-description": "Given N total test cases and M passed test cases, determine if all test cases \nwere passed. Input is a string with N and M separated by space. Output \"Yes\" \nif M = N (all passed), \"No\" otherwise. Constraints: 1 ≤ N ≤ 100, 0 ≤ M ≤ N.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> { seq![] }\n\nspec fn str_to_int(s: Seq<char>) -> int { 0 }\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    exists|lines: Seq<Seq<char>>| lines == split_string(input, '\\n') && lines.len() > 0 &&\n    exists|parts: Seq<Seq<char>>| parts == split_string(lines[0], ' ') && parts.len() == 2 &&\n    {\n        let n = str_to_int(parts[0]);\n        let m = str_to_int(parts[1]);\n        1 <= n <= 100 && 0 <= m <= n\n    }\n}\n\nspec fn extract_n(input: Seq<char>) -> int {\n    let lines = split_string(input, '\\n');\n    let parts = split_string(lines[0], ' ');\n    str_to_int(parts[0])\n}\n\nspec fn extract_m(input: Seq<char>) -> int {\n    let lines = split_string(input, '\\n');\n    let parts = split_string(lines[0], ' ');\n    str_to_int(parts[1])\n}\n\nspec fn correct_output(input: Seq<char>, result: Seq<char>) -> bool {\n    let n = extract_n(input);\n    let m = extract_m(input);\n    (n == m ==> result == seq!['Y', 'e', 's']) && (n != m ==> result == seq!['N', 'o'])\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\nrequires \n    valid_input(input@)\nensures \n    correct_output(input@, result@),\n    result@ == seq!['Y', 'e', 's'] || result@ == seq!['N', 'o']", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0531", "language": "verus", "source": "apps", "source-id": "apps_test_4307", "source-notes": "", "vc-description": "Count how many odd positive integers between 1 and N (inclusive) have exactly 8 positive divisors,\nwhere N is between 1 and 200.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn is_odd(n: int) -> bool {\n    n % 2 == 1\n}\n\nspec fn count_divisors(n: nat) -> nat\n    recommends n > 0\n{\n    Set::new(|d: nat| 1 <= d <= n && n % d == 0).len()\n}\n\nspec fn has_eight_divisors(n: nat) -> bool\n    recommends n > 0\n{\n    count_divisors(n) == 8\n}\n\nspec fn count_odd_with_eight_divisors(n: nat) -> nat {\n    Set::new(|i: nat| 1 <= i <= n && is_odd(i as int) && i > 0 && has_eight_divisors(i)).len()\n}\n\nspec fn valid_input(n: int) -> bool {\n    1 <= n <= 200\n}", "vc-spec": "fn solve(n: int) -> (count: int)\n    requires \n        valid_input(n)\n    ensures \n        n < 105 ==> count == 0,\n        105 <= n && n < 135 ==> count == 1,\n        135 <= n && n < 165 ==> count == 2,\n        165 <= n && n < 189 ==> count == 3,\n        189 <= n && n < 195 ==> count == 4,\n        n >= 195 ==> count == 5,\n        0 <= count && count <= 5,", "vc-code": "{\n    assume(false);\n    0int\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0543", "language": "verus", "source": "apps", "source-id": "apps_test_4335", "source-notes": "", "vc-description": "Given a positive integer N and a string S of length N consisting of lowercase English letters,\ndetermine whether S can be expressed as the concatenation of two identical strings (S = T + T for some string T).\nReturn \"Yes\" if S is a concatenation of two copies of some string; otherwise, return \"No\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, s: Seq<char>) -> bool {\n    1 <= n <= 100 && s.len() == n && forall|i: int| 0 <= i < s.len() ==> 'a' <= s[i] <= 'z'\n}\n\nspec fn is_concatenation_of_two_copies(s: Seq<char>) -> bool {\n    s.len() % 2 == 0 && forall|i: int| 0 <= i < s.len()/2 ==> s[i] == s[s.len()/2 + i]\n}\n\nspec fn yes_seq() -> Seq<char> {\n    seq!['Y', 'e', 's']\n}\n\nspec fn no_seq() -> Seq<char> {\n    seq!['N', 'o']\n}", "vc-helpers": "", "vc-spec": "fn solve(n: int, s: Seq<char>) -> (result: String)\n    requires\n        valid_input(n, s),\n    ensures\n        result@ == yes_seq() || result@ == no_seq(),\n        n % 2 != 0 ==> result@ == no_seq(),\n        n % 2 == 0 ==> (result@ == yes_seq() <==> is_concatenation_of_two_copies(s)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0544", "language": "verus", "source": "apps", "source-id": "apps_test_4337", "source-notes": "", "vc-description": "Given N colorful crackers with colors P, W, G, or Y, determine if exactly 3 or 4 distinct colors are present.\nThe bag always contains at least one cracker of each color P, W, and G.\nOutput \"Three\" if 3 distinct colors, \"Four\" if 4 distinct colors.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(n: int, colors: Seq<char>) -> bool {\n    1 <= n <= 100 &&\n    colors.len() == n &&\n    (forall|c: char| colors.contains(c) ==> (c == 'P' || c == 'W' || c == 'G' || c == 'Y')) &&\n    colors.contains('P') && colors.contains('W') && colors.contains('G')\n}\n\nspec fn distinct_colors(colors: Seq<char>) -> Set<char> {\n    colors.to_set()\n}\n\nspec fn solution_string(distinct_count: int) -> &'static str\n    recommends distinct_count == 3 || distinct_count == 4\n{\n    if distinct_count == 3 { \"Three\" } else { \"Four\" }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: int, colors: Seq<char>) -> (result: &'static str)\n    requires valid_input(n, colors),\n    ensures distinct_colors(colors).len() == 3 || distinct_colors(colors).len() == 4,\n    ensures (distinct_colors(colors).len() == 3 ==> result == \"Three\") && (distinct_colors(colors).len() == 4 ==> result == \"Four\"),\n    ensures result == \"Three\" || result == \"Four\",", "vc-code": "{\n    assume(false);\n    \"Three\"\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0547", "language": "verus", "source": "apps", "source-id": "apps_test_4346", "source-notes": "", "vc-description": "Count visible lanterns on a train path from point 1 to point L. \nLanterns are located at positions divisible by v (i.e., at positions v, 2v, 3v, ...). \nA standing train blocks visibility at positions l through r (inclusive). \nDetermine how many lanterns are visible (not blocked by the standing train).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn split_spaces(line: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn parse_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq![]\n}\n\nspec fn join_lines(lines: Seq<Seq<char>>) -> Seq<char> {\n    seq![]\n}\n\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() > 0 &&\n    is_valid_integer(lines[0]) &&\n    {\n        let t = parse_int(lines[0]);\n        t >= 0 && lines.len() >= t + 1 &&\n        forall|i: int| 1 <= i <= t ==> {\n            let line_parts = split_spaces(lines[i]);\n            line_parts.len() >= 4 &&\n            forall|j: int| 0 <= j < 4 ==> is_valid_integer(line_parts[j]) &&\n            {\n                let parts = split_spaces(lines[i]);\n                let L = parse_int(parts[0]);\n                let v = parse_int(parts[1]);\n                let l = parse_int(parts[2]);\n                let r = parse_int(parts[3]);\n                L >= 1 && v >= 1 && l >= 1 && r >= l && r <= L\n            }\n        }\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    forall|c: char| output.contains(c) ==> (c >= '0' && c <= '9') || c == '-' || c == '\\n'\n}\n\nspec fn output_matches_algorithm(output: Seq<char>, input: Seq<char>) -> bool\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    let t = parse_int(lines[0]);\n    t >= 0 &&\n    {\n        let expected_lines = Seq::new(t as nat, |i: int| {\n            if i + 1 < lines.len() && split_spaces(lines[i + 1]).len() >= 4 {\n                let parts = split_spaces(lines[i + 1]);\n                let L = parse_int(parts[0]);\n                let v = parse_int(parts[1]);\n                let l = parse_int(parts[2]);\n                let r = parse_int(parts[3]);\n                let total_lanterns = L / v;\n                let blocked_lanterns = r / v - (l - 1) / v;\n                let visible_lanterns = total_lanterns - blocked_lanterns;\n                int_to_string(visible_lanterns)\n            } else {\n                seq!['0']\n            }\n        });\n        output == join_lines(expected_lines)\n    }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && (\n        (s[0] == '-' && s.len() > 1 && forall|i: int| 1 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9') ||\n        (s[0] != '-' && forall|i: int| 0 <= i < s.len() ==> s[i] >= '0' && s[i] <= '9')\n    )\n}", "vc-spec": "fn solve(input: &str) -> (output: String)\n    requires \n        input.len() > 0,\n        valid_input(input@),\n    ensures \n        valid_output(output@, input@),\n        output_matches_algorithm(output@, input@),", "vc-code": "{\n    assume(false);\n    String::new()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0553", "language": "verus", "source": "apps", "source-id": "apps_test_4364", "source-notes": "", "vc-description": "Given a 4-digit string, determine which date format(s) it represents:\nYYMM (year-month), MMYY (month-year), AMBIGUOUS (both valid), or NA (neither valid).\nValid months are 01-12, years can be any two digits 00-99.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<u8>) -> bool {\n    s.len() >= 4 && forall|i: int| 0 <= i < 4 ==> b'0' <= s[i] <= b'9'\n}\n\nspec fn char_pair_to_int(c1: u8, c2: u8) -> int \n    recommends b'0' <= c1 <= b'9' && b'0' <= c2 <= b'9'\n{\n    (c1 as int - b'0' as int) * 10 + (c2 as int - b'0' as int)\n}\n\nspec fn valid_month(n: int) -> bool {\n    1 <= n <= 12\n}\n\nspec fn get_first_pair(s: Seq<u8>) -> int \n    recommends valid_input(s)\n{\n    char_pair_to_int(s[0], s[1])\n}\n\nspec fn get_second_pair(s: Seq<u8>) -> int \n    recommends valid_input(s)\n{\n    char_pair_to_int(s[2], s[3])\n}\n\nspec fn correct_result(s: Seq<u8>, result: Seq<u8>) -> bool \n    recommends valid_input(s)\n{\n    let s1 = get_first_pair(s);\n    let s2 = get_second_pair(s);\n    let s1_valid = valid_month(s1);\n    let s2_valid = valid_month(s2);\n    (s1_valid && s2_valid ==> result == \"AMBIGUOUS\\n\".as_bytes()) &&\n    (s1_valid && !s2_valid ==> result == \"MMYY\\n\".as_bytes()) &&\n    (!s1_valid && s2_valid ==> result == \"YYMM\\n\".as_bytes()) &&\n    (!s1_valid && !s2_valid ==> result == \"NA\\n\".as_bytes())\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<u8>) -> (result: Vec<u8>)\n    requires valid_input(stdin_input@),\n    ensures (result@ == \"AMBIGUOUS\\n\".as_bytes() || \n             result@ == \"MMYY\\n\".as_bytes() || \n             result@ == \"YYMM\\n\".as_bytes() || \n             result@ == \"NA\\n\".as_bytes()) &&\n            correct_result(stdin_input@, result@)", "vc-code": "{\n    assume(false);\n    Vec::new()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0560", "language": "verus", "source": "apps", "source-id": "apps_test_4383", "source-notes": "", "vc-description": "Determine if a child's age qualifies for Shichi-Go-San celebration.\nShichi-Go-San celebrates children who are exactly 3, 5, or 7 years old.\nInput is a string containing an integer X (1 ≤ X ≤ 9).\nOutput \"YES\" if X is 3, 5, or 7, otherwise \"NO\".", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && exists|i: int| 0 <= i < s.len() && '0' <= s[i] && s[i] <= '9'\n}\n\nspec fn is_celebrated_age(age: int) -> bool {\n    age == 3 || age == 5 || age == 7\n}\n\nspec fn parse_integer_value(s: Seq<char>) -> int {\n    parse_integer_helper(s, 0)\n}\nspec fn parse_integer_helper(s: Seq<char>, pos: int) -> int\n    decreases s.len() - pos when 0 <= pos <= s.len()\n{\n    if pos >= s.len() {\n        0\n    } else if '0' <= s[pos] && s[pos] <= '9' {\n        (s[pos] as int) - ('0' as int)\n    } else {\n        parse_integer_helper(s, pos + 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: Vec<u8>) -> (result: String)\n    requires valid_input(stdin_input@.map_values(|b: u8| b as char))\n    ensures result == if is_celebrated_age(parse_integer_value(stdin_input@.map_values(|b: u8| b as char))) { \"YES\\n\" } else { \"NO\\n\" }", "vc-code": "{\n    assume(false);\n    \"NO\\n\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0562", "language": "verus", "source": "apps", "source-id": "apps_test_4385", "source-notes": "", "vc-description": "Given 5 antennas at coordinates a, b, c, d, e (where a < b < c < d < e) and a communication range k,\ndetermine if there exists any pair of antennas that cannot communicate directly. Two antennas can\ncommunicate if the distance between them is at most k. The distance between antennas at coordinates\np and q (where p < q) is q - p. Output \"Yay!\" if all pairs can communicate, \":(\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(a: int, b: int, c: int, d: int, e: int, k: int) -> bool {\n    0 <= a <= 123 && 0 <= b <= 123 && 0 <= c <= 123 && \n    0 <= d <= 123 && 0 <= e <= 123 && 0 <= k <= 123 &&\n    a < b && b < c && c < d && d < e\n}\n\nspec fn all_pairs_can_communicate(a: int, b: int, c: int, d: int, e: int, k: int) -> bool {\n    (e - a) <= k\n}", "vc-helpers": "", "vc-spec": "fn solve(a: int, b: int, c: int, d: int, e: int, k: int) -> (result: String)\n    requires\n        valid_input(a, b, c, d, e, k)\n    ensures\n        result@ == \"Yay!\" <==> all_pairs_can_communicate(a, b, c, d, e, k),\n        result@ == \":(\" <==> !all_pairs_can_communicate(a, b, c, d, e, k)", "vc-code": "{\n    assume(false);\n    String::new()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0568", "language": "verus", "source": "apps", "source-id": "apps_test_4398", "source-notes": "", "vc-description": "Given two strings S and T of equal length N, create a new string by alternating characters \nfrom S and T in the order: S[0], T[0], S[1], T[1], ..., S[N-1], T[N-1].", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Helper functions for string processing - these would need to be defined elsewhere */\nspec fn split_lines(input: &str) -> Seq<&str>;\nspec fn string_to_int(s: &str) -> int;\nspec fn split_by_space(s: &str) -> Seq<&str>;\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_lines(input);\n    lines.len() >= 2 && {\n        let n = string_to_int(lines[0]);\n        let parts = split_by_space(lines[1]);\n        parts.len() >= 2 &&\n        n >= 0 &&\n        n <= parts[0].len() && n <= parts[1].len()\n    }\n}\n\nspec fn get_n(input: &str) -> int\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    string_to_int(lines[0])\n}\n\nspec fn get_s(input: &str) -> &str\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    let parts = split_by_space(lines[1]);\n    parts[0]\n}\n\nspec fn get_t(input: &str) -> &str\n    recommends valid_input(input)\n{\n    let lines = split_lines(input);\n    let parts = split_by_space(lines[1]);\n    parts[1]\n}\n\nspec fn alternate_chars(s: &str, t: &str, n: int) -> Seq<char>\n    recommends n >= 0 && n <= s.len() && n <= t.len()\n{\n    if n == 0 {\n        seq![]\n    } else {\n        seq![s.get_char(0), t.get_char(0)] + alternate_chars(&s.substring_char(1, s.len() as int), &t.substring_char(1, t.len() as int), n - 1)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires input.len() > 0\n    ensures\n        valid_input(input) ==> {\n            let n = get_n(input);\n            let s = get_s(input);\n            let t = get_t(input);\n            result.len() == 2 * n + 1 &&\n            result.get_char((result.len() - 1) as int) == '\\n' &&\n            result.substring_char(0, (result.len() - 1) as int).view() == alternate_chars(s, t, n)\n        } && !valid_input(input) ==> result == \"\"", "vc-code": "{\n    assume(false);\n    String::new()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0574", "language": "verus", "source": "apps", "source-id": "apps_test_4418", "source-notes": "", "vc-description": "Given an array of n integers where each element is one of {4, 8, 15, 16, 23, 42}, \nfind the minimum number of elements to remove to make the array \"good\".\nA \"good\" array must have length divisible by 6 and can be split into complete \nsubsequences of exactly \"4, 8, 15, 16, 23, 42\" (in that order).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(n: int, a: Seq<int>) -> bool {\n    n >= 0 && a.len() == n && forall|i: int| 0 <= i < a.len() ==> \n        #[trigger] a[i] == 4int || #[trigger] a[i] == 8int || #[trigger] a[i] == 15int || \n        #[trigger] a[i] == 16int || #[trigger] a[i] == 23int || #[trigger] a[i] == 42int\n}\n\nspec fn number_of_complete_subsequences(n: int, a: Seq<int>) -> int {\n    let k = seq![4int, 8int, 15int, 16int, 23int, 42int];\n    let s = seq![n, 0int, 0int, 0int, 0int, 0int, 0int];\n    let final_s = process_array(s, a, k, 0int);\n    final_s[6int]\n}\n\nspec fn process_array(s: Seq<int>, a: Seq<int>, k: Seq<int>, index: int) -> Seq<int>\n    decreases a.len() - index\n{\n    if s.len() == 7 && k.len() == 6 && 0 <= index <= a.len() &&\n       (forall|i: int| 0 <= i < a.len() ==> \n            #[trigger] a[i] == 4int || #[trigger] a[i] == 8int || #[trigger] a[i] == 15int || \n            #[trigger] a[i] == 16int || #[trigger] a[i] == 23int || #[trigger] a[i] == 42int) &&\n       k == seq![4int, 8int, 15int, 16int, 23int, 42int] &&\n       (forall|i: int| 0 <= i < 7 ==> s[i] >= 0) {\n        if index == a.len() {\n            s\n        } else {\n            let ai = a[index];\n            let new_s = update_state(s, ai, k);\n            process_array(new_s, a, k, index + 1)\n        }\n    } else {\n        seq![0int, 0int, 0int, 0int, 0int, 0int, 0int]\n    }\n}\n\nspec fn update_state(s: Seq<int>, ai: int, k: Seq<int>) -> Seq<int> {\n    if s.len() == 7 && k.len() == 6 &&\n       (ai == 4int || ai == 8int || ai == 15int || ai == 16int || ai == 23int || ai == 42int) &&\n       k == seq![4int, 8int, 15int, 16int, 23int, 42int] &&\n       (forall|i: int| 0 <= i < 7 ==> s[i] >= 0) {\n        if ai == k[5int] && s[5int] > 0 {\n            s.update(6int, s[6int] + 1).update(5int, s[5int] - 1)\n        } else if ai == k[4int] && s[4int] > 0 {\n            s.update(5int, s[5int] + 1).update(4int, s[4int] - 1)\n        } else if ai == k[3int] && s[3int] > 0 {\n            s.update(4int, s[4int] + 1).update(3int, s[3int] - 1)\n        } else if ai == k[2int] && s[2int] > 0 {\n            s.update(3int, s[3int] + 1).update(2int, s[2int] - 1)\n        } else if ai == k[1int] && s[1int] > 0 {\n            s.update(2int, s[2int] + 1).update(1int, s[1int] - 1)\n        } else if ai == k[0int] && s[0int] > 0 {\n            s.update(1int, s[1int] + 1).update(0int, s[0int] - 1)\n        } else {\n            s\n        }\n    } else {\n        seq![0int, 0int, 0int, 0int, 0int, 0int, 0int]\n    }\n}\n\nspec fn number_of_complete_subsequences_partial(n: int, a: Seq<int>, k: Seq<int>, index: int) -> int {\n    if valid_input(n, a) && k.len() == 6 && k == seq![4int, 8int, 15int, 16int, 23int, 42int] && 0 <= index <= a.len() {\n        let s = seq![n, 0int, 0int, 0int, 0int, 0int, 0int];\n        let partial_a = if index == 0 { seq![] } else { a.subrange(0int, index) };\n        let final_s = process_array(s, partial_a, k, 0int);\n        final_s[6int]\n    } else {\n        0int\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(n: i8, a: Vec<i8>) -> (result: i8)\n  requires\n    valid_input(n as int, a@.map(|x: i8| x as int)),\n  ensures\n    0 <= result as int <= n as int,\n    result as int == n as int - 6 * number_of_complete_subsequences(n as int, a@.map(|x: i8| x as int)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0583", "language": "verus", "source": "apps", "source-id": "apps_test_4460", "source-notes": "", "vc-description": "Given five integers representing the values of variables x₁, x₂, x₃, x₄, x₅, find which variable has the value 0.\nInitially, each variable xᵢ had value i, but exactly one variable was changed to 0.\nInput: Five space-separated integers. Output: The index i (1-indexed) of the variable xᵢ that has value 0.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(s: Seq<char>) -> bool {\n    s.len() > 0 && (forall|i: int| 0 <= i < s.len() ==> \n        s[i] == ' ' || s[i] == '\\n' || ('0' <= s[i] <= '9') || s[i] == '-')\n}\n\nspec fn valid_number(s: Seq<char>) -> bool {\n    s.len() == 0 || (forall|i: int| 0 <= i < s.len() ==> \n        '0' <= s[i] <= '9' || (i == 0 && s[i] == '-'))\n}\n\nspec fn count_zeros(numbers: Seq<int>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() == 0 {\n        0int\n    } else {\n        (if numbers[0] == 0 { 1int } else { 0int }) + count_zeros(numbers.subrange(1, numbers.len() as int))\n    }\n}\n\nspec fn find_zero_index(numbers: Seq<int>) -> int\n    decreases numbers.len()\n{\n    if numbers.len() > 0 && count_zeros(numbers) == 1 {\n        if numbers[0] == 0 {\n            0int\n        } else if numbers.len() > 1 {\n            1int + find_zero_index(numbers.subrange(1, numbers.len() as int))\n        } else {\n            0int\n        }\n    } else {\n        0int\n    }\n}\n\nspec fn parse_ints(s: Seq<char>) -> Seq<int> {\n    if s.len() > 0 && valid_input(s) {\n        parse_ints_helper(s, 0, seq![], seq![])\n    } else {\n        seq![]\n    }\n}\n\nspec fn parse_ints_helper(s: Seq<char>, pos: int, current: Seq<char>, result: Seq<int>) -> Seq<int>\n    decreases s.len() - pos\n{\n    seq![]\n}\n\nspec fn generate_output(numbers: Seq<int>) -> Seq<char> {\n    generate_output_helper(numbers, 0, seq![])\n}\n\nspec fn generate_output_helper(numbers: Seq<int>, pos: int, result: Seq<char>) -> Seq<char> {\n    seq![]\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires \n        valid_input(input@),\n        input@.len() > 0,\n    ensures \n        ({\n            let numbers = parse_ints(input@);\n            result@ == generate_output(numbers)\n        }),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0598", "language": "verus", "source": "apps", "source-id": "apps_test_4492", "source-notes": "", "vc-description": "Given N boxes in a row with a_i candies in the i-th box, find the minimum number of candies \nto eat such that every pair of adjacent boxes contains at most x candies in total.\nOperation: Choose any box with at least one candy and eat one candy from it.\nObjective: For all i from 1 to N-1, ensure a_i + a_{i+1} ≤ x.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n/* Helper spec functions for string parsing */\nspec fn split_by_newline_spec(s: &str) -> Seq<&str> { Seq::empty() }\nspec fn split_by_space_spec(s: &str) -> Seq<&str> { Seq::empty() }\nspec fn parse_int_spec(s: &str) -> int { 0 }\nspec fn int_to_string_spec(n: int) -> Seq<char> { Seq::empty() }\nspec fn string_len_spec(s: &str) -> nat { 0 }\nspec fn string_result_len_spec(s: String) -> nat { 0 }\n\nspec fn valid_input(input: &str) -> bool {\n    let lines = split_by_newline_spec(input);\n    lines.len() >= 2 &&\n    {\n        let first_line = split_by_space_spec(lines[0]);\n        first_line.len() >= 2 &&\n        {\n            let n = parse_int_spec(first_line[0]);\n            let x = parse_int_spec(first_line[1]);\n            n >= 2 && x >= 0 &&\n            {\n                let second_line = split_by_space_spec(lines[1]);\n                second_line.len() == n &&\n                forall|i: int| 0 <= i < n ==> parse_int_spec(second_line[i]) >= 0\n            }\n        }\n    }\n}\n\nspec fn minimum_candies_needed(input: &str) -> int\n    recommends valid_input(input)\n{\n    let lines = split_by_newline_spec(input);\n    let first_line = split_by_space_spec(lines[0]);\n    let n = parse_int_spec(first_line[0]);\n    let x = parse_int_spec(first_line[1]);\n    let second_line = split_by_space_spec(lines[1]);\n    let a = Seq::new(n as nat, |i: int| parse_int_spec(second_line[i]));\n    compute_minimum_operations(a, x)\n}\n\nspec fn compute_minimum_operations(a: Seq<int>, x: int) -> int\n    recommends a.len() >= 2 && x >= 0 && forall|i: int| 0 <= i < a.len() ==> a[i] >= 0\n{\n    let a0 = if a[0] > x { x } else { a[0] };\n    let cnt0 = if a[0] > x { a[0] - x } else { 0 };\n    let new_a = a.update(0, a0);\n    compute_operations_from_index(a, x, 1, new_a, cnt0)\n}\n\nspec fn compute_operations_from_index(original_a: Seq<int>, x: int, index: int, current_a: Seq<int>, current_count: int) -> int\n    recommends \n        original_a.len() >= 2 &&\n        x >= 0 &&\n        1 <= index <= original_a.len() &&\n        current_a.len() == original_a.len() &&\n        current_count >= 0 &&\n        forall|i: int| 0 <= i < original_a.len() ==> original_a[i] >= 0\n    decreases original_a.len() - index\n{\n    if index >= original_a.len() {\n        current_count\n    } else {\n        let new_value = if current_a[index] + current_a[index - 1] > x {\n            x - current_a[index - 1]\n        } else {\n            current_a[index]\n        };\n        let additional_ops = if current_a[index] + current_a[index - 1] > x {\n            current_a[index] + current_a[index - 1] - x\n        } else {\n            0\n        };\n        let new_a = current_a.update(index, new_value);\n        compute_operations_from_index(original_a, x, index + 1, new_a, current_count + additional_ops)\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires \n        string_len_spec(input) > 0,\n        valid_input(input),\n    ensures \n        string_result_len_spec(result) > 0,", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0603", "language": "verus", "source": "apps", "source-id": "apps_test_4501", "source-notes": "", "vc-description": "Given N cards with integers written on them, count the number of ways to select\none or more cards such that the average of the selected cards equals exactly A.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn split_lines_func(input: Seq<char>) -> Seq<Seq<char>>\n{\n    Seq::empty()\n}\n\nspec fn split_spaces_func(line: Seq<char>) -> Seq<Seq<char>>\n{\n    Seq::empty()\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool\n{\n    true\n}\n\nspec fn string_to_int_func(s: Seq<char>) -> int\n{\n    0\n}\n\nspec fn valid_input_format(stdin_input: Seq<char>) -> bool {\n    let lines = split_lines_func(stdin_input);\n    lines.len() >= 2 &&\n    {\n        let first_line = split_spaces_func(lines[0]);\n        let second_line = split_spaces_func(lines[1]);\n        first_line.len() == 2 &&\n        is_valid_integer(first_line[0]) &&\n        is_valid_integer(first_line[1]) &&\n        {\n            let N = string_to_int_func(first_line[0]);\n            let A = string_to_int_func(first_line[1]);\n            1 <= N <= 50 &&\n            1 <= A <= 50 &&\n            second_line.len() == N &&\n            (forall|j: int| 0 <= j < second_line.len() ==> \n                is_valid_integer(second_line[j]) &&\n                1 <= string_to_int_func(second_line[j]) <= 50)\n        }\n    }\n}\n\nspec fn is_valid_output(output: Seq<char>) -> bool {\n    output.len() > 1 && \n    output[output.len() as int - 1] == '\\n' &&\n    {\n        let result_str = output.subrange(0, output.len() as int - 1);\n        is_valid_integer(result_str) &&\n        string_to_int_func(result_str) >= 0\n    }\n}\n\nspec fn output_represents_correct_count(stdin_input: Seq<char>, output: Seq<char>) -> bool\n    recommends\n        valid_input_format(stdin_input),\n        is_valid_output(output)\n{\n    let lines = split_lines_func(stdin_input);\n    let first_line = split_spaces_func(lines[0]);\n    let second_line = split_spaces_func(lines[1]);\n    let N = string_to_int_func(first_line[0]);\n    let A = string_to_int_func(first_line[1]);\n    let cards = Seq::new(N as nat, |i: int| string_to_int_func(second_line[i]));\n    let result = string_to_int_func(output.subrange(0, output.len() as int - 1));\n    result == count_valid_selections(cards, A)\n}\n\nspec fn count_valid_selections(cards: Seq<int>, A: int) -> int {\n    let differences = Seq::new(cards.len(), |i: int| cards[i] - A);\n    let total = count_zero_sum_subsets(differences);\n    if total > 0 { total - 1 } else { 0 }\n}\n\nspec fn count_zero_sum_subsets(differences: Seq<int>) -> nat\n    decreases differences.len()\n{\n    if differences.len() == 0 {\n        1\n    } else {\n        let rest_count = count_zero_sum_subsets(differences.subrange(1, differences.len() as int));\n        rest_count + count_subsets_with_sum(differences.subrange(1, differences.len() as int), -differences[0])\n    }\n}\n\nspec fn count_subsets_with_sum(differences: Seq<int>, target: int) -> nat\n    decreases differences.len()\n{\n    if differences.len() == 0 {\n        if target == 0 { 1 } else { 0 }\n    } else {\n        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target) +\n        count_subsets_with_sum(differences.subrange(1, differences.len() as int), target - differences[0])\n    }\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (output: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures\n        output@.len() > 0,\n        output@[output@.len() as int - 1] == '\\n',\n        is_valid_output(output@),\n        output_represents_correct_count(stdin_input@, output@),", "vc-code": "{\n    // impl-start\n    assume(false);\n    unreached()\n    // impl-end\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0616", "language": "verus", "source": "apps", "source-id": "apps_test_4546", "source-notes": "", "vc-description": "Given three integers a, b, and c representing the heights of three poles,\ndetermine if they form an arithmetic sequence (i.e., b - a = c - b).\nInput is a string containing three space-separated integers.\nOutput is \"YES\\n\" if arithmetic sequence, \"NO\\n\" otherwise.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_three_integers(input: Seq<char>, a: int, b: int, c: int) -> bool {\n    true /* Simplified for compilation */\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    s.len() > 0\n}\n\nspec fn split_by_spaces_func(s: Seq<char>) -> Seq<Seq<char>> {\n    Seq::empty()\n}\n\nspec fn parse_int_func(s: Seq<char>) -> int {\n    0\n}\n\nspec fn parse_unsigned_int(s: Seq<char>) -> int {\n    0\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires input.len() > 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0618", "language": "verus", "source": "apps", "source-id": "apps_test_4550", "source-notes": "", "vc-description": "Given three candy packs with a, b, and c candies respectively, determine if it's possible \nto distribute these packs between two students such that each receives the same total number \nof candies. Each pack must be given entirely to one student.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::external_body]\nspec fn extract_numbers(input: Seq<char>, index: int, acc: Seq<int>, current: Seq<char>) -> Seq<int> {\n    Seq::empty()\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    input.len() > 0 &&\n    {\n        let nums = extract_numbers(input, 0, Seq::empty(), Seq::empty());\n        nums.len() >= 3 && \n        (forall|i: int| 0 <= i < 3 ==> #[trigger] nums[i] >= 1 && #[trigger] nums[i] <= 100)\n    }\n}\n\nspec fn parse_three_ints_func(input: Seq<char>) -> (int, int, int) {\n    let nums = extract_numbers(input, 0, Seq::empty(), Seq::empty());\n    (nums[0], nums[1], nums[2])\n}\n\nspec fn can_distribute_equally(a: int, b: int, c: int) -> bool {\n    a + b == c || b + c == a || c + a == b\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (result: Seq<char>)\n    requires \n        input.len() > 0,\n        valid_input_format(input),\n    ensures \n        result == seq!['Y', 'e', 's', '\\n'] || result == seq!['N', 'o', '\\n'],\n        ({\n            let numbers = parse_three_ints_func(input);\n            let a = numbers.0;\n            let b = numbers.1; \n            let c = numbers.2;\n            (result == seq!['Y', 'e', 's', '\\n']) <==> can_distribute_equally(a, b, c)\n        }),\n        ({\n            let numbers = parse_three_ints_func(input);\n            numbers.0 >= 1 && numbers.1 >= 1 && numbers.2 >= 1 &&\n            numbers.0 <= 100 && numbers.1 <= 100 && numbers.2 <= 100\n        }),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0640", "language": "verus", "source": "apps", "source-id": "apps_test_4602", "source-notes": "", "vc-description": "Given N balls at coordinates (x_i, i) for i = 1 to N, and 2N robots (N type-A at (0,i) and N type-B at (K,i)),\nfind the minimum total distance to collect all balls. Each robot can collect the ball on its corresponding line\nand return to its starting position. Type-A robot travels 2×x_i, Type-B robot travels 2×(K-x_i).", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn valid_input(s: Seq<char>) -> bool {\n    let lines = split_by_newlines(s);\n    lines.len() >= 3 &&\n    is_positive_integer(lines[0]) &&\n    is_positive_integer(lines[1]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        1 <= n <= 100 &&\n        1 <= k <= 100 &&\n        is_valid_x_array(lines[2], n, k)\n    }\n}\n\nspec fn valid_output(result: Seq<char>) -> bool {\n    result.len() >= 2 &&\n    result[result.len() - 1] == '\\n' &&\n    is_non_negative_integer(result.subrange(0, result.len() - 1))\n}\n\nspec fn correct_solution(input: Seq<char>, output: Seq<char>) -> bool {\n    valid_input(input) && valid_output(output) ==>\n        {\n            let lines = split_by_newlines(input);\n            let n = string_to_int(lines[0]);\n            let k = string_to_int(lines[1]);\n            let x = parse_int_array(lines[2]);\n            x.len() == n &&\n            (forall|i: int| #[trigger] x[i] == x[i] && 0 <= i < n ==> 0 < x[i] < k) &&\n            {\n                let expected_sum = compute_min_distance(x, k);\n                string_to_int(output.subrange(0, output.len() - 1)) == expected_sum\n            }\n        }\n}\n\nspec fn is_positive_integer(s: Seq<char>) -> bool {\n    is_non_negative_integer(s) && s.len() > 0 && \n    (s.len() > 1 || s[0] != '0') && \n    string_to_int(s) > 0\n}\n\nspec fn is_non_negative_integer(s: Seq<char>) -> bool {\n    s.len() > 0 && \n    forall|i: int| #[trigger] s[i] == s[i] && 0 <= i < s.len() ==> {\n        let c = s[i];\n        '0' <= c && c <= '9'\n    }\n}\n\nspec fn is_valid_x_array(s: Seq<char>, n: int, k: int) -> bool {\n    let x = parse_int_array(s);\n    x.len() == n && \n    forall|i: int| #[trigger] x[i] == x[i] && 0 <= i < n ==> 0 < x[i] < k\n}\n\nspec fn compute_min_distance(x: Seq<int>, k: int) -> int {\n    /* requires forall|i: int| 0 <= i < x.len() ==> 0 < x[i] < k */\n    /* ensures compute_min_distance(x, k) >= 0 */\n    sum_seq(Seq::new(x.len(), |i: int| 2 * min(k - x[i], x[i])))\n}\n\nspec fn split_by_newlines(s: Seq<char>) -> Seq<Seq<char>> { \n    seq![]\n}\n\nspec fn string_to_int(s: Seq<char>) -> int { \n    0\n}\n\nspec fn parse_int_array(s: Seq<char>) -> Seq<int> { \n    seq![]\n}\n\nspec fn sum_seq(seq: Seq<int>) -> int { \n    0\n}\n\nspec fn min(a: int, b: int) -> int { \n    if a <= b { a } else { b } \n}", "vc-helpers": "", "vc-spec": "fn solve(s: &str) -> (result: String)\nrequires\n    s@.len() > 0,\n    valid_input(s@),\nensures\n    result@.len() > 0,\n    result@[result@.len() - 1] == '\\n',\n    valid_output(result@),\n    correct_solution(s@, result@),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0645", "language": "verus", "source": "apps", "source-id": "apps_test_4611", "source-notes": "", "vc-description": "Given N checkpoints with coordinates (x_i, y_i) and times t_i, determine if it's possible \nto visit each checkpoint at the specified time, starting from (0,0) at time 0. \nAt each time step, you must move to an adjacent cell (up, down, left, right) and cannot \nstay in the same position.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nstruct Checkpoint {\n    t: int,\n    x: int,\n    y: int,\n}\n\nspec fn valid_input_format(input: Seq<char>) -> bool {\n    let lines = split_lines(input);\n    lines.len() > 0 && is_valid_integer(lines[0]) && \n    ({\n        let n = parse_int(lines[0]);\n        n >= 0 && n + 1 == lines.len() &&\n        (forall|i: int| 1 <= i < lines.len() ==> is_valid_checkpoint_line(lines[i]))\n    })\n}\n\nspec fn can_visit_all_checkpoints(input: Seq<char>) -> bool\n    recommends valid_input_format(input)\n{\n    let lines = split_lines(input);\n    let n = parse_int(lines[0]);\n    if n == 0 { \n        true \n    } else {\n        let checkpoints = parse_checkpoints(lines.subrange(1, lines.len() as int));\n        checkpoints.len() == n &&\n        checkpoints_feasible(checkpoints, 0, 0, 0)\n    }\n}\n\nspec fn checkpoints_feasible(checkpoints: Seq<Checkpoint>, current_t: int, current_x: int, current_y: int) -> bool\n    decreases checkpoints.len()\n{\n    if checkpoints.len() == 0 { \n        true \n    } else {\n        let cp = checkpoints[0];\n        let dt = cp.t - current_t;\n        let dx = if current_x >= cp.x { current_x - cp.x } else { cp.x - current_x };\n        let dy = if current_y >= cp.y { current_y - cp.y } else { cp.y - current_y };\n        let dis = dx + dy;\n        if dt < dis { \n            false \n        } else if (dt - dis) % 2 != 0 { \n            false \n        } else { \n            checkpoints_feasible(checkpoints.subrange(1, checkpoints.len() as int), cp.t, cp.x, cp.y) \n        }\n    }\n}\n\nspec fn split_lines(input: Seq<char>) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_integer(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_int(line: Seq<char>) -> int {\n    0\n}\n\nspec fn is_valid_checkpoint_line(line: Seq<char>) -> bool {\n    true\n}\n\nspec fn parse_checkpoints(lines: Seq<Seq<char>>) -> Seq<Checkpoint> {\n    seq![]\n}", "vc-helpers": "", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n    requires\n        stdin_input@.len() > 0,\n        valid_input_format(stdin_input@),\n    ensures\n        result@ == seq!['Y', 'e', 's', '\\n'] || result@ == seq!['N', 'o', '\\n'],\n        (result@ == seq!['Y', 'e', 's', '\\n']) <==> can_visit_all_checkpoints(stdin_input@),", "vc-code": "{\n    assume(false);\n    \"No\\n\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0660", "language": "verus", "source": "apps", "source-id": "apps_test_4695", "source-notes": "", "vc-description": "Given integers x and y where 1 ≤ x < y ≤ 12, determine if they belong to the same group \naccording to Snuke's division of integers 1 through 12 into three groups based on some criterion.\nInput: Two space-separated integers x and y\nOutput: \"Yes\" if x and y are in the same group, \"No\" otherwise", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n    spec fn valid_input(input: &str) -> bool\n        recommends input.len() > 0\n    {\n        let parts = split_string_pure(input);\n        parts.len() >= 2 && is_valid_int(&parts[0]) && is_valid_int(&parts[1])\n    }\n    \n    spec fn same_group(a: int, b: int) -> bool {\n        let n1 = seq![1, 3, 5, 7, 8, 10, 12];\n        let n2 = seq![4, 6, 9, 11];\n        (n1.contains(a) && n1.contains(b)) || (n2.contains(a) && n2.contains(b)) || (a == 2 && b == 2)\n    }\n    \n    spec fn correct_output(input: &str, result: Seq<char>) -> bool\n        recommends input.len() > 0\n    {\n        if valid_input(input) {\n            let parts = split_string_pure(input);\n            let a = string_to_int_pure(&parts[0]);\n            let b = string_to_int_pure(&parts[1]);\n            let yes_str = seq!['Y', 'e', 's', '\\n'];\n            let no_str = seq!['N', 'o', '\\n'];\n            (result == yes_str <==> same_group(a, b)) && (result == no_str <==> !same_group(a, b))\n        } else {\n            result == seq![]\n        }\n    }", "vc-helpers": "/* Helper functions for string parsing */\nspec fn split_string_pure(s: &str) -> Seq<String> {\n    Seq::empty() /* placeholder for string splitting */\n}\n\nspec fn is_valid_int(s: &str) -> bool {\n    true /* placeholder for integer validation */\n}\n\nspec fn string_to_int_pure(s: &str) -> int {\n    0 /* placeholder for string to int conversion */\n}", "vc-spec": "fn solve(input: &str) -> (result: String)\n    requires\n        input.len() > 0,\n    ensures\n        result@ == seq!['Y', 'e', 's', '\\n'] || result@ == seq!['N', 'o', '\\n'] || result@ == seq![],\n        correct_output(input, result@),", "vc-code": "{\n    assume(false);\n    \"\".to_string()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0666", "language": "verus", "source": "apps", "source-id": "apps_test_4708", "source-notes": "", "vc-description": "Calculate the total cost for N nights of accommodation with tiered pricing.\nFirst K nights cost X yen each, remaining nights (if any) cost Y yen each.\nInput: Four integers N, K, X, Y on separate lines.\nOutput: Single integer representing the total cost.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\nspec fn valid_input(input: Seq<char>) -> bool {\n    let lines = split_string(input, '\\n');\n    lines.len() >= 4 &&\n    is_valid_integer(lines[0]) &&\n    is_valid_integer(lines[1]) &&\n    is_valid_integer(lines[2]) &&\n    is_valid_integer(lines[3]) &&\n    {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        let x = string_to_int(lines[2]);\n        let y = string_to_int(lines[3]);\n        1 <= n <= 10000 && 1 <= k <= 10000 && 1 <= y < x <= 10000\n    }\n}\n\nspec fn valid_output(output: Seq<char>, input: Seq<char>) -> bool {\n    let lines = split_string(input, '\\n');\n    if lines.len() >= 4 && \n       is_valid_integer(lines[0]) &&\n       is_valid_integer(lines[1]) &&\n       is_valid_integer(lines[2]) &&\n       is_valid_integer(lines[3]) {\n        let n = string_to_int(lines[0]);\n        let k = string_to_int(lines[1]);\n        let x = string_to_int(lines[2]);\n        let y = string_to_int(lines[3]);\n        let expected_ans = if k < n { k * x + (n - k) * y } else { n * x };\n        output == int_to_string(expected_ans) + seq!['\\n']\n    } else {\n        output.len() == 0\n    }\n}\n\nspec fn split_string(s: Seq<char>, delimiter: char) -> Seq<Seq<char>> {\n    seq![]\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n    true\n}\n\nspec fn string_to_int(s: Seq<char>) -> int {\n    0\n}\n\nspec fn int_to_string(n: int) -> Seq<char> {\n    seq![]\n}", "vc-helpers": "", "vc-spec": "fn solve(input: Seq<char>) -> (output: Seq<char>)\n    requires input.len() > 0\n    ensures valid_output(output, input)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VA0670", "language": "verus", "source": "apps", "source-id": "apps_test_4714", "source-notes": "", "vc-description": "Count the number of palindromic numbers in the range [A, B] inclusive.\nA palindromic number is a positive integer that reads the same forwards and backwards when written in decimal notation.\nConstraints: 10000 ≤ A ≤ B ≤ 99999", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "spec fn is_palindromic(n: int) -> bool\n  recommends n >= 0\n{\n  let s = int_to_string(n);\n  forall|i: int| 0 <= i < s.len() / 2 ==> s[i] == s[s.len() - 1 - i]\n}\n\nspec fn count_palindromic_numbers(a: int, b: int) -> int\n  recommends 10000 <= a <= b <= 99999\n  decreases b - a + 1\n{\n  if a > b { \n    0\n  } else if a == b { \n    if is_palindromic(a) { 1 } else { 0 }\n  } else {\n    (if is_palindromic(a) { 1 } else { 0 }) + count_palindromic_numbers(a + 1, b)\n  }\n}\n\nspec fn is_valid_integer(s: Seq<char>) -> bool {\n  s.len() > 0 && forall|i: int| 0 <= i < s.len() ==> '0' <= s[i] <= '9'\n}\n\nspec fn valid_input(stdin_input: Seq<char>) -> bool {\n  stdin_input.len() > 0 &&\n  exists|i: int| 0 <= i < stdin_input.len() && stdin_input[i] == ' ' &&\n  {\n    let parts = split_on_space(stdin_input);\n    parts.len() == 2 && \n    is_valid_integer(parts[0]) && \n    is_valid_integer(parts[1]) &&\n    string_to_int(parts[0]) >= 10000 &&\n    string_to_int(parts[1]) >= 10000 &&\n    string_to_int(parts[0]) <= 99999 &&\n    string_to_int(parts[1]) <= 99999 &&\n    string_to_int(parts[0]) <= string_to_int(parts[1])\n  }\n}", "vc-spec": "fn solve(stdin_input: &str) -> (result: String)\n  requires \n    valid_input(stdin_input@)\n  ensures \n    result@.len() > 0\n  ensures \n    result@[result@.len() as int - 1] == '\\n'\n  ensures {\n    let parts = split_on_space(stdin_input@);\n    let a = string_to_int(parts[0]);\n    let b = string_to_int(parts[1]);\n    result@ == int_to_string(count_palindromic_numbers(a, b)) + seq!['\\n']\n  }", "vc-code": "{\n  assume(false);\n  String::new()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VD0537", "language": "verus", "source": "dafnybench", "source-id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_NoDups", "source-notes": "", "vc-description": "// ASSIGNMENT P1\n\n// CMSC 433 FALL 2023\n\n// PERFECT SCORE:  100 POINTS\n\n//\n\n// This assignment contains nine questions, each of which involves writing Verus\n\n// code. You should include your solutions in a single Verus file and submit it using\n\n// Gradescope.\n\n//\n\n// Revision history\n\n//\n\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n// Question 1 (5 points)\n\n//\n\n// Fill in a requires clause that enables Verus to verify\n\n// method PlusOne\n\n// Question 2 (5 points)\n\n//\n\n// Fill in requires clause(s) that enable(s) Verus to verify the array bounds\n\n// in method Swap (which swaps elements i and j in array a).\n\n// Question 3 (5 points)\n\n//\n\n// Give ensures clause(s) asserting that d is the result, and r the\n\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n\n// the Verus division and mod operators, respectively). By definition, the\n\n// remainder must be non-negative.\n\n// Question 4 (5 points)\n\n//\n\n// Give ensures clause(s) asserting that the return value has the same\n\n// length as array a and contains as its elements the sum of the\n\n// corresponding elements in arrays a and b.\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n\n// if and only if i % j == 0 (% is the Verus mod operator).  Write requires and\n\n// ensures clauses for the method header Euclid below.  Your requires clauses\n\n// should also specify that the first argument is at least as large as the second.\n\n// You do *not* need to implement the method!\n\n// Question 7 (20 points)\n\n//\n\n// Implement, and have Verus verify, the method IsPrime below, which returns true\n\n// if and only if the given positive integer is prime.\n\n// Question 8 (20 points)\n\n//\n\n// Implement, and have Verus verify, the method Reverse below, which returns a new array\n\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n\n// array of ints use the Verus command \"Vec::with_capacity(...)\", where \"...\" is the number\n\n// of elements in the array.\n\n// Question 9 (20 points)\n\n//\n\n// Implement and verify method NoDups, which returns true if and only if there\n\n// are no duplicate elements in array a.  Note that the requires clause allows\n\n// you to assume that a is sorted, and that this precondition is necessary for\n\n// the ensures clause to imply a lack of duplicates.\n\n// a sorted", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn no_dups(a: &Vec<i32>) -> (no_dups: bool)\n    requires forall|j: int| 1 <= j < a.len() ==> a[j-1] <= a[j],\n    ensures no_dups <==> forall|j: int| 1 <= j < a.len() ==> a[j-1] != a[j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VD0848", "language": "verus", "source": "dafnybench", "source-id": "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_HoareTripleReqEns", "source-notes": "", "vc-description": "/*\nVerus include 2 limbaje:\n    * un limbaj pentru specificare \n        MSFOL (ce am discutat până acum)\n        adnotări care să ajute în procesul de verificare\n    * un limbaj pentru scris programe\n*/\n\n// Exemplu de program\n\n/*\n    triple Hoare (| P |) S (| Q |) \n*/\n\n// varianta assume-assert\n\n// varianta requires-ensures\n\n/*\nregula pentru while\n*/\n\n// varianta cu assert\n\n/*\n*/\n\n// varianta cu invariant\n\n//specificarea sumei de patrate\n\n/*\n*/\n\n// verificarea programului pentru suma de patrate\n\n// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\n\n// Base case\n\n// Additional proof steps would be needed here\n\n/*\nspec fn SqrSumBy6(n: int) -> int\n{\n    n * (n + 1) * (2 * n + 1) \n}\n\nproof fn L(n: int) // it takes a while\n    requires n >= 0\n    ensures  SqrSumBy6(n) == 6 * SqrSumRec(n)\n    decreases n\n{\n    if n == 0 {\n        // Base case\n    } else {\n        assert(n > 0);\n        L(n-1);\n        assert(SqrSumBy6(n-1) == n*(n-1)*(2*n - 1));\n        assert(SqrSumBy6(n-1) == 6*SqrSumRec(n-1));\n        assert(6*SqrSumRec(n-1) == n*(n-1)*(2*n - 1));\n        // Additional calc steps would be needed here for full verification\n    }\n}\n*/\n\n// (| k == i*i |) k := k + 2 * i +1; (| k = (i+1)*(i+1) |)\n\n// Proof by algebraic expansion: k + 2*i + 1 = i*i + 2*i + 1 = (i+1)*(i+1)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn SqrSumRec(n: int) -> int\n    recommends n >= 0\n    decreases n\n{\n    if n == 0 { 0 } else { n*n + SqrSumRec(n-1) }\n}\n\nproof fn L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n    decreases n\n{\n    if n == 0 {\n\n    } else {\n        L1(n-1);\n\n    }\n}", "vc-helpers": "", "vc-spec": "spec fn HoareTripleReqEns(i: int, k: int) -> (kprime: int)\n    recommends k == i*i\n    ensures kprime == (i+1)*(i+1)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VH0004", "language": "verus", "source": "humaneval", "source-id": "humaneval_004", "source-notes": "", "vc-description": "This task implements the calculation of Mean Absolute Deviation (MAD)\nfor a sequence of floating-point numbers. The MAD is defined as the average of the\nabsolute deviations from the arithmetic mean of the data set.\n\nThe implementation should calculate the arithmetic mean, compute absolute deviations\nfrom this mean for each element, and then return the average of these absolute deviations\nwhile ensuring the result is non-negative.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(numbers: Seq<f64>) -> f64\n    decreases numbers.len()\n{\n    if numbers.len() == 0 {\n        0.0\n    } else {\n        numbers[0] + sum(numbers.drop_first())\n    }\n}\n\nspec fn abs(x: f64) -> f64 {\n    if x >= 0.0 { x } else { -x }\n}\n\nspec fn valid_input(numbers: Seq<f64>) -> bool {\n    numbers.len() > 0\n}\n\nspec fn arithmetic_mean(numbers: Seq<f64>) -> f64 {\n    sum(numbers) / (numbers.len() as f64)\n}\n\nspec fn absolute_deviations(numbers: Seq<f64>) -> Seq<f64> {\n    Seq::new(numbers.len(), |i: int| abs(numbers[i] - arithmetic_mean(numbers)))\n}\n\nspec fn mad(numbers: Seq<f64>) -> f64 {\n    sum(absolute_deviations(numbers)) / (numbers.len() as f64)\n}", "vc-helpers": "proof fn sum_non_negative(numbers: Seq<f64>)\n    requires forall|i: int| 0 <= i < numbers.len() ==> numbers[i] >= 0.0,\n    ensures sum(numbers) >= 0.0,\n    decreases numbers.len(),\n{\n    if numbers.len() == 0 {\n    } else {\n        sum_non_negative(numbers.drop_first());\n    }\n}", "vc-spec": "fn mean_absolute_deviation(numbers: Vec<f64>) -> (result: f64)\n    requires valid_input(numbers@)\n    ensures result >= 0.0 && result == mad(numbers@)", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "\n}\n\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VS0012", "language": "verus", "source": "numpy_simple", "source-id": "NpConvolve-spec", "source-notes": "", "vc-description": "", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn convolution_sum(arr1: Seq<f32>, arr2: Seq<f32>, n: nat) -> f32\n{\n    0.0\n}\n\nfn convolution_sum_impl(arr1: &Vec<f32>, arr2: &Vec<f32>, n: usize) -> f32\n{\n    // impl-start\n    assume(false);\n    0.0\n    // impl-end\n}\n\nfn convolve(arr1: &Vec<f32>, arr2: &Vec<f32>) -> (result: Vec<f32>)\n    requires \n        arr1.len() > 0,\n        arr2.len() > 0,\n    ensures \n        result.len() == arr1.len() + arr2.len() - 1,", "vc-code": "{\n    // impl-start\n    assume(false);\n    Vec::new()\n    // impl-end\n}", "vc-postamble": "\n}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "default_value", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0004", "language": "verus", "source": "numpy_triple", "source-id": "array_creation_ascontiguousarray", "source-notes": "", "vc-description": "Return a contiguous array (ndim >= 1) in memory (C order).\nThis function ensures the input array is contiguous in C order and guarantees\nminimum dimensionality of 1. For non-empty input, preserves all elements.\n\nSpecification: ascontiguousarray returns a contiguous array with same content,\nensuring minimum dimensionality of 1. For non-empty arrays, elements are preserved\nexactly. For empty arrays, returns a 1-dimensional array with 1 element.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ascontiguousarray(a: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() >= 1,\n        a.len() > 0 ==> result.len() == a.len(),\n        a.len() == 0 ==> result.len() == 1,\n        a.len() > 0 ==> forall|i: int| 0 <= i < a.len() ==> exists|j: int| 0 <= j < result.len() && result[j] == a[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0009", "language": "verus", "source": "numpy_triple", "source-id": "array_creation_diagflat", "source-notes": "", "vc-description": "numpy.diagflat: Create a two-dimensional array with the flattened input as a diagonal.\n\nTakes an input vector (representing flattened data) and creates a square matrix\nwhere the input values appear along the k-th diagonal. The parameter k determines\nwhich diagonal to use: k=0 for main diagonal, k>0 for super-diagonals,\nand k<0 for sub-diagonals.\n\nFor simplicity, we focus on the main diagonal case (k=0) and return a 1D flattened\nrepresentation of the square matrix.\n\nSpecification: diagflat creates a square matrix with input values on the main diagonal.\n\nPrecondition: True (no special preconditions)\nPostcondition: The result is a flattened square matrix where:\n1. The input vector v appears along the main diagonal\n2. All other elements are zero\n3. The matrix has dimensions n × n (flattened to n² elements)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn diagflat(v: Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == v.len() * v.len(),\n        forall|i: int| 0 <= i < v.len() ==> result[i * v.len() + i] == v[i],\n        forall|i: int, j: int| 0 <= i < v.len() && 0 <= j < v.len() && i != j ==> result[i * v.len() + j] == 0.0f32", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0011", "language": "verus", "source": "numpy_triple", "source-id": "array_creation_empty_like", "source-notes": "", "vc-description": "numpy.empty_like: Return a new array with the same shape and type as a given array.\n\nCreates a new array with the same shape and type as the prototype array,\nbut with uninitialized (arbitrary) data. This is useful for creating\narrays that will be filled with values later, avoiding the overhead\nof initialization.\n\nThe returned array has the same dimensions as the prototype but does not\ncopy the values - the contents are undefined and may contain any values.\n\nSpecification: numpy.empty_like returns a vector with the same size as the prototype\nbut with uninitialized values.\n\nPrecondition: True (no special preconditions needed)\nPostcondition: \n1. The result has the same size as the prototype array\n2. The result vector is well-formed with proper indexing\n3. The result is independent of the prototype's values (shape invariant)\n\nMathematical Properties:\n- Size preservation: |result| = |prototype| = n\n- Index validity: all valid indices for prototype are valid for result\n- Type preservation: result has same element type as prototype\n\nNote: We cannot specify the actual values since they are uninitialized,\nbut we can specify structural and size properties that must hold.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_empty_like(prototype: &Vec<f32>) -> (result: Vec<f32>)\n    ensures\n        result.len() == prototype.len(),\n        forall|i: int| 0 <= i < prototype.len() ==> 0 <= i < result.len(),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0012", "language": "verus", "source": "numpy_triple", "source-id": "array_creation_eye", "source-notes": "", "vc-description": "numpy.eye: Return a 2-D array with ones on the diagonal and zeros elsewhere.\n\nReturns the identity matrix of size n x n. For simplicity, we implement \nthe square matrix case (N=M) with diagonal offset k=0.\n\nThis function creates an n x n matrix where all elements are zero except\nfor the main diagonal, which contains ones.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn eye(n: usize) -> (result: Vec<Vec<f32>>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i].len() == n,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> \n            result[i][j] == if i == j { 1.0f32 } else { 0.0f32 },\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n ==> \n            result[i][j] == result[j][i],\n        forall|i: int| 0 <= i < n ==> exists|j: int| 0 <= j < n && \n            result[i][j] == 1.0f32 && forall|k: int| 0 <= k < n && result[i][k] == 1.0f32 ==> k == j,\n        forall|j: int| 0 <= j < n ==> exists|i: int| 0 <= i < n && \n            result[i][j] == 1.0f32 && forall|k: int| 0 <= k < n && result[k][j] == 1.0f32 ==> k == i,\n        forall|i: int, j: int| 0 <= i < n && 0 <= j < n && i != j ==> \n            result[i][j] == 0.0f32,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0035", "language": "verus", "source": "numpy_triple", "source-id": "array_creation_zeros", "source-notes": "", "vc-description": "Return a new vector of given size, filled with zeros\n\nSpecification: zeros returns a vector where all elements are zero\nThis comprehensive specification captures:\n1. All elements equal to zero (basic property)\n2. The result is the additive identity for vector addition\n3. The sum of all elements is zero (for numeric types)\n4. Scalar multiplication by any value preserves the zero property\n5. The dot product with any vector is zero\n6. The norm/magnitude is zero (for types with norm)\n7. Element-wise operations preserve zero structure", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn zeros(n: usize) -> (result: Vec<i32>)\n    ensures\n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> result[i] == 0,\n        forall|v: Vec<i32>, i: int| \n            v.len() == n && 0 <= i < n ==> \n            result[i] + v[i] == v[i] && v[i] + result[i] == v[i],\n        forall|scalar: i32, i: int| \n            0 <= i < n ==> scalar * result[i] == 0,\n        forall|v: Vec<i32>, i: int| \n            v.len() == n && 0 <= i < n ==> result[i] * v[i] == 0,\n        n > 0 ==> result[0] == 0", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0041", "language": "verus", "source": "numpy_triple", "source-id": "array_manipulation_atleast_3d", "source-notes": "", "vc-description": "numpy.atleast_3d: View a 1D vector as a 3D array with shape (1, n, 1).\n\nThis is a specialization of numpy.atleast_3d for 1D input.\nThe function reshapes a 1D array of shape (n,) into a 3D array \nof shape (1, n, 1) while preserving all elements.\n\nSpecification: atleast_3d transforms a 1D vector into a 3D array where:\n- The output has shape (1, n, 1)\n- Each element arr[i] is accessible at position [0][i][0] in the result\n- All elements are preserved without modification\n- The transformation is injective (different inputs produce different outputs)\n\nMathematical properties:\n1. Element preservation: Every element from the input appears exactly once in the output\n2. Shape expansion: A 1D shape (n,) becomes 3D shape (1, n, 1)\n3. Order preservation: Elements maintain their relative ordering\n4. The output contains exactly n elements total", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn atleast_3d(arr: Vec<f32>) -> (result: Vec<Vec<Vec<f32>>>)\n    ensures \n        result.len() == 1,\n        forall|j: int| 0 <= j < 1 ==> result[j].len() == arr.len(),\n        forall|j: int, k: int| 0 <= j < 1 && 0 <= k < arr.len() ==> result[j][k].len() == 1,\n        forall|i: int| 0 <= i < arr.len() ==> {\n            let outer = &result[0];\n            let middle = &outer[i];\n            let value = middle[0];\n            value == arr[i]\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0042", "language": "verus", "source": "numpy_triple", "source-id": "array_manipulation_block", "source-notes": "", "vc-description": "Assemble a 2D matrix from a 2x2 block structure.\nThis is a simplified version focusing on the common case of assembling \na matrix from four blocks arranged in a 2x2 pattern.\n\nSpecification: block assembles a matrix from four submatrices in a 2x2 pattern.\nThe result has dimensions (r1 + r2) × (c1 + c2) where:\n- Top-left block occupies rows [0, r1) and columns [0, c1)\n- Top-right block occupies rows [0, r1) and columns [c1, c1 + c2)\n- Bottom-left block occupies rows [r1, r1 + r2) and columns [0, c1)\n- Bottom-right block occupies rows [r1, r1 + r2) and columns [c1, c1 + c2)\n\n/* Top-left block elements */\n\n/* Top-right block elements */\n\n/* Bottom-left block elements */\n\n/* Bottom-right block elements */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn block(\n    top_left: Vec<Vec<f32>>,\n    top_right: Vec<Vec<f32>>,\n    bottom_left: Vec<Vec<f32>>,\n    bottom_right: Vec<Vec<f32>>\n) -> (result: Vec<Vec<f32>>)\n    requires\n        top_left.len() > 0,\n        top_right.len() > 0,\n        bottom_left.len() > 0,\n        bottom_right.len() > 0,\n        top_left.len() == top_right.len(),\n        bottom_left.len() == bottom_right.len(),\n        top_left[0].len() == bottom_left[0].len(),\n        top_right[0].len() == bottom_right[0].len(),\n        forall|i: int| 0 <= i < top_left.len() ==> top_left[i].len() == top_left[0].len(),\n        forall|i: int| 0 <= i < top_right.len() ==> top_right[i].len() == top_right[0].len(),\n        forall|i: int| 0 <= i < bottom_left.len() ==> bottom_left[i].len() == bottom_left[0].len(),\n        forall|i: int| 0 <= i < bottom_right.len() ==> bottom_right[i].len() == bottom_right[0].len(),\n    ensures\n        result.len() == top_left.len() + bottom_left.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == top_left[0].len() + top_right[0].len(),\n\n        forall|i: int, j: int| \n            0 <= i < top_left.len() && 0 <= j < top_left[0].len() ==> \n            result[i][j] == top_left[i][j],\n\n        forall|i: int, j: int|\n            0 <= i < top_right.len() && 0 <= j < top_right[0].len() ==>\n            result[i][top_left[0].len() + j] == top_right[i][j],\n\n        forall|i: int, j: int|\n            0 <= i < bottom_left.len() && 0 <= j < bottom_left[0].len() ==>\n            result[top_left.len() + i][j] == bottom_left[i][j],\n\n        forall|i: int, j: int|\n            0 <= i < bottom_right.len() && 0 <= j < bottom_right[0].len() ==>\n            result[top_left.len() + i][top_left[0].len() + j] == bottom_right[i][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0045", "language": "verus", "source": "numpy_triple", "source-id": "array_manipulation_broadcast_to", "source-notes": "", "vc-description": "Broadcast a 1D vector to a 2D matrix by repeating it along rows.\nThis implements the most common broadcasting pattern: (n,) -> (m, n)\n\nSpecification: broadcast_to creates a 2D matrix where each row is a copy of the input vector.\n\nMathematical properties:\n1. Shape property: The result has shape (m, n) where n is the original vector length\n2. Value property: Each row in the result equals the original vector\n3. Broadcasting rule: A 1D array of shape (n,) can be broadcast to (m, n) by repeating\n4. Row consistency: All rows in the result are identical to the input vector\n5. Element preservation: Each element in the input appears m times in each column\n\nSanity checks:\n- The output shape is exactly (m, n)\n- Every row contains the same values as the input vector\n- Broadcasting preserves element values without modification\n- The result behaves as if v was copied m times along a new axis\n\nExample behavior:\n- Input: [1, 2, 3] with target shape (2, 3)\n- Output: [[1, 2, 3], [1, 2, 3]]\n\nAdditional properties:\n- Memory efficiency: In NumPy, this creates a view, not a copy\n- Column-wise view: Column j contains m copies of v[j]\n- Broadcasting compatibility: The result can be used in element-wise operations with other (m, n) arrays\n\nMathematical formulation:\n- For input vector v ∈ ℝⁿ and target shape (m, n)\n- Output matrix M ∈ ℝᵐˣⁿ where M[i,j] = v[j] for all i ∈ {0,...,m-1}, j ∈ {0,...,n-1}\n\n/* Primary property: each element (i,j) equals v[j] */\n\n/* Row identity: each row is exactly the input vector */\n\n/* Column uniformity: each column contains a single repeated value */\n\n/* Value preservation: no new values are introduced */\n\n/* Broadcast invariant: the operation is idempotent on rows */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn broadcast_to(v: Vec<f32>, m: usize) -> (result: Vec<Vec<f32>>)\n    requires v.len() > 0,\n    ensures\n        result.len() == m,\n\n        forall|i: int, j: int| 0 <= i < m && 0 <= j < v.len() ==> result[i][j] == v[j],\n\n        forall|i: int| 0 <= i < m ==> result[i]@ == v@,\n\n        forall|j: int, i1: int, i2: int| 0 <= j < v.len() && 0 <= i1 < m && 0 <= i2 < m ==> result[i1][j] == result[i2][j],\n\n        forall|i: int, j: int| 0 <= i < m && 0 <= j < v.len() ==> exists|k: int| 0 <= k < v.len() && result[i][j] == v[k] && k == j,\n\n        forall|i1: int, i2: int| 0 <= i1 < m && 0 <= i2 < m ==> result[i1]@ == result[i2]@", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0046", "language": "verus", "source": "numpy_triple", "source-id": "array_manipulation_column_stack", "source-notes": "", "vc-description": "numpy.column_stack: Stack 1-D arrays as columns into a 2-D array.\n\nTakes a sequence of 1-D arrays and stacks them as columns to make a \nsingle 2-D array. All input arrays must have the same length (number \nof rows in the output).\n\nThe result is represented as a flattened vector in column-major order,\nwhere elements from the same column are contiguous. For a result with\n'rows' rows and 'cols' columns, element at position (i, j) is stored\nat index j * rows + i in the flattened vector.\n\nThis is a fundamental array manipulation operation that combines multiple\n1D arrays into a single 2D structure, useful for constructing matrices\nfrom column vectors.\n\nSpecification: column_stack creates a 2D array (as flattened vector) where\neach input array becomes a column.\n\nPrecondition: cols > 0 (at least one input array)\nPostcondition: \n- The result contains all elements from the input arrays\n- Elements are arranged in column-major order\n- The j-th column of the result contains all elements from arrays[j]\n- For 0 ≤ i < rows and 0 ≤ j < cols, the element at position (i,j)\n  in the 2D view equals arrays[j][i] and is stored at index j*rows + i", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn column_stack(arrays: Vec<Vec<f32>>) -> (result: Vec<f32>)\n    requires\n        arrays.len() > 0,\n        forall|i: int| 0 <= i < arrays.len() ==> arrays[i].len() == arrays[0].len(),\n    ensures\n        result.len() == arrays.len() * arrays[0].len(),\n        forall|i: int, j: int| \n            0 <= i < arrays[0].len() && 0 <= j < arrays.len() ==>\n            result[j * arrays[0].len() + i] == arrays[j][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0049", "language": "verus", "source": "numpy_triple", "source-id": "array_manipulation_delete", "source-notes": "", "vc-description": "numpy.delete: Return a new array with sub-arrays along an axis deleted.\n\nFor a one dimensional array, this returns those entries not returned by\narr[obj]. The function removes elements at the specified index and\nreturns a new array with the remaining elements.\n\nThis specification handles the 1D case where we delete a single element\nat a specified index from a vector.\n\nSpecification: numpy.delete removes the element at the specified index and returns\na new vector containing all other elements in their original order.\n\nThe specification ensures:\n1. The result has size n (one less than the input)\n2. Elements before the deleted index maintain their positions\n3. Elements after the deleted index are shifted left by one position\n\nMathematical properties:\n- Order preservation: Elements maintain their relative order\n- Deletion correctness: The element at the specified index is removed\n- Shift property: Elements after the deleted index have their indices decreased by 1\n\nSanity checks:\n- The result size is exactly one less than the input size\n- No elements are duplicated or lost (except the deleted one)\n- The deleted element does not appear in the result\n\nPrecondition: The array must have at least one element (enforced by type)\n\nPostcondition:\n- For indices i < index: result[i] = arr[i]\n- For indices i ≥ index: result[i] = arr[i+1]\n- The element arr[index] does not appear in the result (unless duplicated elsewhere)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn delete(arr: Vec<f32>, index: usize) -> (result: Vec<f32>)\n    requires \n        arr.len() > 0,\n        index < arr.len(),\n    ensures \n        result.len() == arr.len() - 1,\n        forall|i: int| 0 <= i < index ==> result[i] == arr[i],\n        forall|i: int| index <= i < result.len() ==> result[i] == arr[i + 1],\n        forall|i: int| 0 <= i < arr.len() && i != index ==> \n            exists|j: int| 0 <= j < result.len() && result[j] == arr[i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0051", "language": "verus", "source": "numpy_triple", "source-id": "array_manipulation_dstack", "source-notes": "", "vc-description": "numpy.dstack: Stack arrays in sequence depth wise (along third axis).\n\nFor a sequence of 1D arrays (vectors), this function stacks them along a new third axis,\ncreating a 3D array. Each input vector becomes a \"slice\" in the depth dimension.\n\nFor 1D inputs of length n, the output shape is (1, n, k) where k is the number of arrays.\nThis is because 1D arrays are first reshaped to (1, n) then stacked along axis 2.\n\nThe result is always at least 3-dimensional.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_dstack(arrays: Vec<Vec<f32>>) -> (result: Vec<Vec<Vec<f32>>>)\n    requires \n        arrays.len() > 0,\n        forall|i: int| 0 <= i < arrays.len() ==> \n            forall|j: int| 0 <= j < arrays.len() ==> arrays[i].len() == arrays[j].len(),\n    ensures\n        result.len() == 1,\n        result[0].len() == if arrays.len() > 0 { arrays[0].len() } else { 0 },\n        forall|i: int| 0 <= i < result[0].len() ==> result[0][i].len() == arrays.len(),\n        forall|i: int, j: int| \n            0 <= i < result[0].len() && 0 <= j < arrays.len() ==>\n            result[0][i][j] == arrays[j][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0054", "language": "verus", "source": "numpy_triple", "source-id": "array_manipulation_fliplr", "source-notes": "", "vc-description": "Reverses the order of columns in a 2D matrix (left/right flip).\nFor a matrix with shape (rows × cols), this operation reverses the order \nof elements along each row, effectively flipping the matrix horizontally.\n\nSpecification: fliplr reverses the column order in each row of the matrix.\nThe element at position (i, j) in the input matrix appears at position \n(i, cols-1-j) in the output matrix. This captures the mathematical property\nthat columns are reversed while rows remain in the same order.\n\nSanity checks:\n1. The output has the same dimensions as the input (enforced by type)\n2. Each row contains the same elements, just in reversed order\n3. For matrices with odd number of columns, the middle column stays in place\n\nMathematical properties:\n1. Element mapping: For all valid indices i and j, there exists a corresponding\n   index j' such that output[i,j] = input[i,j'] where j' = cols-1-j\n2. Row preservation: Each row contains exactly the same elements as the input\n3. Column reversal: The first column becomes the last, second becomes second-to-last, etc.", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn fliplr(m: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        m.len() > 0,\n        forall|i: int| 0 <= i < m.len() ==> m[i].len() > 0,\n        forall|i: int, j: int| 0 <= i < m.len() && 0 <= j < m.len() ==> m[i].len() == m[j].len(),\n    ensures\n        result.len() == m.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == m[i].len(),\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==>\n            exists|k: int| 0 <= k < m[i].len() && \n                           result[i][j] == m[i][k] && \n                           j + k == (m[i].len() - 1) as int,\n        forall|i: int, x: f32| 0 <= i < result.len() ==>\n            ((exists|j: int| 0 <= j < m[i].len() && m[i][j] == x) <==> \n             (exists|j: int| 0 <= j < result[i].len() && result[i][j] == x)),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0059", "language": "verus", "source": "numpy_triple", "source-id": "array_manipulation_matrix_transpose", "source-notes": "", "vc-description": "Transposes a matrix by swapping rows and columns.\nFor a matrix with shape (m, n), returns a matrix with shape (n, m)\nwhere result[i, j] = input[j, i]\n\nSpecification: matrix_transpose swaps rows and columns, producing a transposed matrix\nwhere the element at position (i, j) in the result equals the element at position (j, i)\nin the input. The result has dimensions swapped: an m×n matrix becomes n×m.\n\n/* Dimension check: result is n×m when input is m×n */\n\n/* Transpose property: result[i][j] = mat[j][i] */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn matrix_transpose(mat: &Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        mat.len() > 0,\n        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == mat[0].len(),\n    ensures\n\n        result.len() == mat[0].len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == mat.len(),\n\n        forall|i: int, j: int| 0 <= i < result.len() && 0 <= j < result[i].len() ==> \n            result[i][j] == mat[j][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0063", "language": "verus", "source": "numpy_triple", "source-id": "array_manipulation_repeat", "source-notes": "", "vc-description": "Repeat elements of a vector a specified number of times.\nEach element is repeated consecutively.\n\nSpecification: repeat creates a vector where each element from the input \nappears consecutively 'repeats' times. The resulting vector has size n * repeats.\n\nFor a vector [a₀, a₁, ..., aₙ₋₁] and repeats = r, the result is:\n[a₀, a₀, ..., a₀, a₁, a₁, ..., a₁, ..., aₙ₋₁, aₙ₋₁, ..., aₙ₋₁]\n \\___r times___/  \\___r times___/       \\______r times______/\n\nMathematical properties:\n1. Each element appears exactly 'repeats' times consecutively\n2. The total size is n * repeats\n3. Element at index i comes from input element at index ⌊i/repeats⌋\n4. Elements are grouped: positions [k*repeats, (k+1)*repeats) contain a[k]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn repeat<T: Copy>(a: Vec<T>, repeats: usize) -> (result: Vec<T>)\n    requires repeats > 0,\n    ensures\n        result.len() == a.len() * repeats,\n        forall|i: int| 0 <= i < result.len() ==> {\n            let k = i / (repeats as int);\n            0 <= k < a.len() && result[i] == a[k]\n        },\n        forall|k: int| 0 <= k < a.len() ==> forall|j: int| 0 <= j < repeats ==> {\n            let idx = k * (repeats as int) + j;\n            0 <= idx < result.len() && result[idx] == a[k]\n        },", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0075", "language": "verus", "source": "numpy_triple", "source-id": "array_manipulation_swapaxes", "source-notes": "", "vc-description": "Numpy swapaxes function: Interchange two axes of an array.\n\nThis function interchanges two axes of an array. For 2D arrays, swapaxes with axis1=0 and axis2=1 is equivalent to transpose. This specification focuses on 2D arrays where axis1=0 and axis2=1.\n\nSpecification: swapaxes with axes 0 and 1 transposes a 2D array.\nThe element at position (i,j) in the original becomes (j,i) in the result.\n\nMathematical properties:\n1. Dimension swap: rows become columns and vice versa\n2. Element preservation: mat[i][j] = result[j][i]\n3. Idempotence: swapping twice returns to original\n4. Commutativity: swapaxes(a, i, j) = swapaxes(a, j, i)", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn swapaxes(mat: Vec<Vec<f32>>, axis1: usize, axis2: usize) -> (result: Vec<Vec<f32>>)\n    requires\n        mat.len() > 0,\n        mat[0].len() > 0,\n        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == mat[0].len(),\n        axis1 < 2,\n        axis2 < 2,\n    ensures\n        result.len() == mat[0].len(),\n        result.len() > 0 ==> result[0].len() == mat.len(),\n        forall|i: int| 0 <= i < result.len() ==> result[i].len() == mat.len(),\n        forall|i: int, j: int| \n            0 <= i < mat.len() && 0 <= j < mat[0].len() \n            ==> mat[i][j] == result[j][i],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0077", "language": "verus", "source": "numpy_triple", "source-id": "array_manipulation_transpose", "source-notes": "", "vc-description": "numpy.transpose: Returns a matrix with rows and columns swapped.\n\nFor 2D arrays (matrices), transpose swaps the rows and columns.\nThis means that element at position (i,j) in the original matrix\nappears at position (j,i) in the transposed matrix.\n\nThis simplified version handles 2D matrix transpose only.\n\nSpecification: numpy.transpose returns a matrix where rows and columns are swapped.\n\nPrecondition: True (no special preconditions for basic transpose)\nPostcondition: For all valid indices (i,j), result[j][i] = a[i][j]\n\nMathematical properties:\n- Transpose is an involution: (A^T)^T = A\n- For square matrices: trace(A^T) = trace(A)\n- (A^T)[j,i] = A[i,j] for all valid indices", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn numpy_transpose(a: Vec<Vec<f32>>) -> (result: Vec<Vec<f32>>)\n    requires \n        a.len() > 0,\n        forall|i: int| 0 <= i < a.len() ==> a[i].len() == a[0].len(),\n        a[0].len() > 0,\n    ensures\n        result.len() == a[0].len(),\n        forall|j: int| 0 <= j < result.len() ==> result[j].len() == a.len(),\n        forall|i: int, j: int| \n            0 <= i < a.len() && 0 <= j < a[0].len() ==> \n            result[j][i] == a[i][j],", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0080", "language": "verus", "source": "numpy_triple", "source-id": "array_manipulation_vsplit", "source-notes": "", "vc-description": "Split a 2D vector into multiple sub-vectors vertically (row-wise).\nThis is a simplified version that handles splitting into equal parts.\n\nSpecification: vsplit divides a matrix into k equal parts row-wise, \nwhere each part contains consecutive rows from the original matrix", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn vsplit(mat: Vec<Vec<f32>>, k: usize) -> (result: Vec<Vec<Vec<f32>>>)\n    requires \n        k > 0,\n        mat.len() > 0,\n        mat.len() % k == 0,\n        forall|i: int| 0 <= i < mat.len() ==> mat[i].len() == mat[0].len(),\n    ensures\n        result.len() == k,\n        forall|split_idx: int| 0 <= split_idx < k ==> result[split_idx].len() == mat.len() / k,\n        forall|split_idx: int, row_idx: int, col_idx: int| \n            0 <= split_idx < k && 0 <= row_idx < mat.len() / k && 0 <= col_idx < mat[0].len() ==>\n            exists|global_row: int| \n                global_row == split_idx * (mat.len() / k) + row_idx &&\n                0 <= global_row < mat.len() &&\n                result[split_idx][row_idx][col_idx] == mat[global_row][col_idx],\n        forall|orig_row: int| 0 <= orig_row < mat.len() ==>\n            exists|split_idx: int, row_idx: int|\n                0 <= split_idx < k && 0 <= row_idx < mat.len() / k &&\n                orig_row == split_idx * (mat.len() / k) + row_idx,", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0089", "language": "verus", "source": "numpy_triple", "source-id": "bitwise_operations_packbits", "source-notes": "", "vc-description": "Packs binary-valued elements into bits in a UInt8 array.\nEach group of 8 binary values is packed into one UInt8.\nThe result is padded with zeros if needed.\n\nSpecification: packbits correctly packs binary values into UInt8 bytes according to bitorder.\nFor big-endian: first element goes to MSB (bit 7)\nFor little-endian: first element goes to LSB (bit 0)\n\n/* Enumeration for bit ordering in packbits */\n\n// MSB first (default): bit 7 is first element\n\n// LSB first: bit 0 is first element\n\n// Big-endian: bit 7 is first, bit 0 is last\n\n// Little-endian: bit 0 is first, bit 7 is last", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\n#[derive(PartialEq, Eq)]\nenum BitOrder {\n    Big,\n    Little\n}", "vc-helpers": "", "vc-spec": "fn packbits(a: Vec<bool>, bitorder: BitOrder) -> (result: Vec<u8>)\n    requires a.len() > 0,\n    ensures \n        result.len() == (a.len() + 7) / 8,\n        forall|byte_idx: int| 0 <= byte_idx < result.len() ==> {\n            let start_idx = byte_idx * 8;\n            let bits_in_byte = if start_idx + 8 <= a.len() { 8 } else { a.len() - start_idx };\n            match bitorder {\n                BitOrder::Big => {\n\n                    forall|bit_pos: int| 0 <= bit_pos < bits_in_byte ==> {\n                        let bit_value = if start_idx + bit_pos < a.len() && a[start_idx + bit_pos] { 1u8 } else { 0u8 };\n                        (result[byte_idx] & (1u8 << (7 - bit_pos))) == (bit_value << (7 - bit_pos))\n                    }\n                },\n                BitOrder::Little => {\n\n                    forall|bit_pos: int| 0 <= bit_pos < bits_in_byte ==> {\n                        let bit_value = if start_idx + bit_pos < a.len() && a[start_idx + bit_pos] { 1u8 } else { 0u8 };\n                        (result[byte_idx] & (1u8 << bit_pos)) == (bit_value << bit_pos)\n                    }\n                }\n            }\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0092", "language": "verus", "source": "numpy_triple", "source-id": "constants_False_", "source-notes": "", "vc-description": "NumPy's boolean False value, used in comparison operations and boolean arrays.\n\nSpecification: False_ represents the boolean false value with properties:\n1. It equals false\n2. It is the identity for logical OR\n3. It is the absorbing element for logical AND\n4. It is the negation of True_", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn false_() -> (result: bool)\n    ensures \n        result == false,\n        forall|b: bool| (result || b) == b,\n        forall|b: bool| (result && b) == false,\n        result == !true", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0183", "language": "verus", "source": "numpy_triple", "source-id": "indexing_slicing_ndindex", "source-notes": "", "vc-description": "Generate N-dimensional indices for an array with given shape.\nReturns a vector of index tuples, where each tuple represents a valid\nN-dimensional index for an array with the specified dimensions.\n\nFor a 2D array with shape (m, n), this generates all index pairs\n(i, j) where 0 ≤ i < m and 0 ≤ j < n, in C-order (row-major).\n\nExample: For shape (2, 3), generates [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2)]", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "fn ndindex(shape: (usize, usize)) -> (indices: Vec<(usize, usize)>)\n    requires shape.0 > 0 && shape.1 > 0,\n    ensures \n        indices.len() == shape.0 * shape.1,\n        forall|k: int| 0 <= k < indices.len() ==> {\n            let (i, j) = indices[k];\n            i < shape.0 && j < shape.1\n        },\n        forall|i: usize, j: usize| i < shape.0 && j < shape.1 ==> {\n            exists|k: int| 0 <= k < indices.len() && indices[k] == (i, j)\n        },\n        forall|k: int| 0 <= k < indices.len() ==> {\n            let (i, j) = indices[k];\n            k == i * shape.1 + j\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0210", "language": "verus", "source": "numpy_triple", "source-id": "io_operations_load", "source-notes": "", "vc-description": "numpy.load: Load arrays or pickled objects from .npy, .npz or pickled files.\n\nLoads array data from a binary file. This operation reads serialized array data\nfrom disk storage and reconstructs it as a Vector. The function supports:\n- .npy files: Single array format\n- .npz files: Archive format with multiple arrays (simplified to single array here)\n- Pickled files: Python pickle format (when allow_pickle is True)\n\nThe file parameter represents the path to the file to be loaded.\nFor security reasons, pickled files should be avoided unless explicitly allowed.\n\nMemory mapping is not considered in this simplified specification.\n\nSpecification: numpy.load returns a vector containing the data from the file.\n\nThis specification captures the essential properties of the load operation:\n\n1. Data Preservation: The loaded vector contains exactly the data that was stored\n2. Size Consistency: The vector length matches the stored array dimensions\n3. Type Compatibility: Data is correctly interpreted as Float values\n4. Security Constraint: Object arrays are only loaded when explicitly allowed\n\nMathematical Properties:\n- Idempotence: Loading the same file multiple times yields identical results\n- Determinism: For a given file, load always returns the same vector\n- Injectivity: Different valid files produce different vectors (when they differ)\n\nPrecondition: The file exists, is readable, and contains valid array data\nPostcondition: The returned vector faithfully represents the stored data", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn load_ghost(file: String, allow_pickle: bool, n: nat) -> Vec<f64>;\n\nfn load(file: String, allow_pickle: bool, n: usize) -> (result: Vec<f64>)\n    ensures \n        result.len() == n,\n        forall|i: int| 0 <= i < n ==> exists|stored_val: f64| result[i] == stored_val,\n        forall|second_load: Vec<f64>| (#[trigger] second_load == load_ghost(file, allow_pickle, n as nat)) ==>\n            forall|i: int| 0 <= i < n ==> result[i] == second_load[i]", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VT0624", "language": "verus", "source": "numpy_triple", "source-id": "strings_join", "source-notes": "", "vc-description": "Return a string which is the concatenation of the strings in the sequence seq.\n\nnumpy.strings.join: Return a string which is the concatenation of the strings in the sequence seq.\n\nFor each pair of separator and sequence, join the elements of the sequence using the separator.\nThis function operates element-wise on vectors, where each element of the result is obtained\nby joining the corresponding elements of the sequence vector using the corresponding separator.\n\nThe function treats each string in the sequence as a sequence of characters, and joins them\nwith the separator string. For example, join('-', 'abc') produces 'a-b-c'.\n\nFrom NumPy documentation:\n- Parameters: sep (array_like) - Separator string(s), seq (array_like) - Sequence(s) to join\n- Returns: out (ndarray) - Output array with joined strings\n- Examples: join('-', 'osd') → 'o-s-d', join(['-', '.'], ['ghc', 'osd']) → ['g-h-c', 'o.s.d']\n\nMathematical Properties:\n1. Element-wise operation: result[i] = join(sep[i], seq[i])\n2. Character separation: joins individual characters of each string in seq\n3. Empty separator handling: join('', s) = s (no separation)\n4. Empty sequence handling: join(sep, '') = '' (empty result)\n5. Single character sequences: join(sep, 'a') = 'a' (no separator needed)\n\n/* Core correctness property */\n\n/* Length property for non-trivial cases */\n\n/* Empty string preservation */\n\n/* Single character preservation */\n\n/* Non-empty result for non-empty input */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {", "vc-helpers": "", "vc-spec": "spec fn join_chars(separator: Seq<char>, chars: Seq<char>) -> Seq<char>\n    decreases chars.len()\n{\n    if chars.len() <= 1 {\n        chars\n    } else {\n        chars.take(1) + separator + join_chars(separator, chars.skip(1))\n    }\n}\n\nspec fn string_to_chars(s: Seq<char>) -> Seq<char> {\n    s\n}\n\nspec fn chars_to_string_len(chars: Seq<char>) -> nat {\n    chars.len()\n}\n\nfn join(sep: Vec<String>, seq: Vec<String>) -> (result: Vec<String>)\n    requires sep.len() == seq.len(),\n    ensures\n        result.len() == sep.len(),\n        forall|i: int| 0 <= i < result.len() ==> {\n            let s = seq[i]@;\n            let separator = sep[i]@;\n\n            (s.len() <= 1 ==> result[i]@ == s) &&\n            (s.len() > 1 ==> result[i]@ == join_chars(separator, s)) &&\n\n            (s.len() > 1 ==> result[i]@.len() == s.len() + (s.len() - 1) * separator.len()) &&\n\n            (s.len() == 0 ==> result[i]@.len() == 0) &&\n\n            (s.len() == 1 ==> result[i]@ == s) &&\n\n            (s.len() > 0 ==> result[i]@.len() > 0)\n        }", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
{"id": "VV0015", "language": "verus", "source": "verina", "source-id": "verina_advanced_16_task", "source-notes": "", "vc-description": "Implement the insertion sort algorithm in Verus. The function takes a single Vec of integers\nas input and returns a new Vec that contains the same integers in ascending order.\n\nImplementation must follow a standard insertion sort approach, placing each element into its correct position.\nThe resulting Vec must be sorted in ascending order.\nThe returned Vec must be a permutation of the input Vec (i.e., contain exactly the same elements).\n\nInput: A single Vec of integers, denoted as xs.\nOutput: A Vec of integers, sorted in ascending order.\n\nExample:\nInput:  [3, 1, 4, 2]\nOutput: [1, 2, 3, 4]\n\n/* Helper function to check if a Vec is sorted */\n\n/* Helper function to check if two Vecs are multiset equivalent */\n\n/* This would typically involve checking that both vectors contain\n       the same elements with the same multiplicities */\n\n/* Placeholder - actual implementation would be more complex */", "vc-preamble": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sorted(v: Vec<i32>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < v.len() ==> v[i] <= v[j]\n}\n\nspec fn multiset_equivalent(v1: Vec<i32>, v2: Vec<i32>) -> bool {\n    forall|elem: i32| count(v1, elem) == count(v2, elem)\n}\n\nspec fn count(v: Vec<i32>, elem: i32) -> nat {\n    v.to_seq().filter(|x| *x == elem).len()\n}", "vc-helpers": "", "vc-spec": "fn insertion_sort(xs: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        sorted(result),\n        multiset_equivalent(xs, result),", "vc-code": "{\n    assume(false);\n    unreached()\n}", "vc-postamble": "}\nfn main() {}", "qa-issue": 1, "qa-issue-type": "non_compiling", "qa-functions-with-default-values": -1, "qa-methods-with-bodies": -1, "qa-specs-with-default-values": -1, "qa-execs-with-bodies": -1, "qa-execs-with-ghost-types": -1, "qa-definitions-with-sorry": -1, "qa-near-duplicate-group": "", "qa-score": -1}
